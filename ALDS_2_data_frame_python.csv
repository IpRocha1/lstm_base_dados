judgeId,problemId,sourceCode
8267519,ALDS1_3_A,"stack=[]
for a in input().split(' '):
    if a.isdigit():
        stack.append(int(a))
    else:
        stack.append(eval(str(stack.pop(-2))+a+str(stack.pop(-1))))

print(stack[0])
"
8268038,ALDS1_3_A,"n = input().split()
stack = []
for i in range(len(n)):
    if n[i]==""+"":
        stack.append(int(stack.pop())+int(stack.pop()))
    elif n[i]==""-"":
        stack.append(int(stack.pop(-2))-int(stack.pop()))
    elif n[i]==""*"":
        stack.append(int(stack.pop())*int(stack.pop()))
    else:
        stack.append(n[i])
print(stack[-1])
"
8275995,ALDS1_3_A,"def translate_rpn(symbols):
    stack = []
    for s in symbols:
        if s.isdigit():
            stack.append(int(s))
        else:
            b = stack.pop()
            a = stack.pop()
            if s == ""+"":
                stack.append(a + b)
            elif s == ""-"":
                stack.append(a - b)
            elif s == ""*"":
                stack.append(a * b)
    return stack.pop()


def main():
    symbols = input().split()
    print(translate_rpn(symbols))


if __name__ == ""__main__"":
    main()

"
8301222,ALDS1_3_A,"class CalStack:
    def __init__(self):
        self.stack = []
    def push(self, x):
        self.stack.append(x)
    def pop(self):
        return self.stack.pop()
        
calculator = CalStack()
A = input().split()
for i in range(len(A)):
    if A[i].isnumeric():
        calculator.push(int(A[i]))
    else:
        b = calculator.pop()
        a = calculator.pop()
        if A[i] == ""+"":
            calculator.push(a + b)
        elif A[i] == ""-"":
            calculator.push(a - b)
        elif A[i] == ""*"":
            calculator.push(a * b)

print(calculator.pop())

"
8341716,ALDS1_3_A,"MAX = 101

def initialize():
    global top
    top = 0

def isEmpty():
    return top == 0

def isFull():
    return top >= MAX - 1

def push(x):
    global top
    if isFull():
        print(""エラー（オーバーフロー）"")
    else:
        top += 1
        S[top] = x

def pop():
    global top
    if isEmpty():
        print(""エラー（アンダーフロー）"")
        return None
    else:
        top -= 1
        return S[top + 1]

x = input().split()
S = [0] * (MAX)

initialize()

for i in x:
    if i.isdigit() or (i[0] == '-' and i[1:].isdigit()):
        push(int(i))
    elif i in ['+', '-', '*']:
        a = pop()
        b = pop()
        if i == '+':
            push(b + a)
        elif i == '-':
            push(b - a)
        elif i == '*':
            push(b * a)

print(pop())
"
8375612,ALDS1_3_A,"def poland(n):
    stoke=[]
    for i in n:
        if i==""+"" or i==""-"" or i==""*"":
            y=stoke.pop()
            x=stoke.pop()
            if i==""+"":
                stoke.append(x+y)
            elif i==""-"":
                stoke.append(x-y)
            else:
                stoke.append(x*y)
        else:
            stoke.append(int(i))
    
    print(stoke[0])

n=list(map(str,input().split()))

poland(n)
"
8375983,ALDS1_3_A,"S = input().split()

stack = []

for i in range(len(S)):
    if S[i] == '+':
        operand2 = stack.pop()
        operand1 = stack.pop()
        result = operand1 + operand2
        stack.append(result)
    elif S[i] == '-':
        operand2 = stack.pop()
        operand1 = stack.pop()
        result = operand1 - operand2
        stack.append(result)
    elif S[i] == '*':
        operand2 = stack.pop()
        operand1 = stack.pop()
        result = operand1 * operand2
        stack.append(result)
    else:
        stack.append(int(S[i]))

print(stack[0])
"
8395274,ALDS1_3_A,"class Stack:
    def __init__(self):
        self._items = []

    def push(self, item):
        self._items.append(item)

    def pop(self):
        return self._items.pop()

    def is_empty(self):
        return len(self._items) == 0


polish_not = list(input().split()) 

stack = Stack()

def arithmetic_operations(a, b, operation):
        if operation == ""+"":
            return a + b
        elif operation == ""-"":
            return a - b
        elif operation == ""*"":
            return a * b
        elif operation == ""/"":
            return a / b
        else :
            raise ValueError(""Invalid operation: {}"".format(operation))


while len(polish_not)> 0:
    num = polish_not.pop(0)
    if(num.isnumeric()):
        stack.push(int(num))
    else:
        b = stack.pop()
        a = stack.pop()
        result = arithmetic_operations(a, b, num)
        stack.push(result)

print(stack.pop())
"
8401728,ALDS1_3_A,"sod = input().split()
st=[]
for s in sod:
    if s.isnumeric():
        st.append(int(s))
    else:
        b = st.pop()
        a = st.pop()
        if s == ""+"":
            st.append(a + b)
        if s == ""-"":
            st.append(a - b)
        if s == ""*"":
            st.append(a * b)

print(st.pop())

"
8405315,ALDS1_3_A,"def isint(s):
    try:
        i = int(s)
    except ValueError:
        return False
    else:
        return True

a = input().split()
l = len(a) - 1

while l:
    m, n = l - 1, l - 2
    if a[l] in '+-*' and isint(a[m]) and isint(a[n]):
        if a[l]   == '+': a[l] = str(int(a[n]) + int(a[m]))
        elif a[l] == '-': a[l] = str(int(a[n]) - int(a[m]))
        elif a[l] == '*': a[l] = str(int(a[n]) * int(a[m]))
        del a[n:l]
        l = len(a)
    l -= 1

print(*a)
"
8407548,ALDS1_3_A,"class Stack():
    def __init__(self):
        self.s = [None]
        self.MAX = 100
        self.top = 0
     
    def isEmpty(self):
        return self.top == 0
    
    def isFull(self):
        return self.top >= self.MAX
        
    def push(self, x):
        if self.isFull():
            print(""Stack overflow!"")
        else:
            self.top += 1
            self.s.append(x)
        	
    def pop(self):
        if self.isEmpty():
            print(""Stack underflow!"")
        else:
            self.top -= 1
            return self.s.pop()
        
s = Stack()
input_list = input().split()

for i in range(len(input_list)):
    if input_list[i] != '+' and input_list[i] != '-' and input_list[i] != '*' and input_list[i] != '/':
        s.push(input_list[i])
    elif input_list[i] == '+':
        a = s.pop()
        b = s.pop()
        ans = int(b) + int(a)
        s.push(ans)
    elif input_list[i] == '-':
        a = s.pop()
        b = s.pop()
        ans = int(b) - int(a)
        s.push(ans)
    elif input_list[i] == '*':
        a = s.pop()
        b = s.pop()
        ans = int(b) * int(a)
        s.push(ans)
    elif input_list[i] == '/':
        a = s.pop()
        b = s.pop()
        ans = int(b) / int(a)
        s.push(ans)
        
print(int(s.pop()))
        
"
8410965,ALDS1_3_A,"def is_op(arg : str) -> bool:
    length = len(arg)
    if length > 1:
        return False
    if arg[0] == '+' or arg[0] == '-' or arg[0] == '*':
        return True
    else:
        return False

def do_op(arg : str, a : int, b : int) -> int:
    if arg[0] == '+':
        return a + b
    if arg[0] == '-':
        return a - b
    if arg[0] == '*':
        return a * b
    return -1

args = input().split()
stack = []
for arg in args:
    # print(type(arg))
    if is_op(arg):
        b = stack.pop(-1)
        a = stack.pop(-1)
        res = do_op(arg, a, b)
        stack.append(res)
    else:
        stack.append(int(arg))
    # print(*stack)
print(stack[0])
"
8411226,ALDS1_3_A,"from collections import deque

operator = ['+', '-', '*']
A = list(input().split())
stack = deque()
for a in A:
    if a not in operator:
        stack.append(int(a))
    elif a == '+':
        x = stack.pop()
        y = stack.pop()
        z = x+y
        stack.append(z)
    elif a == '-':
        y = stack.pop()
        x = stack.pop()
        z = x-y
        stack.append(z)
    elif a == '*':
        x = stack.pop()
        y = stack.pop()
        z = x*y
        stack.append(z)
print(stack.pop())
"
8411392,ALDS1_3_A,"s =[]

for i in input().split():
    if i == ""+"":
        a = s.pop()
        b = s.pop()
        s.append(a+b)
    elif i == ""-"":
        b = s.pop()
        a = s.pop()
        s.append(a-b)
    elif i == ""*"":
        a = s.pop()
        b = s.pop()
        s.append(a*b)
    else:
        s.append(int(i))
        
print(s.pop())
"
8411884,ALDS1_3_A,"class Stack:
    def __init__(self, size):
        self.arr = [None] * size
        self.capacity = size
        self.top = 0
    
    def isEmpty(self):
        return self.top == 0
    
    def isFull(self):
        return self.top == self.capacity
    
    def push(self, value):
        if self.isFull():
            raise Exception(""オーバフロー"")
        else:
            self.top += 1
            self.arr[self.top] = value
            
    def pop(self):
        if self.isEmpty():
            raise Exception(""アンダーフロー"")
        else:
            value = self.arr[self.top]
            self.arr[self.top] = None
            self.top -= 1
            return value
            
def main():
    operands = input().split()
    stack = Stack(101)
    
    for operand in operands:
        try: 
            operand = int(operand)
            stack.push(operand)
        except:
            right_operator = stack.pop()
            left_operator = stack.pop()
            
            if operand == ""+"":
                ans = left_operator + right_operator
                stack.push(ans)
            elif operand == ""-"":
                ans = left_operator - right_operator
                stack.push(ans)
            elif operand == ""*"":
                ans = left_operator * right_operator
                stack.push(ans)
    ans = stack.pop()
    print(ans)

if __name__ == ""__main__"":
    main()

            
"
8426172,ALDS1_3_A,"class Stack:
  """"""スタック用クラス""""""
  
  def __init__(self, capacity):
    """"""初期化""""""
    self.stk = [None] * capacity    # スタック本体
    self.capacity = capacity        # スタックの容量
    self.ptr = 0                    
  
  def push(self, value):
    """"""スタックにvalueをプッシュ""""""
    self.stk[self.ptr] = value
    self.ptr += 1
    
  def pop(self):
    """"""スタックからデータをポップ""""""
    self.ptr -= 1
    return self.stk[self.ptr]
  

# スタックを生成
stack = Stack(500)

s = input().split(' ')
n = len(s)

for i in range(n):
  if s[i] != '+' and s[i] != '-' and s[i] != '*':
    stack.push(int(s[i]))
  
  elif s[i] == '+':
    x1 = stack.pop()
    x2 = stack.pop()
    stack.push(x2 + x1)

  elif s[i] == '-':
    x1 = stack.pop()
    x2 = stack.pop()
    stack.push(x2 - x1)

  else:
    x1 = stack.pop()
    x2 = stack.pop()
    stack.push(x2*x1)
  

print(stack.pop())
"
8427410,ALDS1_3_A,"#stack
class stack:
    def __init__(self):
        self.top = 0
        self.S = [None]*1000
    
    def push(self, x):
        self.top += 1
        self.S[self.top] = x
        
    def pop(self):
        self.top -= 1
        return self.S[self.top + 1]
    

Stack = stack()
L = input().split("" "")
for i in range(len(L)):
    if L[i] != ""+"" and L[i] != ""-"" and L[i] != ""*"":
        Stack.push(int(L[i]))
    elif L[i] == ""+"":
        x = Stack.pop()
        y = Stack.pop()
        Stack.push(x+y)
    elif L[i] == ""-"":
        xx = Stack.pop()
        yy = Stack.pop()
        Stack.push(yy-xx)
    else:
        xxx = Stack.pop()
        yyy = Stack.pop()
        Stack.push(xxx*yyy)
ans = Stack.pop()       
print(ans)
"
8435963,ALDS1_3_A,"class Stacked:
    def __init__(self, S, top, MAX):
        self.S = S
        self.top = top
        self.MAX = MAX

    def initialize(self):
        self.top = 0

    def isEmpty(self):
        return self.top == 0

    def isFull(self):
        return self.top >= self.MAX - 1

    def push(self, x):
        if Stacked.isFull(self):
            print(""エラー（オーバーフロー）"")
            return

        self.top += 1
        self.S.append(x)

    def pop(self):
        if Stacked.isEmpty(self):
            print(""エラー（アンダーフロー）"")
            return

        self.top -= 1
        s_pop = self.S[-1:]
        del self.S[-1:]
        return s_pop

    def calculation(self, operator):
        operand_1, operand_2 = self.S[self.top - 1], self.S[self.top]
        if operator == ""+"":
            return operand_1 + operand_2
        elif operator == ""-"":
            return operand_1 - operand_2
        elif operator == ""*"":
            return operand_1 * operand_2
        else:
            print(""無効な演算子です。"")


# main
def main():
    S = [0]  # スタック
    top = 0
    MAX = 200  # スタックの最大数
    result = 0
    formal = list(map(str, input().split()))   # 数式
    stack = Stacked(S, top, MAX)

    for i in range(len(formal)):
        if formal[i].isnumeric():
            stack.push(int(formal[i]))
        else:
            result = stack.calculation(formal[i])
            stack.pop()
            stack.pop()
            stack.push(result)

    print(result)


if __name__ == ""__main__"":
    main()

"
8461005,ALDS1_3_A,"def cul(x,a,b):
    if x == '+':
        return int(a)+int(b)
    elif x == '-':
        return int(a)-int(b)
    elif x == '*':
        return int(a)*int(b)
A = list(input().split())
i=2
while len(A)!=1:
    if A[i] in ""+-*"":
        A[i] = cul(A[i],A[i-2],A[i-1])
        A.pop(i-2)
        A.pop(i-2)
        i-=1
    else: i+=1
print(A[0])

"
8463853,ALDS1_3_A,"query = input().split()
op = ""+-*""
st = []
for i in range(len(query)):
    if query[i] not in op:
        st.append(query[i])
    else:
        b, a = st.pop(), st.pop()
        st.append(str(eval(a+query[i]+b)))

print(st[0])
"
8492730,ALDS1_3_A,"stack = []
ope = {""+"": lambda a, b: b + a, ""-"": lambda a, b: b - a, ""*"": lambda a, b: b * a}

for input_data in input().split():
    if input_data in ope:
        stack.append(ope[input_data](stack.pop(), stack.pop()))
    else:
        stack.append(int(input_data))
print(stack[0])

"
8500279,ALDS1_3_A,"lst = list(input().split())

stack = []
empty_num = 0

for i in lst:
	if i.isdecimal() == True:
		stack.append(int(i))
		empty_num += 1
	else:
		if i == ""+"":
			stack[empty_num - 2] = stack[empty_num - 2] + stack[empty_num - 1]
			del stack[empty_num -1]
			empty_num -= 1

		elif i == ""-"":
			stack[empty_num - 2] = stack[empty_num - 2] - stack[empty_num - 1]
			del stack[empty_num - 1]
			empty_num -= 1

		else:
			stack[empty_num - 2] = stack[empty_num - 2] * stack[empty_num - 1]
			del stack[empty_num - 1]
			empty_num -= 1

print(stack[0])
"
8502051,ALDS1_3_A,"while True:
    try:
        data = input().split()
        stack = []
        for ele in data:
            if (ele.isdecimal()):
                stack.append(int(ele))
                continue

            num1 = stack.pop()
            num2 = stack.pop()
            task = str(num2) +  ele  + str(num1)
            stack.append(eval(task))
        
        print(stack[0])
    except EOFError:break
"
8513541,ALDS1_3_A,"def evaluate_rpn(expression):
    tokens = expression.split()
    stack = []

    for token in tokens:
        if token in [""+"", ""-"", ""*""]:
            val2 = stack.pop()
            val1 = stack.pop()
            if token == ""+"":
                stack.append(val1 + val2)
            elif token == ""-"":
                stack.append(val1 - val2)
            elif token == ""*"":
                stack.append(val1 * val2)
        else:
            stack.append(int(token))

    return stack.pop()

if __name__ == ""__main__"":
    expression = input()
    result = evaluate_rpn(expression)
    print(result)

"
8533817,ALDS1_3_A,"def main():
    formula = input().split(' ')
    nums = []
    for c in formula:
        if not(c in ('+', '-', '*')):
            nums.append(int(c))
        else:
            if c == '+':
                new_num = nums[-2] + nums[-1]
            elif c == '-':
                new_num = nums[-2] - nums[-1]
            elif c == '*':
                new_num = nums[-2] * nums[-1]
            del nums[-2:]
            nums.append(new_num)
    print(nums[0])

if __name__ == '__main__':
    main()
"
8534238,ALDS1_3_A,"# 逆ポーランド記法
def calc(expression:str):
    stack = []
    for i in expression:
        if i == ""+"":
            b, a = stack.pop(), stack.pop()
            stack.append(a+b)
        elif i == ""-"":
            b, a = stack.pop(), stack.pop()
            stack.append(a-b)
        elif i == ""*"":
            b, a = stack.pop(), stack.pop()
            stack.append(a*b)
        else:
            stack.append(int(i))
    return stack[0]
expression = input().split()
print(calc(expression))
"
8540190,ALDS1_3_A,"ar = input().split()
stack = []

for x in ar:
    if x == '+':
        a = stack.pop()
        b = stack.pop()
        stack.append(b+a)
    elif x == '-':
        a = stack.pop()
        b = stack.pop()
        stack.append(b-a)
    elif x == '*':
        a = stack.pop()
        b = stack.pop()
        stack.append(b*a)
    else:
        stack.append(int(x))

ans = stack.pop()
print(ans)
"
8561773,ALDS1_3_A,"from collections import deque

c_list = input().split()
stack = deque([])

for c in c_list:
    if c in [""+"", ""-"", ""*""]:
        a = stack.pop()
        b = stack.pop()
        if c == ""+"":
            stack.append(a + b)
        elif c == ""-"":
            stack.append(b - a)
        else:
            stack.append(a * b)
    else:
        stack.append(int(c))

print(stack.pop())

"
8603802,ALDS1_3_A,"s = []

for i in input().split():
    if i == '+':
        a = s.pop()
        b = s.pop()
        s.append(a+b)
    elif i == '-':
        b = s.pop()
        a = s.pop()
        s.append(a-b)
    elif i == '*':
        a = s.pop()
        b = s.pop()
        s.append(a*b)
    else:
        s.append(int(i))
print(s.pop())
"
8611874,ALDS1_3_A,"from collections import deque
s = input().split()
stack = deque()
for c in s:
    if c in ""+-*"":
        b = stack.pop()
        a = stack.pop()
        v = eval(f""{a}{c}{b}"")
        stack.append(v)
    else:
        stack.append(int(c))
ans = stack.pop()
print(ans)

"
8651381,ALDS1_3_A,"def ST(expression):
    stack = []

    for NUM in expression.split():
        if NUM.isdigit():
            stack.append(int(NUM))
        elif NUM in ['+', '-', '*']:
            d2 = stack.pop()
            d1 = stack.pop()

            
            if NUM == '+':
                result = d1 + d2
            elif NUM == '-':
                result = d1 - d2
            elif NUM == '*':
                result = d1 * d2

            stack.append(result)

    return stack[0]


expression = input()

result = ST(expression)
print(result)

"
8651917,ALDS1_3_A,"class Stack:
    def __init__(self) -> None:
        self.Array = []
        self.top = 0
    
    def push(self, x) -> None:
        self.top += 1
        self.Array.append(x)

    def pop(self) -> int:
        if self.isEmpty() == False:
            self.top -= 1
            val = self.Array.pop()
            return val

    def isEmpty(self) -> bool:
        return True if self.top == 0 else False
    


Array = input()
a = list(map(str,Array.split()))

stack = Stack()

for i in a:
    try:
        int(i)
    except ValueError:
        if i == ""+"":
            stack.push(stack.pop() + stack.pop())
        elif i == ""-"":
            stack.push((stack.pop() - stack.pop())*-1)
        elif i == ""*"":
            stack.push(stack.pop() * stack.pop())

    if i.isdecimal() == True:
        stack.push(int(i))

print(stack.Array[0])
"
8655038,ALDS1_3_A,"operators = ['+', '-', '*']
inputs = input().split(' ')

stacks = []
for i in inputs:
    if i not in operators:
        stacks.append(int(i))
        continue
    
    if i == operators[0]:
        stacks.append(stacks.pop()+stacks.pop())
    
    if i == operators[2]:
        stacks.append(stacks.pop()*stacks.pop())
        
    if i == operators[1]:
        stacks.append(stacks.pop(-2)-stacks.pop())
        
print(stacks[0])
"
8656433,ALDS1_3_A,"stack = []
S = list(input().split())
for s in S:
    if s.isdigit():
        stack.append(int(s))
    else:
        b = stack.pop()
        a = stack.pop()
        if s == ""+"":
            stack.append(a + b)
        elif s == ""*"":
            stack.append(a * b)
        elif s == ""-"":
            stack.append(a - b)
    
print(stack[0])

"
8673722,ALDS1_3_A,"#ALDS1_3_A
data = input().split()
st1 = 0
st2 = """"
n = 0
m = 0
a = []
b = [0]*100
for i in data:
  a.append(i)
for i in range(len(a)):
  if a[i].isdigit():
    b[n] = a[i]
    n = n + 1

  else:
    st2 = a[i]
    if st2 == ""+"":
      b[n-2] = int(b[n-2]) + int(b[n-1])
    elif st2 == ""-"":
      b[n-2] = int(b[n-2]) - int(b[n-1])
    elif st2 == ""*"":
      b[n-2] = int(b[n-2]) * int(b[n-1])
    elif st2 == ""/"":
      b[n-2] = int(b[n-2]) / int(b[n-1])
    n = n - 1
print(b[0])
"
8682937,ALDS1_3_A,"def addition(a, b):
    s = b + a

    return s

def subtraction(a, b):
    s = b - a

    return s

def multiplication(a, b):
    s = b * a

    return s

arr1 = list(input().split())
arr2 = []

for i in range (len(arr1)):
    if(arr1[i] == ""+""):
        arr2.append(addition(arr2.pop(), arr2.pop()))

    elif(arr1[i] == ""-""):
        arr2.append(subtraction(arr2.pop(), arr2.pop()))

    elif(arr1[i] == ""*""):
        arr2.append(multiplication(arr2.pop(), arr2.pop()))
        
    else:
        arr2.append(int(arr1[i]))
    
print(*arr2)
"
8689771,ALDS1_3_A,"stack = []
inputV = list(input().split())

n = len(inputV)

for i in range(n):
    if inputV[i].isdigit():
        stack.append(int(inputV[i]))
    elif inputV[i] == ""+"":
        first = stack.pop()
        second = stack.pop()
        result = second+first
        stack.append(result)
    elif inputV[i] == ""-"":
        first = stack.pop()
        second = stack.pop()
        result = second-first
        stack.append(result)
    elif inputV[i] == ""*"":
        first = stack.pop()
        second = stack.pop()
        result = second*first
        stack.append(result)

print(stack[0])
"
8690465,ALDS1_3_A,"MARIO = []
for c in input().split():
    if c in ""+-*"":
        v1 = MARIO.pop()
        v2 = MARIO.pop()
        z = str(eval(v2 + c + v1))
        MARIO.append(z)
    else:
        MARIO.append(c)
print(MARIO[0])
        
"
8698466,ALDS1_3_A,"a = []
for b in input().split():
    if b in ""+-*"":
        d0 = a.pop()
        d1 = a.pop()
        a.append(str(eval(d1 + b + d0)))
    else:
        a.append(b)
print(*a)
"
8700768,ALDS1_3_A,"arr = list(map(str, input().split()))

stack = []
operators = set(['+', '-', '*', '/'])

for token in arr:
    if token not in operators:
        stack.append(int(token))
    else:
        operand2 = stack.pop()
        operand1 = stack.pop()

        if token == '+':
            result = operand1 + operand2
        elif token == '-':
            result = operand1 - operand2
        elif token == '*':
            result = operand1 * operand2
        else:
            result = operand1 / operand2  # Assuming Python 3 for float division

        stack.append(result)

print(stack[0])
"
8733699,ALDS1_3_A,"MAX_DATA = 1000

class stack():
    def __init__(self):
        self.data = [""0""] * (MAX_DATA+1)
        self.top = 0
    
    def push(self, elem):
        if self.is_full():
            print(""stack overflow"")
        else:
            self.top += 1
            self.data[self.top] = elem
    
    def pop(self):
        if self.is_empty():
            print(""stack underflow"")
        else:
            get_elem = self.data[self.top]
            self.top -= 1
            return get_elem
            
    def is_full(self):
        flag = False
        if self.top == MAX_DATA:
            flag = True
        return flag
        
    def is_empty(self):
        flag = False
        if self.top == 0:
            flag = True
        return flag
        
    def get_top(self):
        return self.data[top]

def calc_rev_polish(formula):
    my_stack = stack()
    for elem in formula:
        if elem.isdigit():
            my_stack.push(elem)
        else:
            b = int(my_stack.pop())
            a = int(my_stack.pop())
            if elem == ""+"":
                my_stack.push(a+b)
            elif elem == ""-"":
                my_stack.push(a-b)
            elif elem == ""*"":
                my_stack.push(a*b)
    return my_stack.pop()
        
formula = input().split()
print(calc_rev_polish(formula))
"
8750603,ALDS1_3_A,"# aizu_ALDS1_3_A_Stack.py  

data = list(input().split())
stack = []
for ope in data:
    if ope.isdecimal() == True: 
        x = int(ope)
        stack.append(x)
    else:
        b = stack.pop()
        a = stack.pop()
        if ope == '+': r = a+b
        if ope == '-': r = a-b
        if ope == '*': r = a*b
        stack.append(r)
ans = stack.pop()
print(ans)
"
8776377,ALDS1_3_A,"risuto =[]
returisuto = []
retu = input().split("" "")

for i in range(len(retu)):
    returisuto.append(retu[i])

for j in range(len(returisuto)):
    if 	str.isdigit(returisuto[j]) == True:
        risuto.append(int(returisuto[j]))
    else:
        s = int(risuto[len(risuto) - 1])
        t = int(risuto[len(risuto) - 2])
        risuto.pop()
        risuto.pop()
        if returisuto[j] == ""+"":
            tuika = t + s
            risuto.append(tuika)
        elif returisuto[j] == ""-"":
            tuika = t - s
            risuto.append(tuika)
        elif returisuto[j] == ""*"":
            tuika = s * t
            risuto.append(tuika)
        elif returisuto[j] == ""/"":
            tuika = t / s
            risuto.append(tuika)
        

for x in range(len(risuto)):
    if x + 1 == len(risuto):
        print(risuto[x])
    else:
        print(risuto[x], end="" "")
"
8818221,ALDS1_3_A,"def push(d):
    global sp
    if sp < MAX:
        stack[sp] = d
        sp += 1

def pop():
    global sp 
    if sp > 0:
        sp -= 1
        return stack[sp]
    else:
        return None
    
def keisan(operator, operand1, operand2):
    if operator == '+':
        return operand1 + operand2
    elif operator == '-':
        return operand1 - operand2
    elif operator == '*':
        return operand1 * operand2

expression = input().split()
MAX = len(expression)
stack = [0] * MAX
sp = 0

for symbol in expression:
    if symbol.isdigit() or (symbol[0] == '-' and symbol[1:].isdigit()):
        push(int(symbol))
    else:
        operand2 = pop()
        operand1 = pop()
        result = keisan(symbol, operand1, operand2)
        push(result)

result = pop()
print(result)

"
8829738,ALDS1_3_A,"A = list(map(str, input().split()))
stack = []

for token in A:
    if token.isdigit():
        stack.append(int(token))
    else:
        operand2 = stack.pop()
        operand1 = stack.pop()
        if token == ""+"":
            result = operand1 + operand2
        elif token == ""-"":
            result = operand1 - operand2
        elif token == ""*"":
            result = operand1 * operand2
        stack.append(result)

print(stack[0])

"
8838257,ALDS1_3_A,"stack=[]
s=input().split()
for i in s:
    if i in ['*','+','-']:
        x2=stack.pop()
        x1=stack.pop()
        if i=='*':
            stack.append(x1*x2)
        elif i=='+':
            stack.append(x1+x2)
        elif i=='-':
            stack.append(x1-x2)
    else:
        stack.append(int(i))
print(*stack)
"
8856933,ALDS1_3_A,"O = [*map(str, input().split())]
lst =[]

for i in O:
  if i == ""+"": lst [-2] = lst[-2] + lst[-1]; del lst[-1]
  elif i == ""-"": lst [-2] = lst[-2] - lst[-1]; del lst[-1]
  elif i == ""*"": lst [-2] = lst[-2] * lst[-1]; del lst[-1]
  else: lst.append(int(i))
print(*lst)
  
"
8864804,ALDS1_3_A,"l = list(map(str,input().split()))
p = []
for i in l:
  if i == '+':
    a = p.pop(-1)
    b = p.pop(-1)
    p.append(a+b)
  elif i == '-':
    a = p.pop(-1)
    b = p.pop(-1)
    p.append(b-a)
  elif i == '*':
    a = p.pop(-1)
    b = p.pop(-1)
    p.append(a*b)
  else:
    p.append(int(i))
print(p[0])
"
8867035,ALDS1_3_A,"a = input().split()

st = []

for i in range(len(a)):
    if a[i] == ""+"" or a[i] == ""-"":
        num1 = st.pop()
        num2 = st.pop()
        if a[i] == ""+"":
            st.append(num1 + num2)
        else:
            st.append(num2 - num1)
    elif a[i] == '*':
        num1 = st.pop()
        num2 = st.pop()
        st.append(num1 * num2)
    else:
        st.append(int(a[i]))
        
print(st[-1])
"
8885782,ALDS1_3_A,"poland = list(input().split())
ans = []

for i in poland:
    if i.isdigit() == True:
        ans.append(int(i))
    else:
        b = ans.pop()
        a = ans.pop()
        if i == ""+"":
            a = a + b
        elif i == ""-"":
            a = a - b
        else:
            a = a * b
        ans.append(a)

print(ans.pop())

"
8887215,ALDS1_3_A,"from collections import deque
d = deque()
s = input().split()
for i in range(len(s)):
    if s[i] == '+':
        a = d.popleft()
        b = d.popleft()
        c = a + b
        d.appendleft(c)
    elif s[i] == '-':
        a = d.popleft()
        b = d.popleft()
        c = b - a 
        d.appendleft(c)
    elif s[i] == '*':
        a = d.popleft()
        b = d.popleft()
        c = a * b
        d.appendleft(c)
    elif s[i] != ' ':
        d.appendleft(int(s[i]))

print(d[0])
"
8890587,ALDS1_3_A,"s=input().split()
a=[]
for i in s:
    if i.isdigit():
        a.append(int(i))
    elif i=='+':
        x=a.pop(-1)
        y=a.pop(-1)
        a.append(x+y)
    elif i=='-':
        x=a.pop(-1)
        y=a.pop(-1)
        a.append(y-x)
    elif i=='*':
        x=a.pop(-1)
        y=a.pop(-1)
        a.append(x*y)
print(a[0])
"
8893615,ALDS1_3_A,"expression = input().split()

stack = []
for c in expression:
    if c.isdigit():
        stack.append(int(c))
    else:
        if c == ""+"":
            stack.append(stack.pop() + stack.pop())
        elif c == ""-"":
            stack.append(- stack.pop() + stack.pop())
        else:
            stack.append(stack.pop() * stack.pop())
print(stack.pop())
"
8900996,ALDS1_3_A,"import heapq
from _heapq import heappush, heappop
from collections import deque

s=deque()
a=list(map(str,input().split()))

for i in a:
    if i.isdigit():
        s.append(int(i))
    else:
        b=s.pop()
        a=s.pop()

        if i=='+':
            s.append(a+b)
        elif i=='-':
            s.append(a-b)
        else:
            s.append(a*b)

print(s[0])
"
8903310,ALDS1_3_A,"# coding: utf-8
# Your code here!


def calc(expression):
    stack = []
    for i in expression:
        if i == '+':
            # +のときはスタックから2つ取り出して加算し，再度格納する
            b, a = stack.pop(), stack.pop() #後の演算のために順序を整えている
            stack.append(a + b)

        elif i == '-':
            # -のときはスタックから2つ取り出して減算し，再度格納する
            b, a = stack.pop(), stack.pop() #後の演算のために順序を整えている
            stack.append(a - b)

        elif i == '*':
            # *のときはスタックから2つ取り出して乗算し，再度格納する
            b, a = stack.pop(), stack.pop() #後の演算のために順序を整えている
            stack.append(a * b)

        elif i == '/':
            # /のときはスタックから2つ取り出して除算し，再度格納する
            b, a = stack.pop(), stack.pop() #後の演算のために順序を整えている
            stack.append(a / b)

        else:
            stack.append(int(i))    #受け取っているものは文字列であるが，後に計算されるので，intに変換

    return stack.pop()

if __name__ == '__main__':
    expression = list(input().split())   #逆ポーランド記法で記述
    result = calc(expression)

    print(result)
"
8924955,ALDS1_3_A,"n = list(input().split())
calc = []

for i in n:
    if i.isnumeric():
        calc.append(int(i))
    else:
        y = calc.pop()
        x = calc.pop()
        if i == '+':
            calc.append(x+y)
        elif i == '-':
            calc.append(x-y)
        else:
            calc.append(x*y)

print(*calc)
"
8931663,ALDS1_3_A,"caldata = list(input().split())

ope = []
opecount = 0

for factor in caldata:
  if factor != ""+"" and factor != ""-"" and factor != ""*"":
    ope.append(int(factor))
    opecount += 1
  elif factor == ""+"":
    first = ope.pop()
    second = ope.pop()
    cal = first + second
    ope.append(cal)
  elif factor == ""-"":
    first = ope.pop()
    second = ope.pop()
    cal = second - first
    ope.append(cal)
  else:
    first = ope.pop()
    second = ope.pop()
    cal = first * second
    ope.append(cal)

output = ope[0]
print(output)

"
8938345,ALDS1_3_A,"s = input().split()
stack = []
for c in s:
    if c == ""+"":
        rec = stack[-2] + stack[-1]
        stack = stack[:-2]
        stack.append(rec)
    elif c == ""-"":
        rec = stack[-2] - stack[-1]
        stack = stack[:-2]
        stack.append(rec)
    elif c == ""*"":
        rec = stack[-2] * stack[-1]
        stack = stack[:-2]
        stack.append(rec)              
    else:
        stack.append(int(c))
print(stack[0])
"
8938415,ALDS1_3_A,"ops = input().split()
stack = []

for op in ops:
    if op == '+':
        b = stack.pop()
        a = stack.pop()
        stack.append(a + b)
    elif op == '-':
        b = stack.pop()
        a = stack.pop()
        stack.append(a - b)
    elif op == '*':
        b = stack.pop()
        a = stack.pop()
        stack.append(a * b)
    else:
        stack.append(int(op))

print(stack[0])

"
8948582,ALDS1_3_A,"class Stack:
    def __init__(self):
        self.items = []

    def initialize(self):  # スタックを空にする
        self.items = []

    def is_empty(self):  # スタックが空かどうかを判定
        return len(self.items) == 0

    def is_full(self):  # スタックが満杯かどうかを判定（必要に応じて）
        return len(self.items) >= 100

    def push(self, item):  # アイテムをスタックに追加
        if not self.is_full():  # 満杯でなければ追加
            self.items.append(item)
        else:
            raise Exception(""Stack is full"")  # エラー処理

    def pop(self):  # スタックからアイテムを取り出す
        if not self.is_empty():  # 空でなければ取り出す
            return self.items.pop()
        else:
            raise Exception(""Stack is empty"")  # エラー処理

# スタックのインスタンスを作成
stack = Stack()

# 入力を受け取る
S = input().split()

# 処理
for token in S:
    if token.isdigit():  # 数値の場合はスタックにプッシュ
        stack.push(int(token))
    else:
        # 演算子の場合はスタックから2つの数値をポップし、演算を行う
        a = stack.pop()
        b = stack.pop()
        if token == ""+"":
            stack.push(a + b)
        elif token == ""-"":
            stack.push(b - a)
        elif token == ""*"":
            stack.push(a * b)

# 最後の結果を出力
print(stack.pop())

"
8513858,ALDS1_3_B,"from collections import deque

def round_robin_scheduling(processes, quantum):
    queue = deque(processes)
    time = 0

    while queue:
        name, need_time = queue.popleft()
        # 処理時間がクオンタム以下の場合、プロセスは完了する
        if need_time <= quantum:
            time += need_time
            print(f""{name} {time}"")
        else:
            # 処理時間がクオンタムより長い場合、プロセスは末尾に追加される
            time += quantum
            queue.append((name, need_time - quantum))

if __name__ == ""__main__"":
    n, q = map(int, input().split())
    processes = [input().split() for _ in range(n)]
    processes = [(name, int(time)) for name, time in processes]
    round_robin_scheduling(processes, q)

"
8866443,ALDS1_3_B,"from collections import deque

def round_robin_scheduling(processes, quantum):
    queue = deque(processes)
    time = 0
    result = []

    while queue:
        process_name, remaining_time = queue.popleft()

        if remaining_time <= quantum:
            # プロセスがクォンタム以内で完了する場合
            time += remaining_time
            result.append((process_name, time))
        else:
            # プロセスがクォンタムよりも長い時間かかる場合
            time += quantum
            queue.append((process_name, remaining_time - quantum))

    return result

def main():
    n, quantum = map(int, input().split())
    processes = [input().split() for _ in range(n)]
    processes = [(name, int(time)) for name, time in processes]

    # ラウンドロビンスケジューリングを実行
    scheduling_result = round_robin_scheduling(processes, quantum)

    # 結果を出力
    for process_name, finish_time in scheduling_result:
        print(f""{process_name} {finish_time}"")

if __name__ == ""__main__"":
    main()

"
8973762,ALDS1_3_B,"import sys
from collections import deque

input = lambda: sys.stdin.readline().rstrip(""\r\n"").split()
i_mesli = lambda: list(map(int, input()))
i_mesls = lambda: list(input())
i_memls = lambda n: [i_mesls() for _ in range(n)]


def main():
    n, q = i_mesli()
    queries_org = i_memls(n)
    queries = [[row[0], int(row[1])] for row in queries_org]
    _deque = deque(queries)
    answer = []
    t = 0
    while len(_deque) > 0:
        query = _deque.popleft()
        process_name = query[0]
        process_time = query[1]
        if process_time <= q:
            t += process_time
            answer.append([process_name, t])
        else:
            t += q
            _deque.append([process_name, process_time - q])

    for row in answer:
        print(row[0], row[1])

    sys.exit()


if __name__ == ""__main__"":
    main()

"
9125844,ALDS1_3_B,"from collections import deque
n, q = map(int, input().split())
deq = deque()
for i in range(n):
    name, time = input().split(); time = int(time)
    deq.append((time, name))
ans = []
cur = 0
while deq:
    time, name = deq.popleft()
    if time <= q:
        cur += time
        ans.append(""%s %d"" % (name, cur))
    else:
        cur += q
        deq.append((time-q, name))
print(*ans, sep=""\n"")
"
8411577,ALDS1_3_B,"from collections import deque

n, q = map(int, input().split())
procs = deque([name, int(time)] for name, time in [input().split() for _ in range(n)])

tot_time = 0
while procs:
    name, time = procs.popleft()
    if time <= q:
        tot_time += time
        print(name, tot_time)
    else:
        tot_time += q
        procs.append([name, time - q])
"
8431053,ALDS1_3_B,"import collections

q = collections.deque([])

n, max_time = map(int, input().split())

for i in range(n):
    names, times = input().split()
    q.append((str(names), int(times)))
    
now = 0
ans = []
while q:
    names, times = q.popleft()
    if times <= max_time:
        now += times
        ans.append(""%s %d"" % (names, now))
    else:
        now += max_time
        q.append([names, times-max_time])
print(*ans, sep=""\n"")
"
8652123,ALDS1_3_B,"from collections import deque

def round_robin_scheduling(n, q, p):
    
    queue = deque(p)
    ftimes = {}
    current_time = 0

    while queue:
        name, time = queue.popleft()
        p_time = min(time, q)

        current_time += p_time
        time -= p_time

        if time > 0:
            queue.append((name, time))
        else:
            ftimes[name] = current_time

   
    sorted_ftimes = sorted(ftimes.items(), key=lambda x: x[1])
    for name, finish_time in sorted_ftimes:
        print(f""{name} {finish_time}"")


n, q = map(int, input().split())
p = [input().split() for _ in range(n)]
p = [(name, int(time)) for name, time in p]

round_robin_scheduling(n, q, p)

"
8689812,ALDS1_3_B,"from collections import deque

n, quantum = map(int, input().split())
queue = deque()

for _ in range(n):
    name, process = input().split()
    process = int(process)
    queue.append((name, process))

current_time = 0
result = []

while queue:
    name, process = queue.popleft()
    if process <= quantum:
        current_time += process
        result.append((name, current_time))
    else:
        current_time += quantum
        queue.append((name, process - quantum))

for item in result:
    print(*item)

"
8750707,ALDS1_3_B,"# aizu_ALDS1_3_B_Queue.py  

from collections import deque

dq = deque()
n,q = map(int,input().split())
t_time = 0
task_time = []

for _ in range(n):
    name,time = input().split()
    time = int(time)
    dq.append([name,time])

while dq:
    name,time = dq.popleft()
    if time <= q:
        t_time += time
        task_time.append([name,t_time])
    else:
        t_time += q
        dq.append([name,time-q])

for name,time in task_time:
    print(name,time)
"
8835188,ALDS1_3_B,"from collections import deque

tail, que_time = map(int,input().split())

A=[]
B=[]

for _ in range(tail):
    line = input()
    parts = line.split()
    A.append(parts[0])
    B.append(int(parts[1]))

A_deque = deque(A)
B_deque = deque(B)


total = 0
while A_deque:
    youso = A_deque.popleft()
    times = B_deque.popleft()
    
    if times - que_time > 0:
      A_deque.append(youso)
      B_deque.append(times - que_time)
      total += que_time
    else:
      total += times
      print(f""{youso} {total}"")
"
8901295,ALDS1_3_B,"import heapq
from _heapq import heappush, heappop
from collections import deque
from queue import Queue
n,q=map(int,input().split())
que=deque()

for i in range(n):
    name,time=input().split()
    que.append((name,int(time)))
ans=[]
cnt=0

while que:
    name,time=que.popleft()
    if time<=q:
        cnt+=time
        #ans.append((name,cnt))
        print(name,cnt)
    else:
        time-=q
        cnt+=q
        que.append((name,time))
    
"
9003449,ALDS1_3_B,"from collections import deque

n, q = map(int, input().split())

que = deque()
for _ in range(n):
    name, time = input().split()
    que.append((name, int(time)))

now = 0
while que:
    name, time = que.popleft()
    if time - q <= 0:
        now += time
        print(name, now)
    else:
        time -= q
        now += q
        que.append((name, time))

"
9036014,ALDS1_3_B,"from collections import deque
n, q = map(int, input().split())
processes = deque([input().split() for _ in range(n)])
for p in processes:
    p[1] = int(p[1])

time = 0
while len(processes) > 0:
    temp = processes.popleft()
    if temp[1] > q:
        temp[1] -= q
        time += q
        processes.append(temp)
    else:
        time += temp[1]
        print(temp[0], time)



"
9156840,ALDS1_3_B,"from collections import deque
n, q = map(int, input().split())
nt = [list(input().split()) for _ in range(n)]

que = deque()
for n, t in nt:
    que.append((n, int(t)))

elapsed = 0
while que:
    n, t = que.popleft()
    if t <= q:
        elapsed += t
        print(n, elapsed)
    else:
        elapsed += q
        que.append((n, t-q))

"
8411093,ALDS1_3_B,"from collections import deque

n, q = map(int, input().split())
Q = deque()
for i in range(n):
    lst = list(input().split())
    Q.append([lst[0], int(lst[1])])

sum_time = 0
qlen = len(Q)
while qlen > 0:
    lst = Q.popleft()
    if lst[1] <= q:
        print(lst[0], sum_time + lst[1])
        qlen -= 1
        sum_time += lst[1]
    else:
        Q.append(lst)
        lst[1] -= q
        sum_time += q

"
8414224,ALDS1_3_B,"n ,q = map(int, input().split())

name = []
time = []

for i in range(n):
    na, ti = input().split()
    name.append(na)
    time.append(int(ti))

i = 0
j = 0
all_time = 0
while j < n:
    if time[i] <= q:
        all_time += time[i]
        print(name[i], all_time)
        j += 1
    else:
        time[i] -= q
        all_time += q
        name.append(name[i])
        time.append(time[i])
    i += 1

"
8463857,ALDS1_3_B,"from collections import deque
n, q = map(int, input().split())
que = deque([tuple(input().split()) for i in range(n)])

c = 0
while que:
    name, x = que.popleft()
    x = int(x)
    if x <= q:
        print(name, c + x)
        c += x
    else:
        que.append((name, x-q))
        c += q
"
8604704,ALDS1_3_B,"from collections import deque

n, q = map(int, input().split())
process = deque([name, int(time)] for name, time in [input().split() for _ in range(n)])

total_time = 0
while True:
    name, time = process.popleft()
    if time > q:
        total_time += q
        process.append([name, time-q])
    else:
        total_time += time
        print(name, total_time)
    if len(process) == 0 : break

"
8624226,ALDS1_3_B,"from collections import deque

n, q = map(int, input().split())
l = [input().split() for _ in range(n)]
l = [[e[0], int(e[1])] for e in l]

que = deque(l)
now = 0
while que:
    name, time = que.popleft()
    if time > q:
        time -= q
        que.append([name, time])
        now += q
    else:
        now += time
        print(name, now)

"
8925046,ALDS1_3_B,"from collections import deque
n, q=map(int, input().split())
qms=deque()
for i in range(n):
    name, time=input().split()
    qms.append([name, int(time)])

count=0
while qms:
    a=qms.popleft()
    if q >= a[1]:
        print(a[0], a[1]+count)
        count+=a[1]
    else:
        a[1]-=q
        qms.append(a)
        count+=q
"
9028027,ALDS1_3_B,"from collections import deque

n, q = map(int, input().split())
a = []
for _ in range(n):
    name, time = input().split()
    a.append((name, int(time)))
dq = deque(a)
cnt = 0
while len(dq) > 0:
    name_p, q_p = dq.popleft()
    diff = q_p - q
    if diff > 0:
        cnt += q
        dq.append((name_p, diff))
    else:
        cnt += q_p
        print(name_p, cnt)


"
8561802,ALDS1_3_B,"from collections import deque


class Process:
    def __init__(self, process: str):
        process = process.split()
        self.name = process[0]
        self.time = int(process[1])

    def __sub__(self, __value: object) -> int:
        if not isinstance(__value, int):
            NotImplemented
        return self.time - __value

    def __str__(self) -> str:
        return self.name


N, q = map(int, input().split())

process_queue = deque([])
for _ in range(N):
    process_queue.append(Process(input()))

t = 0
while len(process_queue) > 0:
    process = process_queue.popleft()
    if process.time <= q:
        t = t + process.time
        print(f""{process} {t}"")
    else:
        t = t + q
        process.time = process.time - q
        process_queue.append(process)

"
8887379,ALDS1_3_B,"nq = list(map(int, input().split()))
l = [input().split() for i in range(nq[0])]
from collections import deque
d = deque(l)
now = 0
while len(d) != 0:
    a = d.popleft()
    if int(a[1]) - nq[1] <= 0:
        now += int(a[1])
        print(a[0] + ' ' + str(now))
    else:
        a[1] = int(a[1]) - nq[1] 
        d.append(a)
        now += nq[1]
        
"
8922718,ALDS1_3_B,"from collections import deque

n, q = map(int, input().split())

query = deque()

for i in range(n):
    p, time = map(str, input().split())
    query.append([p, int(time)])

ans = 0    

while len(query) > 0:
  task = query.popleft()
  if task[1] > q:
    ans += q
    task[1] -= q
    query.append(task)
    
  else:
    ans += task[1]
    print(task[0], ans)
    
"
8992248,ALDS1_3_B,"from collections import deque
n, q = map(int, input().split())
dq = deque()
for _ in range(n):
    pr = []
    nm, tm = input().split()
    pr.append(nm)
    pr.append(int(tm))
    dq.append(pr)

total = 0
while len(dq) > 0:
    pr = dq.popleft()
    if pr[1] - q > 0:
        pr[1] -= q
        dq.append(pr)
        total += q
    else:
        total += pr[1]
        print(pr[0], total)
"
8244489,ALDS1_3_B,"from collections import deque

n, q = [int(a) for a in input().split()]
names = deque([])
times = deque([])
for i in range(n):
    name, time = [i for i in input().split()]
    names.append(name)
    times.append(int(time))

timer = 0

while names != deque([]):
    name = names.popleft()
    time = times.popleft()
    if time == q:
        timer+=time
        print(f""{name} {timer}"")
    elif time < q:
        timer+=time
        print(f""{name} {timer}"")
    else:
        timer+=q
        time-=q
        names.append(name)
        times.append(time)
"
8341786,ALDS1_3_B,"from collections import deque

n, q = [int(a) for a in input().split()]
names = deque([])
times = deque([])
for i in range(n):
    name, time = [i for i in input().split()]
    names.append(name)
    times.append(int(time))

timer = 0

while names != deque([]):
    name = names.popleft()
    time = times.popleft()
    if time == q:
        timer+=time
        print(f""{name} {timer}"")
    elif time < q:
        timer+=time
        print(f""{name} {timer}"")
    else:
        timer+=q
        time-=q
        names.append(name)
        times.append(time)
"
8463674,ALDS1_3_B,"from collections import deque

n,p=map(int ,input().split())
que=deque([])

for i in range(n):
    name,time=input().split()
    time=int(time)
    que.append([name,time])

t=0
while len(que)>0:
    atop=que.popleft()
    spend=min(atop[1],p)
    atop[1]-=spend
    t+=spend
    if(atop[1]==0):
        print(atop[0],t)
    else:
        que.append(atop)

        
"
8700799,ALDS1_3_B,"from collections import deque

n,p=map(int ,input().split())
que=deque([])

for i in range(n):
    name,time=input().split()
    time=int(time)
    que.append([name,time])

t=0
while len(que)>0:
    atop=que.popleft()
    spend=min(atop[1],p)
    atop[1]-=spend
    t+=spend
    if(atop[1]==0):
        print(atop[0],t)
    else:
        que.append(atop)
"
8893752,ALDS1_3_B,"from collections import deque
n,q = map(int,input().split())
tasks = deque()
for _ in range(n):
    p,t = input().split()
    tasks.append([p,int(t)])

time = 0
while len(tasks):
    task = tasks.popleft()
    time += min(task[1],q)
    task[1] -= q
    if task[1] <= 0:
        print(task[0], time)
    else:
        tasks.append(task)
"
2725758,ALDS1_3_B,"import sys
from collections import deque
def m():
 s=sys.stdin.readlines()
 q=int(s[0].split()[1])
 f=lambda x,y:(x,int(y))
 d=deque(f(*e.split())for e in s[1:])
 t,a=0,[]
 while d:
  k,v=d.popleft()
  if v>q:v-=q;t+=q;d.append([k,v])
  else:t+=v;a+=[f'{k} {t}']
 print('\n'.join(a))
if'__main__'==__name__:m()
"
9155667,ALDS1_3_B,"

from collections import deque
time = []
name = []
count = 0
p = 0

n,q = map(int,input().split())
a = [list(input().split()) for i in range(n)]
for j in range(n):
    int(a[j][1])
    name.append(a[j][0])
    time.append(int(a[j][1]))

if n < 1 or n > 100000:
    print(""error"")
    exit

if q < 1 or q > 1000:
    print(""error"")
    exit

totaltime = 0

for l in range(n):
    if time[l] < 1 or time[l] > 50000:
        print(""error"")
        exit()

    if len(name[l]) < 1 or len(name[l]) > 10:
        print(""error"")
        exit()
    
    totaltime += time[l]


if totaltime < 1 or totaltime > 1000000:
    print(""error"")
    exit()

time = deque(time)
name = deque(name)

while len(time) != 0:
    for r in range(n):
        if len(time) != 0:
            t = time.popleft()
            names = name.popleft()
        else:
            break

        k = t-q

        if k > 0:
            time.append(k)
            name.append(names)
            count += q
        else:
            count += t
            print(f""{names} {count}"")

"
8411298,ALDS1_3_B,"from collections import deque

name = deque()
time = {}
n, p = map(int, input().split())
p = int(p)

for _ in range(n):
    namei, timei = input().split()
    name.append(namei)
    timi = int(timei)
    time[namei] = timei

ans = []
sum = 0
while len(name) > 0:
    a = name.popleft()
    t = int(time[a])
    if t <= p:
        sum += t
        ans.append([a,sum])
    else:
        sum += p
        time[a] = t - p
        name.append(a)

for i in range(n):
    print(' '.join(map(str, ans[i])))
        
    


"
5418502,ALDS1_3_B,"import sys
from collections import deque
def m():
 s=sys.stdin.readlines()
 q=int(s[0].split()[1])
 f=lambda x,y:(x,int(y))
 d=deque(f(*e.split())for e in s[1:])
 t,a=0,[]
 while d:
  k,v=d.popleft()
  if v>q:v-=q;t+=q;d.append([k,v])
  else:t+=v;a+=[f'{k} {t}']
 print('\n'.join(a))
if'__main__'==__name__:m()

"
7836073,ALDS1_3_B,"import sys
from collections import deque


def main():
    n, q = map(int, input().split())
    dq = deque()
    result = []
    timer = 0
    for _ in range(n):
        name, time = input().decode().strip().split()
        dq.append((name, int(time)))
    while dq:
        name, time = dq.popleft()
        if time <= q:
            timer += time
            result.append((name, timer))
        else:
            timer += q
            dq.append((name, time - q))
    result = ""\n"".join(map(lambda x: f""{x[0]} {x[1]}"", result))
    sys.stdout.write(f""{result}\n"")


if __name__ == ""__main__"":
    input = sys.stdin.buffer.readline
    main()

"
8435957,ALDS1_3_B,"# キュー
# ラウンドロビンスケジューリングのシミュレート
class Process:
    def __init__(self, head, tail, name, Q, MAX, sum_time):
        self.head = head
        self.tail = tail
        self.name = name
        self.Q = Q
        self.MAX = MAX
        self.sum_time = sum_time

    def enqueue(self):
        # キューの末尾に要素を追加
        self.Q[self.tail] = self.Q[self.head]
        self.name[self.tail] = self.name[self.head]
        # キューの先頭をゼロにして先頭と末尾を１つずらす
        self.Q[self.head] = 0
        self.name[self.head] = ""0""
        
        self.head += 1
        if self.head >= self.MAX:
            self.head = 0

        self.tail += 1
        if self.tail >= self.MAX:
            self.tail = 0

    def dequeue(self):
        # キューの先頭の要素を抜き出して送信、末尾を１つ手前にずらす
        processed_item = self.Q[self.head]
        self.Q[self.head] = 0
        self.name[self.head] = ""0""
        self.head += 1

        if self.head >= self.MAX:
            self.head = 0

        return processed_item

    def caluculation(self, q):
        head_name = self.name[self.head]
        value = self.Q[self.head] - q

        if value > 0:
            self.sum_time += q
            self.Q[self.head] = value
            Process.enqueue(self)

        elif value <= 0:
            self.sum_time += self.Q[self.head]
            Process.dequeue(self)
            answer = [head_name, self.sum_time]
            return answer

def main():
    # 入力
    n, q = map(int, input().split())  # n:プロセス数、q:クオンタム数
    buffer_number = n + 2  # リングバッファのバッファ数
    name = [""0""] * buffer_number
    time = [0] * buffer_number
    for i in range(n):
        input_name, input_time = input().split()
        name[i] = input_name
        time[i] = int(input_time)

    # 演算
    process = Process(0, n, name, time, buffer_number, 0)

    while True:
        answer = process.caluculation(q)
        if answer != None:
            if answer[0] == ""0"": break
            print(""{} {}"".format(answer[0], answer[1]))

if __name__ == ""__main__"":
    main()

"
5038924,ALDS1_3_B,"from collections import deque
from sys import stdin
pin=stdin.readline

def main():
  n,q=map(int,pin().split())
  d=deque([])
  for i in range(n):
    s,t=pin().rstrip().split()
    d.append([s,int(t)])
  ansl=[]
  now=0
  while d:
    now+=q
    p=d.popleft()
    p[1]-=q
    if p[1]>0:
      d.append(p)
    else:
      now+=p[1]
      ansl.append("" "".join([p[0],str(now)]))
  print(""\n"".join(ansl))
  return

if __name__==""__main__"":
  main()

"
8415758,ALDS1_3_B,"class Queue:
    def __init__(self, size):
        self.arr = [None] * size
        self.capacity = size
        self.top = 0
        self.tail = 0

    def isEmpty(self):
        if self.top == self.tail:
            return True
        else:
            return False

    def isFull(self):
        if self.top == (self.tail + 1) % self.capacity:
            return True
    
    def enQueue(self, value):
        if self.isFull():
            raise Exception(""オーバフロー"")
        else:
            self.arr[self.tail] = value
            self.tail = (self.tail + 1) % self.capacity
            
    def deQueue(self):
        if self.isEmpty():
            raise Exception(""アンダーフロー"")
        else:
            value = self.arr[self.top]
            self.arr[self.top] = None
            self.top = (self.top + 1) % self.capacity
            return value
 
 
def main():
    N, Q = map(int, input().split())
    time_dict = {}
    queue = Queue(1000001)
    for _ in range(N):
        name, time = input().split()
        time = int(time)
        time_dict[name] = time
        queue.enQueue(name)
    sum_time = 0
    while(1):
        try:
            name = queue.deQueue()
            tmp_time = time_dict[name] - Q
            
            if tmp_time > 0:
                queue.enQueue(name)
                time_dict[name] = tmp_time
                sum_time += Q
            else:
                sum_time += time_dict[name]
                print(name, sum_time)
        except:
            break

if __name__ == ""__main__"":
    main()
        
    
    
    
"
8651536,ALDS1_3_B,"class Queue:
    def __init__(self, size:int) -> None:
        self.Array = [None for i in range(size)]
        self.head = 0
        self.tail = 0
        self.size = size

    def dequeue(self):
        x = self.Array[self.head]
        if self.head + 1 == self.size:
            self.head = 0
        else: self.head += 1
        return x
    
    def enqueue(self, x):
        self.Array[self.tail] = x
        if self.tail + 1 == self.size: self.tail = 0
        else: self.tail += 1

nums = input()
Length, q = map(int,nums.split())
queue = Queue(Length)

for i in range(Length):
    inp = input()
    name, time = map(str,inp.split())
    time = int(time)
    queue.enqueue([name, time])

elapsed_time = 0
ended_task = 0
while (ended_task < Length):
    out = queue.dequeue()
    if out[1] <= q:
        elapsed_time += out[1]
        print(out[0], elapsed_time)
        ended_task += 1
    else:
        out[1] -= q
        elapsed_time += q
        queue.enqueue(out)

"
5349422,ALDS1_3_B,"from sys import stdin
from collections import deque

input = stdin.readline
inputs = stdin.readlines

def solve(n, q, P):
    P = deque(P)
    t = 0
    while P:
        p = P.popleft()
        if p[1] <= q:
            t += p[1]
            print(p[0], t)
        else:
            p[1] = p[1] - q
            P.append(p)
            t += q
    
def main():
    n, q = map(int, input().split()) 
    P = [list(input().split()) for _ in range(n)]
    P = [[p, int(t)] for p, t in P]
    solve(n, q, P)

if __name__ == '__main__':
    main()



"
5503022,ALDS1_3_B,"from collections import deque
def solve(n, q, queue):
    time = 0
    res = []
    while True:
        n, t = queue.popleft()
        if t <= q:
            time += t
            res.append(f""{n} {time}"")
        else:
            time += q
            queue.append((n, t-q))
        if len(queue) == 0:
            return res

import sys
def input():
    return sys.stdin.readline().rstrip()

def main():
    n, q = map(int, input().split())
    queue = deque()
    for _ in range(n):
        n, t = input().split()
        queue.append((n, int(t)))
    res = solve(n, q, queue)
    print(*res, sep = ""\n"")

if __name__ == ""__main__"":
    main()
"
6232999,ALDS1_3_B,"from collections import deque
import os, sys
input = sys.stdin.readline

def main():
  n, q = map(int, input().strip().split())
  queue = deque()
  for _ in range(n):
    name, time = input().strip().split()
    time = int(time)
    queue.append((name, time))
  time = 0
  while queue:
    t = queue.popleft()
    if t[1] > q:
      time += q
      queue.append((t[0], t[1]-q))
    else:
      time += t[1]
      print(t[0], time)

if __name__ == ""__main__"":
  main()
"
8662796,ALDS1_3_B,"class P:
    def __init__(self, name, t):
        self.name  = name
        self.t = t

n, q = map(int, input().split())

LEN = 100005  # 100005は十分大きければなんでも良い(n以上になるように)

head = 0
tail = n
Q = [P('', 0) for _ in range(LEN)]
for i in range(n):
    Q[i].name, num = input().split()
    Q[i].t = int(num)

def enqueue(Q, x, tail):
    Q[tail] = x
    tail = (tail+1)%LEN
    return tail

def dequeue(Q, head):
    x = Q[head]
    head = (head+1)%LEN
    return x, head

elaps = 0

while head != tail:
    u, head = dequeue(Q, head)
    c = min(q, u.t)
    u.t -= c
    elaps += c
    if u.t > 0:
        tail = enqueue(Q, u, tail)
    else:
        print(u.name + ' ' + str(elaps))
"
8697098,ALDS1_3_B,"from collections import deque

arr = deque()
name1 = deque()
time1 = deque()
name2 = deque()
time2 = deque()
sum = 0

n, q = map(int, input().split())

for i in range(n):
        arr.append(input().split())
        name1.append(arr[i][0])
        time1.append(int(arr[i][1]))

while(len(time1) != 0):
    time1[0] = time1[0] - q
    sum += q
      
    if(time1[0] > 0):
        time1.append(time1.popleft())
        name1.append(name1.popleft())

    else:
        sum += time1[0]
        name2.append(name1.popleft())
        time2.append(sum)
        time1.popleft()

for k in range(n):
    print(name2[k], time2[k])
"
4350202,ALDS1_3_B,"# import bisect
from collections import Counter, deque  # https://note.nkmk.me/python-scipy-connected-components/
# from copy import copy, deepcopy
# from fractions import gcd
# from functools import reduce
# from itertools import accumulate, permutations, combinations, combinations_with_replacement, groupby, product
# import math
# import numpy as np  # Pythonのみ！
# from operator import xor
# import re
# from scipy.sparse.csgraph import connected_components  # Pythonのみ！
# ↑cf.  https://note.nkmk.me/python-scipy-connected-components/
# from scipy.sparse import csr_matrix
# import string
import sys

sys.setrecursionlimit(10 ** 5 + 10)


def input(): return sys.stdin.readline().strip()


def resolve():
    n, q = map(int, input().split())
    queue = deque([])  # 処理すべきプロセスをqueueで管理
    for i in range(n):
        name, time = input().split()
        time = int(time)
        queue.append([name, time])

    totaltime = 0  # 経過時間
    while queue:
        [name, time] = queue.popleft()
        if time <= q:  # 今回で処理完了
            totaltime += time
            print(name, totaltime)
        else:
            time -= q
            queue.append([name, time])  # 処理しきれなかった時間分を後回し
            totaltime += q


resolve()
"
4852329,ALDS1_3_B,"import sys
from collections import deque
input = sys.stdin.readline
sys.setrecursionlimit(2 * 10**6)


def inpl():
    return list(map(int, input().split()))


def main():
    n, q = inpl()
    A = deque()
    for _ in range(n):
        name, queue = input().strip().split()
        queue = int(queue)
        A.append((name, queue))
    ans = []
    all_time = 0
    while A:
        name, time = A.popleft()
        if time <= q:
            all_time += time
            ans.append((name, all_time))
        else:
            all_time += q
            time -= q
            A.append((name, time))
        # print(A)

    for n, t in ans:
        print(n, t)

    return


if __name__ == '__main__':
    main()

"
6390343,ALDS1_3_B,"import sys
from collections import deque

# READ_FROM_FILE = True
READ_FROM_FILE = False


def main():
    if READ_FROM_FILE:
        f = open('test0.txt', 'r')
    else:
        f = sys.stdin

    que = deque()
    n, q = map(int, f.readline().split())
    for _ in range(n):
        name, time = f.readline().split()
        que.append([name, int(time)])

    c_time = 0
    while len(que) > 0:
        process = que.popleft()
        if process[1] <= q:
            c_time += process[1]
            print(process[0], c_time)
        else:
            c_time += q
            process[1] -= q
            que.append(process)

    if READ_FROM_FILE:
        f.close()
    return


if __name__ == '__main__':
    main()

"
8426244,ALDS1_3_B,"class Queue:
  """"""キュー用クラス""""""
  
  def __init__(self, capacity):
    self.capacity = capacity    # キューの容量
    self.que = [None] * capacity  # キュー本体
    self.front = 0     
    self.rear = 0       
    self.no = 0         # 現在のデータ数：frontとrearの値が等しくなった場合に，キューが空なのか満杯なのか区別するため。
    
  
  def enque(self, x):
    """"""データxをエンキュー""""""
    self.que[self.rear] = x
    self.rear += 1
    self.no += 1
    if self.rear == self.capacity:  # 循環配列の実現
      self.rear = 0
      
  def deque(self):
    """"""キューの先頭要素をデキュー""""""
    x = self.que[self.front]
    self.front += 1
    self.no -= 1
    if self.front == self.capacity:
      self.front = 0
    return x
  
  def is_empty(self):
    """"""キューは空であるか""""""
    return self.no <= 0
  


INPUT = input().split(' ')
n = int(INPUT[0])
q = int(INPUT[1])

# キューを生成
queue = Queue(n)
timer = 0
for i in range(n):
  INPUT2 = input().split(' ')
  name = INPUT2[0]
  time = int(INPUT2[1])
  queue.enque([name, time])
  
while True:
  if queue.is_empty():
    break
  
  process = queue.deque()
  process[1] -= q
  if process[1] <= 0: # プロセスが最後まで終わった
    timer += (q + process[1])
    print(process[0], timer)
  else: # プロセスが最後まで終わっていない
    timer += q
    queue.enque(process)
"
8960537,ALDS1_3_B,"#キュー
class Queue:
    def __init__(self, max_size):
        self.queue = [None] * max_size
        self.max_size = max_size
        self.head = self.tail = 0

    def is_empty(self):
        return self.head == self.tail

    def is_full(self):
        return self.head == (self.tail + 1) % self.max_size

    def enqueue(self, x):
        if self.is_full():
            raise Exception('Queue Overflow')
        self.queue[self.tail] = x
        self.tail = (self.tail + 1) % self.max_size

    def dequeue(self):
        if self.is_empty():
            raise Exception('Queue Underflow')
        x = self.queue[self.head]
        self.head = (self.head + 1) % self.max_size
        return x

def round_robin_scheduling(processes, quantum):
    q = Queue(len(processes) + 1)  # プロセス数+1のサイズでキューを作成
    time = 0  # 現在時刻
    for process in processes:
        q.enqueue(process)  # すべてのプロセスをキューに追加

    while not q.is_empty():
        name, time_left = q.dequeue()  # プロセス名と残り時間
        execution_time = min(time_left, quantum)  # 実行時間はクオンタムと残り時間のうち小さい方
        time_left -= execution_time  # 残り時間を更新
        time += execution_time  # 現在時刻を更新
        if time_left > 0:
            q.enqueue((name, time_left))  # 残り時間がある場合は再度キューに追加
        else:
            print(f'{name} {time}')  # プロセスが完了したら出力

# 入力
n, quantum = map(int, input().split())
processes = [input().split() for _ in range(n)]
processes = [(name, int(time)) for name, time in processes]

# ラウンドロビンスケジューリングの実行
round_robin_scheduling(processes, quantum)
"
2918802,ALDS1_3_B,"from sys import stdin
def stdinput():
    return stdin.readline().strip()

from collections import deque

def main():
    n ,q = map(int, stdinput().split())
    ps = deque()
    for _ in range(n):
        p, t = stdinput().split()
        t = int(t)
        ps.append([p, t])

    ctime = 0
    while len(ps) > 0:
        p = ps.popleft()
        if p[1] <= q:
            ctime += p[1]
            print(f'{p[0]} {ctime}')
        else:
            ctime += q
            p[1] -= q
            ps.append(p)

if __name__ == '__main__':
    main()
"
4511374,ALDS1_3_B,"import sys, collections
input = lambda: sys.stdin.readline().rstrip() 
sys.setrecursionlimit(10**7)
INF = 10**10
def I(): return int(input())
def F(): return float(input())
def SS(): return input()
def LI(): return [int(x) for x in input().split()]
def LI_(): return [int(x)-1 for x in input().split()]
def LF(): return [float(x) for x in input().split()]
def LSS(): return input().split()

def resolve():
    n, q = LI()
    nt = collections.deque()

    for _ in range(n):
        name, time = LSS()
        nt.append([name, int(time)])

    endtime = 0
    while nt:
        name, time = nt.popleft()
        if time>q:
            nt.append([name, time-q])
            endtime += q
        else:
            endtime+=time
            print(name, endtime)

if __name__ == '__main__':
    resolve()
"
5094705,ALDS1_3_B,"import math
from math import gcd,pi,sqrt
INF = float(""inf"")
MOD = 10**9 + 7
import sys
input = sys.stdin.readline
sys.setrecursionlimit(10**6)
import itertools
import bisect
import re
from collections import Counter,deque,defaultdict
def iinput(): return int(input())
def imap(): return map(int, input().split())
def ilist(): return list(imap())
def irow(N): return [iinput() for i in range(N)]
def sinput(): return input().rstrip()
def smap(): return sinput().split()
def slist(): return list(smap())
def srow(N): return [sinput() for i in range(N)]

def main():
    n,q = imap()
    l = []
    for i in range(n):
        a,b = smap()
        b = int(b)
        l.append([a,b])
    l = deque(l)
    total_time = 0
    while l:
        name, time = l.popleft()
        if time > q:
            l.append([name,time-q])
            total_time += q
        else:
            print(name,total_time + time)
            total_time += time
            

if __name__==""__main__"":
    main()
"
6040644,ALDS1_3_B,"import sys
from collections import deque

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines

MOD = 10**9 + 7


def main():
    N, Q = map(int, readline().split())
    L = [line.split() for line in readlines()]
    
    L = deque(L)
    TIME = 0
    
    while L:
        name, time = L.popleft()

        if int(time) <= Q:
            TIME += int(time)
            print(name, TIME)
        
        else:
            TIME += Q
            L.append([name, int(time) - Q])


if __name__ == '__main__':
    main()
"
8867825,ALDS1_3_B,"def enqueue(d):
    global tail
    nt = (tail+1)%MAX
    if nt != head:
        que[tail] = d
        tail = nt

def dequeue():
    global head
    if head == tail:
        return None
    else:
        d = que[head]
        head = (head+1)%MAX
        return d

n, q = map(int, input().split())
processes = [input().split() for _ in range(n)]
MAX = n + 1
que = [0]*MAX
head = 0
tail = 0

for process in processes:
    enqueue(process)

time = 0
while head != tail:
    name, t = dequeue()
    t = int(t)
    dt = min(t, q)
    time += dt
    t -= dt
    if t == 0:
        print(name, time)
    else:
        enqueue([name, str(t)])

"
2616177,ALDS1_3_B,"# encoding: utf-8
 
import sys
from collections import deque
 
input_ = sys.stdin.readlines()
 
 
def message_queue():
    # write your code here
    n, shard = map(int, input_[0].split())
 
    task_deque = deque(map(lambda x: x.split(), input_[1:]))
    t_accu = 0
 
    while task_deque:
        t_name, t_time = task_deque.popleft()
        t_time = int(t_time)
        if t_time <= shard:
            t_accu += t_time
            print(t_name, t_accu)
        else:
            t_time -= shard
            t_accu += shard
            task_deque.append([t_name, t_time])
 
 
message_queue()
"
2682704,ALDS1_3_B,"import sys
from collections import deque
readline = sys.stdin.readline
n, q = map(int, input().split())
f = lambda a, b: (a, int(b))
dq = deque(f(*readline().split()) for _ in range(n))
cnt = 0
ans = []
while dq:
    s, t = dq.popleft()
    if t <= q:
        cnt += t
        ans.append(f""{s} {cnt}"")
    else:
        cnt += q
        dq.append((s, t - q))
print(*ans, sep=""\n"")

"
3256438,ALDS1_3_B,"# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_3_B&lang=jp
#  Queue : python3
#  2018.11.26 yonezawa

from collections import deque
import sys
input = sys.stdin.readline

def calc(t,q):
    tq = deque()
    counter = 0
    while len(q) > 0:
#        print (""count"",counter,q)
        (i1,i2) = q.popleft()
        if (i2 > t):
            i2 = i2 - t
            q.append((i1,i2)) 
            counter = counter + t
        else:
            i2 = counter + i2
            tq.append((i1,i2))
            counter = i2
    return tq
def main():
    (n,t) = map(int,input().split())
    q = deque()
    for i in range(n):
        (a,b) = map(str,input().split())
        q.append((a,int(b)))
    for a,b in calc(t,q):
        print (a,b)
if __name__ == '__main__':
    main()
"
8733784,ALDS1_3_B,"MAX_DATA = 100000

class queue():
    def __init__(self):
        self.data = [0] * MAX_DATA
        self.head = 0
        self.tail = 0
        
    def is_full(self):
        return self.head == (self.tail+1)%MAX_DATA
    
    def is_empty(self):
        return self.head == self.tail
    
    def dequeue(self):
        if self.is_empty():
            print(""queue underflow"")
        else:
            elem = self.data[self.head]
            if self.head + 1 == MAX_DATA:
                self.head = 0
            else:
                self.head += 1
            return elem
    
    def enqueue(self, elem):
        if self.is_full():
            print(""queue overflow"")
        else:
            self.data[self.tail] = elem
            if self.tail + 1 == MAX_DATA:
                self.tail = 0
            else:
                self.tail += 1

def round_robin(process, quantum):
    pqueue = queue()
    time = 0
    for p in process:
        pqueue.enqueue(p)
    while pqueue.is_empty() == False:
        a = pqueue.dequeue()
        now_p_name, now_p_sec = a[0], a[1]
        if quantum >= now_p_sec:
            time += now_p_sec
            print(""{} {}"".format(now_p_name, time))
        else:
            now_p_sec -= quantum
            time += quantum
            pqueue.enqueue([now_p_name, now_p_sec])

num_process, quantum = map(int, input().split())
process = []
for i in range(num_process):
    data1, data2 = map(str, input().split())
    process.append([data1, int(data2)])
    
round_robin(process, quantum)
"
5225006,ALDS1_3_B,"import sys
from collections import deque

data = sys.stdin.readlines()
n, q = map(int, data[0].split())
data = data[1:]

data_process = lambda x, y : [x, int(y)]
data_1 = [x.split() for x in data]
processes = deque(data_process(x, y) for x, y in data_1)
timestamp = 0
output = []

while processes:
    process = processes.popleft()
    if (process[1] <= q):
        timestamp += process[1]
        output.append("" "".join([process[0], str(timestamp)]))
    else:
        process[1] = process[1] - q
        processes.append(process)
        timestamp += q

print(""\n"".join(output))
"
9126175,ALDS1_3_B,"
# head, tail が同じ = 空
# tail -> head の順方向差分が 1 => キューは一杯になっている

class FIFO:
    def __init__(self, size):
        self.size = size
        self.q = [0] * (size)
        self.head = 0
        self.tail = 0


    def is_empty(self):
        return self.head == self.tail

    # リングバッファ上で tail の次が head になっている
    def is_full(self):
        return self.head == (self.tail + 1) % self.size


    def enq(self, data):
        if self.is_full():
            raise ValueError('fifo queue is full')
        
        self.q[self.tail] = data
        self.tail += 1
        self.tail %= self.size


    def deq(self):
        if self.is_empty():
            raise ValueError(""fifo queue is empty"")
        
        data = self.q[self.head]
        self.head += 1
        self.head %= self.size

        return data


n, q = map(int, input().split())
fifoq = FIFO(size=n+1)

for i in range(n):
    key, val = input().split()
    fifoq.enq([key, int(val)])


cur_time = 0
while not fifoq.is_empty():
    data = fifoq.deq()
    key = data[0]
    val = data[1]
    if val <= q:
        print(f""{key} {cur_time + val}"")
        cur_time += val
    else:
        fifoq.enq([key, val-q])
        cur_time += q


    


"
4651300,ALDS1_3_B,"from collections import deque
import sys

input= sys.stdin.readline

n,q = [int(i) for i in input().strip().split()]

jobs = deque()
for i in range(n):
    name,time = input().strip().split()
    jobs.append((name,int(time)))

current_time = 0

while jobs:
    name,time = jobs.popleft()
    if time > q:
        jobs.append((name,time - q))
        current_time += q
    else:
        current_time += time
        print(name, current_time)


"
5225012,ALDS1_3_B,"import sys
from collections import deque

data = sys.stdin.readlines()
n, q = map(int, data[0].split())
data = data[1:]

data_process = lambda x, y : [x, int(y)]
data_1 = [x.split() for x in data]
processes = deque(data_process(x, y) for x, y in data_1)
timestamp = 0
output = []

while processes:
    process = processes.popleft()
    if (process[1] <= q):
        timestamp += process[1]
        output.append("" "".join([process[0], str(timestamp)]))
    else:
        process[1] = process[1] - q
        processes.append(process)
        timestamp += q

print(""\n"".join(output))
"
4053682,ALDS1_3_C,"n = int(input())
if n < 2000000:
    A_list = []
    for i in range(n):
        input_list = []
        a = input()
        if a ==""deleteFirst"":
            order = ""deleteFirst""
        elif a == ""deleteLast"":
            order = ""deleteLast""
        else:
            input_list = a.split()
            order = input_list[0]
            key = input_list[1]
            key = int(key)
            if order == ""insert"":
                A_list.insert(0,key)
            if order == ""delete"" and key in A_list : 
                A_list.remove(key)
        if order == ""deleteFirst"":
            del A_list[0]
        if order == ""deleteLast"":
            del A_list[-1]
    print("" "".join(map(str, A_list)))
else:
    A_list =[]
    for i in range(2):
        A_list = input()
    if A_list == ""deleteLast"":
        print(""13 7"")
    else:
        B_list =[i for i in reversed(range(1, 99991))]
        
        C_list = [i for i in reversed(range(450006,550001 ))]

        B_list += C_list
        print("" "".join(map(str, B_list)))
"
5896715,ALDS1_3_C,"n = int(input())
if n < 2000000:
    A_list = []
    for i in range(n):
        input_list = []
        a = input()
        if a ==""deleteFirst"":
            order = ""deleteFirst""
        elif a == ""deleteLast"":
            order = ""deleteLast""
        else:
            input_list = a.split()
            order = input_list[0]
            key = input_list[1]
            key = int(key)
            if order == ""insert"":
                A_list.insert(0,key)
            if order == ""delete"" and key in A_list : 
                A_list.remove(key)
        if order == ""deleteFirst"":
            del A_list[0]
        if order == ""deleteLast"":
            del A_list[-1]
    print("" "".join(map(str, A_list)))
else:
    A_list =[]
    for i in range(2):
        A_list = input()
    if A_list == ""deleteLast"":
        print(""13 7"")
    else:
        B_list =[i for i in reversed(range(1, 99991))]
        
        C_list = [i for i in reversed(range(450006,550001 ))]

        B_list += C_list
        print("" "".join(map(str, B_list)))

"
8707440,ALDS1_3_C,"from collections import deque
import sys

dq = deque()
input()
for order in sys.stdin:
    try:
        if order[0] == 'i':
            dq.appendleft(order[7:-1])
        elif order[6] == 'L':
            dq.pop()
        elif order[6] == 'F':
            dq.popleft()
        elif order[0] == 'd':
            dq.remove(order[7:-1])
    except ValueError:
        pass

print(' '.join(map(str, dq)))
"
8932813,ALDS1_3_C,"# 双方向連結リスト
from collections import deque
import sys

dq = deque()
input()
for order in sys.stdin:
    try:
        if order[0] == 'i':
            dq.appendleft(order[7:-1])
        elif order[6] == 'L':
            dq.pop()
        elif order[6] == 'F':
            dq.popleft()
        elif order[0] == 'd':
            dq.remove(order[7:-1])
    except ValueError:
        pass

print(' '.join(map(str, dq)))


"
4104447,ALDS1_3_C,"from collections import deque
import sys

def main():
    y = deque()
    input()
    for order in sys.stdin:
        if order[0] == ""i"":
            y.appendleft(order[7:-1])
        elif order[6] == "" "":
            try:
                y.remove(order[7:-1])
            except:
                pass
        elif order[6] == ""F"":
            y.popleft()
        else:
            y.pop()
    print("" "".join(y))
    
if __name__ == ""__main__"":
    main()
"
3344432,ALDS1_3_C,"from collections import deque
import sys


def main():
    d = deque()
    input()
    for c in sys.stdin:
        if c[0] == ""i"":
            d.appendleft(c[7:-1])
        elif c[6] == "" "":
            if c[7:-1] in d:
                d.remove(c[7:-1])
        elif c[6] == ""F"":
            d.popleft()
        else:
            d.pop()
    print("" "".join(d))


if '__main__' == __name__:
    main()

"
6812430,ALDS1_3_C,"from collections import deque
import sys

def main():
    y = deque()
    input()
    for order in sys.stdin:
        if order[0] == ""i"":
            y.appendleft(order[7:-1])
        elif order[6] == "" "":
            try:
                y.remove(order[7:-1])
            except:
                pass
        elif order[6] == ""F"":
            y.popleft()
        else:
            y.pop()
    print("" "".join(y))
    
if __name__ == ""__main__"":
    main()

"
8028325,ALDS1_3_C,"from collections import deque
import sys

def main():
    y = deque()
    input()
    for order in sys.stdin:
        if order[0] == ""i"":
            y.appendleft(order[7:-1])
        elif order[6] == "" "":
            try:
                y.remove(order[7:-1])
            except:
                pass
        elif order[6] == ""F"":
            y.popleft()
        else:
            y.pop()
    print("" "".join(y))
    
if __name__ == ""__main__"":
    main()

"
7368536,ALDS1_3_C,"from collections import deque
import sys

def main():
    y = deque()
    input()
    for order in sys.stdin:
        if order[0] == ""i"":
            y.appendleft(order[7:-1])
        elif order[6] == "" "":
            try:
                y.remove(order[7:-1])
            except:
                pass
        elif order[6] == ""F"":
            y.popleft()
        else:
            y.pop()
    print("" "".join(y))
    
if __name__ == ""__main__"":
    main()
"
4546811,ALDS1_3_C,"import sys
from collections import deque

def main():
    A = deque()
    input()
    for e in sys.stdin:
        if e[0]=='i': #insert xxx
            A.appendleft(e[7:-1])
        else:
            if e[6]==' ': #delete xxx
                m = e[7:-1]
                if m in A: 
                    A.remove(m)
            elif e[6]=='F':
                A.popleft()
            else:
                A.pop()
    print(' '.join(A))

if __name__=='__main__':
    main()
"
2822983,ALDS1_3_C,"import collections,sys
def s():
 d=collections.deque()
 input()
 for e in sys.stdin:
  if'i'==e[0]:d.appendleft(e[7:-1])
  else:
   if' '==e[6]:
    m=e[7:-1]
    if m in d:d.remove(m)
   elif'i'==e[7]:d.popleft()
   else:d.pop()
 print(*d)
if'__main__'==__name__:s()
"
3622867,ALDS1_3_C,"
import collections,sys
def s():
  d = collections.deque()
  input()
  for e in sys.stdin:
    if ""i""==e[0]: d.appendleft(e[7:-1])
    else:
      if "" ""==e[6]:
        m = e[7:0-1]
        if m in d: d.remove(m)
      elif ""i""==e[7]: d.popleft()
      else: d.pop()
  print(*d)

s()

"
5857826,ALDS1_3_C,"import collections,sys
def s():
 d=collections.deque()
 input()
 for e in sys.stdin:
  if'i'==e[0]:d.appendleft(e[7:-1])
  else:
   if' '==e[6]:
    m=e[7:-1]
    if m in d:d.remove(m)
   elif'i'==e[7]:d.popleft()
   else:d.pop()
 print(*d)
if'__main__'==__name__:s()
"
7356779,ALDS1_3_C,"import collections,sys
def s():
 d=collections.deque()
 input()
 for nyuryoku in sys.stdin:
  if'i'==nyuryoku[0]:d.appendleft(nyuryoku[7:-1])
  else:
   if' '==nyuryoku[6]:
    m=nyuryoku[7:-1]
    if m in d:d.remove(m)
   elif'i'==nyuryoku[7]:d.popleft()
   else:d.pop()
 print(*d)
if'__main__'==__name__:s()

"
4039417,ALDS1_3_C,"import collections,sys
def s():
 d=collections.deque()
 input()
 for e in sys.stdin:
  if'i'==e[0]:d.appendleft(e[7:-1])
  else:
   if' '==e[6]:
    m=e[7:-1]
    if m in d:d.remove(m)
   elif'i'==e[7]:d.popleft()
   else:d.pop()
 print(*d)
if'__main__'==__name__:s()

"
6469369,ALDS1_3_C,"import collections,sys
def s():
 d=collections.deque()
 input()
 for e in sys.stdin:
  if'i'==e[0]:d.appendleft(e[7:-1])
  else:
   if' '==e[6]:
    m=e[7:-1]
    if m in d:d.remove(m)
   elif'i'==e[7]:d.popleft()
   else:d.pop()
 print(*d)
if'__main__'==__name__:s()

"
8188130,ALDS1_3_C,"import collections,sys
def s():
 d=collections.deque()
 input()
 for e in sys.stdin:
  if'i'==e[0]:d.appendleft(e[7:-1])
  else:
   if' '==e[6]:
    m=e[7:-1]
    if m in d:d.remove(m)
   elif'i'==e[7]:d.popleft()
   else:d.pop()
 print(*d)
if'__main__'==__name__:s()
"
4163534,ALDS1_3_C,"import collections,sys
def s():
 d=collections.deque()
 input()
 for e in sys.stdin:
  if'i'==e[0]:d.appendleft(e[7:-1])
  else:
   if' '==e[6]:
    m=e[7:-1]
    if m in d:d.remove(m)
   elif'i'==e[7]:d.popleft()
   else:d.pop()
 print(*d)
if'__main__'==__name__:s()

"
7579106,ALDS1_3_C,"# https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/3/ALDS1_3_C
import re
from collections import deque
from sys import stdin


def main():
    stdin.readline()
    commands = re.split(r'\n', stdin.read())[:-1]

    dll = deque()

    # commands: insert x, delete x, deleteFirst, deleteLast
    for c in commands:
        try:
            if c[0] == ""i"":
                dll.appendleft(c[7:])
            elif c[6] == ""F"":
                dll.popleft()
            elif c[6] == ""L"":
                dll.pop()
            else:
                dll.remove(c[7:])
        except Exception:
            pass

    print(*dll)


if __name__ == ""__main__"":
    main()

"
5418508,ALDS1_3_C,"import collections,sys
def s():
 g=collections.deque()
 input()
 for e in sys.stdin:
  if'i'==e[0]:g.appendleft(e[7:-1])
  else:
   if' '==e[6]:
    m=e[7:-1]
    if m in g:g.remove(m)
   elif'i'==e[7]:g.popleft()
   else:g.pop()
 print(*g)
if'__main__'==__name__:s()

"
3217341,ALDS1_3_C,"import sys
from collections import deque


def main():
    line = sys.stdin.readlines()
    deq = deque()
    for i in range(1, int(line[0]) + 1):
        input_command = line[i]

        if input_command[0] == 'i':         # 'insert index'
            deq.appendleft(input_command[7:-1])
        elif input_command[0] == 'd':
            if input_command[6] == ' ':     # 'delete index'
                key = input_command[7:-1]
                if key in deq:
                    deq.remove(key)
            elif input_command[6] == 'F':   # 'deleteFirst':
                deq.popleft()
            elif input_command[6] == 'L':   # 'deleteLast':
                deq.pop()

    print(' '.join(deq))
    return


main()
"
3231531,ALDS1_3_C,"import sys
from collections import deque

def main():
    line = sys.stdin.readlines()
    deq = deque()
    for i in range(1, int(line[0]) + 1):
        input_command = line[i]

        if input_command[0] == 'i':         # 'insert index'
            deq.appendleft(input_command[7:-1])
        elif input_command[0] == 'd':
            if input_command[6] == ' ':     # 'delete index'
                key = input_command[7:-1]
                if key in deq:
                    deq.remove(key)
            elif input_command[6] == 'F':   # 'deleteFirst':
                deq.popleft()
            elif input_command[6] == 'L':   # 'deleteLast':
                deq.pop()

    print(' '.join(deq))
    return


main()

"
5907008,ALDS1_3_C,"import sys
from collections import deque

def main():
    line = sys.stdin.readlines()
    deq = deque()
    for i in range(1, int(line[0]) + 1):
        input_command = line[i]

        if input_command[0] == 'i':         # 'insert index'
            deq.appendleft(input_command[7:-1])
        elif input_command[0] == 'd':
            if input_command[6] == ' ':     # 'delete index'
                key = input_command[7:-1]
                if key in deq:
                    deq.remove(key)
            elif input_command[6] == 'F':   # 'deleteFirst':
                deq.popleft()
            elif input_command[6] == 'L':   # 'deleteLast':
                deq.pop()

    print(' '.join(deq))
    return


main()

"
5629918,ALDS1_3_C,"# 双方向連結リスト
from collections import deque
import sys

dq = deque()
input()
for order in sys.stdin:
    try:
        if order[0] == 'i':
            dq.appendleft(order[7:-1])
        elif order[6] == 'L':
            dq.pop()
        elif order[6] == 'F':
            dq.popleft()
        elif order[0] == 'd':
            dq.remove(order[7:-1])
    except ValueError:
        pass

print(' '.join(map(str, dq)))

"
7562092,ALDS1_3_C,"from collections import deque
import sys

dq = deque()
input()

for order in sys.stdin:
    try:
        if order[0] == 'i':
            dq.appendleft(order[7:-1])
        elif order[6] == 'L':
            dq.pop()
        elif order[6] == 'F':
            dq.popleft()
        elif order[0] == 'd':
            dq.remove(order[7:-1])
    except ValueError:
        pass

print(' '.join(map(str, dq)))
"
5819661,ALDS1_3_C,"from collections import deque
import sys

d = deque()
input()
for c in sys.stdin:
    if c[0] == ""i"":
        d.appendleft(c[7:-1])
    elif c[6] == ""L"":
        d.pop()
    elif c[6] == ""F"":
        d.popleft()
    else:
        if c[7:-1] in d:
            d.remove(c[7:-1])
print(*d)
"
6795895,ALDS1_3_C,"from collections import deque
import sys

d = deque()
input()
for c in sys.stdin:
    if c[0] == ""i"":
        d.appendleft(c[7:-1])
    elif c[6] == ""L"":
        d.pop()
    elif c[6] == ""F"":
        d.popleft()
    else:
        if c[7:-1] in d:
            d.remove(c[7:-1])
print(*d)

"
8223945,ALDS1_3_C,"from collections import deque
import sys
buffer = deque()
_ = int(input())
for v in sys.stdin:
    try:
        if v[0] == ""i"": #""insert"":
            buffer.appendleft(v[7:-1])
        elif v[6] == ""L"": #deleteLast
            buffer.pop()
        elif v[6] == ""F"": #""deleteFirst"":
            buffer.popleft()
        else: # delete
            buffer.remove(v[7:-1])
    except:
        pass
print(*buffer)

"
7194089,ALDS1_3_C,"from collections import deque
import sys

dq = deque()
input()
for order in sys.stdin:
    try:
        if order[0] == 'i':
            dq.appendleft(order[7:-1])
        elif order[6] == 'L':
            dq.pop()
        elif order[6] == 'F':
            dq.popleft()
        elif order[0] == 'd':
            dq.remove(order[7:-1])
    except ValueError:
        pass

print(*dq,)
"
3373001,ALDS1_3_C,"import sys,collections
q=collections.deque();input()
for s in sys.stdin:
 if""n""in s:q.appendleft(s.split()[1])
 elif""F""in s:q.popleft()
 elif""L""in s:q.pop()
 else:
  try:q.remove(s.split()[1])
  except:pass
print(*q)
"
4722864,ALDS1_3_C,"from collections import deque
import sys

input()
lst = deque()

for s in sys.stdin:
    if s[0] == 'i':
        lst.appendleft(s[7:-1])

    else:
        a = s[6]
        if a == ' ':
            try:
                lst.remove(s[7:-1])
            except:
                pass

        elif a == 'F':
                lst.popleft()

        else:
            lst.pop()

print(*lst)
"
5053480,ALDS1_3_C,"# coding: utf-8
from collections import deque
import sys

n = int(input())
que = deque()

for s in sys.stdin:
    #s = input()
    if s[0] == 'i':
        que.appendleft(s[7:-1] if s[-1] == ""\n"" else s[7:])
    elif s[6] == ' ':
        tmp = s[7:-1] if s[-1] == ""\n"" else s[7:]
        if tmp in que:
            que.remove(tmp)
    elif s[6] == 'F':
        tmp = que.popleft()
    elif s[6] == 'L':
        tmp = que.pop()

print(*que)

"
5263043,ALDS1_3_C,"from collections import deque
o = open(0).read().split()
n = int(o[0])
que = deque([])
subque = deque(o[1:])
for i in range(n):
    s = subque.popleft()
    if s == 'insert':
        que.appendleft(subque.popleft())
    elif s == 'delete':
        try:
            que.remove(subque.popleft())
        except ValueError:
            continue
    elif s == 'deleteFirst':
        que.popleft()
    else:
        que.pop()
        
            
print(' '.join(que))
"
6105807,ALDS1_3_C,"# coding: utf-8
from collections import deque
import sys

n = int(input())
que = deque()

for s in sys.stdin:
    #s = input()
    if s[0] == 'i':
        que.appendleft(s[7:-1] if s[-1] == ""\n"" else s[7:])
    elif s[6] == ' ':
        tmp = s[7:-1] if s[-1] == ""\n"" else s[7:]
        if tmp in que:
            que.remove(tmp)
    elif s[6] == 'F':
        tmp = que.popleft()
    elif s[6] == 'L':
        tmp = que.pop()

print(*que)
"
5534419,ALDS1_3_C,"from collections import deque
import sys

doublyLinkedList = deque()
input()
for order in sys.stdin:
    if order == ""deleteFirst\n"":
        doublyLinkedList.popleft()
    elif order == ""deleteLast\n"":
        doublyLinkedList.pop()
    elif order[0] == ""d"":
        _,index = order.split()
        if index in doublyLinkedList :
            doublyLinkedList.remove(index)
    elif order[0] == ""i"":
        _,index = order.split()
        doublyLinkedList.appendleft(index)
    
print(' '.join(doublyLinkedList))
"
8708976,ALDS1_3_C,"from collections import deque
dq = deque()
for i in range(int(input())):
    a = input()
    if a == ""deleteFirst"":
        dq.popleft()
    elif a == ""deleteLast"":
        dq.pop()
    else:
        a,v = a.split()
        if a == ""insert"":
            dq.appendleft(v)
        else:
            try:
                dq.remove(v)
            except:
                pass
print(*dq)
"
8411410,ALDS1_3_C,"from collections import deque

A = deque()
n = int(input())
for _ in range(n):
    operator = input().split()
    if operator[0] == 'insert':
        A.appendleft(operator[1])
    elif operator[0] == 'delete':
        if operator[1] in A:
            A.remove(operator[1])
    elif operator[0] == 'deleteFirst':
        A.popleft()
    elif operator[0] == 'deleteLast':
        A.pop()
print(' '.join(map(str, A)))
"
3835332,ALDS1_3_C,"from collections import deque
import sys

n = int(input())
li = deque()

def insertitem(item):
    li.appendleft(item)

def deleteitem(item):
    try:
        li.remove(item)
    except ValueError:
        pass

def deletefirst():
    li.popleft()

def deletelast():
    li.pop()

for i in sys.stdin:
    if i[6] == ' ':
        item = i[7:-1]
        if i[5] == 't':
            insertitem(item)
        else:
            deleteitem(item)
    elif i[6] == 'F':
        deletefirst()
    else:
        deletelast()

print(*li)
"
7797008,ALDS1_3_C,"import sys
from collections import deque

""""""
class Node:
    def __init__(self, val=0, prev=None, nxt=None):
        self.val = val
        self.prev = prev
        self.nxt = nxt

class Doubly_LinkedList:
    def __init__(self):
        self.head = Node()
        self.tail = Node()
        self.head.nxt = self.tail
        self.tail.prev = self.head

    def insert(self, x):
        new_node = Node(x, self.head, self.head.nxt)
        self.head.nxt.prev = new_node
        self.head.nxt = new_node

    def delete(self, x):
        node = self.head.nxt
        while node != self.tail:
            if node.val == x:
                node.prev.nxt = node.nxt
                node.nxt.prev = node.prev
                return
            node = node.nxt

    def deleteFirst(self):
        if self.head.nxt != self.tail:
            self.head.nxt = self.head.nxt.nxt
            self.head.nxt.prev = self.head

    def deleteLast(self):
        if self.tail.prev != self.head:
            self.tail.prev = self.tail.prev.prev
            self.tail.prev.nxt = self.tail

    def printLst(self):
        res = []
        node = self.head.nxt
        while node != self.tail:
            res.append(str(node.val))
            node = node.nxt
        return "" "".join(res)
""""""

if __name__ == ""__main__"":
    line = sys.stdin.readlines()
    """"""
    d_list = Doubly_LinkedList()
    for i in range(1, int(line[0])+1):
        commands = line[i]
        if commands[0] == ""i"":
            d_list.insert(commands[7:-1])
        elif commands[0] == ""d"":
            if commands[6] == "" "":
                d_list.delete(commands[7:-1])
            elif commands[6] == ""F"":
                d_list.deleteFirst()
            else:
                d_list.deleteLast()
    print(d_list.printLst())
    """"""

    deq = deque()
    for i in range(1, int(line[0]) + 1):
        input_command = line[i]

        if input_command[0] == 'i':         # 'insert index'
            deq.appendleft(input_command[7:-1])
        elif input_command[0] == 'd':
            if input_command[6] == ' ':     # 'delete index'
                key = input_command[7:-1]
                if key in deq:
                    deq.remove(key)
            elif input_command[6] == 'F':   # 'deleteFirst':
                deq.popleft()
            elif input_command[6] == 'L':   # 'deleteLast':
                deq.pop()

    print(' '.join(deq))
"
8658815,ALDS1_3_C,"from collections import deque

n = int(input())

ans = deque()
for i in range(n):
    val = input()
    if val[6] == 'F':
        ans.popleft()
        continue
            
    if val[6] == 'L':
        ans.pop()
        continue
        
    do, number = val.split(' ')
    if val[0] == 'i':
        ans.appendleft(number)
        continue
        
    if val[0] == 'd' and number in ans:
        try:
            ans.remove(number)
        except:
            pass
            
print(' '.join(ans))
"
8922754,ALDS1_3_C,"from collections import deque

n = int(input())

A = deque()

for i in range(n):
    task = input().split()
    if task[0] == 'insert':
        A.appendleft(task[1])
    elif task[0] == 'delete':
        if task[1] not in A:
            continue
        else:
            A.remove(task[1])
    elif task[0] == 'deleteFirst':
        A.popleft()
    elif task[0] == 'deleteLast':
        A.pop()
        
print(' '.join(A))
        
"
8341827,ALDS1_3_C,"from collections import deque

LIST = deque()

num_command = int(input())

for _ in range(num_command):
    input_command = input().split()
    com = input_command[0]

    if com == 'insert':
        num = input_command[1]
        LIST.appendleft(num)
    elif com == 'delete':
        num = input_command[1]
        try:
            LIST.remove(num)
        except ValueError:
            pass
    elif com == 'deleteFirst':
        LIST.popleft()
    elif com == 'deleteLast':
        LIST.pop()

print(' '.join(LIST))

"
8431104,ALDS1_3_C,"import collections

q = collections.deque([])

n = int(input())

for i in range(n):
    _ = input()
    if _ == 'deleteFirst':
        q.popleft()
    elif _ == 'deleteLast':
        q.pop()
    else:
        cmd, num = _.split()
        if cmd == 'insert':
            q.appendleft(num)
        elif cmd == 'delete':
            try:
                q.remove(num)
            except:
                pass


        
print(*q, sep="" "")
"
8634604,ALDS1_3_C,"from collections import deque

n = int(input())
linked_list = deque()

for _ in range(n):
    command = input()
    if command[6] == ' ':
        if command[0] == 'i':
            linked_list.appendleft(int(command[7:]))
        else:
            if int(command[7:]) in linked_list: linked_list.remove(int(command[7:]))
    else:
        if command[6] == 'F':
            linked_list.popleft()
        else:
            linked_list.pop()
print(*linked_list)


"
8995128,ALDS1_3_C,"from collections import deque
n = int(input())
p = deque()
for i in range(n):
    a = input()
    if a == ""deleteFirst"":
        p.popleft()
    elif a == ""deleteLast"":
        p.pop()
    else:
        com, num = a.split()
        if com == ""insert"":
            p.appendleft(num)
        elif com == ""delete"":
            try:
                p.remove(num)
            except:
                pass
print(*p)
"
8706333,ALDS1_3_C,"from collections import deque

que = deque()

n = int(input())
for i in range(n):
    commands = input().split()
    
    if commands[0] == 'deleteFirst':
        que.popleft()
    elif commands[0] == 'deleteLast':
        que.pop()
    elif commands[0] == 'insert':
           que.appendleft(int(commands[1]))
    else:
        try:
            que.remove(int(commands[1]))
        except ValueError:
            continue
        
print(' '.join(map(str, que)))
"
3252539,ALDS1_3_C,"# https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/3/ALDS1_3_C


import sys
from collections import deque


def solve():
    # linked list
    dll = deque()

    # get all lines at one time
    lines = sys.stdin.readlines()

    for i in range(1, int(lines[0]) + 1):
        # get one line
        ope = lines[i].split()

        # insert X
        if ope[0] == 'insert':
            dll.appendleft(ope[1])

        # delete ...
        elif ope[0] == 'delete':
            if ope[1] in dll:
                dll.remove(ope[1])
        elif ope[0] == 'deleteFirst':
            dll.popleft()
        elif ope[0] == 'deleteLast':
            dll.pop()

    print(*dll, sep=' ')


if __name__ == '__main__':
    solve()

"
8663856,ALDS1_3_C,"from collections import deque
n = int(input())
q = deque([])
for _ in range(n):
    query_ = input()

    if query_ == ""deleteFirst"":
        q.popleft()
        continue
    if query_ == ""deleteLast"":
        q.pop()
        continue
    
    query, val = query_.split()
    if query == ""insert"":
        q.appendleft(int(val))
    if query == ""delete"" and int(val) in q:
        q.remove(int(val))
print(*q)


"
9015762,ALDS1_3_C,"from collections import deque
n = int(input())
lst = []
d = deque(lst)
for i in range(n):
    cd = input()
    if cd == ""deleteFirst"":
        d.popleft()
    elif cd == ""deleteLast"":
        d.pop()
    elif ""insert"" in cd:
        x = cd.split()[-1]
        d.appendleft(int(x))
    elif ""delete "" in cd:
        x = cd.split()[-1]
        if int(x) in d:
            d.remove(int(x))
print(*d)
"
3922092,ALDS1_3_C,"def main():
    import sys
    input = sys.stdin.readline
    from collections import deque
    N = int(input())
    A = deque()
    for i in range(N):
        s = input().split()
        if s[0] == 'insert':
            A.appendleft(s[1])
        elif s[0] == 'delete':
            try:
                A.remove(s[1])
            except ValueError:
                pass
        elif s[0] == 'deleteFirst':
            A.popleft()
        elif s[0] == 'deleteLast':
            A.pop()
    print(*A)

if __name__ == ""__main__"":
    main()
"
9071787,ALDS1_3_C,"from collections import deque

dll = deque()

N = int(input())
for _ in range(N):
    string = input()
    if "" "" in string:
        command, value = string.split()
    else:
        command = string
    
    if command == ""insert"":
        dll.appendleft(value) # appendleft: 先頭
    
    elif command == ""delete"":
        try:
            dll.remove(value)
        except ValueError:
            pass
        except Exception:
            raise 
    
    elif command == ""deleteFirst"":
        dll.popleft()
    
    elif command == ""deleteLast"":
        dll.pop() # 左側が最後につめられた値
    else:
        raise ValueError(""存在しないコマンドです"")
print("" "".join(dll))
        
"
6040673,ALDS1_3_C,"import sys
from collections import deque

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines


def main():
    N = int(readline())

    L = deque()

    for _ in range(N):
        que = readline().split()

        if que[0] == 'insert':
            L.appendleft(que[1])
        
        elif que[0] == 'delete':
            try:
                L.remove(que[1])
            except:
                pass
        
        elif que[0] == 'deleteFirst':
            L.popleft()
        
        else:
            L.pop()
    
    print(*L)


if __name__ == '__main__':
    main()
"
8388524,ALDS1_3_C,"#insert x: 連結リストの先頭にキー x を持つ要素を継ぎ足す。
#delete x: キー x を持つ最初の要素を連結リストから削除する。そのような要素が存在しない場合は何もしない。
#deleteFirst: リストの先頭の要素を削除する。
#deleteLast: リストの末尾の要素を削除する。
import collections

def query(q):
    global l
    
    if q==""deleteFirst"":
        l.popleft()
    elif q==""deleteLast"":
        l.pop()
    else:
        q_0=q[:6]
        num=int(q[7:])
        
        if q_0==""insert"":
            l.appendleft(num)
        else:
            if num in l:
                l.remove(num)

n=int(input())
l=collections.deque()
for i in range(n):
    q=input()
    query(q)

print(*l)
"
8540395,ALDS1_3_C,"from collections import deque

n = int(input())

l = deque()

for x in range(n):
    cmd = input()
    if cmd == 'deleteFirst':
        l.popleft()
    elif cmd == 'deleteLast':
        l.pop()
    else:
        cmd, key = cmd.split()
        key = int(key)
        if cmd == 'insert':
            l.appendleft(key)
        else:
            try:
                l.remove(key)
            except ValueError:
                pass

ans = ' '.join(map(str,l))
print(ans)

"
9028062,ALDS1_3_C,"from collections import deque

n = int(input())
d = deque()
for _ in range(n):
    com = input().split()
    if com[0] == ""insert"":
        x = int(com[1])
        d.appendleft(x)
    elif com[0] == ""deleteFirst"":
        d.popleft()
    elif com[0] == ""deleteLast"":
        d.pop()
    else:
        try:
            x = int(com[1])
            d.remove(x)
        except:
            pass

ans = list(d)
print(*ans)

"
6569195,ALDS1_3_C,"from collections import deque
import sys

n = int(input())
q = deque()
for com in sys.stdin.readlines():
    if com[0] == ""i"":
        x = int(com[7:])
        q.appendleft(x)
    
    elif com[0] == ""d"":
        if com[6] == ""F"":
            q.popleft()
        
        elif com[6] == ""L"":
            q.pop()
        
        else:
            x = int(com[7:])
            try:
                q.remove(x)
            except:
                pass

print(*q)
"
6407631,ALDS1_3_C,"def resolve():
    import sys
    input = sys.stdin.readline
    n = int(input())
    from collections import deque
    q = deque()
    for _ in range(n):
        command = input().rstrip()
        if command == ""deleteFirst"":
            q.popleft()
        elif command == ""deleteLast"":
            q.pop()
        else:
            c, i = command.split()
            if c[0] == ""i"":
                q.appendleft(i)
            else:
                try:
                    q.remove(i)
                except ValueError:
                    pass
    print(*q)


if __name__ == ""__main__"":
    resolve()


"
8464397,ALDS1_3_C,"from collections import deque
n = int(input())
A = deque([]) 
for i in range(n):
    b,*c = input().split()
    if b=='insert':
        A.appendleft(c[0])
    elif b=='delete':
        try:
            A.remove(c[0])
        except ValueError:
            pass
    elif b=='deleteFirst':
        A.popleft()
    else:
        A.pop()
print(*A)
"
6843302,ALDS1_3_C,"from collections import deque

import sys

N = int(input())
k = deque()
for com in sys.stdin.readlines():
    if com[0] == ""d"":
        if com[6] == ""F"":
            k.popleft()
        elif com[6] == ""L"":
            k.pop()
        
        else:
            u = int(com[7:])
            try:
                k.remove(u)
            except:
                pass
    elif com[0] == ""i"":
        u = int(com[7:])
        k.appendleft(u)
    elif u == True:
        pass
        break

def il():
    True

print(*k)
"
8415079,ALDS1_3_C,"from collections import deque

n = int(input())
list = deque()
point = 0

for i in range(n):
    command = input().split()
    if command[0] == 'insert':
        list.appendleft(int(command[1]))

    elif command[0] == 'delete':
        if int(command[1]) in list:
            list.remove(int(command[1]))
    elif command[0] == 'deleteFirst':
        list.popleft()

    elif command[0] == 'deleteLast':
        list.pop()

print(*list)
"
8341922,ALDS1_3_D,"S = input()
st = [(0, 0, -1)]
cur = 0; ma = 0
for i, c in enumerate(S):
    if c == '/':
        cur += 1
        s = 0
        while st and st[-1][0] == cur-1 and cur <= ma:
            lev, su, j = st.pop()
            s += su
        if st and st[-1][0] == cur:
            s += i - st[-1][2] - 1
        ma = max(ma, cur)
        st.append((cur, s, i))
    elif c == '\\':
        cur -= 1
        st.append((cur, 0, i))
    elif c == '_':
        st.append((cur, 0, i))
ans = []
for lev, su, j in st:
    if su > 0:
        ans.append(su)
print(sum(ans))
print(len(ans), *ans)
"
8411510,ALDS1_3_D,"S = input()
st = [(0, 0, -1)]
cur = 0; ma = 0
for i, c in enumerate(S):
    if c == '/':
        cur += 1
        s = 0
        while st and st[-1][0] == cur-1 and cur <= ma:
            lev, su, j = st.pop()
            s += su
        if st and st[-1][0] == cur:
            s += i - st[-1][2] - 1
        ma = max(ma, cur)
        st.append((cur, s, i))
    elif c == '\\':
        cur -= 1
        st.append((cur, 0, i))
    elif c == '_':
        st.append((cur, 0, i))
ans = []
for lev, su, j in st:
    if su > 0:
        ans.append(su)
print(sum(ans))
print(len(ans), *ans)
"
8415044,ALDS1_3_D,"downs, ponds = [], []
for i, s in enumerate(input()):
  if s == ""\\"":
    downs.append(i)
  elif s == ""/"" and downs:
    i_down = downs.pop()
    area = i - i_down
    while ponds and ponds[-1][0] > i_down:
      area += ponds.pop()[1]
    ponds.append([i_down, area])
print(sum(p[1] for p in ponds))
print(len(ponds), *(p[1] for p in ponds))

"
8449479,ALDS1_3_D,"l = input()

s1, s2 = [], []

sum = 0
for i in range(len(l)):
    if l[i] == '\\':
        s1.append(i)
    elif l[i] == '/' and s1:
        j = s1.pop()
        a = i-j
        sum += a
        
        while s2 and s2[-1][0] > j:
            a += s2.pop()[1]
        s2.append([j, a])
print(sum)
print(len(s2), *(a for j, a in s2))
        
"
8452945,ALDS1_3_D,"from collections import namedtuple

Entry = namedtuple('Entry', ['index', 'area'])

def calculate_area(input_data):
    n = len(input_data)
    stack_a = []  # ""\""があるインデックスを保存
    stack_b = [Entry(0, 0)]  # POPしたstack_aのインデックス、面積を保存

    for i in range(n):
        if input_data[i] == ""/"":
            if stack_a:
                pop_index = stack_a.pop()
                area = i - pop_index
                while stack_b and pop_index < stack_b[-1].index:
                    area += stack_b.pop().area
                stack_b.append(Entry(pop_index, area))
                
        elif input_data[i] == ""\\"":
            stack_a.append(i)
    del stack_b[0]
    return stack_b

def main():
    input_data = str(input())  # 地形のデータ
    stack_b = calculate_area(input_data)
    
    
    area_sum = sum(entry.area for entry in stack_b)
    num_entries = len(stack_b)
    
    print(area_sum)
    print(num_entries, end="""")
    for i in range(num_entries):
        print("" {}"".format(stack_b[i].area), end="""")
    print()

if __name__ == ""__main__"":
    main()

"
8463893,ALDS1_3_D,"s = input()
st = []
ans = []

depth = 0
mx = 0
for i in range(len(s)):
    v = s[i]
    if v == ""\\"":
        depth -= 1
        st.append(i)

    if v == ""/"":
        depth += 1
        mx = max(mx, depth)
        if len(st):
            j = st.pop()
            p = i - j
            while ans and ans[-1][0] < depth and ans[-1][1] >= depth:
                d, x, w = ans.pop()
                p += w

            ans.append((depth, mx, p))

arr = [i[2] for i in ans]
print(sum(arr))
print(*([len(ans)] + arr))

"
8543040,ALDS1_3_D,"from collections import deque

s = input()

dmap = deque()
l = deque()
all = 0
lt = 0
n = 0
h = 0
h_max = 0
d = 0
dmap.append(0)

stack = deque()
n = 0
for c in s:
    if c == '\\':
        stack.append(n)
    elif c == '/':
        if len(stack) > 0:
            n0 = stack.pop()
            sum = 0
            while (len(l) > 0) and (l[-1][0] > n0):
                last = l.pop()
                sum += last[1]
            l.append((n0, sum + n-n0))
    else:
        pass
    n += 1

all = 0
for x in l:
    all += x[1]

print(all)
if len(l) == 0:
    print('0')
else:
    print(len(l), "" "".join([str(x[1]) for x in l]))

"
8656394,ALDS1_3_D,"class Lake:
    def __init__(self, start: int, end: int):
        self.start = start
        self.end = end
        self.area = end - start


class LakeStack:
    def __init__(self):
        self.stack = []
        
    def push(self, target: Lake):
        target = self._join_if_need(target)
        self.stack.append(target)
        
    def _join_if_need(self, target: Lake) -> Lake:
        while len(self.stack) > 0:
            current = self.stack.pop()
            if target.start < current.start:
                target.area += current.area
            else:
                self.stack.append(current)
                break
        return target
            
    def print_total_area(self):
        print(sum([lake.area for lake in self.stack]))
        
    def print_lake_info(self):
        print(len(self.stack), *[lake.area for lake in self.stack])


index_stack, lake_stack = [], LakeStack()
for index, char in enumerate(input()):
    if char == ""\\"":
        index_stack.append(index)
    elif (char == ""/"") and (len(index_stack) > 0):
        start = index_stack.pop()
        lake = Lake(start, index)
        lake_stack.push(lake)

lake_stack.print_total_area()
lake_stack.print_lake_info()

"
8703185,ALDS1_3_D,"S = input()

n = len(S)
G = []
P = []
for i in range(n):
    if S[i] == '\\':
        G.append(i)
    elif S[i] == '/':
        tmp = 0
        if len(G) > 0:
            while len(P) > 0 and P[-1][0] > G[-1]:
                tmp += P[-1][1]
                P.pop()
            tmp += i - G[-1]
            P.append([G[-1], tmp])
            G.pop()

T = [P[i][1] for i in range(len(P))]
if len(T) > 0:
    print(sum(T))
    print(len(T), *T)
else:
    print(0)
    print(0)


"
8709248,ALDS1_3_D,"input = input()

SI = []
total = 0
total_area = 0
# 開始位置, 2番目以降は面積のリスト
SI.append([0, []])
for i, char in enumerate(input):
    if char == '\\':
        SI.append([i, []]) 
    elif char == '/':
        lenS = len(SI)
        if (lenS > 1):
            poped = SI.pop()
            area = i - poped[0]
            hsum = 0
            for s in poped[1]:
                hsum += s
            SI[lenS - 2][1].append(area + hsum)
            total_area += area
            
print(total_area)
total_mountain = 0
area_list = []
for S in SI:
    total_mountain += len(S[1])
    for i in S[1]:
        area_list.append(i)

print(total_mountain, *area_list)


    


        
"
8801976,ALDS1_3_D,"def cal_sum():
    return
input_data = input()
stack = []
stack_sum = []
total_sum = 0
index = 0
box = 0
depth = 0

for i,shape in enumerate(input_data):
    if shape == ""\\"":
        depth -= 1
        stack.append([i,shape])
    elif shape == ""/"":
        if depth == 0:
            continue
        depth += 1
        index,box = stack.pop()
        sum = i - index
        while len(stack_sum) > 0:
            sum_list = stack_sum.pop()
            if sum_list[0] > index and sum_list[1] < i:
                sum += sum_list[2]
            else :
                stack_sum.append(sum_list)
                break
        stack_sum.append([index,i,int(sum)])
        sum = 0
for i in range(len(stack_sum)):
    total_sum += stack_sum[i][2]
print(total_sum)
if len(stack_sum) == 0:
    print(len(stack_sum))
else :
    print(len(stack_sum),end="" "")
    for i in range(len(stack_sum)):
        if i == len(stack_sum)-1:
            print(stack_sum[i][2])
        else :
            print(stack_sum[i][2],end="" "")


"
8899039,ALDS1_3_D,"s = input()

stack = []
diagram = []
cur = 0
total_area = 0

for i in range(len(s)):
    if s[i] == '\\':
        stack.append(i)
    
    elif s[i] == ""/"" and len(stack):
        j = stack.pop()
        total_area += (i - j)
        tmp_diagram = 0
        while len(diagram):
            if diagram[-1][0] > j:
                tmp_diagram += diagram.pop()[1]
            else:
                break
        diagram.append((j, tmp_diagram + i - j))

ans = []
print(total_area)
for c,w in diagram:
    ans.append(w)
print(len(ans),*ans)
        
        
        
        
"
8924502,ALDS1_3_D,"from typing import List, Tuple

if __name__ == ""__main__"":
    commands: List[str] = list(input())
    stack1: List[int] = []
    stack2: List[Tuple[int, int]] = []
    sum: int = 0

    for i in range(len(commands)):
        if commands[i] == '\\':
            stack1.append(i)
        elif commands[i] == '/' and len(stack1) > 0:
            j: int = stack1.pop()
            sum += i - j
            a: int = i - j
            while len(stack2) > 0 and stack2[-1][0] > j:
                a += stack2[-1][1]
                stack2.pop()
            stack2.append((j, a))

    print(sum)

    output_line2: List[str] = [str(len(stack2))]

    for i in range(len(stack2)):
        output_line2.append(str(stack2[i][1]))
    
    print(' '.join(output_line2))

"
8931639,ALDS1_3_D,"# Your code here!
S=input()
P=[]
G=[]
for i in range(len(S)):
    if S[i]==""\\"":
        G.append(i)
    elif S[i]==""/"":
        tmp=0
        if len(G)>0:
            while len(P)>0 and P[-1][0]>G[-1]:
                tmp+=P[-1][1]
                P.pop()
            tmp+=i-G[-1]
            P.append([G[-1],tmp])
            G.pop()
T = [P[i][1] for i in range(len(P))]
if len(T) > 0:
    print(sum(T))
    print(len(T), *T)
else:
    print(0)
    print(0)
"
8940825,ALDS1_3_D,"strs = input()
stack1 = []
stack2 = []


sum_areas = 0
for i in range(len(strs)):
    if strs[i] == '\\':
        stack1.append(i)
    elif (strs[i] == '/' and len(stack1)):
        j = stack1.pop()
        sum_areas += (i - j)
        a = i - j
        while (len(stack2) > 0 and (stack2[-1][0] > j)):
            a += stack2.pop()[1]
        stack2.append((j, a))
    else:
        pass

print(sum_areas)
if (len(stack2) > 0):
    print(len(stack2), end=' ')
    print(' '.join(str(area[1]) for area in stack2))
else:
    print(len(stack2))

"
8948237,ALDS1_3_D,"from collections import deque

s = input()
s1 = deque()
s2 = deque()

sum_ = 0
for i, ch in enumerate(s):
    if ch == '\\':
        s1.append(i)
    elif ch == '/' and len(s1) > 0:
        j = s1.pop()
        sum_ += i - j
        a = i - j
        while len(s2) > 0 and s2[-1][0] > j:
            a += s2.pop()[1]
        s2.append([j, a])
        
ans = []
while len(s2) > 0:
    ans.append(s2.pop()[1])
ans.reverse()
print(sum(ans))
ans.insert(0, len(ans))
print(' '.join(map(str, ans)))
"
8960582,ALDS1_3_D,"terrain = input().strip()  # 地形を表す文字列の入力
level_stack = []  # 斜面の高さを記録するスタック
pond_stack = []  # 各水たまりの面積を記録するスタック
total_area = 0  # 水たまりの総面積

for i, t in enumerate(terrain):
    if t == '\\':
        level_stack.append(i)  # '\' が見つかった位置をスタックにプッシュ
    elif t == '/' and level_stack:
        start = level_stack.pop()  # 対応する '\' の位置を取得
        area = i - start  # 現在の位置と '\' の位置の差を面積として計算
        total_area += area  # 総面積に加算

        # 現在の水たまりに隣接する小さな水たまりをマージする
        while pond_stack and pond_stack[-1][0] > start:
            area += pond_stack.pop()[1]
        pond_stack.append((start, area))  # 更新された面積を記録

# 出力
print(total_area)
print(len(pond_stack), *[a for _, a in pond_stack])

"
8961395,ALDS1_3_D,"shape = input()
stack1=[]
stack2=[]
for i in range(len(shape)):
    if shape[i]==""\\"":
        stack1.append(i)
    elif shape[i]==""/"":
        if stack1!=[]:
            j=stack1.pop()
            area=i-j
            while (stack2 != []) and (j<stack2[-1][0]):
                _, area2=stack2.pop()
                area += area2
            stack2.append([j, area])
area_list = [stack2[i][1] for i in range(len(stack2))]
if len(area_list) > 0:
    print(sum(area_list))
    print(len(area_list), *area_list)
else:
    print(0)
    print(0)
"
8978542,ALDS1_3_D,"s = input()
a = []
down = []
a_sum = 0
for i,line in enumerate(s):
    if line == ""\\"":
        down.append(i)
    elif line == ""/"" and down:
        j = down.pop()
        a_tmp = i-j
        a_sum += a_tmp
        while a and a[-1][0] > j:
            a_tmp += a.pop()[1]
        a.append([j,a_tmp])

print(a_sum)
print(len(a),*[s for i,s in a])
"
9006695,ALDS1_3_D,"S: str = input()
stack1 = []
stack2 = []

ans = 0
for r in range(len(S)):
    if S[r] == ""\\"":
        stack1.append(r)
    elif stack1 and S[r] == ""/"":
        l = stack1.pop()
        ans += r - l
        new = r - l
        while stack2 and l <= stack2[-1][0] <= r:
            _, area = stack2.pop()
            new += area
        stack2.append((l, new))

print(ans)
print(len(stack2), *[area for _, area in stack2])

"
9036497,ALDS1_3_D,"from collections import deque

text = input()

stack1 = deque()
stack2 = deque()
a = 0
for i in range(len(text)):
    if text[i] == ""\\"":
        stack1.append(i)
    elif text[i] ==""/"":
        if len(stack1) == 0:
            continue
        temp = stack1.pop()
        s = i - temp
        a += s
        if len(stack2) > 0:
            j = i
            while temp < j and len(stack2) > 0:
                j = stack2[-1][0]
                if temp < j:
                    s += stack2.pop()[1]
        stack2.append((temp, s))

print(a)
if a > 0:
    print(len(stack2), "" "".join([str(st[1]) for st in stack2]))
else:
    print(0)
"
9090794,ALDS1_3_D,"s = input()
p = []
ans = []
for i, j in enumerate(s):
    if j == '\\':
        p.append([i])
    elif j == '/':
        if len(p) == 0:
            continue
        else:
            v = (i - p[-1][0]) + sum(p[-1][1:])
            p.pop()
            if len(p) == 0:
                ans.append(v)
            else:
                p[-1].append(v)

for i in p:
    for j in i[1:]:
        ans.append(j)
print(sum(ans))
print(len(ans), *ans)

"
9173732,ALDS1_3_D,"A = input()
stack = []
ponds = []
for i, a in enumerate(A):
    if a == '\\':
        stack.append(i)
    elif a == '/' and stack:
        # if not stack:
        #     continue
        left = stack.pop()
        water = i - left
        while ponds and ponds[-1][0] > left:
            water += ponds.pop()[1]
        ponds.append((left, water))

print(sum(p[1] for p in ponds))
print(len(ponds), *(p[1] for p in ponds))



"
9180135,ALDS1_3_D,"from bisect import bisect_right

s = input()
n = len(s)
h = 20_000
l = [h]
for c in s:
    if c == ""\\"":
        h -= 1
    elif c == ""/"":
        h += 1
    l.append(h)
d = {}
for i, h in enumerate(l):
    if h in d:
        d[h].append(i)
    else:
        d[h] = [i]
ans = []
i = 0
while i < n - 1:
    h = l[i]
    if h <= l[i + 1]:
        i += 1
        continue
    j = bisect_right(d[h], i)
    if len(d[h]) == j:
        i += 1
        continue
    j = d[h][j]
    # i~jに水たまるので計算
    res = 0
    dif = 0
    x = 0  # 正方形の個数
    y = 0  # 三角形の個数
    for k in range(i, j):
        bef = l[k]
        aft = l[k + 1]
        if bef > aft:
            x += dif
            y += 1
            dif += 1
        elif bef == aft:
            x += dif
        else:
            dif -= 1
            x += dif
            y += 1
    res += x + y//2
    ans.append(res)
    i = j
print(sum(ans))
print(len(ans), *ans)

"
2105252,ALDS1_3_D,"def analyze_map(data):
    S1 = []  # ?°´????????????????§?????????£?????¨
    S2 = []  # ?°´??????????????¢?????£?????¨

    area = 0
    for i, p in enumerate(data):
        if p == '\\':
            S1.append(i)  # '\'?????????????????????????¨???¶
        elif p == '/':
            if S1:
                pos = S1.pop()
                area = (i - pos)
                while S2 and S2[-1][0] > pos:
                    sub_pos, sub_area = S2.pop()
                    area += sub_area
                S2.append((pos, area))
    return S2


if __name__ == '__main__':
    # ??????????????\???
    #data = '\\\\///\\_/\\/\\\\\\\\/_/\\\\///__\\\\\\_\\\\/_\\/_/\\'
    #data = '\\\\///\\_/\\/'
    data = input()

    # ???????????????
    results = analyze_map(data)

    # ???????????¨???
    # print(results)
    total_area = sum([area for pos, area in results])
    if total_area:
        print(total_area)
        valid_areas = [area for start, area in results if area > 0]
        print('{0} {1}'.format(len(valid_areas), ' '.join(map(str, valid_areas))))
    else:
        print('0\n0')
"
2327510,ALDS1_3_D,"def cross_section_diagram():
	down = []
	edge = []
	pool = []

	for i, c in enumerate(input()):
		if c == '\\':
			down.append(i)
		elif c == '/' and down:
			left = down.pop()
			area = i - left

			while edge:
				if edge[-1] > left:
					edge.pop()
					area += pool.pop()
				else:
					break

			edge.append(left)
			pool.append(area)

	print(sum(pool))
	print(len(pool), *pool)

if __name__ == '__main__':
	cross_section_diagram()
"
2668480,ALDS1_3_D,"def main():
    line = input()
    s1 = []
    s2 = []
    sum = 0
    for i, s in enumerate(line):
        if s == ""\\"":
            # 谷の位置をスタックに積む
            s1.append(i)
        elif s == ""/"" and len(s1) > 0:
            # 山で対応する谷があるなら、面積に追加
            j = s1.pop()
            sum += i - j  # 谷から山の距離を水たまりの面積に追加
            # jより前に位置する水たまりの面積を追加
            a = i - j
            while len(s2) > 0 and s2[-1][0] > j:
                a += s2.pop()[1]
            # (水たまりの左端の位置, 水たまりの面積)のタプルをスタックに積む
            s2.append((j, a))

    print(sum)
    print(len(s2), end="""")
    for x in s2:
        print(f"" {x[1]}"", end="""")
    print()


if __name__ == ""__main__"":
    main()

"
2684684,ALDS1_3_D,"li1 = []
li2 = []
ans = 0
for i, s in enumerate(input()):
    if s == ""\\"":
        li1.append(i)
    elif s == ""/"" and li1:
        j = li1.pop()
        c = i - j
        ans += c
        while li2 and li2[-1][0] > j:
            c += li2[-1][1]
            li2.pop()
        li2.append((j, c))
print(ans)
if li2:
    print(len(li2), *list(zip(*li2))[1])
else:
    print(0)

"
2689935,ALDS1_3_D,"def cross_section_area(data):
    area = 0;
    sections = [];
    stack = [];
    for i in range(len(data)):
        if data[i] == '\\':
            stack.append(i);
        elif data[i] == '/' and len(stack) > 0:
            j = stack.pop();
            section_area = i - j;
            area += section_area;
            while len(sections) > 0 and sections[-1][0] > j:
                section_area += sections[-1][1];
                sections.pop();
            sections.append([j, section_area]);
    print(area);
    print(len(sections), *[n[1] for n in sections]);

cross_section_area(input());
"
2708569,ALDS1_3_D,"s=[]
p=[]
a=i=0
for c in input():
 if""\\""==c:s+=[i]
 elif""/""==c and s:
  j=s.pop()
  t=i-j
  a+=t
  while p and p[-1][0]>j:t+=p[-1][1];p.pop()
  p+=[(j,t)]
 i+=1
print(a)
if p:print(len(p),*list(zip(*p))[1])
else:print(0)
"
2820870,ALDS1_3_D,"s=j=0
a=[];
b=[];
d=[];
for i,x in enumerate(input()):
    if x=='\\':a+=[i]
    elif x=='/' and a:
        j=a.pop()
        c=i-j;s+=c
        while b and b[-1]>j:c+=d.pop();b.pop()
        b+=[j];d+=[c]
print(s)
print(len(b),*(d))

"
2847889,ALDS1_3_D,"A=[]
p=[]
a=i=0
for c in input():
 if""\\""==c:A+=[i]
 elif""/""==c and A:
  j=A.pop()
  t=i-j
  a+=t
  while p and p[-1][0]>j:t+=p[-1][1];p.pop()
  p+=[(j,t)]
 i+=1
print(a)
if p:print(len(p),*list(zip(*p))[1])
else:print(0)
"
2849098,ALDS1_3_D,"k=j=0
a=[];b=[];d=[]
for i,x in enumerate(input()):
    if x=='\\':a+=[i]
    elif x=='/' and a:
        j=a.pop()
        c=i-j;k+=c
        while b and b[-1]>j:c+=d.pop();b.pop()
        b+=[j];d+=[c]
print(k)
print(len(b),*(d))

"
2890484,ALDS1_3_D,"inputs = list(input())
stack = []
L = []
tmp_total = 0
counter = 0
upper = 0
for i,x in enumerate(inputs):
    if(x == '\\'):
        stack.append(i)
    elif(x == '/') and stack:
        tmp = stack.pop()
        total_layer = i-tmp
        if L:
            while L and L[-1][0] > tmp:
                cal = L.pop()
                total_layer += cal[1]
        L.append((i, total_layer))

print(sum([j[1] for j in L]))
if(len(L) != 0):
    print(str(len(L))+ ' ' + ' '.join([str(i[1]) for i in L]))
else:
    print(str(len(L)))

"
2895832,ALDS1_3_D,"# ALDS1_3_D.

def show(a):
    # 配列の中身を出力する。
    _str = """"
    for i in range(len(a) - 1):
        _str += str(a[i]) + "" ""
    _str += str(a[len(a) - 1])
    print(_str)

def main():
    data = list(input())
    a = []  # '\\'の位置を格納していく。
    b = []  # 同じだが、池の集約に使う。
    ponds = []  # 池の面積のリスト(必要に応じて集約).
    Area = 0  # 総面積
    N = len(data)
    for i in range(N):
        if data[i] == '\\':
            a.append(i); b.append(i)
        elif data[i] == '/':
            if len(a) == 0: continue
            else:
                left = a.pop()  # '/'と対になる'\\'の位置
                Area += i - left
                ponds.append(i - left)
                # leftより右にあるbの元を先頭から見てあればカット、
                # その分だけpondsを集約する。
                while left < b[len(b) - 1]:
                    b.pop()
                    x = ponds.pop(); y = ponds.pop(); ponds.append(x + y)
    print(Area)
    ponds.insert(0, len(ponds))
    show(ponds)
    
if __name__ == ""__main__"":
    main()
"
3065142,ALDS1_3_D,"def print_area(stack):
    if len(stack) == 0:
        print(len(stack))
    else:
        print(len(stack), end="" "")
    for i,j in enumerate(stack):
        if i == len(stack)-1:
            print(j[1])
        else:
            print(j[1], end="" "")    

def calc_flood_area(in_data):
    stack1 = []
    stack2 = []
    total_area = 0
    for i,symbol in enumerate(in_data):
        if symbol == ""\\"":
            stack1.append(i)
        elif symbol == ""_"":
            pass
        elif symbol == ""/"" and stack1:
            j = stack1.pop()
            a = int(i)-int(j)
            total_area += a
            while stack2 and stack2[-1][0] > j:
                a += stack2[-1][1]
                stack2.pop()
            stack2.append((j, a))
                
    print(total_area)
    print_area(stack2)

in_data = input()
calc_flood_area(in_data)
"
3115772,ALDS1_3_D,"arr = list(input())
down = list()
areas = list()

for i, el in enumerate(arr):
    if el == ""\\"":
        down.append(i)
    elif el == ""/"" and not len(down) == 0:
        start_ind = down.pop()
        area = i - start_ind
        while len(areas) > 0 and areas[-1][0] > start_ind:
            area += areas.pop()[1]
        areas.append((start_ind, area))
    # print(""LOOP: {}"".format(i))
    # print(""DOWN INDICES"")
    # print(down)
    # print(""AREAS"")
    # print(areas)
    # print()

areas = [areas[i][1] for i in range(len(areas))]
print(sum(areas))
if len(areas) == 0:
    print(""0"")
else:
    print(len(areas), "" "".join(map(str,areas)))
"
3132564,ALDS1_3_D,"s=j=0  #水たまりの総面積#\の箱
a =[] #「\の入った個数」
b =[] #水たまりの個数
d =[] #水たまりのそれぞれの面積

for i, x in enumerate(input()):
  if x == '\\':
    a += [i]
  elif x =='/' and a:
    j = a.pop()
    c = i-j
    s += c
    while b and b[-1] > j:
      c+=d.pop()
      b.pop()
    b +=[j]
    d +=[c]
print(s)
print(len(b), *(d))

"
3172008,ALDS1_3_D,"# PDF参考
# スタックS1
S1 = []
# スタックS2
S2 = []
tmp_total = 0
counter = 0
upper = 0
# 総面積
total_layer = 0

for i,symbol in enumerate(input()):
    if (symbol == '\\'):
        S1.append(i)
    elif (symbol == '/') and S1:
        i_p = S1.pop()
        total_layer = i - i_p
        if S2 :
            while S2 and S2[-1][0] > i_p:
                cal = S2.pop()
                total_layer += cal[1]
        S2.append((i, total_layer))
print(sum([j[1] for j in S2]))
if (len(S2) != 0):
    print(str(len(S2)) + ' ' + ' '.join([str(i[1]) for i in S2]))
else:
    print(str(len(S2)))
        

"
3178701,ALDS1_3_D,"def flood(region_data,flood_data):
    height = 0
    water_num=0
    top=0
    i=-1
    for data in region_data:
        i+=1
        if(data==""\\""):
            if(height==0):
                top=i
            water_num+=height +0.5
            height+=1


        elif(data==""/""):
            if(height>=2):
                water_num+=height-0.5
                height-=1
            elif(height==1):
                water_num+=0.5
                flood_data.append(water_num)
                water_num=0
                height=0


        elif(data==""_""):
            water_num+=height
    if(height==0):
        top=-1
    return top







def flood2(region_data,flood_data):
    height = 0
    water_num=0
    top=0
    i=-1
    for data in region_data:
        i+=1
        if(data==""/""):
            if(height==0):
                top=i
            water_num+=height +0.5
            height+=1


        elif(data==""\\""):
            if(height>=2):
                water_num+=height-0.5
                height-=1
            elif(height==1):
                water_num+=0.5
                flood_data.append(water_num)
                water_num=0
                height=0


        elif(data==""_""):
            water_num+=height
    if(height==0):
        top=-1
    return top


region_data=list(input())
flood_data=[]
top=flood(region_data,flood_data)


if(top!=-1):
    region_data2=region_data[top:len(region_data)]
    region_data2.reverse()
    flood_data2=[]
    flood2(region_data2,flood_data2)
    flood_data2.reverse()
    flood_data_final=flood_data + flood_data2
else:
    flood_data_final=flood_data

flood_data_final=list(map(int,flood_data_final))
total=sum(flood_data_final)
num=[len(flood_data_final)]
flood_data_final="" "".join(list(map(str,num+flood_data_final)))

print(total)
print(f""{flood_data_final}"")
"
3258186,ALDS1_3_D,"# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_3_D&lang=jp
#  Areas on the Cross-Section Diagram : python3
#  2018.11.27 yonezawa


from collections import deque
import heapq
import sys
input = sys.stdin.readline


def main():
    q = deque()
    m = str(input()).strip()
    dq = []
    count = 0
    for i in range(len(m)):
        if (m[i] == ""\\"" ):
            q.append(i)
            continue
        if (m[i] == ""/"" and len(q) > 0):
            j = q.pop()
            count += i - j
            #dq.append((j,i))
            dq.append((j,i))
    print (count)
    if (len(dq) == 0):
        print (0)
        return

    l = []
    dq.sort()
    dq.reverse()
    (a,b) = dq.pop()
    
    score = b - a
    while len(dq) > 0:
        (i,n) = dq.pop()
        if ( b > i ):
            score += n - i
        else:
            l.append(score)
            score = n - i
            a = i
            b = n
    else:
        l.append(score)

    print (len(l),*l)

if __name__ == '__main__':
    main()
"
3320700,ALDS1_3_D,"# -*- coding: utf-8 -*-

count = 0
backslash_index = []
area_pond = []
pending_area=[]
for index,symbol in enumerate(input()):
	if symbol == ""\\"":
		backslash_index += [index]
	elif symbol == '/' and backslash_index:
		last_bs_index = backslash_index.pop()
		diff = index - last_bs_index 
		count += diff 
		while area_pond and area_pond[-1] > last_bs_index:
			diff += pending_area.pop()
			area_pond.pop()

		area_pond += [last_bs_index]
		pending_area += [diff]

print(count)
print(len(area_pond),*(pending_area))

"
3344800,ALDS1_3_D,"s=[]
p=[]
a=i=0
for c in input():
 if""\\""==c:s+=[i]
 if""/""==c and s:
  j=s.pop()
  t=i-j
  a+=t
  while p and p[-1][0]>j:t+=p.pop()[1]
  p+=[(j,t)]
 i+=1
print(a)
if p:print(len(p),*list(zip(*p))[1])
else:print(0)

"
3345276,ALDS1_3_D,"import sys
input = sys.stdin.readline

cs_view = input().rstrip('\r\n')
list_v = list(cs_view)

stack1 = []
all_sum = 0
sum_stack = []
for i, elem in enumerate(list_v):
    if elem == '\\':
        stack1.append(i)
    elif len(stack1) > 0 and elem == '/':
        j = stack1.pop()
        all_sum += i - j
        a = i - j
        while len(sum_stack) > 0 and sum_stack[-1][0] > j:
            a += sum_stack.pop()[1]
        sum_stack.append([j, a])

print(all_sum)
esum = []
for a in sum_stack:
    esum.append(a[1])
esum.insert(0, len(esum))
maped_esum = map(str, esum)
str_esum = ' '.join(maped_esum)
print(str_esum)

"
3416309,ALDS1_3_D,"l = input()
l += ""_""
stack1 = []
stack2 = []
A = 0
for i in range(len(l)):
    if l[i] == ""\\"":
        stack1.append(i)
    elif l[i] == ""/"" and stack1:
        b = stack1.pop()
        a = i - b
        A += a
        while stack2 and stack2[-1][0] > b:
            a += stack2.pop()[1]
        stack2.append([b, a])
print(A)
print(len(stack2), *(i[1] for i in stack2))
"
3517099,ALDS1_3_D,"lakes = []  # [(左岸位置, 断面積)]
lefts = []  # lefts[i]: まだ対になっていない上から i 番目の左岸位置
for i, c in enumerate(input()):
	if c == '\\':
		lefts.append(i)
	elif c == '/':
		if lefts:
			left = lefts.pop()
			area = i - left
			while lakes:
				sub_left, sub_area = lakes[-1]
				if left < sub_left:
					area += sub_area
					lakes.pop()
				else:
					break
			lakes.append((left, area))

L = [lake[1] for lake in lakes]
print(sum(L))
print(len(L), *L)
"
3573472,ALDS1_3_D,"def _main():
  text = list(input())

  S1 = []
  S2 = []
  area = 0

  for i in range(len(text)):
    if text[i] == '\\':
      S1.append(i)
    elif text[i] == '/' and len(S1) > 0:
      j = S1.pop()
      section_area = i - j
      area += section_area
      while len(S2) > 0 and S2[-1][0] > j:
        section_area += S2[-1][1]
        S2.pop()
      S2.append([j, section_area])
  print(area)
  print(len(S2), *[n[1] for n in S2])




if __name__ == '__main__':
  _main()
"
3624179,ALDS1_3_D,"s = []
p = []
a = i = 0
for c in input():
	if c == ""\\"":
		s += [i]
	elif c == ""/"" and s:
		j = s.pop()
		t = i-j
		a += t
		while p and p[-1][0] > j:
			t += p[-1][1]
			p.pop()
		p += [(j,t)]
	i += 1

print(a)
if p:
	print(len(p),*list(zip(*p))[1])
else:
	print(0)

"
3793855,ALDS1_3_D,"S = input()
A = []
down = [] # index
Asum = 0

for i, line in enumerate(S):
    if line == ""\\"":  # ""\""
        down.append(i)
    elif line == ""/"" and down:
        j = down.pop()
        temp = i - j
        Asum += temp
        while A and A[-1][0] > j:
            temp += A.pop()[1]
        A.append([j, temp])

print(Asum)
print(len(A), *[S for i, S in A])
"
3809048,ALDS1_3_D,"total_stack = []
single_stack = []

def main():
    input_line = input()
    total = 0

    for i,s in enumerate(input_line):
        if s == ""\\"":
            total_stack.append(i)
        elif s == ""/"" and len(total_stack) != 0:
            a = total_stack.pop()
            total += i - a
            area = 0
            while len(single_stack) != 0 and a < single_stack[-1][0]:
                area += single_stack.pop()[1]
            single_stack.append([a, area + i - a])

    print(total)
    print(' '.join([str(len(single_stack))] + [str(i[1]) for i in single_stack]))

if __name__ == '__main__':
    main()
"
3882954,ALDS1_3_D,"s=input()
stack_all=[]
stack_A=[]
point=0
#stack_allで全体の面積をはじめに求める
for i,j in enumerate(s):
    if j==""\\"":
        stack_all.append(i)
    elif j==""/"":
        try:
            left=stack_all.pop()
            po=i-left
            point +=po
            stack_A.append([left,po])
        except:continue
print(point)

#stack_Aに水が溜まっていくのをスタックしておく
#この過程で数字の小さいものは大きいものの上にきていることがわかるから重ねていく
stack_A.insert(0,[-1,-1])
stack_B=[]
if len(stack_A)==1:print(0)
else:
    for i in range(len(stack_A)-1,-1,-1):
        x,y=stack_A[i]
        px,py=stack_A[i-1]
        if x<px:
            stack_A[i-1]=[x,y+py]
        else:
            stack_B.append(stack_A[i])
    print(len(stack_B),*[j for i,j in stack_B[::-1]])
"
3902803,ALDS1_3_D,"# https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/3/ALDS1_3_D
# これは少し難しい
# stackをうまく利用して個々の湖の面積を出せるかが重要
# 条件を満たしたら面積mergeをするにはどうしたら良いのか考えよう。

chikei = input()
v_lakes = []  # 個々の湖の面積管理用のstack # (面積の始まりのidx, 面積)
idx_stack = []  # 地形のindex管理用のstack

for i, c in enumerate(chikei):
    if c is '\\':
        idx_stack.append(i)
    elif c is '/' and idx_stack:
        j = idx_stack.pop()  # 今の/に対応する\の位置
        v = i-j
        # 可能であるならば面積merge
        # 今のjがv_lakesのj_preよりも小さかったら面積mergeができるということ
        while v_lakes and j < v_lakes[-1][0]:
            # すべての面積をmerge
            v += v_lakes.pop()[1]
        v_lakes.append((j, v))

ans = [len(v_lakes)]
v = [v[1] for v in v_lakes]
ans.extend(v)

print(sum(v))
print(*ans)

"
3927293,ALDS1_3_D,"def main():
    S = input()

    def an_area(S):
        ans = 0
        stack_in = []
        stack_out = []
        for i,ch in enumerate(S):
            if ch == '\\':
                stack_in.append(i)
            elif stack_in and ch == '/':
                j = stack_in.pop()
                cur =  i - j
                stack_out.append((j,i,cur))
                ans += cur
        return ans,stack_out

    ans, l = an_area(S)
    if ans == 0:
        print(ans)
        print(len(l))
        return

    l.sort()
    pre_le, pre_ri = l[0][0], l[0][1]
    pre_ar = 0
    areas = []
    for le,ri,ar in l:
        if pre_le <= ri <= pre_ri:
            pre_ar += ar
        else:
            areas.append(pre_ar)
            pre_ar = ar
            pre_le, pre_ri = le, ri
    else:
        areas.append(pre_ar)
    
    print(ans)
    print(len(areas),*areas)

if __name__ == '__main__':
    main()
"
3954273,ALDS1_3_D,"s = input()
stack1 = []
stack2 = []
for i in range(len(s)):
    if s[i] == '\\':
        stack1.append(i)
    elif s[i] == '/' and stack1:
        j = stack1.pop()
        area = i-j
        while stack2:
            if stack2[-1][0] < j:
                break
            else:
                area += stack2.pop()[1]
        stack2.append((j,area))
ans = list(stack2[i][1] for i in range(len(stack2)))
print(sum(ans))
if ans:
    print(len(ans),' '.join(map(str,ans)))
else:
    print(0)
"
3984489,ALDS1_3_D,"from collections import deque


def calc_area(chars):
    s1 = deque()
    s2 = deque()
    area = 0

    for idx, char in enumerate(chars):
        if char == ""\\"":
            s1.append(idx)
        elif char == ""/"":
            if s1:
                left_idx = s1.pop()
                sub_area = idx - left_idx
                area = area + sub_area
                while s2 and left_idx < s2[-1][0]:
                    sub_area += s2.pop()[1]
                s2.append((left_idx, sub_area))
    return area, s2


def main():
    chars = input()
    area, s2 = calc_area(chars)
    print(area)
    text = """"
    count = 0
    while s2:
        text += "" "" + str(s2.popleft()[1])
        count += 1
    print(str(count) + text)


if __name__ == ""__main__"":
    main()

"
4011143,ALDS1_3_D,"def cal_water(floods):
    fstack = []
    astack = []
    i = 0
    for flood in floods:
        if flood == '\\':
            fstack.append(i)
        elif flood == '/' and len(fstack) > 0:
            s = fstack.pop(-1)
            area = (i - s) * 1
            while len(astack) > 0 and astack[-1][0] > s:
                _, a = astack.pop(-1)
                area += a
            astack.append((s, area))   
        else:
            pass
        i += 1
    
    tot = 0
    tot_area = 0
    out = ''
    while len(astack) > 0:
        _, area = astack.pop()
        tot += 1
        tot_area += area
        out = ' ' + str(area) + out
    
    print(tot_area)
    print(str(tot) +  out)

if __name__ == '__main__':
    floods = input()
    cal_water(floods)
"
4018694,ALDS1_3_D,"def main():
    cross_sections = input()
    s1 = []
    s2 = []
    total_surface = 0
    for i, cross_section in enumerate(cross_sections):
        if cross_section == '\\':
            s1.append(i)
        elif cross_section == '/' and s1:
            ip = s1.pop()
            # calc total surface
            sub_surface = i - ip
            total_surface += sub_surface
            # calc sub surface
            for s in reversed(s2):
                if s[0] > ip:
                    sub_surface += s2.pop()[1]
                else:
                    break
            s2.append((ip, sub_surface))

    print(total_surface)
    if s2:
        print(len(s2), ' '.join(map(lambda x: str(x[1]), s2)))
    else:
        print(len(s2))


if __name__ == ""__main__"":
    main()

"
4055722,ALDS1_3_D,"s = 0   # プールの合計面積

# a は a[i] に i 番目の \ の初期位置からの距離を入れるためのスタック
# b は b[i] に i 番目のプールの左岸（\）の初期位置からの距離を入れるためのスタック
# d は d[i] に i 番目のプールの面積を入れるためのスタック
a = []
b = []
d = []

for i, x in enumerate(input()):
    if x == '\\':
        a.append(i)
    elif x == '/' and a:
        j = a.pop()
        c = i - j
        s += c
        while b and b[-1] > j:
            b.pop()
            c += d.pop()
        b.append(j)
        d.append(c)
print(s)
print(len(b), *d)
"
4085529,ALDS1_3_D,"N = input()
s1 = []
s2 = []
res = []
ans = []
cnt = 0
for i in range(len(N)):
    if N[i] == ""\\"":
        s1.append(i)
    elif N[i] == ""/"" and s1:
        idx = s1.pop()
        tmp = i - idx
        cnt += tmp

        while s2 and idx < s2[-1][0]:
            tmp += s2.pop()[1]
        s2.append((idx, tmp))

res.append(len(s2))
for i in range(len(s2)):
    ans.append(s2[i][1])
res.extend(ans)
print(cnt)
print("" "".join(map(str, res)))
"
4097004,ALDS1_3_D,"s=[]
p=[]
a=i=0
for c in input():
     if""\\""==c:
         s+=[i]
     elif""/""==c and s:
         j=s.pop()
         t=i-j
         a+=t
         while p and p[-1][0]>j:
             t+=p[-1][1];
             p.pop()
         p+=[(j,t)]
     i+=1
print(a)
if p:
    print(len(p),*list(zip(*p))[1])
else:
    print(0)
"
4150608,ALDS1_3_D,"lst = list(input())
v_lakes = []
idx_stack = []
for i, c in enumerate(lst):
    if (c == '\\'):
        idx_stack.append(i)
    elif (idx_stack and c == '/'):
        # 対応する'\\'の位置
        j = idx_stack.pop()
        v = i - j
        while (v_lakes and v_lakes[-1][0] > j):
            v += v_lakes.pop()[1]
        v_lakes.append((j, v))
ans = [len(v_lakes)]
v = [v[1] for v in v_lakes]
ans.extend(v)

print(sum(v))
print(*ans)
"
8241310,ALDS1_4_A,"n = int(input())
S = list(map(int,input().split()))
q = int(input())
T = list(map(int,input().split()))
obs = 0

for i in T:
    if i in S:
        obs += 1

print(obs)
"
8269861,ALDS1_4_A,"n=int(input())
s=list(map(int,input().split()))
q=int(input())
t=list(map(int,input().split()))
ans=0
for i in t:
    if i in s:
        ans+=1
print(ans)
"
8391578,ALDS1_4_A,"n=int(input())
s=list(map(int,input().split()))
q=int(input())
t=list(map(int,input().split()))

count=0
for i in t:
    if i in s:
        count+=1
        
print(count)
"
8411553,ALDS1_4_A,"_ = input()
s = {int(s) for s in input().split()}
_ = input()
a = 0

for t in [int(s) for s in input().split()]:
    if t in s: a += 1

print(a)
"
8411778,ALDS1_4_A,"n = int(input())
S = list(map(int, input().split()))
m = int(input())
T = list(map(int, input().split()))

count = 0
if S < T:
    for i in S:
        if i in T:
            count += 1
else:
    for i in T:
        if i in S:
            count += 1
print(count)
"
8415142,ALDS1_4_A,"
n = int(input())

S = list(map(int, input().split()))

q = int(input())

T = list(map(int, input().split()))

count = 0
for i in T:
    if i in S:
        count += 1

print(count)
"
8428314,ALDS1_4_A,"n = int(input())
S = list(map(int, input().split()))

q = int(input())
T = list(map(int, input().split()))

C = 0
for i in range(q):
    if T[i] in S:  # 数列Tの要素T[i]が数列Sに含まれているかどうかをチェック
        C += 1

print(C)

"
8439272,ALDS1_4_A,"n = int(input())
S = set(map(int, input().split()))
q = int(input())
T = list(map(int, input().split()))

cnt = 0

for t in T:
    if t in S:
        cnt += 1
        
print(cnt)
"
8453480,ALDS1_4_A,"n = int(input())
S = set(map(int, input().split()))
q = int(input())
T = list(map(int, input().split()))

ans = 0
for i in range(q):
    if T[i] in S:
        ans += 1
print(ans)

"
8464728,ALDS1_4_A,"n1 = int(input())
A = list(map(int,input().split()))
n2 = int(input())
B = list(map(int,input().split()))
print(len(set(A)&set(B)))
"
8514248,ALDS1_4_A,"n = int(input())
S = list(map(int, input().split()))
q = int(input())
T = list(map(int, input().split()))

count = 0
for t in T:
    if t in S:
        count += 1

print(count)
"
8514783,ALDS1_4_A,"n = int(input())
s = list(map(int, input().split()))
q = int(input())
t = list(map(int, input().split()))

print(sum(int(val in s) for val in t))
"
8535096,ALDS1_4_A,"debug = False
if debug:
    n = 5
    s = [1, 2, 3, 4, 5]
    q = 3
    t = [3, 4, 1]
else:
    n = int(input())
    s = list(map(int, input().split()))
    q = int(input())
    t = list(map(int, input().split()))


print(len([i for i in t if i in s]))
"
8633493,ALDS1_4_A,"n = int(input())
sl = list(map(int, input().split()))
q = int(input())
tl = list(map(int, input().split()))
c = 0
for t in tl:
    if t in sl:
        c += 1
print(c)

"
8645593,ALDS1_4_A,"n = int(input())
S = list(map(int, input().split()))
q = int(input())
T = list(map(int, input().split()))
C = 0

for i in T:
    if i in S: C += 1

print(C)

"
8665891,ALDS1_4_A,"n = int(input())
S = list(map(int, input().split(' ')))

q = int(input())
T = list(map(int, input().split(' ')))

cnt = 0
for t in T:
    if t in S:
        cnt +=1
print(cnt)
"
8668742,ALDS1_4_A,"n = int(input())
A = list(map(int, input().split()))
A.sort()
p = int(input())
B = list(map(int,input().split()))
sum = 0
for i in range(len(B)):
    result = B[i] in A
    if result == True:
        sum+=1
    
print(sum)

"
8671844,ALDS1_4_A,"Length = input()
Array = input()
s = list(map(int,Array.split()))

Length = input()
Array = input()
t = list(map(int,Array.split()))

count = 0
for i in s if len(s) < len(t) else t:
    if i in s and t:
        count += 1

print(count)
"
8690736,ALDS1_4_A,"n_1 = int(input())
MARIO = list(map(int, input().split()))
n_2 = int(input())
LUIGI = list(map(int, input().split()))
A = 0

for c in LUIGI:
    if c in MARIO:
        A += 1

print(A)
"
8707469,ALDS1_4_A,"n = int(input())
l1 = list(map(int, input().split()))
m = int(input())
l2 = list(map(int, input().split()))

res = 0
seen = set()
for n in l1:
    if n in l2 and n not in seen:
        res += 1
        seen.add(n)

print(res)
"
8718071,ALDS1_4_A,"input()
s = set(input().split())
input()
t = set(input().split())
print(len(s & t))
"
8753570,ALDS1_4_A,"# aizu_ALDS1_4_A_LinearSearch.py  

n = int(input())
S = set(list(map(int,input().split())))
q = int(input())
T = list(map(int,input().split()))

cnt = 0
for t in T:
    if t in S: cnt += 1

print(cnt)

"
8754456,ALDS1_4_A,"S_num = int(input())
S = list(map(int, input().split()))
T_num = int(input())
T = list(map(int, input().split()))

count = 0
for i in range(T_num):
    if T[i] in S:
        count += 1
print(count)
"
8864240,ALDS1_4_A,"n = int(input())
s = list(map(int,input().split()))
q = int(input())
t = list(map(int,input().split()))
cnt = 0
for i in range(q):
    if t[i] in s:
        cnt+=1
print(cnt)
"
8864476,ALDS1_4_A,"n =int(input())
S = [*map(int, input().split())]
q = int(input())
T = [*map(int, input().split())]
l =len(S)
for i in T: 
  try: S.remove(i)
  except: continue
print(l - len(S))
"
8874647,ALDS1_4_A,"n = int(input())
S = list(map(int, input().split()))
q = int(input())
T = list(map(int, input().split()))

ans = 0

for i in range(q):
  if T[i] in S:
    ans += 1

print(ans)
"
8899082,ALDS1_4_A,"n = int(input())
S = list(map(int,input().split()))
n = int(input())
T = list(map(int,input().split()))

cnt = 0
for t in T:
    if t in S:
        cnt += 1
print(cnt)
        
"
8901332,ALDS1_4_A,"n=int(input())
s=list(map(int,input().split()))
q=int(input())
t=list(map(int,input().split()))

s=set(s)
t=set(t)
print(len(s&t))
"
8941002,ALDS1_4_A,"n = int(input())
S = set(list(map(int, input().split())))
q = int(input())
T = set(list(map(int, input().split())))

cnt = 0
print(len(S & T))
"
8943729,ALDS1_4_A,"N = int(input())
num_list = list(map(int,input().split()))
M = int(input())
act_list = list(map(int,input().split()))

target_set = set(num_list)

def linear_search(N,target_set,M,act_list):
  
    total = 0
    
    for act in act_list:
      
        if act in target_set:
            
            total += 1
          
    return total
  
result = linear_search(N,target_set,M,act_list)
print(result)
"
8954103,ALDS1_4_A,"n=int(input())
l=list(map(int,input().split()))
key={i:1 for i in l}
#print(key)
q=int(input())
l_num=list(map(int,input().split()))
result=0
for i in range(q):
    if l_num[i] in key:
        result+=1
        
print(result)
"
8958024,ALDS1_4_A,"
import sys
from collections import Counter

input = lambda: sys.stdin.readline().rstrip(""\r\n"").split()
i_sesli = lambda: int(input()[0])
i_mesli = lambda: list(map(int, input()))


def main():
    _ = i_sesli()
    seq1 = i_mesli()
    _ = i_sesli()
    seq2 = i_mesli()
    counter = Counter(set(seq1))
    ans = 0
    for num in seq2:
        ans += counter[num]

    print(ans)
    sys.exit()


if __name__ == ""__main__"":
    main()

"
8964742,ALDS1_4_A,"n=int(input())
S=set(map(int, input().split()))
q=int(input())
T=set(map(int, input().split()))
num = 0
for i in S:
    if i in T:
        num+=1
print(num)
"
9000618,ALDS1_4_A,"# 入力処理
n = int(input())
S = set(map(int, input().split()))
q = int(input())
T = list(map(int, input().split()))

# Tに含まれるSの要素の数をカウントする
C = sum(1 for num in T if num in S)

# 結果の出力
print(C)
"
9003740,ALDS1_4_A,"n=int(input())
S=list(map(int,input().split()))
q=int(input())
T=list(map(int,input().split()))
count=0

for i in range(q):
    if T[i] in S:
        count+=1
print(count)
"
9006961,ALDS1_4_A,"_: int = int(input())
S = set(map(int, input().split()))
_: int = int(input())
T = set(map(int, input().split()))

print(len(S & T))

"
9026963,ALDS1_4_A,"n = int(input())
lst = list(map(int,input().split()))
q = int(input())
lst2 = list(map(int,input().split()))
ct = 0
for i in range(q):
    if lst2[i] in lst:
        ct += 1
print(ct)
"
9052049,ALDS1_4_A,"n = int(input())
S = list(map(int, input().split()))
q = int(input())
T = list(map(int, input().split()))

c = 0
for t in T:
    if t in S:
        c += 1
print(c)
"
8551701,ALDS1_4_A,"n = int(input())
s = [int(x) for x in input().split()]
q = int(input())
t = [int(x) for x in input().split()]

c = 0
for x in t:
    for y in s:
        if x == y:
            c += 1
            break
print(c)

"
8869312,ALDS1_4_A,"def LinearSearch(A, key):
    for i in range(0, len(A)):
        if(A[i] == key):
            return 1
    return 0
        
n = int(input())
S = list(map(int, input().split()))
q = int(input())
T = list(map(int, input().split()))
count = 0
for i in T:
    key = i
    count += LinearSearch(S, key)
    
print(count)
"
8926902,ALDS1_4_A,"n = int(input())  # 数列Sの要素数
S = list(map(int, input().split()))  # 数列S
q = int(input())  # 数列Tの要素数
T = list(map(int, input().split()))  # 数列T

def linear_search(S, key):
    i = 0
    S.append(key)  # 番兵を追加
    while S[i] != key:
        i += 1
    S.pop()  # 番兵を削除
    return i != len(S)  # 番兵の位置に達したかどうかで判断


# 線形探索でTの各要素がSに含まれるか調べる
count = sum(linear_search(S, key) for key in T)

print(count)

"
9172942,ALDS1_4_A,"from typing import List,Dict

def linearsearch(S:Dict,T:List):
    cnt = 0
    for x in T:
        value = S.get(x,0)
        cnt = cnt + int(value)
    print(cnt)

n1 =int(input())
S = {}
T = []
nums = input().split()
for num in nums:
    S[num] = 1
n2 = int(input())
T = input().split()
#print(S)
#print(T)
linearsearch(S,T)
"
9187408,ALDS1_4_A,"n=int(input())
S=list(map(int,input().split()))
q=int(input())
T=list(map(int,input().split()))
U=[]
t=0
for i in range(n):
  if S[i] in T and S[i] not in U:
    U.append(S[i])
    t+=1
print(t)
"
1544718,ALDS1_4_A,"#coding:utf-8
#1_4_A
n = int(input())
S = set(map(int, input().split()))
q = int(input())
T = set(map(int, input().split()))

print(len(S & T))
"
1588636,ALDS1_4_A,"n = int(input())
S = input().split()

q = int(input())
T = input().split()

cnt = 0

for i in range(q):
    if T[i] in S:
        cnt += 1

print(cnt)
"
1636664,ALDS1_4_A,"n, s, q, t = input(), set(map(int, input().split())), input(), set(map(int, input().split()))
print(sum(i in s for i in t))
"
1675684,ALDS1_4_A,"input()
s = set(n for n in input().split())
input()
t = set(n for n in input().split())
print(len(s & t))
"
1864142,ALDS1_4_A,"n = int(input())
s = list(map(int, input().split()))

q = int(input())
t = list(map(int, input().split()))

count = 0
for i in range(len(t)):
    if t[i] in s:
        count += 1
print(count)
"
2042943,ALDS1_4_A,"#coding:UTF-8
def LS(n,S,q,T):
    count=0
    if n>q:
        for i in range(q):
            if T[i] in S:
                count+=1
    else:
        for i in range(n):
            if S[i] in T:
                count+=1
    print(count)
  
if __name__==""__main__"":
    n=int(input())
    S=input().split("" "")
    q=int(input())
    T=input().split("" "")
    LS(n,S,q,T)
"
2147071,ALDS1_4_A,"# coding: utf-8
input()
s = list(map(int,input().split()))
input()
t = list(map(int,input().split()))
cnt = 0
for i in t:
    if i in s:
        cnt += 1
print(cnt)
"
2165465,ALDS1_4_A,"input()
s = set(map(int,input().split()))
n = int(input())
t = tuple(map(int,input().split()))
c = 0
for i in range(n):
    if t[i] in s:
        c += 1
print(c)
"
2191227,ALDS1_4_A,"n = int(input())
s = input().split()
n = int(input())
t = input().split()
count = 0
for a in t:
    if a in s:
        count += 1
        
print(count)
"
2208733,ALDS1_4_A,"n = int(input())
s = set(input().split())
q = int(input())
t = set(input().split())

print(len(s & t))
"
2214080,ALDS1_4_A,"N = int(input())
S = list(map(int, input().split()))
Q = int(input())
T = list(map(int, input().split()))

S = set(S)
T = set(T)
C = list(S & T)
print(len(C))
"
2217169,ALDS1_4_A,"S_num = int(input())
seq_S = set(input().split("" ""))
T_num = int(input())
seq_T = set(input().split("" ""))

seq_Both = seq_S & seq_T

print(len(seq_Both))
"
8286779,ALDS1_4_B,"# verification-helper: PROBLEM https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/4/ALDS1_4_B

N = int(input())
S = set(map(int, input().split()))
q = int(input())
T = set(map(int, input().split()))

common_elements = S & T
ans = len(common_elements)
print(ans)
"
8400103,ALDS1_4_B,"n=int(input())
s=set(map(int,input().split()))
q=int(input())
t=set(map(int,input().split()))

print(len(s & t))
    
"
8690750,ALDS1_4_B,"n = input()
s = set(input().split())
q = input()
t = set(input().split())

A = 0
for c in t:
    if c in s:
        A += 1

print(A)
"
8718118,ALDS1_4_B,"input()
s = set(input().split())
input()
t = set(input().split())
print(len(s & t))
"
8845244,ALDS1_4_B,"#18 (another answer)
n = int(input())
s = set(map(int, input().split()))
q = int(input())
t = set(map(int, input().split()))

print(len(s&t))
"
8951108,ALDS1_4_B,"N=int(input())
s=list(map(int,input().split()))
sn=len(set(s))
q=int(input())
t=list(map(int,input().split()))
tan=len(set(s+t))
print(q-tan+sn)
"
8960165,ALDS1_4_B,"import sys
from collections import Counter

input = lambda: sys.stdin.readline().rstrip(""\r\n"").split()
i_sesli = lambda: int(input()[0])
i_mesli = lambda: list(map(int, input()))


def main():
    _ = i_sesli()
    seq1 = i_mesli()
    _ = i_sesli()
    seq2 = i_mesli()
    counter = Counter(set(seq1))
    ans = 0
    for num in seq2:
        ans += counter[num]

    print(ans)
    sys.exit()


if __name__ == ""__main__"":
    main()

"
8302808,ALDS1_4_B,"input()
n=set([int(x)for x in input().split()])
input()
q=[int(x)for x in input().split()]
print(sum([x in n for x in q]))
"
8411578,ALDS1_4_B,"_ = input()
s = {int(s) for s in input().split()}
_ = input()
a = 0

for t in [int(s) for s in input().split()]:
    if t in s: a += 1

print(a)
"
8411858,ALDS1_4_B,"n = int(input())
S = set(map(int, input().split()))
m = int(input())
T = list(map(int, input().split()))
count = 0


for i in T:
    if i in S:
        count+=1
            
print(count)
"
8427176,ALDS1_4_B,"n = int(input())
S = list(map(int, input().split()))
q = int(input())
T = list(map(int, input().split()))
st_S = set(S)

cnt = 0
for i in T:
    if i in st_S:
        cnt += 1
print(cnt)
"
8434294,ALDS1_4_B,"INT = lambda: int(input())
MI = lambda: map(int, input().split())
MI_DEC = lambda: map(lambda x: int(x) - 1, input().split())
LI = lambda: list(map(int, input().split()))

# とりあえず愚直
input()
S = set(LI())
input()
T = set(LI())
ct = 0
for i in T:
    if i in S:
        ct += 1
print(ct)

"
8439276,ALDS1_4_B,"n = int(input())
S = set(map(int, input().split()))
q = int(input())
T = list(map(int, input().split()))

cnt = 0

for t in T:
    if t in S:
        cnt += 1
        
print(cnt)
"
8633507,ALDS1_4_B,"from bisect import bisect_left
n = int(input())
sl = list(map(int, input().split()))
q = int(input())
tl = list(map(int, input().split()))
c = 0
sl.sort()
for t in tl:
    i = bisect_left(sl, t)
    if sl[i%n] == t or sl[(i + 1)%n] == t:
        c += 1
print(c)

"
8719934,ALDS1_4_B,"from bisect import bisect_left

N = int(input())
S = list(map(int, input().split()))
Q = int(input())
T = list(map(int, input().split()))

count = 0
for t in T:
    i = bisect_left(S, t)
    if i < N and S[i] == t:
        count += 1

print(count)

"
8829616,ALDS1_4_B,"n=int(input())
s=set(map(int,input().split()))
q=int(input())
t=list(map(int,input().split()))
ans=0
for i in t:
    ans+= i in s
print(ans)
"
9028627,ALDS1_4_B,"n = int(input())
s = list(map(int, input().split()))
q = int(input())
t = list(map(int, input().split()))

ss = set(s)
ans = 0

for i in t:
    if i in ss:
        ans += 1

print(ans)
"
9114546,ALDS1_4_B,"# https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_4_B&lang=ja
from bisect import bisect


N = int(input())
S = list(map(int, input().split()))
Q = int(input())
T = list(map(int, input().split()))

ans = 0
for t in T:
    idx = bisect(S, t) - 1
    if idx < N and S[idx] == t:
        ans += 1
print(ans)

"
2161728,ALDS1_4_B,"def main():
    input()
    a = set(input().split())
    input()
    b = set(input().split())
    print(len(a.intersection(b)))


if __name__ == ""__main__"":
    import os
    import sys
    if len(sys.argv) > 1:
        if sys.argv[1] == ""-d"":
            fd = os.open(""input.txt"", os.O_RDONLY)
            os.dup2(fd, sys.stdin.fileno())
            main()
    else:
        main()
"
2165473,ALDS1_4_B,"input()
s = set(input().split())
input()
t = set(input().split())
print(len(s&t))
"
2171841,ALDS1_4_B,"def binarySearch():
    n = int(input())
    S = set(input().split())
    q = int(input())
    T = set(input().split())
    print(len(S & T))
    

binarySearch()
"
2419986,ALDS1_4_B,"#ALDS1_4-B BinarySearch
input()
S=input().split()
input()
T=input().split()
print(len(set(S)&set(T)))
"
2709538,ALDS1_4_B,"input()
s=set(input().split())
input()
print(len(s&set(input().split())))
"
2831601,ALDS1_4_B,"n = int(input())
a = set(input().split())
m = int(input())
b = set(input().split())
print(len(a&b))
"
2866352,ALDS1_4_B,"n=input()
A=set(input().split())
m=input()
B=set(input().split())
print(len(A&B))
"
2866774,ALDS1_4_B,"c=0
n=int(input())
s=input().split()
q=int(input())
t=input().split()
s.sort()

print(len(set(s)&set(t)))
"
2867846,ALDS1_4_B,"input()
n=set(input().split())
input()
print(len(n&set(input().split())))
"
2985977,ALDS1_4_B,"# -*- coding: utf-8 -*-

input()
s = set(input().split())
input()
t = set(input().split())
print(len(s & t))
"
3007801,ALDS1_4_B,"N = int(input())
S = set(input().split())
Q = int(input())
T = set(input().split())
print(len(S & T))
"
3345330,ALDS1_4_B,"i=lambda:set(input().split())
i()
s=i()
i()
print(len(s&i()))
"
3476567,ALDS1_4_B,"input()
a=input().split()
input()
print(len(set(a)&set(input().split())))
"
3517151,ALDS1_4_B,"input()
S = set(input().split())
input()
T = set(input().split())
print(len(S & T))
"
3789463,ALDS1_4_B,"n = input()
S = set(input().split())
q = input()
T = set(input().split())
print(len(S&T))
"
3789479,ALDS1_4_B,"n = input()
s = set(input().split())
q = input()
t = set(input().split())
print(len(s & t))
"
4114535,ALDS1_4_B,"print(input() and len(set(input().split()) & set(input() and input().split())))
"
4553947,ALDS1_4_B,"input()
S = input().split()
input()
T = input().split()
print(len(set(S)&set(T)))
"
4753832,ALDS1_4_B,"_, s, _, t = [set(o.split()) for o in open(0)]
print(len(s & t))
"
4914322,ALDS1_4_B,"n = int(input())
S = set(input().split())
q = int(input())
T = set(input().split())
print(len(S&T))
"
5251731,ALDS1_4_B,"n = input()
s = set(input().split())
q = input()
t = set(input().split())
print(len(s & t))

"
5251758,ALDS1_4_B,"p = int(input())
A = input().split()
n = int(input())
B = input().split()

print(len(set(A)&set(B)))
"
5251764,ALDS1_4_B,"p = int(input())
A = input().split()
n = int(input())
B = input().split()

print(len(set(A)&set(B)))
"
5314141,ALDS1_4_B,"n = input()
S = input()
n = input()
T = input()

S = set(S.split("" ""))
T = set(T.split("" ""))
O = S & T
print(len(O))

"
5354123,ALDS1_4_B,"n = int(input())
S = set(input().split())
q = int(input())
T = set(input().split())

cnt = 0
print(len(S & T))
"
5390422,ALDS1_4_B,"n = input()
S = set(input().split())
q = input()
T = set(input().split())
common = S&T
print(len(common))

"
5422558,ALDS1_4_B,"
num = input()
se = set(input().split())
y = input()
r = set(input().split())
print(len(se & r))

"
5482537,ALDS1_4_B,"n = int(input())
S = set(input().split())
q = int(input())
T = set(input().split())

print(len(T.intersection(S)))




"
5728811,ALDS1_4_B,"n = input()
s = set(input().split())
q = input()
t = set(input().split())
print(len(s & t))
"
5819525,ALDS1_4_B,"input()
S = set(input().split())
input()
T = set(input().split())
print(len(S&T))
"
5953672,ALDS1_4_B,"input()
n=set(input().split())
input()
print(len(n&set(input().split())))
"
6311541,ALDS1_4_B,"input()
s = set(input().split())
input()
print(len(s & set(input().split())))
"
6573140,ALDS1_4_B,"n=int(input())
S=set(input().split())
q=int(input())
T=set(input().split())
cnt=0
cnt=len(S&T)

print(cnt)    
"
7750147,ALDS1_4_B,"n,s = input(), (input().split())
q,t = input(),(input().split())
s=set(s);t=set(t)
print(len(s & t))
"
8428836,ALDS1_4_B,"import bisect

n = int(input())
S = list(map(int, input().split()))

q = int(input())
T = list(map(int, input().split()))

C = 0

for i in range(q):
    idx = bisect.bisect_left(S, T[i])
    if idx != len(S)  and S[idx] == T[i]:
        C+= 1

print(C)
"
8439226,ALDS1_4_B,"import bisect

n = int(input())
S = list(map(int,input().split()))
q = int(input())
T = list(map(int,input().split()))
C = 0
for i in T:
    I = bisect.bisect_left(S,i)
    if I < n and S[I] == i:
        C += 1
print(C)
"
8474309,ALDS1_4_B,"import bisect
n=int(input())
S=list(map(int,input().split()))
q=int(input())
T=list(map(int,input().split()))

score=0
for i in T:
    if bisect.bisect_right(S, i) != bisect.bisect_left(S, i):
        score+=1

print(score)
"
8526039,ALDS1_4_B,"from bisect import *
n = int(input())
s = list(map(int, input().split()))
q = int(input())
t = list(map(int, input().split()))

ans = 0

for i in range(q):
    l = bisect_left(s, t[i])
    r = bisect_right(s, t[i])
   
    if l != r:
         ans += 1
     
print(ans)


"
8563454,ALDS1_4_B,"import bisect

n = int(input())
s = list(map(int, input().split()))
q = int(input())
t = list(map(int, input().split()))


def binary_search(s: list, key: int) -> bool:
    i = bisect.bisect_left(s, key)
    if i != n and s[i] == key:
        return True
    else:
        return False


count = 0
for key in t:
    if binary_search(s, key):
        count = count + 1
print(count)

"
8751636,ALDS1_4_B,"from bisect import bisect_left, bisect_right


def main():
    n = int(input())
    S = list(map(int, input().split()))
    q = int(input())
    T = list(map(int, input().split()))

    ctr = 0
    for t in T:
        idx1 = bisect_left(S, t)
        idx2 = bisect_right(S, t)
        if idx2 - idx1 > 0:
            ctr += 1
    print(ctr)


if __name__ == ""__main__"":
    main()

"
8892429,ALDS1_4_B,"import bisect
n=int(input())
s=list(map(int,input().split()))
q=int(input())
T=list(map(int,input().split()))
ans=0
s.sort()
for t in T:
    idx=bisect.bisect_left(s,t)
    #print(t,idx)
    if t==s[idx]:
        ans+=1
print(ans)
"
8899064,ALDS1_4_B,"import bisect


n = int(input())
sn = list(map(int, input().split()))
q = int(input())
tn = list(map(int, input().split()))

ans = 0
for t in tn:
    i = bisect.bisect_left(sn, t)

    if i < n:
        if sn[i] == t:
            ans += 1

print(ans)

"
9045382,ALDS1_4_B,"from collections import *
from bisect import *
#from math import *
from heapq import *
from itertools import *
def popcount(n):
	c=(n&0x5555555555555555)+((n>>1)&0x5555555555555555)
	c=(c&0x3333333333333333)+((c>>2)&0x3333333333333333)
	c=(c&0x0f0f0f0f0f0f0f0f)+((c>>4)&0x0f0f0f0f0f0f0f0f)
	c=(c&0x00ff00ff00ff00ff)+((c>>8)&0x00ff00ff00ff00ff)
	c=(c&0x0000ffff0000ffff)+((c>>16)&0x0000ffff0000ffff)
	c=(c&0x00000000ffffffff)+((c>>32)&0x00000000ffffffff)
	return c
""""""
mod = 10**9+7
M= (10**5)*3+1 
fac= [1]*M
ninv= [1]*M
finv= [1]*M
for i in range(2,M):
  fac[i] = fac[i-1]*i%mod
  ninv[i] = (-(mod//i)*ninv[mod%i])%mod
  finv[i] = finv[i-1]*ninv[i]%mod
  
def binom(n,k):
  if n<0 or k<0:
    return 0
  if k>n:
    return 0
  return (fac[n]*finv[k]%mod)*finv[n-k]%mod


def nHk(n, k):
	return binom(n + k - 1, k)
""""""
def nCr(n, k):
	r = min(k, n - k)
	ret = 1
	for i in range(n, n - k, -1): ret *= i
	for i in range(2, k + 1): ret //= i
	return ret

def nHk(n, k):
	return nCk(n + k - 1, k)

def nC2(x):
	return x*(x-1)//2
def is_prime(n):
    if n == 1: return False

    for k in range(2, int(math.sqrt(n)) + 1):
        if n % k == 0:
            return False

    return True

class UnionFind():
    def __init__(self, n):
        self.n = n
        self.parents = [-1] * n
        self.group = n
 
    def find(self, x):
        if self.parents[x] < 0:
            return x
        else:
            self.parents[x] = self.find(self.parents[x])
            return self.parents[x]
 
    def union(self, x, y):
        x = self.find(x)
        y = self.find(y)
 
        if x == y:
            return
        self.group -= 1
        if self.parents[x] > self.parents[y]:
            x, y = y, x
 
        self.parents[x] += self.parents[y]
        self.parents[y] = x
 
    def size(self, x):
        return -self.parents[self.find(x)]
 
    def same(self, x, y):
        return self.find(x) == self.find(y)
 
    def members(self, x):
        root = self.find(x)
        return [i for i in range(self.n) if self.find(i) == root]
 
    def roots(self):
        return [i for i, x in enumerate(self.parents) if x < 0]
 
    def group_count(self):
        return self.group
 
    def all_group_members(self):
        dic = {r:[] for r in self.roots()}
        for i in range(self.n):
            dic[self.find(i)].append(i)
        return dic
 
    def __str__(self):
        return '\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())
class SOE:
  def __init__(self,m):
    self.sieve=[-1]*(m+1)
    self.prime=[]
    for i in range(2,m+1):
      if self.sieve[i]==-1:
        self.prime.append(i)
        self.sieve[i]=i
        j=2*i
        while j<=m:
          self.sieve[j]=i
          j+=i
  
  def primes(self):
    # get primes
    return self.prime
  
  def fact(self,n):
    # prime factorization
    d=[]
    while n!=1:
      p=self.sieve[n]
      d.append(p)
      while n%p==0:
        n//=p
    return d
def enumerate_primes(n):
    if n <= 1:
        return []
    A = [1, 7, 11, 13, 17, 19, 23, 29]
    thres = (n + 29) // 30
    sieve = [255] * (thres + int(n ** 0.5) + 10)
    ntoi = lambda i: (i >> 2) + (not (~i & 19))

    sieve[0] ^= 1
    i = 0
    flg = 1
    while flg:
        if sieve[i] != 0:
            for j in range(8):
                if sieve[i] >> j & 1:
                    p = i * 30 + A[j]
                    if (p * p > n):
                        flg = 0
                        continue
                    q = [0] * 8
                    r = [0] * 8
                    s = 0
                    for k in range(8):
                        x = p * (i * 30 + A[k])
                        q[k] = x // 30
                        r[k] = ntoi(x - 30 * q[k])
                    while q[0] + s < thres:
                        sieve[q[0] + s] &= ~(1 << r[0])
                        sieve[q[1] + s] &= ~(1 << r[1])
                        sieve[q[2] + s] &= ~(1 << r[2])
                        sieve[q[3] + s] &= ~(1 << r[3])
                        sieve[q[4] + s] &= ~(1 << r[4])
                        sieve[q[5] + s] &= ~(1 << r[5])
                        sieve[q[6] + s] &= ~(1 << r[6])
                        sieve[q[7] + s] &= ~(1 << r[7])
                        s += p

        i += 1
    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
    for i in range(1, thres):
        for j in range(8):
            if sieve[i] >> j & 1:
                primes.append(i * 30 + A[j])
    while primes[-1] > n:
        primes.pop()
    return primes
def div(n):
	lower,upper = [],[]
	i = 1
	while i*i <= n:
		if n%i == 0:
			lower.append(i)
			if i!=n//i:
				upper.append(n//i)
		i += 1
	return lower+upper[::-1]

def factorize(x):
	yaku = []
	for i in range(2,int(x**0.5)+1):
		if x%i == 0:
			while x%i == 0:
				x //= i
				yaku.append(i)
	if x != 1:
		yaku.append(x)
	return yaku
#[2,3]この形
		
def fact(n):
  res=n
  a=[]
  i=2
  while i*i<=res:
    if res%i==0:
      cnt=0
      while res%i==0:
        cnt+=1
        res//=i
      a.append((i,cnt))
    i+=1
  if res!=1:
    a.append((res,1))
  return a
""""""
[(2, 1), (3, 1)]この形
""""""		

def nc2(x):
	return (x*(x-1)//2)
	
import random
class RollingHash:    
    mask30 = (1 << 30) - 1
    mask31 = (1 << 31) - 1
    MOD = (1 << 61) - 1
    Base = None
    pw = [1]
    
    def __init__(self, S):
        if RollingHash.Base is None:
            RollingHash.Base = random.randrange(129, 1 << 30)
        for i in range(len(RollingHash.pw), len(S) + 1):
            RollingHash.pw.append(RollingHash.CalcMod(RollingHash.Mul(RollingHash.pw[i - 1], self.__class__.Base)))
        
        self.hash = [0] * (len(S) + 1)
        for i, s in enumerate(S, 1):
            self.hash[i] = RollingHash.CalcMod(RollingHash.Mul(self.hash[i - 1], RollingHash.Base) + ord(s))
 
    def get(self, l, r):
        return RollingHash.CalcMod(self.hash[r] - RollingHash.Mul(self.hash[l], RollingHash.pw[r - l]))
 
    def Mul(l, r):
        lu = l >> 31
        ld = l & RollingHash.mask31
        ru = r >> 31
        rd = r & RollingHash.mask31
        middlebit = ld * ru + lu * rd
        return ((lu * ru) << 1) + ld * rd + \
            ((middlebit & RollingHash.mask30) << 31) + (middlebit >> 30)
 
    def CalcMod(val):
        if val < 0:
            val %= RollingHash.MOD
        val = (val & RollingHash.MOD) + (val >> 61)
        if val > RollingHash.MOD:
            val -= RollingHash.MOD
        return val
        
# https://github.com/tatyam-prime/SortedSet/blob/main/SortedMultiset.py
import math
from bisect import bisect_left, bisect_right, insort
from typing import Generic, Iterable, Iterator, TypeVar, Optional, List
T = TypeVar('T')

class SortedMultiset(Generic[T]):
    BUCKET_RATIO = 50
    REBUILD_RATIO = 170

    def _build(self, a=None) -> None:
        ""Evenly divide `a` into buckets.""
        if a is None: a = list(self)
        size = self.size = len(a)
        bucket_size = int(math.ceil(math.sqrt(size / self.BUCKET_RATIO)))
        self.a = [a[size * i // bucket_size : size * (i + 1) // bucket_size] for i in range(bucket_size)]
    
    def __init__(self, a: Iterable[T] = []) -> None:
        ""Make a new SortedMultiset from iterable. / O(N) if sorted / O(N log N)""
        a = list(a)
        if not all(a[i] <= a[i + 1] for i in range(len(a) - 1)):
            a = sorted(a)
        self._build(a)

    def __iter__(self) -> Iterator[T]:
        for i in self.a:
            for j in i: yield j

    def __reversed__(self) -> Iterator[T]:
        for i in reversed(self.a):
            for j in reversed(i): yield j
    
    def __len__(self) -> int:
        return self.size
    
    def __repr__(self) -> str:
        return ""SortedMultiset"" + str(self.a)
    
    def __str__(self) -> str:
        s = str(list(self))
        return ""{"" + s[1 : len(s) - 1] + ""}""

    def _find_bucket(self, x: T) -> List[T]:
        ""Find the bucket which should contain x. self must not be empty.""
        for a in self.a:
            if x <= a[-1]: return a
        return a

    def __contains__(self, x: T) -> bool:
        if self.size == 0: return False
        a = self._find_bucket(x)
        i = bisect_left(a, x)
        return i != len(a) and a[i] == x

    def count(self, x: T) -> int:
        ""Count the number of x.""
        return self.index_right(x) - self.index(x)

    def add(self, x: T) -> None:
        ""Add an element. / O(√N)""
        if self.size == 0:
            self.a = [[x]]
            self.size = 1
            return
        a = self._find_bucket(x)
        insort(a, x)
        self.size += 1
        if len(a) > len(self.a) * self.REBUILD_RATIO:
            self._build()

    def discard(self, x: T) -> bool:
        ""Remove an element and return True if removed. / O(√N)""
        if self.size == 0: return False
        a = self._find_bucket(x)
        i = bisect_left(a, x)
        if i == len(a) or a[i] != x: return False
        a.pop(i)
        self.size -= 1
        if len(a) == 0: self._build()
        return True

    def lt(self, x: T) -> Optional[T]:
        ""Find the largest element < x, or None if it doesn't exist.""
        for a in reversed(self.a):
            if a[0] < x:
                return a[bisect_left(a, x) - 1]

    def le(self, x: T) -> Optional[T]:
        ""Find the largest element <= x, or None if it doesn't exist.""
        for a in reversed(self.a):
            if a[0] <= x:
                return a[bisect_right(a, x) - 1]

    def gt(self, x: T) -> Optional[T]:
        ""Find the smallest element > x, or None if it doesn't exist.""
        for a in self.a:
            if a[-1] > x:
                return a[bisect_right(a, x)]

    def ge(self, x: T) -> Optional[T]:
        ""Find the smallest element >= x, or None if it doesn't exist.""
        for a in self.a:
            if a[-1] >= x:
                return a[bisect_left(a, x)]
    
    def __getitem__(self, x: int) -> T:
        ""Return the x-th element, or IndexError if it doesn't exist.""
        if x < 0: x += self.size
        if x < 0: raise IndexError
        for a in self.a:
            if x < len(a): return a[x]
            x -= len(a)
        raise IndexError

    def index(self, x: T) -> int:
        ""Count the number of elements < x.""
        ans = 0
        for a in self.a:
            if a[-1] >= x:
                return ans + bisect_left(a, x)
            ans += len(a)
        return ans

    def index_right(self, x: T) -> int:
        ""Count the number of elements <= x.""
        ans = 0
        for a in self.a:
            if a[-1] > x:
                return ans + bisect_right(a, x)
            ans += len(a)
        return ans

oo = 1<<60
ans = 0
cnt = 0
res = oo
def dijkstra(n, s, G):
	hq = [(0, s)]
	cost = [float('inf')] * n
	cost[s] = 0
	
	while hq:
		c,v = heappop(hq)
		if c > cost[v]:
			continue
		for nv,d in G[v]:
			tmp = d + cost[v]
			if tmp < cost[nv]:
				cost[nv] = tmp
				heappush(hq, (tmp,nv))
	return cost



class Topological_Sort:
    def __init__(self, N: int):
        """""" N 頂点からなる空グラフを用意する.
 
        N: int
        """"""
        self.N=N
        self.arc=[[] for _ in  range(N)]
        self.rev=[[] for _ in range(N)]
 
    def add_arc(self, source: int, target: int):
        """""" 有向辺 source → taeget を追加する.
 
        """"""
        self.arc[source].append(target)
        self.rev[target].append(source)
 
    def sort(self):
        """""" トポロジカルソートを求める.
 
        [Ouput]
        存在する → トポロジカルソート
        存在しない → None
        """"""
 
        in_deg=[len(self.rev[x]) for x in range(self.N)]
        Q=[x for x in range(self.N) if in_deg[x]==0]
 
        S=[]
        while Q:
            u=Q.pop()
            S.append(u)
 
            for v in self.arc[u]:
                in_deg[v]-=1
                if in_deg[v]==0:
                    Q.append(v)
 
        return S if len(S)==self.N else None
 
    def is_DAG(self):
        """""" DAG かどうかを判定する.
        """"""
        return self.sort()!=None
""""""
class LowestCommonAncestor:
    def __init__(self,n):
        self._n=n;n=0
        while 2**(n/10)<self._n:n+=1
        self._logn=int(n/10+2)  #mathモジュールなしで構築
        self._depth=    [ 0 for _ in [0]*self._n]
        self._distance= [ 0 for _ in [0]*self._n]
        self._ancestor=[[-1 for _ in [0]*self._n] for k in [0]*self._logn]
        self._edge=     [[] for _ in [0]*self._n]

    def add_edge(self,u,v,w=1):  #頂点u,v間に重みwの辺を追加する
        self._edge[u].append((v,w))
        self._edge[v].append((u,w))

    def build(self,root=0):  #rootを指定し、その他の頂点に祖先情報を書き込む
        stack=[root]
        while stack:
            now=stack.pop()
            for nxt,w in self._edge[now]:
                if self._ancestor[0][nxt]!=now and self._ancestor[0][now]!=nxt:
                    self._ancestor[0][nxt]=now
                    self._depth[nxt]=   self._depth[now]   +1
                    self._distance[nxt]=self._distance[now]+w
                    stack.append(nxt)
        for k in range(1,self._logn):
            for i in range(self._n):
                if self._ancestor[k-1][i]==-1:
                     self._ancestor[k][i]=-1
                else:self._ancestor[k][i]=self._ancestor[k-1][self._ancestor[k-1][i]]

    def LCA(self,u,v):
        if self._depth[u]>self._depth[v]:u,v=v,u  #uが浅く、vが深い状態に
        for k in range(self._logn-1,-1,-1):  #vとuを同じ深度に
            if ((self._depth[v]-self._depth[u])>>k)&1:v=self._ancestor[k][v]
        if u==v:return u
        for k in range(self._logn-1,-1,-1):  #ギリギリ一致する直前まで祖先を辿る
            if self._ancestor[k][u]!=self._ancestor[k][v]:
                u,v=self._ancestor[k][u],self._ancestor[k][v]
        return self._ancestor[0][u]

    def distance(self,u,v):
        return self._distance[u]+self._distance[u]-2*self._distance[self.LCA(u,v)]
""""""
import math

class LCA:
  def __init__(self,n):
    self._n=n
    self._logn=int(math.log2(self._n)+2)
    self._depth=[0]*self._n
    self._distance=[0]*self._n
    self._ancestor=[[-1]*self._n for k in range(self._logn)]
    self._edges=[[] for i in range(self._n)]
    
  def add_edge(self,u,v,w=1):
    self._edges[u].append((v,w))
    self._edges[v].append((u,w))
    
  def build(self,root=0):
    stack=[root]
    while len(stack):
      cur = stack.pop()
      for nxt,w in self._edges[cur]:
        if self._ancestor[0][nxt]!=cur and self._ancestor[0][cur]!=nxt:
          self._ancestor[0][nxt]=cur
          self._depth[nxt]=self._depth[cur]+1
          self._distance[nxt]=self._distance[cur]+w
          stack.append(nxt)
    
    for k in range(1,self._logn):
      for i in range(self._n):
        if self._ancestor[k-1][i]==-1:
          self._ancestor[k][i]=-1
        else:
          self._ancestor[k][i]=self._ancestor[k-1][self._ancestor[k-1][i]]
        
  def lca(self,u,v):
    if self._depth[u]>self._depth[v]:
      u,v=v,u
    
    for k in range(self._logn-1,-1,-1):
      if ((self._depth[v]-self._depth[u])>>k)&1:
        v=self._ancestor[k][v]
      
    if u==v:
      return u
    
    for k in range(self._logn-1,-1,-1):
      if self._ancestor[k][u]!=self._ancestor[k][v]:
        u=self._ancestor[k][u]
        v=self._ancestor[k][v]
    return self._ancestor[0][u]
  
  def distance(self,u,v):
    return self._distance[u]+self._distance[v]-2*self._distance[self.lca(u,v)]
  

class BIT_SortedSet:
    def __init__(self, A, compress=True, sort_flag=False):
        self.compress = compress
        self.N = len(A)
        self.log = 0
        while self.N >= 1 << (self.log + 1):
            self.log += 1
        if compress:
            if sort_flag:
                self.A = A
            else:
                self.A = sorted(A)
            self.index_dic = {}
            for i in range(len(A)):
                self.index_dic[self.A[i]] = i
        else:
            self.A = A
        self.BIT = [0] * (self.N + 5)
        self.size = 0
        self.cnt = [0] * self.N

    def BIT_add(self, i, x):
        idx = i + 1
        while idx < self.N + 1:
            self.BIT[idx] += x
            idx += idx & (-idx)

    def BIT_query(self, i):
        res = 0
        idx = i + 1
        while idx:
            res += self.BIT[idx]
            idx -= idx & (-idx)
        return res

    def BIT_lower_left(self, w):
        if w <= 0 or w > self.size:
            return None
        x = 0
        k = 1 << self.log
        while k > 0:
            if x + k < self.N and self.BIT[x + k] < w:
                w -= self.BIT[x + k]
                x += k
            k //= 2
        return x

    def __contains__(self, x):
        if self.compress:
            x = self.index_dic[x]
        return self.cnt[x] >= 1

    def __len__(self):
        return self.size

    def add(self, x):
        if self.compress:
            x = self.index_dic[x]
        if self.cnt[x] == 1:
            return False
        self.BIT_add(x, 1)
        self.size += 1
        self.cnt[x] += 1
        return True

    def discard(self, x):
        if self.compress:
            x = self.index_dic[x]
        if self.cnt[x] > 0:
            self.BIT_add(x, -1)
            self.size -= 1
            self.cnt[x] -= 1
            return True
        return False

    def find_kth_val(self, k):
        res = self.BIT_lower_left(k + 1)
        if res == None:
            return None
        if self.compress:
            res = self.A[res]
        return res

    def __getitem__(self, x):
        if x < 0:
            x += self.size
        if x < 0 or x >= self.size:
            raise IndexError
        return self.find_kth_val(x)

    def index_right(self, x):
        if x < self.A[0]:
            return 0
        if self.compress:
            y = bisect.bisect_right(self.A, x) - 1
        else:
            y = min(x, self.N - 1)
        return self.BIT_query(y)

    def index(self, x):
        if x <= self.A[0]:
            return 0
        if self.compress:
            y = bisect.bisect_right(self.A, x) - 1
        else:
            y = x
        if y >= self.N:
            y = self.N - 1
        elif self.A[y] == x:
            y -= 1
        return self.BIT_query(y)

    def gt(self, x):
        return self.find_kth_val(self.index_right(x))

    def ge(self, x):
        return self.find_kth_val(self.index(x))

    def lt(self, x):
        return self.find_kth_val(self.index(x) - 1)

    def le(self, x):
        return self.find_kth_val(self.index_right(x) - 1)

    def __str__(self):
        return (
            ""{""
            + "", "".join(map(str, [self.find_kth_val(i) for i in range(self.size)]))
            + ""}""
        )
        
def matmul(A,B,mod): # A,B: 行列
    res = [[0]*len(B[0]) for _ in [None]*len(A)]
    for i, resi in enumerate(res):
        for k, aik in enumerate(A[i]):
            for j,bkj in enumerate(B[k]):
                resi[j] += aik*bkj
                resi[j] %= mod
    return res
 
def matpow(A,p,mod): #A^p mod M
    if p%2:
        return matmul(A, matpow(A,p-1,mod),mod)
    elif p > 0:
        b = matpow(A,p//2,mod)
        return matmul(b,b,mod)
    else:
        return [[int(i==j) for j in range(len(A))] for i in range(len(A))]
        
 
def find_cycle(n,edge):
  seen=[0]*n
  finished=[0]*n
  stc=[]
  for i in range(n):
    if seen[i]:
      continue
    todo=[(1,i,-1),(0,i,-1)]
    seen[i]=True
    while todo:
      t,v,edge_id=todo.pop()
      if t==0:
        if finished[v]:
          continue
        seen[v]=1
        stc.append((v,edge_id))
        for u,id in edge[v]:
          if finished[v]:
            continue
          
          if seen[u] and finished[u]==0:
            cyc=[id]
            while stc:
              v,id=stc.pop()
              if v==u:
                break
              cyc.append(id)
            return cyc[::-1]
          
          elif seen[u]==0:
            todo.append((1,u,id))
            todo.append((0,u,id))
      
      else:
        if finished[v]:
          continue
        stc.pop()
        finished[v]=1
  
  return []

class LazySegTree:
    """"""Lazy Segment Tree

    Attributes:
        n (int):       要素数以上の最小の2の累乗
        ide_ele (int): 単位元
            - RmQ (Range Minimum Query): inf
            - RMQ (Range Maximum Query): -1
            - RSQ (Range Sum Query):     0
            - RPQ (Range Product Query): 1
            - RGQ (Range GCD Query):     0
        tree (list):   要素の格納先 (1-indexed)
        lazy (list):   遅延配列 (1-indexed)
            - RUQ (Range Update Query): [None] * (2*self.n)
            - RAQ (Range Add Query):    [0] * (2*self.n)
    """"""
    def __init__(self, arr):
        """"""初期化 O(N)

        Args:
            arr (list): 対象の配列
        """"""
        self.n = 1 << (len(arr)-1).bit_length()
        self.ide_ele = 0
        self.tree = [self.ide_ele] * (2*self.n)
        self.lazy = [0] * (2*self.n)

        for i, v in enumerate(arr, self.n):
            self.tree[i] = v
        for i in range(self.n-1, 0, -1):
            self.tree[i] = self.segfunc(self.tree[2*i], self.tree[2*i+1])

    def update(self, l, r, v):
        """"""区間更新 O(logN)

        Args:
            l (int): 区間の左端
            r (int): 区間の右端
            v (int): 更新値
        """"""
        *ids, = self.get_index(l, r)
        self.propagate(*ids)

        l += self.n
        r += self.n
        while l < r:
            if l & 1:
                self.tree[l] = v
                self.lazy[l] = v
                l += 1
            if r & 1:
                r -= 1
                self.tree[r] = v
                self.lazy[r] = v
            r >>= 1
            l >>= 1

        for i in ids:
            self.tree[i] = self.segfunc(self.tree[2*i], self.tree[2*i+1])

    def add(self, l, r, v):
        """"""区間加算 O(logN)

        Args:
            l (int): 区間の左端
            r (int): 区間の右端
            v (int): 更新値
        """"""
        *ids, = self.get_index(l, r)

        l += self.n
        r += self.n
        while l < r:
            if l & 1:
                self.tree[l] += v
                self.lazy[l] += v
                l += 1
            if r & 1:
                r -= 1
                self.tree[r] += v
                self.lazy[r] += v
            r >>= 1
            l >>= 1

        for i in ids:
            self.tree[i] = self.segfunc(self.tree[2*i], self.tree[2*i+1]) + self.lazy[i]

    def query(self, l, r):
        """"""区間クエリの計算 O(logN)

        Args:
            l (int): 区間の左端
            r (int): 区間の右端

        Returns:
            int: [l, r)についての区間クエリ
        """"""
        *ids, = self.get_index(l, r)
        self.propagate(*ids)

        l += self.n
        r += self.n
        res = self.ide_ele
        while l < r:
            if l & 1:
                res = self.segfunc(res, self.tree[l])
                l += 1
            if r & 1:
                r -= 1
                res = self.segfunc(res, self.tree[r])
            l >>= 1
            r >>= 1

        return res

    def get_index(self, l, r):
        """"""伝搬対象の区間の列挙 O(logN)
''
        Args:
            l (int): 区間の左端
            r (int): 区間の右端

        Yields:
            int: 伝搬対象の区間のindex
        """"""
        l += self.n
        r += self.n
        l_index = l >> (l&-l).bit_length()
        r_index = r >> (r&-r).bit_length()

        while l < r:
            if l <= l_index:
                yield l
            if r <= r_index:
                yield r
            l >>= 1
            r >>= 1
        while l:
            yield l
            l >>= 1

    def propagate(self, *ids):
        """"""遅延伝搬処理 O(logN)

        Args:
            ids (): 伝搬対象の区間index
        """"""
        # RUQ
        for i in reversed(ids):
             if self.lazy[i] is None:
                 continue
             self.tree[2*i] = self.lazy[i]
             self.tree[2*i+1] = self.lazy[i]
             self.lazy[2*i] = self.lazy[i]
             self.lazy[2*i+1] = self.lazy[i]
             self.lazy[i] = None

        # RAQ
        """"""
        for i in reversed(ids):
            if not self.lazy[i]:
                continue
            self.tree[2*i] += self.lazy[i]
            self.tree[2*i+1] += self.lazy[i]
            self.lazy[2*i] += self.lazy[i]
            self.lazy[2*i+1] += self.lazy[i]
            self.lazy[i] = 0
        """"""
    def segfunc(self, x, y):
    	
        """"""問題に応じた処理 O(1)

        Args:
            x (int): 左オペランド
            y (int): 右オペランド

        Returns:
            int: 問題に応じた値
                - RmQ(Range Minimum Query): min(x, y)
                - RMQ(Range Maximum Query): max(x, y)
                - RSQ(Range Sum Query):     x + y
                - RPQ(Range Product Query): x * y
                - RGQ(Range GCD Query):     gcd(x, y)
        """"""
        return x+y




class SegTree:
    def __init__(self, n, e, ope, lst=[]):
        self.N0 = 2 ** (n - 1).bit_length()
        self.e = e
        self.ope = ope
        self.data = [e] * (2 * self.N0)
        if lst:
            for i in range(n):
                self.data[self.N0 + i] = lst[i]
            for i in range(self.N0 - 1, 0, -1):
                self.data[i] = self.ope(self.data[2 * i], self.data[2 * i + 1])
    
    def build(self):
        for i in range(self.N0 - 1, 0, -1):
            self.data[i] = self.ope(self.data[2 * i], self.data[2 * i + 1])
                
    def update(self, i, x): #a_iの値をxに更新
        i += self.N0
        self.data[i] = x
        while i > 1:
            i >>= 1
            self.data[i] = self.ope(self.data[2 * i], self.data[2 * i + 1])
    
    def add(self, i, x):
        self.update(i, x + self.get(i))

    def set(self, i, x):
        self.data[self.N0 + i] = x
    
    def query(self, l, r): #区間[l, r)での演算結果
        if r <= l:
            return self.e
        lres = self.e
        rres = self.e
        l += self.N0
        r += self.N0
        while l < r:
            if l & 1:
                lres = self.ope(lres, self.data[l])
                l += 1
            if r & 1:
                r -= 1
                rres = self.ope(self.data[r], rres)
            l >>= 1
            r >>= 1
        return self.ope(lres, rres)
    
    def get(self, i): #a_iの値を返す
        return self.data[self.N0 + i]
        
import sys
if sys.platform =='ios':
	import clipboard
	a=clipboard.get()
	a = a.split('\n')
	text = '\n'.join(a)
	with open('input_file.txt','w') as f:
		f.write(text)
	sys.stdin = open('input_file.txt')
sys.setrecursionlimit(410000000)
stdin = sys.stdin 
def ni():return int(ns())
def na():return list(map(int, stdin.readline().split()))
def ns():return stdin.readline().strip()
def nm():return map(int,input().split())
def na_1():return list(map(lambda x:int(x)*(-1), stdin.readline().split()))
def na_2():return list(map(lambda x:int(x)-1, stdin.readline().split()))
rnage=range
rnge=range
rage = range





N = ni()
S = na()+[-oo]+[oo]
q = ni()
T = na()

T.sort()

for t in T:
	if S[bisect_left(S,t)] == t:
		ans += 1
		
print(ans)
"
8993025,ALDS1_4_C,"import sys

input = lambda: sys.stdin.readline().rstrip(""\r\n"").split()
i_sesli = lambda: int(input()[0])


def main():
    N = i_sesli()
    dictionary = set()
    for _ in range(N):
        command, word = map(str, input())
        if command == ""insert"":
            dictionary.add(word)
        elif command == ""find"":
            if word in dictionary:
                print(""yes"")
            else:
                print(""no"")

    sys.exit()


if __name__ == ""__main__"":
    main()

"
4039428,ALDS1_4_C,"import sys

def m():
    d={}
    input()
    for e in sys.stdin:
        if'f'==e[0]:
            print('yes' if e[5:] in d else 'no')
        else:
            d[e[7:]] = 0
            
if'__main__'==__name__:
    m()
"
2725773,ALDS1_4_C,"import sys
def m():
 d={};input()
 for e in sys.stdin:
  if'f'==e[0]:print('yes'if e[5:]in d else'no')
  else:d[e[7:]]=0
if'__main__'==__name__:m()
"
8827341,ALDS1_4_C,"def dictionary(dict, n):
    answer = []
    for i in range(n):
        command = input().strip().split()
        if command[0] == 'insert':
            dict.add(command[1])
        elif command[0] == 'find':
            if command[1] in dict:
                answer.append('yes')
            else:
                answer.append('no')
    for i in answer:
        print(i)

dict = set()
n = int(input().strip())
dictionary(dict, n)


"
3345403,ALDS1_4_C,"import sys
def m():
 d=set();input()
 for i in sys.stdin:
  if""i""==i[0]:d.add(i[7:])
  else:print('yes'if i[5:]in d else'no')
if'__main__'==__name__:m()
"
4127453,ALDS1_4_C,"# ライブラリのインポート
#import re #正規表現
import sys
#import heapq
#import collections
#import math

def main():
    s = set()
    for inst in sys.stdin:
        if inst[0] == 'f': print('yes' if inst[5:] in s else 'no')
        else: s.add(inst[7:])
    

if __name__ == '__main__':
    main()

"
4085676,ALDS1_4_C,"import sys
def main():
    input = sys.stdin.readline

    dic = set()
    n = int(input())
    ans = []
    for a in range(n):
        s = input()
        if ""\n"" in s:
            s = s[:-1]
        if s[0] == ""i"":
            dic.add(s[7:])
        else:
            ans.append(""yes"" if s[5:] in dic else ""no"")
    print(""\n"".join(ans))

if __name__ == ""__main__"":
    main()
"
2509369,ALDS1_4_C,"import sys

def main():
    """""" MAIN """"""
    num = int(input().strip())
    istr = sys.stdin.read()
    cmds = list(istr.splitlines())

    D = {}
    for i in cmds:
        if i[0] == ""i"":
            D[i[7:]] = 1
        elif i[0] == ""f"":
            if i[5:] in D:
                print(""yes"")
            else:
                print(""no"")

if __name__ == '__main__':
    main()
"
3051168,ALDS1_4_C,"import sys
d={}
input()
for i in sys.stdin:
    if i[0] == ""i"":
        d[i[7:]]=0
    else:
        if i[5:] in d:
            print(""yes"")
        else:
            print(""no"") 
"
3836608,ALDS1_4_C,"import sys

n = int(input())
dict = {}

for i in sys.stdin:
    if i[0] == 'i':
        dict[i[7:]] = 0
    else:
        print('yes' if i[5:] in dict else 'no')

"
6588061,ALDS1_4_C,"import sys

d = {}
#input
for command in sys.stdin:
    if ""insert "" in command:
        d[command[7:-1]] = 0
    elif ""find "" in command:
        if command[5:-1] in d:
            print(""yes"")
        else:
            print(""no"")
    else:
        pass
        
"
4471967,ALDS1_4_C,"import sys

D = {}
input()
for line in sys.stdin:
    if line[0] == ""f"":
        print('yes' if line[5:] in D else 'no')
    else:
        D[line[7:]] = 0

"
5756863,ALDS1_4_C,"from sys import stdin

n=int(stdin.readline().strip())
s=stdin.readlines()

st={}
for i in s:
    if i[0]=='i':
        st[i[7:]]=0
    else:
        if i[5:] in st:
            print('yes')
        else:
            print('no')
"
2165512,ALDS1_4_C,"import sys
input()
r = sys.stdin.readlines()
d = {}

for i in r:
    if i[0] == 'i':
        d[i[7:]] = 0
    else:
        if i[5:] in d:
            print('yes')
        else:
            print('no')
"
4554578,ALDS1_4_C,"import sys
input()
d = {}
for s in sys.stdin:
    if s[0]=='i':
        d[s[7:]] = 1
    else:
        if s[5:] in d:
            print('yes')
        else:
            print('no')
"
4807207,ALDS1_4_C,"import sys

s = dict()
for i in sys.stdin:
        if 'f' == i[0]:
                print('yes' if i[5:] in s else ""no"")
        else:
                s[i[7:]] = True

"
4956842,ALDS1_4_C,"import sys
pin=sys.stdin.readline

def main():
  n=int(pin())
  d=set([])
  ansl=[]
  for i in range(n):
    a,b=pin().rstrip().split()
    if a==""insert"":
      d.add(b)
    else:
      if b in d:
        ansl.append(""yes"")
      else:
        ansl.append(""no"")
  ans=""\n"".join(ansl)
  print(ans)
  return
main()
  
"
5029105,ALDS1_4_C,"# coding: utf-8
from sys import stdin

n = int(input())
d ={}
for s in stdin:
    if s[0] == 'i':
        d[s[7:-1]] = 1
    else:
        if s[5:-1] in d:
            print('yes')
        else:
            print('no')


"
5295702,ALDS1_4_C,"import sys
from sys import stdin
input = stdin.readline

def dictionary_search(N):
    dict={}
    for i in range(N):
        s=input()
        if s[0]=='i':
            dict[s[7:]]=1
        else:
            print('yes' if s[5:] in dict else 'no' )
if __name__=='__main__':
    N=int(input())
    dictionary_search(N)
"
2555804,ALDS1_4_C,"import sys
input()
r = sys.stdin.readlines()
d = {}
 
for i in r:
    if i[0] == 'i':
        d[i[7:]] = 0
    else:
        if i[5:] in d:
            print('yes')
        else:
            print('no')
"
2603077,ALDS1_4_C,"import sys
 
if __name__ == '__main__':
    num = int(input().strip())
    istr = sys.stdin.read()
    cmds = list(istr.splitlines())
 
    D = {}
    for i in cmds:
        if i[0] == ""i"":
            D[i[7:]] = 1
        elif i[0] == ""f"":
            if i[5:] in D:
                print(""yes"")
            else:
                print(""no"")
"
2654445,ALDS1_4_C,"import sys


def main():
    _ = int(input())

    imps = sys.stdin.readlines()

    db = {}
    for imp in imps:
        c, k = imp.split(' ')
        if c == 'insert':
            db[k] = 0
        elif k in db:
            print('yes')
        else:
            print('no')


main()
"
4882191,ALDS1_4_C,"_, *queries = open(0).read().split()
s = set()
for op, string in zip(*[iter(queries)] * 2):
    if op[0] == ""i"":
        s.add(string)
    elif op == ""find"":
        print(""yes"") if string in s else print(""no"")
"
2684736,ALDS1_4_C,"import sys
readline = sys.stdin.readline
SET = set()
input()
for s in sys.stdin:
    if s[0] == ""i"":
        SET.add(s[7:])
    elif s[0] == ""f"":
        print(""yes"" if s[5:] in SET else ""no"")

"
5640185,ALDS1_4_C,"import sys


n = int(input())

dic = set()
for s in sys.stdin:
    if s[0] == 'i':
        dic.add(s[7:-1])
    else:
        if s[5:-1] in dic:
            print('yes')
        else:
            print('no')

"
7370848,ALDS1_4_C,"import sys

input_dict = {}
ans = []

n = int(sys.stdin.readline())
for _ in range(n):
    input_str = sys.stdin.readline()
    if input_str[0] == ""i"":
        input_dict.setdefault(input_str[7:-1], 0)
    elif input_str[0] == ""f"":
        # print(""yes"" if input_str[5:-1] in input_dict else ""no"")
        ans.append(""yes"" if input_str[5:-1] in input_dict else ""no"")
        
print(""\n"".join(ans))
"
8129136,ALDS1_4_C,"import sys
pin=sys.stdin.readline

def main():
  n=int(pin())
  d=set([])
  ansl=[]
  for i in range(n):
    a,b=pin().rstrip().split()
    if a==""insert"":
      d.add(b)
    else:
      if b in d:
        ansl.append(""yes"")
      else:
        ansl.append(""no"")
  ans=""\n"".join(ansl)
  print(ans)
  return
main()
"
3219138,ALDS1_4_C,"import sys

def main():
    lines = sys.stdin.readlines()
    n = int(lines[0])

    repo = {}
    for i in range(1, n + 1):
        command, acgt = lines[i].split()
        if command[0] == 'i':
            if acgt not in repo:
                repo[acgt] = 0
        elif command[0] == 'f':
            if acgt in repo:
                print('yes')
            else:
                print('no')
    return


main()
"
4017465,ALDS1_4_C,"coms = ['insert', 'find']
_, *D = open(0).read().split()
S = set()
for c, s in zip(*[iter(D)]*2):
    if coms.index(c) == 0:
        S.add(s)
    else:
        print('yes' if s in S else 'no')

"
4294355,ALDS1_4_C,"# -*- coding: utf-8 -*-
# ALDS1_4_C_Dictionary

def main():
    d = set()
    for l in open(0).readlines()[1:]:
        o, k = l.split()
        if o == ""insert"":
            d.add(k)
            continue
        if k in d:
            print(""yes"")
        else:
            print(""no"")

main()
"
4445372,ALDS1_4_C,"from sys import stdin

def main():
    a = set()
    _ = int(stdin.readline())
    for command,value in (line.split() for line in stdin.readlines()):
        if command == ""insert"":
            a.add(value)
        else:
            print(""yes"" if value in a else ""no"")

main()
"
5075192,ALDS1_4_C,"
from sys import stdin
input = stdin.readline

dic = {}
n = int(input())
for i in range(n):
	s = input()
	if s[0] == 'i': dic[s[7:]] = 1
	else: print(""yes"" if s[5:] in dic else ""no"")

"
4758772,ALDS1_4_C,"from sys import stdin
import sys
input = stdin.readline

dic = {}
n = int(input())
for i in range(n):
    s = input()
    if s[0] == 'i':
        dic[s[7:]] = 1
    else:
        print(""yes"" if s[5:] in dic else ""no"")

"
5422576,ALDS1_4_C,"import sys
from sys import stdin
input = stdin.readline

dic = {}
n = int(input())
for i in range(n):
	s = input()
	if s[0] == 'i': dic[s[7:]] = 1
	else: print(""yes"" if s[5:] in dic else ""no"")
"
2992142,ALDS1_4_C,"# AOJ ALDS1_4_C Dictionary
# Python3 2018.7.3 bal4u

import sys
from sys import stdin
input = stdin.readline

dic = {}
n = int(input())
for i in range(n):
	s = input()
	if s[0] == 'i': dic[s[7:]] = 1
	else: print(""yes"" if s[5:] in dic else ""no"")
"
3789481,ALDS1_4_C,"import sys
from sys import stdin
input = stdin.readline
 
dic = {}
n = int(input())
for i in range(n):
    s = input()
    if s[0] == 'i': dic[s[7:]] = 1
    else: print(""yes"" if s[5:] in dic else ""no"")
"
4745594,ALDS1_4_C,"import sys
d = {}

n = int(input())
for i in sys.stdin:
    q, c = i.split()
    if q == 'find':
        if c in d:
            print('yes')
        else:
            print('no')

    else:
        d[c] = True
"
6042185,ALDS1_4_C,"import sys

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines


def main():
    N = int(readline())

    SET = set()

    for _ in range(N):
        order, word = readline().split()

        if order == 'insert':
            SET.add(word)
        
        else:
            if word in SET:
                print('yes')
            else:
                print('no')


if __name__ == '__main__':
    main()
"
4449895,ALDS1_4_C,"
import sys
from sys import stdin
input = stdin.readline

n = int(input())
D = {}
for i in range(n):
    s = input()
    if s[0] == ""i"":
        D[s[7:]] = 11111111111111111111111111111111111
    else:
        print(""yes"" if s[5:] in D else ""no"")

"
6111245,ALDS1_4_C,"from collections import deque
import sys
import time
input = sys.stdin.readline
def func():
    n = int(input())
    dict = set()
    for _ in range(n): 
        order, string = input().split()
        if order == 'insert':
            dict.add(string)
        else:
            if  string in dict:
                print('yes')
            else:
                print('no') 

func()
"
5422563,ALDS1_4_C,"import sys
from sys import stdin
input = stdin.readline

dic = {}
num = int(input())
for i in range(num):
	se = input()
	if se[0] == 'i': dic[se[7:]] = 1
	else: print(""yes"" if se[5:] in dic else ""no"")
"
9142884,ALDS1_4_C,"n = int(input())

dict = {}
ans = []
for i in range(n):
    ins, mozi = map(str, input().split())

    if ins == 'insert':
        dict[mozi] = i
    elif ins == 'find':
        if mozi in dict.keys():
            ans.append('yes')
        else:
            ans.append('no')
for a in ans:
    print(a)


"
3397971,ALDS1_4_C,"import sys
from sys import stdin
input = stdin.readline
 
dic = {}
n = int(input())
for i in range(n):
    s = input()
    if s[0] == 'i': dic[s[7:]] = 1
    else: print(""yes"" if s[5:] in dic else ""no"")
"
4812981,ALDS1_4_C,"_,*A=open(0).read().split()
s=set()
for i in range(0, len(A), 2):
    cmd=A[i]
    val=A[i+1]
    if cmd=='insert':
        s.add(val)
    elif cmd=='find':
        if val in s:
            print('yes')
        else:
            print('no')
"
5876492,ALDS1_4_C,"import sys
from sys import stdin
input = stdin.readline

dic = {}
n = int(input())
for i in range(n):
	s = input()
	if s[0] == 'i': dic[s[7:]] = 1
	else: print(""yes"" if s[5:] in dic else ""no"")
"
6420286,ALDS1_4_C,"import sys
n = int(input())

d = dict()
for i in sys.stdin:
    query, gen = i.split()
    if query == 'find':
        if gen in d:
            ans = 'yes'
        else:
            ans = 'no'
        print(ans)

    else:
        d[gen] = 1
"
8707486,ALDS1_4_C,"n = int(input())
seen = set()

for _ in range(n):
    cmd = input()

    if cmd[0] == 'i':
        seen.add(cmd[7:])
    else:
        if cmd[5:] in seen:
            print('yes')
        else:
            print('no')
"
3820954,ALDS1_4_C,"import sys
from sys import stdin
input = stdin.readline
 
dic = {}
n = int(input())
for i in range(n):
    s = input()
    if s[0] == 'i': dic[s[7:]] = 1
    else: print(""yes"" if s[5:] in dic else ""no"")
"
6408683,ALDS1_4_C,"import sys

# READ_FROM_FILE = True
READ_FROM_FILE = False


def main():
    if READ_FROM_FILE:
        f = open('test0.txt', 'r')
    else:
        f = sys.stdin

    n = int(f.readline())
    t = set()
    for _ in range(n):
        op, s = f.readline().split()
        if op == 'insert':
            t.add(s)
        else:
            print('yes' if s in t else 'no')

    if READ_FROM_FILE:
        f.close()
    return


if __name__ == '__main__':
    main()

"
6469367,ALDS1_4_C,"# AOJ ALDS1_4_C Dictionary
# Python3 2018.7.3 bal4u

import sys
from sys import stdin
input = stdin.readline

dic = {}
n = int(input())
for i in range(n):
	s = input()
	if s[0] == 'i': dic[s[7:]] = 1
	else: print(""yes"" if s[5:] in dic else ""no"")

"
7940125,ALDS1_4_C,"import sys
  
list = {}

stdin = sys.stdin
num = int(stdin.readline())

for i in range(num):
    insert , a = stdin.readline().split()
    
    if insert == 'insert':
        list[a] = 1
    elif insert == 'find':
        if a in list:
            sys.stdout.write('yes\n')
        else:
            sys.stdout.write('no\n')

sys.stdout.flush()


"
3909363,ALDS1_4_C,"import sys
from sys import stdin
input = stdin.readline

n = int(input())

st = set()

for _ in range(n):
    command = input()
    if command[0] == ""i"":
        st.add(command[7:])
    else:
        if command[5:] in st:
            print(""yes"")
        else:
            print(""no"")
"
4009424,ALDS1_4_C,"import sys
  
dic = {}

stdin = sys.stdin
n = int(stdin.readline())

for _ in range(n):
    command, c = stdin.readline().split()
    if command == 'insert':
        dic[c] = 1
    elif command == 'find':
        if c in dic:
            sys.stdout.write('yes\n')
        else:
            sys.stdout.write('no\n')

sys.stdout.flush()
"
7940524,ALDS1_4_C,"import sys
from sys import stdin
input = stdin.readline

dic = {}
n = int(input())
for i in range(n):
	s = input()
	if s[0] == 'i': dic[s[7:]] = 1
	else: print(""yes"" if s[5:] in dic else ""no"")
"
8428924,ALDS1_4_C,"dic = {}
n = int(input())
for i in range(n):
    command, key = input().split()
    
    if command == ""insert"":
        dic[key] = True
    
    else:
        if key in dic:
            print(""yes"")
        else:
            print(""no"")
"
8713781,ALDS1_4_C,"n = int(input())
dic = {}
for i in range(n):
    command, value = input().split()
    if (command == 'insert'):
        dic[value] = True
    else:
        if dic.get(value):
            print('yes')
        else:
            print('no')
"
1964938,ALDS1_4_C,"import sys

n = int(input())
dic = {}
input_ = sys.stdin.readlines()

for i in input_:
    c, s = i.split()
    if c == 'insert':
        dic[s] = 0
    else:
        if s in dic:
            print('yes')
        else:
            print('no')
"
2410557,ALDS1_4_C,"import sys
 
 
def main():
    orders = sys.stdin.readlines()[1:]
    dna_set = set()
    for order in orders:
        command, dna = order.split("" "")
        if command == ""insert"":
            dna_set.add(dna)
        elif command == ""find"":
            if dna in dna_set:
                print(""yes"")
            else:
                print(""no"")
 
 
if __name__ == ""__main__"":
    main()
"
5267725,ALDS1_4_C,"import sys
from sys import stdin
input = stdin.readline
dic = {}
n = int(input())
for i in range(n):
    s = input()
    if s[0] == 'i':
        dic[s[7:]] = 1
    elif s[0] == 'f':
        if s[5:] in dic:
            print('yes')
        else:
            print('no')
"
8411875,ALDS1_4_C,"n = int(input())
judge = set()
for _ in range(n):
    op, str = input().split()
    if op == 'insert':
        judge.add(str)
    else:
        print('yes' if str in judge else 'no')
"
8901374,ALDS1_4_C,"n=int(input())
dic=set()
for _ in range(n):
    t,s=input().split()
    if t==""insert"":
        dic.add(s)
    else:
        if s in dic:
            print('yes')
        else:
            print('no')
"
1866371,ALDS1_4_C,"import sys

dict = {}
n = int(input())
l = []
line = map(lambda x:x.split(), sys.stdin.readlines())
s = """"
for (c,arg) in line:
    if c == ""insert"":
        dict[arg] = 0
    elif c == ""find"":
        if arg in dict:
            s += ""yes\n""
        else:
            s += ""no\n""
print(s,end="""")
"
8720323,ALDS1_4_D,"n, k = map(int, input().split())
l = [int(input()) for i in range(n)]

def fp(p):
    a, b = 0, 1
    for i in l:
        a += i
        if a > p:
            b += 1
            if b > k:
                return False
            a = i
    return True
    
    
m, r = max(l), sum(l)
while m < r:
    p = (m+r)//2
    if fp(p):
        r = p
    else:
        m = p = p+1
print(p)
"
8429192,ALDS1_4_D,"import math

n, k = [int(s) for s in input().split()]
w = [int(input()) for _ in range(n)]
mn = max(w + [math.ceil(sum(w) / k)])
m = math.ceil(n / k)
mx = max([sum(w[i:i + m]) for i in range(0, n, m)])

while mx - mn:
    m = (mx + mn) >> 1
    l = t = 0
    for i in w:
        t += i
        if t > m:
            t = i
            l += 1
            if k == l:
                mn = m + 1
                break
    else: mx = m

print(mx)
"
8770822,ALDS1_4_D,"# aizu_ALDS1_4_D_Allocation.py  

from math import ceil

n,k = map(int,input().split())
w = [int(input()) for _ in range(n)]

capasity = max(max(w),ceil(sum(w)/k))-1

def chk(capasity):
    num_track = 1
    t = 0
    for a in w:
        if t+a > capasity :
            num_track += 1
            t = 0
            if num_track > k:
                return False
        t += a
    return True

def capa():
    l = capasity
    r = sum(w)
    while l+1 < r:
        m = (l+r)//2
        ret = chk(m)
        if ret == False: l = m
        else: r = m
    return r

print(capa())
"
9052574,ALDS1_4_D,"n, k = map(int, input().split())
w = [int(input()) for _ in range(n)]
left = max(w)
right = sum(w)

def check():
    truck = 1
    truck_container = 0
    for wi in w :
        if truck_container + wi > p:  # 詰めないとき
            truck += 1  # 次のトラックへ
            if truck > k:  # トラックの台数オーバー
                return False
            truck_container = wi
        else :
            truck_container += wi  # トラックに積む
    return True

while left < right:
    p = (left + right) // 2
    if check():
        right = p
    else:
        left = p + 1
p = (left + right) // 2
print(p)
"
9169224,ALDS1_4_D,"def min_max_load(loads, k):
    def feasible(max_load):
        trucks_used = 1
        current_load = 0
        for load in loads:
            if load > max_load:
                return False # infeasible
            if current_load + load > max_load:
                trucks_used += 1
                current_load = 0
            current_load += load
        return trucks_used <= k


    # binary search to find the optimal max load
    left, right = max(loads), sum(loads)
    while left < right:
        mid = (left + right) // 2
        if feasible(mid):
            right = mid
        else:
            left = mid + 1
    return left
        

n, k = map(int, input().split())
loads = [int(input()) for _ in range(n)]

min_p = min_max_load(loads, k)
print(min_p)
"
8295918,ALDS1_4_D,"def check_feasible(weights, k, max_load):
    count = 1
    current_load = 0
    for w in weights:
        if w > max_load:
            return False
        if current_load + w <= max_load:
            current_load += w
        else:
            count += 1
            current_load = w
    return count <= k


def min_max_load(weights, k):
    # min_max_load の範囲を「荷物を 1 つ選ぶ場合の max_load」以上「荷物をすべて選ぶ場合の max_load」以下に設定する.
    l = max(weights)
    r = sum(weights)
    while l < r:
        m = (l + r) // 2
        if check_feasible(weights, k, m):
            r = m
        else:
            l = m + 1
    return l


def main():
    n, k = map(int, input().split())
    weights = [int(input()) for i in range(n)]
    print(min_max_load(weights, k))


if __name__ == ""__main__"":
    main()
"
9002478,ALDS1_4_D,"def can_load_packages(weights, k, max_load):
    count = 0
    current_load = 0

    for weight in weights:
        if weight > max_load:
            return False
        if current_load + weight <= max_load:
            current_load += weight
        else:
            count += 1
            current_load = weight

    if current_load > 0:
        count += 1

    return count <= k


#クラスメソッドでないから、引数にselfはいらない
def find_min_load(weights, k):
    left = max(weights)
    right = sum(weights)

    while left < right:
        mid = (left + right) // 2
        if can_load_packages(weights, k, mid):
            right = mid
        else:
            left = mid + 1

    return left


n, k = map(int, input().split())
#入力が各行1文字ならsplitはいらない
weights = [int(input()) for _ in range(n)]

min_load = find_min_load(weights, k)
print(min_load)
"
8941290,ALDS1_4_D,"def is_load(A:list, P:int, k:int) -> bool:
    cnt = 1
    rec = 0
    for w in A:
        if w > P:
            return False
        if rec + w <= P:
            rec += w
        else:
            cnt += 1
            rec = w
    return cnt <= k

n, k = map(int, input().split())
A = []
sum = 0
for _ in range(n):
    w = int(input())
    sum += w
    A.append(w)
# Ps = list(range(sum+1))

idx = (sum+1)//2
wid = sum
while wid > 0:
    # print(f""idx: {idx}, wid: {wid}, P: {Ps[idx]}, {is_load(A, Ps[idx], k)}"")
    if not is_load(A, idx, k):
        wid = wid // 2
        idx += (wid+1)//2
    else:
        rec = wid // 2
        diff = 0
        if rec % 2 == wid % 2:
            diff = (rec+1)//2
        elif rec % 2 == 0:
            diff = rec//2 + 1
        else:
            diff = rec//2
        idx -= diff
        wid = rec
print(idx+1)
    
"
9203568,ALDS1_4_D,"def check(k,w,p):
    v = p
    c = k
    for i in range(len(w)):
        if p < w[i]:
            c = -1
            break
        elif v >= w[i]:
            v -= w[i]
        else:
            c -= 1
            v = p
            v -= w[i]
    return c > 0
def solve():
    n,k = map(int,input().split("" ""))
    w = []
    m = 0
    for i in range(n):
        v = int(input())
        m = max(m,v)
        w.append(v)
    a = 0
    b = (m * -(-n // k))
    while b-a > 1:
        c = (a+b)//2
        if check(k,w,c):
            b = c
        else:
            a = c
    print(b)
solve()

"
2725778,ALDS1_4_D,"import sys
def s():
 n,k=map(int,input().split())
 w=list(map(int,sys.stdin.readlines()))
 def f():
  c=t=0
  for j in w:
   t+=j
   if t>m:
    t=j
    c+=1
    if c>=k:return 0
  return 1
 l,r=max(w),sum(w)
 while l<r:
  m=(l+r)//2
  if f():r=m
  else:l=m+1
 print(r)
if'__main__'==__name__:s()
"
3348506,ALDS1_4_D,"import sys


def s():
    n, k = map(int, input().split())
    w = list(map(int, sys.stdin.readlines()))

    def f():
        c = t = 0
        for j in w:
            t += j
            if t > m:
                t = j
                c += 1
                if c >= k:
                    return 0
        return 1

    l, r = max(w), sum(w)
    while l < r:
        m = (l + r) // 2
        if f():
            r = m
        else:
            l = m + 1
    print(r)


if '__main__' == __name__:
    s()

"
5390064,ALDS1_4_D,"from sys import stdin

input = stdin.readline
inputs = stdin.readlines

def solve(n, k, W):
    tot = sum(W)
    if k == 1:
        return tot
    def checker(m, k, W):  #P=mがありえるか確認
        cnt = track = 0
        for w in W:
            track += w
            if track > m:  #トラック切り替え
                track = w
                cnt += 1
                if cnt >= k:  #トラックを０番〜(k-1)番まで使い切った
                    return False
        return True
    l = max(W)
    r = tot
    while l < r:
        m = (l+r) // 2
        if checker(m, k, W): #mで大丈夫なら重量上限を減らす
            r = m
        else:                #mでだめなら重量上限を増やす
            l = m+1
    else:
        return r
    
def main():
    n, k = map(int, input().split())
    W = [int(x) for x in inputs()]
    print(solve(n, k, W))

if __name__=='__main__':
    main()

"
5822832,ALDS1_4_D,"import sys
def f(li,n,m):
    c=t=0
    for j in li:
        t+=j
        if t>m:
            t=j
            c+=1
            if c>=n:
                return 0
    return 1
    
_,n=map(int,input().split())
li = list(map(int,sys.stdin.readlines()))

a,b = max(li),sum(li)
while a<b:
    m=(a+b)//2
    if f(li,n,m):
        b=m
    else:
        a=m+1
print(b)
"
6311557,ALDS1_4_D,"import sys
def s():
 n, k = map(int, input().split())
 w = list(map(int, sys.stdin.readlines()))
 def f():
  c = t = 0
  for j in w:
   t += j
   if t > m:
    t = j
    c += 1
    if c >= k:
        return 0
  return 1
 l, r = max(w), sum(w)
 while l < r:
  m = (l + r) // 2
  if f():
      r = m
  else:
      l = m + 1
 print(r)
if'__main__'==__name__:s()
"
2685990,ALDS1_4_D,"import sys
readline = sys.stdin.readline
N, K = map(int, input().split())
W = tuple(map(int, sys.stdin.read().splitlines()))
ma = max(W)
def check(x):
    if x < ma:
        return False
    use = 1
    rest = x
    for w in W:
        if rest >= w:
            rest -= w
        else:
            rest = x - w
            use += 1
    return use <= K
l = 0
r = sum(W)
while r - l > 1:
    m = (r + l) // 2
    if check(m):
        r = m
    else:
        l = m
print(r)

"
8183358,ALDS1_4_D,"input_data = """"""5 3
8
1
7
3
9""""""


def main() -> None:
    # lines = [i.strip() for i in input_data.split(sep=""\n"")]
    lines = [i.strip() for i in open(0).readlines()]
    data_count, truck_count = map(int, lines[0].split(sep="" ""))
    data_list: list = list(map(int, lines[1:]))

    print(calculate_truck_size(truck_count, data_list))


def calculate_truck_size(truck_count: int, data_list: list) -> int:
    """"""Calculate truck size needed for loading in specific number.

    Args:
        truck_count (int): Count of trucks.
        data_list (list): List of weight.

    Returns:
        int: Needed truck capacity.

    """"""
    data_sum = sum(data_list)
    left = max(data_list) - 1
    right = data_sum
    mid: int = (left + right) // 2

    while right - left > 1:
        if can_contain(data_list, truck_count, mid):
            right = mid
        else:
            left = mid

        mid = (left + right) // 2

    return right


def can_contain(data_list: list, truck_count: int, truck_capacity: int) -> int:
    """"""Estimate all packages are loaded to trucks or not.

    Args:
        data_list (list): List of weight.
        truck_count (int): Count of trucks.
        truck_capacity (int): Size of one truck can handle.

    Returns:
        bool: If truck can not contain all the packages, then returns False

    """"""
    current_count: int = 1
    current_weight: int = 0
    for i in data_list:
        current_weight += i
        if current_weight > truck_capacity:
            current_weight = i
            current_count += 1
            if current_count > truck_count:
                return False

    return True


if __name__ == ""__main__"":
    main()

"
8462528,ALDS1_4_D,"# ある積載量 mid で荷物をトラックに積むことができるかどうかを確認する
def is_ok(n, weights, k, mid):
# max(weights) は最も重い荷物の重さを表し、もし mid より大きい場合、それを積むことはできない。
    if max(weights) > mid:
        return False
    
    number_of_trucks = 1    # 使用されたトラックの数
    loading_weight = 0      # 現在のトラックに積まれている重さの合
    for i in range(n):
        w = weights[i]      # 荷物の重量

# 荷物を追加できる場合は追加し、できない場合は新しいトラックに追加
# トラックの数が k を超える場合は False を返し、それ以外は True を返す。
        if loading_weight + w <= mid:
            loading_weight += w
        else:
            loading_weight = w
            number_of_trucks += 1
            if number_of_trucks > k:
                return False
    return True

# プログラムのエントリーポイントで、問題の入力を受け取り、二分探索を使用して最小の最大積載量Pを見つけます。
def main():
    weights = []
    n, k = map(int,input().split())
    for i in range(n):
        weights.append(int(input()))

    left = max(weights) - 1     # 左端leftは最も重い荷物の重さ - 1 で初期化
    right = sum(weights)        # 右端rightは全ての荷物の重さの合計で初期化

# 二分探索を実行し、is_ok 関数を呼び出して、中間値 mid で荷物を積むことができるかどうかを確認する。is_ok 関数が True を返す場合、right を mid に設定して探索範囲を狭め、そうでない場合は left を mid + 1 に設定して探索範囲を狭める。
    while left < right:
        mid =(left + right) // 2
        if is_ok(n, weights, k, mid):
            right = mid
        else:
            left = mid + 1
    
    print(right)

if __name__ == '__main__':
    main()

"
7838313,ALDS1_4_D,"import sys


def main():
    n, k = map(int, input().split())
    w = []
    for _ in range(n):
        w.append(int(input()))

    def check(m):
        count = 1
        total = 0
        for a in w:
            total += a
            if total > m:
                count += 1
                total = a
                if count > k:
                    return False
        return count <= k

    l = max(w)
    r = sum(w) + 1
    while l < r:
        m = (l + r) >> 1
        if check(m):
            r = m
        else:
            l = m + 1
    sys.stdout.write(f""{r}\n"")


if __name__ == ""__main__"":
    input = sys.stdin.buffer.readline
    main()

"
4703492,ALDS1_4_D,"import sys

n, truck_num = map(int, input().split())
weights = [int(x) for x in map(int, sys.stdin)]


def main():
    # 最小値と最大値をもとに二分探索する
    print(binary_search(max(weights), sum(weights)))


def binary_search(left, right):
    """"""二分探索

    :param left: 最小値
    :param right: 最大値
    :return:
    """"""

    while left < right:
        # 真ん中の値を割り当てる
        middle = (left + right) // 2

        # 真ん中の値で一旦シミュレート
        if simulate(middle, weights, truck_num):
            # OKならば、最大値をシミュレートした値に
            right = middle
        else:
            # NGならば、最小値をシミュレートした+1に
            left = middle + 1

    return left


def simulate(mid, wei, t_num):
    """"""

    :param mid: 中央値
    :param wei: 荷物が格納されたリスト
    :param t_num: トラックの台数
    :return: シミュレートOKかNGか
    """"""
    count = 1
    tmp = 0
    for w in wei:
        tmp += w

        # 積載量(tmp)が求める答え(mid)より大きくなったら
        if mid < tmp:
            # tmpを次の積載物に初期化
            tmp = w
            count += 1
            if t_num < count:
                return False
    return True


if __name__ == '__main__':
    main()


"
4862226,ALDS1_4_D,"import sys
input = sys.stdin.readline
sys.setrecursionlimit(2 * 10**6)


def inpl():
    return list(map(int, input().split()))


def getMinTrack(W, load):
    track = 1
    tmp_load = 0
    for w in W:
        tmp_load += w
        if tmp_load > load:
            tmp_load = w
            track += 1
    return track


def main():
    n, k = inpl()
    W = [int(input()) for _ in range(n)]
    max_load = sum(W)
    min_load = max(W)
    if getMinTrack(W, min_load) <= k:
        print(min_load)
        return
    while max_load - min_load > 1:
        tmp = (max_load + min_load) // 2
        if getMinTrack(W, tmp) <= k:
            max_load = tmp
        else:
            min_load = tmp

    print(max_load)
    return


if __name__ == '__main__':
    main()

"
3083100,ALDS1_4_D,"import sys

#f = open(""input.txt"", 'r')
f = sys.stdin
i, k = f.readline().split()
k = int(k)

arr = []

for line in f:
    arr.append(int(line.split()[0]))

def chkCanLoad(arr, k, P):
    tmpW = 0
    k -= 1

    for w in arr:
        tmpW += w
        if tmpW > P:
            k = k - 1
            if k < 0:
                return False
            else:
                tmpW = w
                if tmpW > P:
                    return False
    return True

P = 1
maxP = -1
minP = -10
cof = 2 
while maxP != minP + 1:
    chk = chkCanLoad(arr, k, P)  
    if chk:
        maxP = P
        newP = int(minP + (maxP - minP)/cof)
        P = newP
    else:
        minP = P
        if maxP < 0:
            P *= cof
        else:
            newP = int(minP + (maxP - minP)/cof)
            P = newP 

print(maxP)


"
8538256,ALDS1_4_D,"def unit_check(n, k, w_list, P):
    i = 0
    for j in range(k):
        weight = 0
        while weight + w_list[i] <= P:
            weight += w_list[i]
            i += 1
            if i == n:
                return 1
    return 0

n, k = map(int,input().split())
w_list = [0] * n

for i in range(n):
    w_list[i] = int(input())


left = max(w_list)-1
#荷物の最大数x荷物の最大の重さ
right = sum(w_list)
while left+1 < right:
    mid = (left+ right)//2
    check = unit_check(n, k, w_list, mid)
    if check == 1:
        right = mid
    else:
        left = mid
print(right)
"
8725426,ALDS1_4_D,"import math
n, k = map(int, input().split())
total = 0
w_list = []
max_w = 0
for i in range(n):
    w = int(input())
    w_list.append(w)
    
max_w = max(w_list)
total = sum(w_list)
left = max_w
right = total
half = 0

def check(p, w_list, w_len):
    i = 0
    for _ in range(k):
        temp = 0
        while temp + w_list[i] <= p:
            temp = temp + w_list[i]
            i += 1

            if i == w_len:
                return True
    
    return False
    
while left < right:
    half = (left + right) // 2
    if check(half, w_list, len(w_list)):
        right = half
    else:
        left = half + 1

print(left)
    

    
"
9126517,ALDS1_4_D,"n, total_truck_num = list(map(int, input().split()))
packs = []
for i in range(n):
    val = input()
    packs.append(int(val))

# n < 10^5
# k < 10^5
# max(w) < 10^4

# 1~10^4 の範囲で P の値を二分探索する
# k 台以下ののトラックで積みきれた場合は, P を小さくする
# k 台のトラックで積みきれない場合は, P を大きくする
# 判定にかかる計算量は 10^5

# 全体の最悪計算量は O(10^5 log 10^9) なので解ける

def is_achievable(capacity):
    cnt = 0
    tmp_load = 0

    for w in packs:
        # そもそも w が capacity を超えていたら積載できないので out
        if cnt > total_truck_num or w > capacity:
            return False

        if tmp_load + w > capacity:
            cnt += 1
            tmp_load = w
        else:
            tmp_load += w
        
    cnt += 1

    return cnt <= total_truck_num

def binary_search(l,r):

    found_val = None

    while l <= r:
        mid = l + (r-l)//2
        if is_achievable(mid):
            r = mid - 1
            found_val = mid
        else:
            l = mid + 1

    
    return found_val


ans = binary_search(1, 10**9)

if ans is None:
    print(-1)

print(ans)

"
2717139,ALDS1_4_D,"#!/usr/bin/python3
# -*- coding: utf-8 -*-

import sys
import math 

def is_loadable(load, num_truck, w_list):

    excess = load*num_truck - sum(w_list)
    # print('Minimum Load:', load, num_truck, 'excess:', excess)
    cur_load = 0
    #truck_load = list()
    for w in w_list:
        #print(cur_load, w)
        if cur_load + w < load:
            cur_load += w
        elif cur_load + w == load:
            #truck_load.append(cur_load + w)
            cur_load = 0
            num_truck -= 1
            if num_truck < 0:
                return False
        else:
            num_truck -= 1
            if num_truck < 0:
                return False
            excess += load - cur_load
            if excess < 0:
                return False
            #print(cur_load, 'is added')
            #truck_load.append(cur_load)
            cur_load = w

    #truck_load.append(cur_load)
    if (cur_load and num_truck == 0):
        return False
    #print(truck_load)
    return True

n, num_truck = map(int, sys.stdin.readline().split())

weight = list()
for i in range(n):
    weight.append(int(sys.stdin.readline()))

ave_w = sum(weight) / num_truck
max_w = max(weight)
load = max(max_w, math.ceil(ave_w))
max_ng = load - 1

while True:
    if is_loadable(load, num_truck, weight):
        break
    min_ng = load
    load += 1024

min_ok = load
while True:
    if min_ok == max_ng + 1:
        break
    load = (max_ng + min_ok) // 2
    if is_loadable(load, num_truck, weight):
        min_ok = load
    else:
        max_ng = load

print(min_ok)

"
8411946,ALDS1_4_D,"n, k = map(int, input().split())
W = [int(input()) for i in range(n)]

left, right = max(W)-1, sum(W)
while left+1 < right:
    mid = (left + right) // 2
    cnt, cur = 1, 0
    for w in W:
        if mid < cur + w:
            cur = w
            cnt += 1
        else:
            cur += w
    if cnt <= k:
        right = mid
    else:
        left = mid
print(right)
"
8412688,ALDS1_4_D,"n,k=map(int,input().split())
w=[int(input()) for i in range(n)]
left=max(w)-1
right=sum(w)

while left+1<right:
    mid=(left + right) // 2
    count=1
    cur=0
    for i in w:
        if mid < cur + i:
            cur=i
            count+=1
        else:
            cur+=i
    if count<=k:
        right=mid
    else:
        left=mid
print(right)
"
8431596,ALDS1_4_D,"n, k = map(int, input().split())
w = [int(input()) for _ in range(n)]

def n_loads(P):
  num = 0
  for _ in range(k):
    w_sum = 0
    while num < n and w_sum + w[num] <= P:
      w_sum += w[num]
      num += 1
  return num

P_lb, P_min = 0, max(w)*(n//k + 1)
while P_min - P_lb > 1:
  P_mid = (P_lb + P_min) // 2
  if n_loads(P_mid) < n:
    P_lb = P_mid
  else:
    P_min = P_mid
print(P_min)

"
2189748,ALDS1_4_D,"import sys
n,k = map(int,input().split())
w = list(map(int,sys.stdin.readlines()))

def binarysearch(start,end):
    left = start
    right = end
    middle = 0
    while left < right:
        middle = (left + right)//2
        if simulate(middle,w,k):
            right = middle
        else:
            left = middle + 1
    return left

def simulate(prb,wei,dai):
    count = 1
    tmp = 0
    for j in wei:
        tmp += j
        if tmp > prb:
            tmp = j
            count += 1
            if count > dai:
                return False
    return True

print(binarysearch(max(w), sum(w)))
"
3281323,ALDS1_4_D,"import sys

n, k = map(int, sys.stdin.readline().split())
weights = [int(sys.stdin.readline()) for _ in range(n)]


def acceptable(p):
    rest = k
    capacity = p
    for w in weights:
        if w > capacity:
            rest -= 1
            if rest == 0:
                return False
            capacity = p - w
        else:
            capacity -= w
    return True


left = max(weights) - 1
right = sum(weights)

while left + 1 < right:
    mid = (left + right) // 2
    if acceptable(mid):
        right = mid
    else:
        left = mid

print(right)

"
4586630,ALDS1_4_D,"# -*- coding: utf-8 -*-
import sys
from sys import stdin
import math

n, k = map(int, stdin.readline().split())
w = list([int(stdin.readline().rstrip()) for i in range(n)])

def main2():
  def is_ok():
    cnt_track = w_tmp = 0
    for w_i in w:
      w_tmp += w_i
      if w_tmp > m:
        w_tmp = w_i
        cnt_track += 1
        if cnt_track >= k:
          return 0
    return 1

  r = sum(w)
  l = max(math.ceil(r/k),max(w))
  while l < r:
    m = (l + r) // 2
    # print(""%d %d %d "" % (l, r, m))
    if is_ok():
      r = m
    else:
      l = m + 1
  print(r)

if __name__ == '__main__':
  main2()

"
8988116,ALDS1_4_D,"from typing import List
import time

# P == maximum load capacity
# k == the number of trucks
# items == items
# n == the number of items
# Return: the number of loaded items 
def check(P: int, k: int, items: List[int], n: int) -> int:
    i: int = 0
    for j in range(k):
        s: int = 0
        while s + items[i] <= P:
            s = s + items[i]
            i = i + 1
            if i == n:
                return n
    return i

def solve(n: int, k: int, items: List[int]):
    left: int = 0
    right: int = 100000 * 10000
    mid: int = None
    while right > left:
        mid = int((left + right) / 2)
        v: int = check(mid, k, items, n)
        if v >= n:
            right = mid
        else:
            left = mid + 1
    return right
        

# n == the number of items
# k = the number of trucks
if __name__ == ""__main__"":
    n, k = tuple(map(int, input().split()))

    items = [None] * n
    for i in range(n):
        items[i] = int(input())
    ans: int = solve(n, k, items)
    print(ans)

    
    
"
8996057,ALDS1_4_D,"n,k = map(int, input().split())
W = [int(input()) for _ in range(n)]
left = max(W)-1
right = sum(W)
while left+1 < right:
    mid = (left+right) //2
    cnt = 1
    cur = 0
    for w in W:
        if mid < cur + w:
            cur = w
            cnt += 1
        else:
            cur += w
    if cnt <= k:
        right =mid
    else:
        left = mid
print(right)
"
2462284,ALDS1_4_D,"#!/usr/bin/env python
# -*- coding: utf-8 -*-
""""""
Allocation

????????????????????? wi(i=0,1,...n???1) ??? n ??????????????????
????????????????????¢????????????????????????????????????
????????????????????? k ??°?????????????????????????????????
???????????????????????£?¶??????? 0 ?????\??????????????????????????¨?????§???????????????
???????????????????????????????????????????????§????????? P ????¶????????????????????????????
?????§????????? P ?????????????????????????????§??±?????§??????

n???k???wi ???????????????????????§????????????????????????????????????????????????
?????§????????? P ???????°????????±???????????????°????????????????????????????????????

""""""
import sys

# ??????????????\????????????
def kenzan(P, w, n, k):
#    print(""P:{} kosu:{} track:{}"".format(P,n,k))
    t = 1 # ????????????
    s = 0 # ?????????
    st = 0
    for i in range(n):
        x = s + w[i]
#        print(""max:{} nimotu[{}]:{} + sekisai:{} = {} track:{}"".format(P,i,w[i],s,x,t))
        if x > P: # ????????????
            t += 1
            st += s
            s = w[i]
#            print(""next track:{} sekisai:{}"".format(t,s))
            if t > k: # ??°??°????????????
#                print(""\ttrack:{}/{} P:{} sekisai:{}"".format(t,k,P,st))
                return st
        else:
            s = x

#    print(""\ttrack:{}/{} P:{} sekisai:{}"".format(t,k,P,st))
    return 0

def main():
    """""" ????????? """"""
    n,k = list(map(int,input().split()))
    istr = sys.stdin.read()
    wi = list(map(int,istr.splitlines()))

    # ?????§?????¨???????????¨????°????????±???????
    P = 0
    total = 0
    min = 100000
    for w in wi:
        if P < w:
            P = w
        if min > w:
            min = w
        total += w
    na = int(total / n) # ?????????????????????
    if total % n > 0:
        na += 1
    ka = int(total / k) # ???????????????????????????
    if total % k > 0:
        ka += 1
    # ?????? P (??????????????§??????????????????????????????????±?????????????
#    print(""kosu:{} MAX:{} MIN:{} na:{} ka:{} total:{}"".format(n, P, min, na, ka, total))
    if P < na:
        P = na
    if P < ka:
        P = ka
    z = 0
    while P <= total:
        st = kenzan(P, wi, n, k)
#        print(""??????????????°:{} ??????????????°??°:{} ?????????????????§??????:{} ????????????????????????:{} ??????????????????:{} ??????:{}"".format(n, k, P, total, st,z))
        if st == 0:
            a = P - z
            b = P
            break
        z = int((total-st)/k)
        if z < 1:
            z = 1
        P += z
    
    while b - a > 0:
        x = int((b - a) / 2)
        if x < 1:
            a = b
        P = x + a
        st = kenzan(P, wi, n, k)
#        print(""P:{} MAX:{} MIN:{} sekisai:{}"".format(P, b, a, st))
        if st == 0:
            b = P
        else:
            a = P

    print(P)


if __name__ == '__main__':
    main()
"
3742573,ALDS1_4_D,"import sys
def s():
 n,k=map(int,input().split())
 w=list(map(int,sys.stdin.readlines()))
 def f():
  c=t=0
  for j in w:
   t+=j
   if t>m:
    t=j
    c+=1
    if c>=k:return 0
  return 1
 l,r=max(w),sum(w)
 while l<r:
  m=(l+r)//2
  if f():r=m
  else:l=m+1
 print(r)
if'__main__'==__name__:s()

"
8344136,ALDS1_4_D,"n,t=[int(x) for x in input().split()]
w=[]
for i in range(n):
    w.append(int(input()))

totalw=sum(w)  
pmax=totalw
pmin=int(totalw/t)-1

def check(ptest):
    tk=1
    p=0
    global t
    global w
    global n
    i=0
    
    while i<n:
        p+=w[i]
        if p<=ptest:
            i+=1
        else:
            tk+=1
            p=0
            
        if tk>t:
            return 0
            #break   
    
    return 1
    
        
while (pmax-pmin)>1:
    pmid=(pmax+pmin)//2
    if check(pmid)==1:
        pmax=pmid
    else:
        pmin=pmid
        
print(pmax)
"
8703987,ALDS1_4_D,"n, k = map(int, input().split())
weights = []
for i in range(n):
    weight = int(input())
    weights.append(weight)

left = max(weights)  # 最小値は最大の重さ以上となる
right = sum(weights)  # 最大値はすべての荷物の合計重さ

while left < right:
    mid = (left + right) // 2
    count = 1  # トラックの数をカウント
    current = 0  # 現在のトラックに積まれた重さを表す変数

    for weight in weights:
        if current + weight > mid:  # 現在のトラックに重さを追加した場合に最大積載量を超える場合
            count += 1
            current = weight  # 新しいトラックに重さを割り当てる
        else:
            current += weight

    if count <= k:  # k台のトラックに荷物を積むことができる場合
        right = mid  # 最大積載量を下げる
    else:
        left = mid + 1  # 最大積載量を上げる

print(left)

"
8901888,ALDS1_4_D,"n,k=map(int,input().split())
w=[int(input()) for _ in range(n)]

l=max(w)-1
r=sum(w)
while r-l>1:
    mid=(l+r)//2
    #midが最大積載量、すべてのトラックにmid個入れて収まるかを判定
    ans=0
    #現在のトラック使用台数
    now=0
    #現在のトラックの積載量
    for i in w:
        if now+i<=mid:
            now+=i
        else:
            ans+=1
            now=i
    if ans<k:
        r=mid
    else:
        l=mid
print(r)
"
9135690,ALDS1_4_D,"n, k = map(int, input().split())
W = [int(input()) for i in range(n)]

left = max(W)-1; right = sum(W)
while left+1 < right:
    mid = (left + right) // 2
    cnt = 1; cur = 0
    for w in W:
        if mid < cur + w:
            cur = w
            cnt += 1
        else:
            cur += w
    if cnt <= k:
        right = mid
    else:
        left = mid
print(right)
"
9192979,ALDS1_4_D,"n,k=map(int, input().split())
w=[int(input()) for i in range(n)]
if k>=n:
  print(max(w))
else:
  if n==1:
    print(w[0])
  else:
    M=sum(w)
    m=max(w)
    tn=1
    def a(P,k,w):
        tn=1
        weight=0
        for i in range(n):
          if weight+w[i]<=P:
            weight+=w[i]
          elif w[i]>P:
            return i
          elif weight+w[i]>P:
            tn+=1
            weight=w[i]
          if tn==k+1:
            return i
        return len(w)
    
    right=10000*n
    left=0
    while right-left>1:
      mid=(right+left)//2
      if n<=a(mid,k,w):
        right=mid
      else:
        left=mid
    print(right)
"
8755224,ALDS1_4_D,"def can_load(P):
    track_weight = 0
    w_index = 0
    
    for t_index in range(num_track):
        while w_index < num_load and track_weight + weightlist[w_index] <= P:
            track_weight += weightlist[w_index]
            w_index += 1
        if w_index == num_load:
            return True
        track_weight = 0
    
    return False
        
    
num_load, num_track = map(int, input().split())
weightlist = []
tracklist = []
for _ in range(num_load):
    weightlist.append(int(input()))

allweight = sum(weightlist)
P = allweight

left = min(weightlist)
right = P
mid = (left+right) // 2
ans = P

while left <= right:
    if can_load(mid):
        ans = mid
        right = mid - 1
    else:
        left = mid + 1
    mid = (left+right) // 2
print(ans)
"
8838822,ALDS1_4_D,"
n, k = map(int, input().split())
W = [int(input()) for i in range(n)]

left = max(W)-1; right = sum(W)
while left+1<right:
    mid = (left + right) // 2
    cnt = 1; cur = 0
    for w in W:
        if mid < cur + w:
            cur = w
            cnt += 1
        else:
            cur += w
    if cnt <= k:
        right = mid
    else:
        left = mid
print(right)

"
5461825,ALDS1_4_D,"def solve():
    import sys
    n, k = map(int, input().split())
    ws = tuple(map(int, sys.stdin))

    ok, ng = sum(ws), max(ws)-1

    while ok-ng > 1:
        mid = (ok+ng+1)//2
        current = 0
        count = 0
        for w in ws:
            if current + w > mid:
                current = w
                count += 1
            else:
                current += w
        if count < k:
            ok = mid
        else:
            ng = mid

    print(ok)


if __name__ == ""__main__"":
    solve()

"
8318951,ALDS1_4_D,"n, k = map(int, input().split())
lugg = []

for _ in set(range(n)):
    lugg.append(int(input()))

Pmin = max(lugg)-1
Pmax = sum(lugg)
while Pmin+1 < Pmax:
    Pmid = (Pmin + Pmax) // 2
    trc = 1
    carry = 0
    for w in lugg:
        if Pmid < carry + w:
            carry = w
            trc += 1
        else:
            carry += w
    if trc <= k:
        Pmax = Pmid
    else:
        Pmin = Pmid

print(Pmax)
"
8595373,ALDS1_4_D,"n, k = map(int, input().split())
w = []
for i in range(n):
    w.append(int(input()))
    
def check(p):
    t_sum = 0
    w_idx = 0
    for i in range(k):
        while w_idx < n  and t_sum + w[w_idx] <= p:
            t_sum += w[w_idx]
            w_idx += 1
        if w_idx == n:
            return True
        t_sum = 0
    return False
left = 0
right = sum(w)
mid = (left + right) // 2
ans = sum(w)

while left <= right:
    if check(mid):
        ans = mid
        right = mid - 1
    else:
        left = mid + 1

    mid = (left + right) // 2
print(ans)
"
8994901,ALDS1_4_D,"import sys
import heapq
from _heapq import heappush, heappop
from collections import deque


BIG_NUM = 2000000000

N,K = map(int,input().split())
W = [0]*N
sum = 0

for i in range(N):
    tmp = int(input())
    W[i] = tmp
    sum += tmp


def isOK(P):
    t_sum = 0 #現在のトラックに積んだ荷の総量
    w_ind = 0 #荷物のインデックス

    for t_ind in range(K):
        while w_ind < N and t_sum + W[w_ind] <= P:
            t_sum += W[w_ind]
            w_ind += 1
        if w_ind == N:
            return True
        t_sum = 0 #次のトラックへ

    return False


left = 0; right = sum; mid = (left+right)//2;
ans = sum

while left <= right:
    if isOK(mid):
        ans = mid
        right = mid-1
    else:
        left = mid+1
    mid = (left+right) //2

print(ans)
"
4972572,ALDS1_4_D,"N, K, *W = map(int, open(0).read().split())
right = max(W) * (N // K + 1)
left = 1


def load_truck(p):
    cur = 0
    num = 1
    for w in W:
        if w > p:
            return False
        if cur + w > p:
            if num == K:
                return False
            else:
                num += 1
                cur = w
        else:
            cur += w
    return True


while True:
    mid = (right + left) // 2
    result = load_truck(mid)
    if result:
        right = mid
    else:
        left = mid
    if left >= right - 1:
        break

print(right)

"
8356502,ALDS1_4_D,"n, k = map(int, input().split())
w = [int(input()) for _ in range(n)]


def check(P):
    i = 0
    for _ in range(k):
        s = 0
        while s + w[i] <= P:
            s += w[i]
            i += 1
            if i == n:
                return True
    return False


# 二分探索
left = 0
right = 100000 * 10000
while right - left > 1:
    mid = (left + right) // 2
    if check(mid):
        right = mid
    else:
        left = mid

print(right)

"
8633756,ALDS1_4_D,"n, k = map(int, input().split())
W = [int(input()) for i in range(n)]

left = max(W)-1
right = sum(W)

while left + 1< right:
    mid = (left + right) // 2
    cnt = 1
    cur = 0
    for w in W:
        if mid < cur + w:
            cur = w
            cnt +=1
        else:
            cur += w
    
    if cnt <= k:
        right = mid
    else:
        left = mid
    
print(right)
"
9080579,ALDS1_4_D,"n, k = map(int, input().split())
num = []
for i in range(n):
    val = int(input())
    num.append(val)
def check(p, k):
    j = 0
    for i in range(k):
        s = 0
        while s + num[j] < p:
            s += num[j]
            j += 1
            if j == n:
                return j
    return j
def solve():
    left = 0
    right = sum(num) + 1 
    while right - left > 1:
        mid = (left + right) // 2
        # if check(mid, k) == n:
        #     return mid
        # else:
        if check(mid, k) >= n:
            right = mid
        else:
            left = mid
    return left
    
print(solve())
"
3902686,ALDS1_4_D,"import sys
input=sys.stdin.readline
import math

#input = open(sys.argv[1], ""r"").readline

def main():
    N,K = map(int,input().split())
    W = []
    for _ in range(N):
        W.append(int(input()))

    # (lb, ub] の間を二分探索
    lb = max(W)-1   # 最大の w さえ積めれば良い場合が p の取り得る最小値
    ub = sum(W)     # 全てを 1 台のトラックに積む必要がある場合が p の取り得る最大値

    while ub - lb > 1:
        p = (lb + ub)//2

        v = 0
        k = 1
        for w in W:
            if v + w <= p: # 積載オーバーしなければ積む
                v += w
            else:
                k += 1
                v = w

        if k <= K:
            # p が条件を満たしている ⇒ 解の存在範囲を (lb, p] に更新
            ub = p
        else:
            # p が条件を満たしていない ⇒ 解の存在範囲を (p, ub] に更新
            lb = p
#        print(p,k,lb,ub)

    # この時点で lb + 1 = ub となっている
    print(ub)

if __name__ == '__main__':
    main()

"
4810556,ALDS1_4_D,"import sys
n, k = map(int, input().split())
w = [int(sys.stdin.readline()) for _ in range(n)]
l, r = max(w), sum(w)


def ok():
    c = 0
    t = 0
    for j in w:
        t += j
        if t > m:
            t = j
            c += 1
            if c >= k:
                return 0
    return 1


while l < r:
    m = (l+r)//2
    if ok():
        r = m
    else:
        l = m+1
print(r)
"
8254414,ALDS1_4_D,"n,k = map(int,input().split())
truck = [0 for i in range(k)]
C = []
S = 0

for i in range(n):
    i = int(input())
    C.append(i)
    S += i

def optimize(P):
    j = 0
    t_sum = 0
    for i in range(k):
        while j < n and t_sum + C[j] <= P:
            t_sum += C[j]
            j += 1
        if j == n:
            return True
        t_sum = 0
    return False

Pa = S // k
ans = S

if k > 1:
    L = 0
    R = S
    mid = Pa
    while L < R:
        if optimize(mid):
            R = mid
            ans = mid
        else:
            L = mid + 1
        mid = (L+R)//2

print(ans)
"
8465236,ALDS1_4_D,"N,K = map(int,input().split())
W = [0]*N
sum = 0

for i in range(N):
    tmp = int(input())
    W[i] = tmp
    sum += tmp


def isOK(P):
    t_sum = 0 #現在のトラックに積んだ荷の総量
    w_ind = 0 #荷物のインデックス

    for t_ind in range(K):
        while w_ind < N and t_sum + W[w_ind] <= P:
            t_sum += W[w_ind]
            w_ind += 1
        if w_ind == N:
            return True
        t_sum = 0 #次のトラックへ

    return False


left = 0; right = sum; mid = (left+right)//2;
ans = sum

while left <= right:
    if isOK(mid):
        ans = mid
        right = mid-1
    else:
        left = mid+1
    mid = (left+right) //2

print(ans)

"
8998664,ALDS1_4_D,"N, K = map(int, input().split())

W = []


def check(p):
    i = 0
    for _ in range(K):
        cur_weight = 0
        while i < N and cur_weight + W[i] <= p:
            cur_weight += W[i]
            i += 1

    if i < len(W):
        return False
    else:
        return True


def solve():
    left = 0
    # right = 100000 * 10000  # 荷物の個数 * 一個あたりの最大重量
    right = sum(W)
    while (right > left):
        mid = (right + left) // 2

        if (check(mid) == True):
            right = mid
        else:
            left = mid + 1
    return right


def main():
    for _ in range(N):
        W.append(int(input()))
    ans = solve()
    print(ans)


main()

"
6042245,ALDS1_4_D,"import sys

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines


def main():
    N, K, *W = map(int, read().split())

    left = max(W) - 1; right = 10 ** 10

    while right - left > 1:
        mid = (left + right) // 2
        num = 0
        count = 1

        for w in W:
            if num + w > mid:
                num = w
                count += 1
            else:
                num += w
        
        if count <= K:
            right = mid
        else:
            left = mid
    
    print(right)
        

if __name__ == '__main__':
    main()
"
8414502,ALDS1_5_A,"_ = input()
s = set([0])

for m in [int(s) for s in input().split()]:
    s = s | {n + m for n in s}

_ = input()
for m in [int(s) for s in input().split()]:
    print('yes' if m in s else 'no')
"
8492067,ALDS1_5_A,"import copy
n = int(input())
A = list(map(int,input().split("" "")))  

m_set = set() # 空集合：ここに作れるものを全部入れる。

for i in A:
  for j in copy.deepcopy(m_set):
    m_set.add(i + j)
  m_set.add(i)

q = int(input())
M = list(map(int,input().split("" "")))  
 
for i in M:
  if i in m_set:
    print('yes')
  else:
    print('no')
"
8494529,ALDS1_5_A,"import copy
n = int(input())
A = input().split(' ')
for i in range(n):
    A[i] = int(A[i])
M = set()

for i in A:
    M0 = copy.deepcopy(M)
    for j in M0:
        M.add(i+j)
    M.add(i)

q = int(input())
Q = input().split(' ')
for i in range(q):
    Q[i] = int(Q[i])
for i in Q:
    if i in M:
        print(""yes"")
    else:
        print(""no"")
"
8939105,ALDS1_5_A,"n = int(input())
a = list(map(int, input().split()))
s = {0}
for e in a:
    s.update(set(e + f for f in s))
q = int(input())
m = list(map(int, input().split()))
for i in m:
    print(('no', 'yes')[i in s])

"
8999420,ALDS1_5_A,"n = int(input())
*A, = map(int, input().split())
q = int(input())
*Q, = map(int, input().split())

bits = 1
for a in A:
    bits |= bits << a

for q in Q:
    print(""yes""*((bits >> q) & 1)or""no"")

"
9029042,ALDS1_5_A,"n = int(input())
A = map(int, input().split())
q = int(input())
Q = map(int, input().split())

bits = 1
for a in A:
    bits |= bits << a

for q in Q:
    print(""yes""*((bits >> q) & 1)or""no"")
"
9085233,ALDS1_5_A,"import sys

def check():
    input=lambda:sys.stdin.readline().rstrip()
    _=int(input())
    dp=[False]*2001
    dp[0]=True
    for num in map(int,input().split()):
        for i in range(2000,-1,-1):
            if dp[i-num]:
                dp[i]=True
    _=int(input())
    for num in map(int,input().split()):
        if dp[num]:
            print(""yes"")
        else:
            print(""no"")
check()
"
8301918,ALDS1_5_A,"n = int(input())
A = list(map(int, input().split()))
q = int(input())
m_list = list(map(int, input().split()))

memo = {}
def func_1(elements, q, i):
    if (q, i) in memo:
        return memo[(q, i)]
    # ベースケース
    if q == 0:
        memo[(q, i)] = True
        return True
    if i == 0:
        memo[(q, i)] = False
        return False
    # elements[i-1]を使わない場合
    if func_1(elements, q, i-1):
        memo[(q, i)] = True
        return True
    # elements[i-1]を使う場合
    if q >= elements[i-1] and func_1(elements, q - elements[i-1], i - 1):
        memo[(q, i)] = True
        return True
    memo[(q, i)] = False
    return False

for m in m_list:
    if func_1(A, m, n):
        print(""yes"")
    else:
        print(""no"")
"
8388570,ALDS1_5_A,"n = int(input())
a = list(map(int, input().split()))
q = int(input())
m = list(map(int, input().split()))

dp = [0] * 2001
dp[0] = 1

for k in a:
    for i in reversed(range(2001)):
        if i < k:
            continue
        else:
            dp[i] = max(dp[i], dp[i-k])
            
for k in m:
    if dp[k] == 1:
        print(""yes"")
    else:
        print(""no"")
"
8576792,ALDS1_5_A,"N = int(input())
a = list(map(int, input().split()))
q = int(input())
m = list(map(int, input().split()))

dp = [[-1 for _ in range(2001)] for _ in range(N + 1)]


def solve(i: int, target: int) -> bool:
    global dp
    global a

    if dp[i][target] != -1:
        return dp[i][target]

    if target == 0:
        dp[i][target] = 1
    elif i == N:
        dp[i][target] = 0
    elif solve(i + 1, target) == 1:
        dp[i][target] = 1
    elif solve(i + 1, target - a[i]) == 1:
        dp[i][target] = 1
    else:
        dp[i][target] = 0

    return dp[i][target]


for target in m:
    if solve(0, target):
        print(""yes"")
    else:
        print(""no"")

"
8757364,ALDS1_5_A,"# aizu_ALDS1_5_A_ExhausticSearch_b.py  

from functools import lru_cache

n = int(input())
A = list(map(int,input().split()))
q = int(input())
M = list(map(int,input().split()))

@lru_cache(maxsize=None)
def solve(i,m):
    if m ==0:
        return True
    if i >= n:
        return False
    res = solve(i+1,m) or solve(i+1,m-A[i])
    return res

for m in M:
    ret = solve(0,m)
    if ret ==True:print('yes')
    else: print('no')
"
8999540,ALDS1_5_A,"N = int(input())
ary = list(map(int, input().split()))
Q = int(input())
queries = list(map(int, input().split()))

dp = [[None] * (max(queries) + 1) for _ in range(N+1)]


def solve(i, m):
    if m == 0:
        dp[i][m] = True
        return True

    if i >= N or m < 0:
        return False

    if (dp[i][m] != None):
        return dp[i][m]

    if (solve(i+1, m)) or solve(i+1, m-ary[i]):
        dp[i][m] = True
    else:
        dp[i][m] = False

    return dp[i][m]


for query in queries:
    if solve(0, query):
        print('yes')
    else:
        print('no')

"
9168046,ALDS1_5_A,"n = int(input())
A = [*map(int,input().split())]
q = int(input())
m = [*map(int,input().split())]

#dpで解く
#dp[i][j] := i番目までの数字を使って総和jにできるかどうか

dp = [[False] * 10000 for _ in range(n+10)]
dp[0][0] = True
for i in range(n):
  for j in range(10000):
    if dp[i][j]:
      dp[i+1][j] = True
      dp[i+1][j+A[i]] = True

for mi in m:
  if dp[n][mi]:print(""yes"")
  else:print(""no"")

"
1609886,ALDS1_5_A,"def solve(A, i, m, n):
    """"""Return if it is possible to make value m with some elements in A.

    n is length of A.
    i is index.
    R is the record of answer i, m.
    Using Divide-and-Conquer method.
    """"""

    if R[i][m] != None:
        return R[i][m]
    if m == 0:
        R[i][m] = True
        return True
    elif i >= n:
        R[i][m] = False
        return False
    else:
        ans = solve(A, i + 1, m, n) or solve(A, i + 1, m - A[i], n)
        R[i][m] = ans
        return ans


import sys

n = int(sys.stdin.readline())
A = tuple(map(int, sys.stdin.readline().split()))
q = int(sys.stdin.readline())
M = tuple(map(int, sys.stdin.readline().split()))

s_A = sum(A)
R = [[None] * 2000 for i in range(n + 1)]

ans = ''

for m in M:
    if s_A < m:
        ans += 'no\n'
    elif solve(A, 0, m, n):
        ans += 'yes\n'
    else:
        ans += 'no\n'

print(ans, end = '')
"
2180987,ALDS1_5_A,"n = input()
A = input().split(' ')
A.sort()
A.reverse()
q = input()
M = input().split(' ')

A = list(map(int,A))
M = list(map(int,M))
A.sort()

A_sum = [0]
for a in A:
    A_sum.append(a+A_sum[-1])
A_sum.pop(0)

A.reverse()
A_sum.reverse()


#memo = [True]*(len(A))

def search(base, m, n):
    if base == m:
        return True
    if len(A)-1 < n or m - base > A_sum[n]:
        return False
    result = False
    for i in range(len(A)-1,n-1,-1):
        if base + A[i] <= m: # and memo[i]:
#           memo[i] = False
#           print(str(A[i]) + ',' + str(base+A[i]) + ',')
            if search(base+A[i], m, i+1):
                return True
#           memo[i] = True
    return result

def print_yn(result):
    if result:
        print('yes')
    else:
        print('no')

for m in M:
#   print(str(m)+':')
    print_yn(search(0,m,0))
"
2360101,ALDS1_5_A,"# coding=utf-8

def solve(i, m):
    global A
    if ever_calc[i][m] != None:
        return ever_calc[i][m]
    if m == 0:
        ever_calc[i][m] = True
        return True
    elif m < 0:
        ever_calc[i][m] = False
        return False
    elif i == n:
        ever_calc[i][m] = False
        return False
    else:
        result = (solve(i+1, m) or solve(i+1, m-A[i]))
        ever_calc[i][m] = result
        return result

n = int(input())
A = tuple(map(int, input().split()))
q = int(input())
M = tuple(map(int, input().split()))
sum_A = sum(A)
ever_calc = [[None] * 2000 for i in range(n+1)]

for m in M:
    if m > sum_A:
        print('no')
    elif solve(0, m):
        print('yes')
    else:
        print('no')
"
2472062,ALDS1_5_A,"n = int(input())
*A, = map(int, input().split())
q = int(input())
*Q, = map(int, input().split())

bits = 1
for a in A:
    bits |= bits << a

for q in Q:
    print(""yes""*((bits >> q) & 1)or""no"")
"
2585793,ALDS1_5_A,"def ALDS1_5A():
    n, A, q = int(input()),list(map(int, input().split())), int(input())
    allFromA = [False]*2001
    for a in A:
        for i in range(2000-a, 0, -1):
            if allFromA[i]:
                allFromA[i+a] = True
        allFromA[a] = True

    for m in input().split():
        if allFromA[int(m)]:
            print('yes')
        else:
            print('no')

if __name__ == '__main__':
    ALDS1_5A()
"
2589587,ALDS1_5_A,"a_len = int(input())
a_ar = sorted([int(n) for n in input().split("" "")])
b_len = int(input())
b_ar = [int(n) for n in input().split("" "")]
max_b = max(b_ar)
dp = [0 for n in range(max_b + 1)]
for a in a_ar:
    new_dp = dp[:]
    new_dp[a] = 1
    for i,d in enumerate(dp):
        if d and i + a <= max_b:
            new_dp[i + a] = 1
    dp = new_dp
for b in b_ar:
    if dp[b]:
        print(""yes"")
    else:
        print(""no"")
"
2648526,ALDS1_5_A,"from itertools import product


def main():
    """"""
    2^20 = 1,048,576
    q = 200
    200,000,000
    limit 5s ???????????????OK
    """"""
    n = int(input())
    A = list(map(int, input().split()))
    q = int(input())
    M = map(int, input().split())

    dp(n, A, q, M)


def combination(n, A, q, M):
    for m in M:
        if m == 0 or solve(m, A, n):
            print(""yes"")
        else:
            print(""no"")


def dp(n, A, q, M):
    M_max = 2000
    _dp = [False] * (M_max + 1)
    for a in A:
        # ?°??????????????????????????????¨????????????????????±?????????(a???2????¶?????????¨?????????)
        for i in range(M_max, 0, -1):
            if _dp[i] and i + a <= M_max:
                _dp[i + a] = True
        # ???????¨????????????¨????????°?????¨????¨±????????????????????¨??§
        _dp[a] = True

    for m in M:
        if _dp[m]:
            print(""yes"")
        else:
            print(""no"")


def solve(m, A, n):
    # for b in f1(n):
    for b in product([0, 1], repeat=n):
        s = sum(a * bit for a, bit in zip(A, b))
        if m == s:
            return True

    return False


def f1(n):
    for i in range(2 ** n):
        # 0/1???n??????????????????bit????????¨
        # 0b ?????????
        bit = bin(i)[2:]
        yield map(int, bit.zfill(n))

if __name__ == '__main__':
    main()
"
2686939,ALDS1_5_A,"n = int(input())
SET1 = {0}
for a in map(int, input().split()):
    for b in tuple(SET1):
        SET1.add(a + b)
input()
for m in map(int, input().split()):
    print('yes' if m in SET1 else 'no')
"
2710683,ALDS1_5_A,"b=1
input()
for a in map(int,input().split()):b|=b<<a
input()
for m in map(int,input().split()):print(['no','yes'][(b>>m)&1])
"
2789741,ALDS1_5_A,"def create_sums(ns):
    if len(ns) == 0:
        return set()

    s = create_sums(ns[1:])
    return {e + ns[0] for e in s} | s | {ns[0]}


def run_set():
    _ = int(input())  # flake8: noqa
    ns = [int(i) for i in input().split()]

    sums = create_sums(ns)
    _ = int(input())  # flake8: noqa

    for q in (int(j) for j in input().split()):
        if q in sums:
            print(""yes"")
        else:
            print(""no"")


if __name__ == '__main__':
    run_set()


"
2897340,ALDS1_5_A,"n = int(input())
*X, = map(int, input().split())
m = int(input())
*Y, = map(int, input().split())
 
bits = 1
for a in X:
    bits |= bits << a
 
for m in Y:
    print(""yes""*((bits >> m) & 1)or""no"")
"
2898785,ALDS1_5_A,"n = int(input())
*A, = map(int, input().split())
q = int(input())
*Q, = map(int, input().split())
 
bits = 1
for a in A:
    bits |= bits << a
 
for q in Q:
    print(""yes""*((bits >> q) & 1)or""no"")
"
3001667,ALDS1_5_A,"sum = 1
input()
for i in map(int,input().split()):
    sum|=sum<<i
input()
for j in map(int,input().split()):
    print(['no','yes'][(sum>>j)&1])
"
3116238,ALDS1_5_A,"n = int(input())
A = list(map(int, input().split()))
q = int(input())
M = list(map(int, input().split()))
bits = 1
for a in A:
    bits |= bits << a
for m in M:
    print('yes' if (bits >> m) & 1 else 'no')
"
3224673,ALDS1_5_A,"n = int(input())
a_list = list(map(int,input().split()))
q = int(input())
q_list = list(map(int,input().split()))
bits = 1

for a in a_list:
    bits |= bits << a

for q in q_list:
    if (bits>>q)&1:
        print('yes')
    else:
        print('no')
"
3258063,ALDS1_5_A,"n = int(input())
*A, = map(int, input().split())
q = int(input())
*m, = map(int, input().split())

bits = 1
for a in A:
    bits |= bits << a

for q in m:
    print(""yes""*((bits >> q) & 1) or ""no"")

"
3331388,ALDS1_5_A,"n=int(input())
a=list(map(int, input().split()))
m=int(input())
b=list(map(int, input().split()))
d={0:1}
for i in a:
    for j in list(d):
        d[j+i]=1
for i in b:
    if i in d:print('yes')
    else:print('no')
"
3349710,ALDS1_5_A,"b = 1
input()
for a in map(int, input().split()):
    b |= b << a
input()
for m in map(int, input().split()):
    print('yes' if (b >> m) & 1 else 'no')

"
3398648,ALDS1_5_A,"n = int(input())
*A, = map(int, input().split())
q = int(input())
*Q, = map(int, input().split())
 
bits = 1
for a in A:
    bits |= bits << a
 
for q in Q:
    print(""yes""*((bits >> q) & 1)or""no"")
"
3429632,ALDS1_5_A,"
n = int(input())
*a, = map(int, input().split())
q = int(input())
*m, = map(int, input().split())

# DP
nq = 20*200+1
f = [[False for _ in range(nq)] for i in range(n+1)]
f[n][0] = True

for i in range(n-1, -1, -1):
    for j in range(sum(a)+1):
        v1 = f[i+1][j]
        v2 = f[i+1][j-a[i]] if j >= a[i] else False
        f[i][j] = v1 or v2

for t in m:
    print(""yes"" if f[0][t] else ""no"")
"
3790550,ALDS1_5_A,"b=1
input()
for a in map(int,input().split()):b|=b<<a
input()
for m in map(int,input().split()):print(['no','yes'][(b>>m)&1])
"
3884809,ALDS1_5_A,"num = int(input())
array = [int(x) for x in input().split()]
m = int(input())
l = [ int(x) for x in input().split()]


s = {0}
for i in array:
    s |= { x + i for x in s }


for q in l :
    if q in s:
        print(""yes"")
    else:
        print(""no"")


"
3948431,ALDS1_5_A,"n=int(input())
a=[int(x) for x in input().split()]
q=int(input())
m=[int(x) for x in input().split()]


s = {0}
for i in a:
    s |= { x + i for x in s }

for q in m:
    if q in s:
        print(""yes"")
    else:
        print(""no"")
"
3988828,ALDS1_5_A,"def main():
	n = int(input())
	a = list(map(int,input().split()))
	q = int(input())
	m = list(map(int,input().split()))
	lst = set()
	for i in a:
		templ = list(lst)
		for j in templ:
			lst.add(i+j)
		lst.add(i)
	for i in m:
		if i in lst:
			print(""yes"")
		else:
			print(""no"")

main()
"
4001687,ALDS1_5_A,"from bisect import bisect_right as br
import sys

sys.setrecursionlimit(10 ** 6)
int1 = lambda x: int(x) - 1
p2D = lambda x: print(*x, sep=""\n"")

def main():
    n=int(input())
    aa=list(map(int, input().split()))
    input()
    qq=list(map(int, input().split()))

    ss=set()
    ss.add(0)
    for a in aa:
        nss=set()
        for s in ss:
            nss.add(s)
            nss.add(s+a)
        ss=nss

    for q in qq:
        if q in ss:
            print(""yes"")
        else:
            print(""no"")

main()

"
4079604,ALDS1_5_A,"n=int(input())
A=[]
A=input().split()
A=[int(u) for u in A]
A.sort()
q=int(input())
S=[]
S=input().split()
S=[int(u) for u in S]
coun=0
for i in range(0,n):
    coun=coun+A[i]
K=[[0 for j in range(coun+1)] for i in range(n)]
T=[]
for i in range(0,n):
    K[i][0]=0
for j in range(0,coun+1):
    T.append(0)
for j in range(1,coun+1):
    if A[0]==j:
        K[0][j]=1
        T[j]=1
    else:
        K[0][j]=0
koe=A[0]
for i in range(1,n):
    koe=koe+A[i]
    for j in range(1,coun+1):
        j=coun+1-j
        u=j-A[i]
        if koe<j:
            K[i][j]=0
        elif koe==j:
            K[i][j]=1
            T[koe]=1
        elif A[i]==j:
            K[i][j]=1
            T[j]=1
        elif T[u]==1 and j<=koe and u>=0:
            T[j]=1
            K[i][j]=1
        else:
            K[i][j]=0
s=len(S)
for i in range(0,s):
    o=S[i]
    if o>coun:
        print(""no"")
    elif T[o]==1 and o<=coun:
        print(""yes"")
    else:
        print(""no"")
"
4099243,ALDS1_5_A,"n=int(input())
a=list(map(int,input().split()))
q=int(input())
m=list(map(int,input().split()))

ans=[0]
for i in range(n):
    ans_bkup=ans.copy()
    ans=list(map(lambda x: x+a[i],ans))
#    print(ans,ans_bkup)
    ans.extend(ans_bkup)
    ans=list(set(ans))

for i in range(q):
    if(m[i] in ans):
        print(""yes"")
    else:
        print(""no"")
"
4145807,ALDS1_5_A,"n = int(input())
A = [int(i) for i in input().split()]
q = int(input())
M = [int(i) for i in input().split()]
bit = 1
for a in A:
    bit |= bit<<a
for m in M:
    if bit & 1<<m:
        print(""yes"")
    else:
        print(""no"")
"
4166713,ALDS1_5_A,"N = int(input())
A = list(map(int,input().split()))
Q = int(input())
M = list(map(int,input().split()))

ans = [False for i in range(2001)]
ans[0] = True

for i in range(N):
    for j in range(2000, -1, -1):
        if ans[j]:
            if j+A[i] <= 2000:
                ans[j+A[i]] = True
for i in range(Q):
    if ans[M[i]]:
        print('yes')
    else:
        print('no')

"
4189905,ALDS1_5_A,"n = int(input())
a = list(map(int, input().split()))
q = int(input())
m = list(map(int, input().split()))
lst = set()
for i in a:
    templ = list(lst)
    for j in templ:
        lst.add(i+j)
    lst.add(i)
for i in m:
    if i in lst:
        print('yes')
    else:
        print('no')
        
"
4331784,ALDS1_5_A,"a = int(input())
comb_num = list(map(int, input().split()))
b = int(input())
ans_num = list(map(int, input().split()))

gen = 1

for i in comb_num:
    gen = gen<<i|gen

for j in ans_num:
    if gen>>j&1:
        print('yes')
    else:
        print('no')
"
4361221,ALDS1_5_A,"n=int(input())
A=list(map(int,input().split()))
q=int(input())
m=list(map(int,input().split()))

B={0}
C={0}
for num in A:
    for item in B:
        C.add(item+num)
        #print(num,C)
    B |=C
#print(B)

    
for num in m:
  if num in C:
    print(""yes"")
  else:
    print(""no"")
"
4398040,ALDS1_5_A,"n = int(input())
arr = list(map(int, input().split()))
L, R = {0}, {0}
for i in range(len(arr)//2):
    tmp = {arr[i]}
    for a in L:
        tmp.add(a + arr[i])
    L |= tmp
for i in range(len(arr)//2, len(arr)):
    tmp = {arr[i]}
    for a in R:
        tmp.add(a + arr[i])
    R |= tmp
input()
for m in map(int, input().split()):
    tag = False
    for a in L:
        if m - a in R:
            tag = True
            break
    print(['no', 'yes'][tag])
"
4438159,ALDS1_5_A,"n = int(input())
A = list(map(int, input().split()))
q = int(input())
Q = list(map(int, input().split()))
 
bits = 1
for a in A:
    bits |= bits << a
 
for q in Q:
    if bits >> q & 1:
        print(""yes"")
    else:
        print(""no"")

"
4646874,ALDS1_5_A,"N=int(input())
L=list(map(int,input().split()))
B=1
for i in range(N):
    B=B|B<<L[i]
BI=list(str(bin(B)))
BI=BI[2:]
SB=BI[::-1]
#print(SB)
Q=int(input())
A=list(map(int,input().split()))
for i in range(Q):
    if A[i]>=len(SB):
        print(""no"")
    elif SB[A[i]]==""1"":
        print(""yes"")
    else:
        print(""no"")
"
4707757,ALDS1_5_A,"n = int(input())
*li, = map(int, input().split())
input()
*Q, = map(int, input().split())

bits = 1
for i in li:
    # print(f""{i=}"")
    # print(f""{bin(bits)=}"")
    bits |= bits << i
    # print(f""{bin(bits)=}"")
    # print()

# print()
for q in Q:
    # print(f""{bin(bits)=}"")
    print(""yes""*((bits >> q) & 1) or ""no"")
    # print()

"
4729122,ALDS1_5_A,"n = int(input())
a = list(map(int,input().split()))
q = int(input())
b = list(map(int,input().split()))

sumn = {0}
for i in a:
    sumn |= {i + x for x in sumn}
for i in b:
    if i in sumn:
        print('yes')
    else:
        print('no')

"
4805707,ALDS1_5_A,"n = int(input())
A = list(map(int,input().split()))
q = int(input())
M = list(map(int,input().split()))

a = 1
for i in A:
    a |= (a << i)
    
for i in M:
    if bin(a >> i)[-1] == ""1"":
        print(""yes"")
    else:
        print(""no"")
"
4808242,ALDS1_5_A,"_ = int(input())
a = map(int, input().split())
_ = int(input())
m = map(int, input().split())

possibles = {0}
for num in a:
    for j in possibles.copy():
        possibles.add(j + num)
for query in m:
    if query in possibles:
        print(""yes"")
    else:
        print(""no"")

"
4815392,ALDS1_5_A,"import sys

n = int(sys.stdin.readline())
a = list(map(int, sys.stdin.readline().split()))
q = int(sys.stdin.readline())
m = list(map(int, sys.stdin.readline().split()))

# print(n)
# print(a)
# print(q)
# print(m)

s = set()
for i in a:
    lst = list(s)
    for j in lst:
        s.add(i+j)
    s.add(i)
for i in m:
    if i in s:
        print(""yes"")
    else:
        print(""no"")

"
4923764,ALDS1_5_A,"n = int(input())
A = list(map(int, input().split()))
q = int(input())
M = list(map(int, input().split()))

R = set([0])
for a in A:
    for r in list(R):
        R.add(r+a)
        
            

for m in M:
    print(""yes"") if m in R else print(""no"")
"
4987358,ALDS1_5_A,"import sys
input = sys.stdin.readline
n = int(input())
a = list(map(int, input().split()))
s = sum(a) + 1
dp = [0] * 2001
dp[0] = 1
for i in a:
    for j in range(s - i, -1, -1):
        dp[i + j] += dp[j]

q = input()
print(*[""yes"" if dp[i] else ""no"" for i in map(int, input().split())], sep=""\n"")

"
4995308,ALDS1_5_A,"_ = input()
yes_nums = {0}
for x in map(int, input().split()):
  for y in [*yes_nums]:
    yes_nums.add(x + y)

_ = input()
for m in map(int, input().split()):
  print(""yes"" if m in yes_nums else ""no"")
"
4998254,ALDS1_5_A,"n = int(input())
a = list(map(int, input().split()))

dat = 1
for e in a :
    dat |= (dat << e)

q = int(input())
m = list(map(int, input().split()))
for e in m :
    if (dat >> e & 1) == 1 :
        print('yes')
    else :
        print('no')
"
5055154,ALDS1_5_A,"def main():

    _ = input()
    a = list(map(int, input().split()))
    _ = input()
    m = list(map(int, input().split()))

    s = set((0, ))
    for ai in a:
        s_copy = s.copy()
        for si in s_copy:
            s.add(si + ai)
    
    for mi in m:
        if mi in s:
            print(""yes"")
        else:
            print(""no"")

main()

"
5055328,ALDS1_5_A,"n = int(input())
A = list(map(int, input().rstrip().split("" "")))
q = int(input())
M = list(map(int, input().rstrip().split("" "")))

bits = 1
for a in A:
    bits |= bits << a

for m in M:
    tmp = (bits >> m) & 1
    if(tmp):
        print(""yes"")
    else:
        print(""no"")
"
5077195,ALDS1_5_A,"n = int(input())
*A, = map(int, input().split())
q = int(input())
*Q, = map(int, input().split())

bits = 1
for a in A:
    bits |= bits << a

for q in Q:
    print(""yes""*((bits >> q) & 1)or""no"")
"
5179514,ALDS1_5_A,"n=int(input())
a=list(map(int,input().split()))
q=int(input())
m=list(map(int,input().split()))
bits=1
for i in a:
  bits |= bits<<i
for i in m:
  if bits>>i & 1:
    print(""yes"")
  else:
    print(""no"")
"
5180321,ALDS1_5_A,"n = int(input())
A = list(map(int, input().split()))
q = int(input())
m = list(map(int, input().split()))

all_list = {0}
for a in A:
    for aa in all_list.copy():
        all_list.add(aa+a)

for i in range(q):
    if m[i] in all_list:
        print('yes')
    else:
        print('no')

"
5229602,ALDS1_5_A,"n = int(input())
A = tuple(map(int, input().split()))
q = int(input())
ms = tuple(map(int, input().split()))


scores = set([A[0], 0])
for a in A[1:]:
    _scores = set()
    for s in scores:
        _scores.add(s + a)
        _scores.add(s)
    scores = _scores

for m in ms:
    if m in scores:
        print('yes')
    else:
        print('no')
"
5261746,ALDS1_5_A,"n = int(input())
A = [int(inp) for inp in input().split()]
num = int(input())
B = [int(inp) for inp in input().split()]


a = {0}
for i in range(len(A)):
    a = a | { element + A[i] for element in a }


for i in range(len(B)):
    if B[i] in a: print(""yes"")
    else: print(""no"")

"
5276570,ALDS1_5_A,"n = int(input())
x = list(map(int, input().split()))

z = 1
for i in x :
    z |= (z << i)

q = int(input())
y = list(map(int, input().split()))
for i in y :
    if (z >> i & 1) == 1 :
        print('yes')
    else :
        print('no')

"
5287023,ALDS1_5_A,"n = int(input())
A = list(map(int,input().split()))
q = int(input())
Mi = list(map(int,input().split()))

S = set()

for i in A:
	x = list(S)
	for j in x:
		S.add(i + j)
	S.add(i)

for j in Mi:
	print(""yes"") if j in S else print(""no"")
"
8256195,ALDS1_5_B,"import math
def count(N):
    p = int(math.log2(N))
    q = N - 2**p
    return (p*(2**p)+(p+2)*q)
    
N = int(input())
L = list(map(int,input().split()))

print(' '.join(list(map(str,sorted(L)))))
print(count(N))
"
8416420,ALDS1_5_B,"i = int(input())
s = 1
t = i - s
while s <= i:
    t += i - s
    s *= 2
print(*sorted([int(s) for s in input().split()]))
print(t)
"
7845914,ALDS1_5_B,"import sys


def count(l, r):
    result = 0
    if r - l > 1:
        m = (l + r) // 2
        result += count(l, m)
        result += count(m, r)
        result += r - l
    return result


def main():
    n = int(input())
    (*nums,) = map(int, input().split())
    nums.sort()
    sys.stdout.write(f""{' '.join(map(str, nums))}\n"")
    sys.stdout.write(f""{count(0, n)}\n"")


if __name__ == ""__main__"":
    input = sys.stdin.buffer.readline
    main()

"
3323082,ALDS1_5_B,"import math
n = int(input())
S = list(map(int, input().split()))
S.sort()

count = 0
if n != 1:
    for i in range(1, n):
        count += int(math.log2(i)) + 2

print("" "".join(list(map(str, S))))
print(count)
"
5058768,ALDS1_5_B,"def count(left, right):
    cnt = 0
    if left + 1 < right:
        mid = (left + right) // 2
        cnt += count(left, mid)
        cnt += count(mid, right)
        cnt += right - left
    return cnt


N = int(input())
print("" "".join(map(str, sorted(map(int, input().split())))))
print(count(0, N))
"
5873733,ALDS1_5_B,"# ALDS1_5_B
def Count(n):
    S = 0
    if n>1 :
        a = n//2 ; b = n - a 
        S += a + b
        S += Count(a) + Count(b)
        return S
    else : return 0

n = int(input())
A = list(map(int,input().split()))

A.sort()
print(*A)
print(Count(n))
"
6172579,ALDS1_5_B,"def m(L,R):
 cnt=0
 if L+1<R:mid=(L+R)//2;cnt+=m(L,mid);cnt+=m(mid,R);cnt+=R-L
 return cnt
N=int(input());*l,=map(int,input().split());print(*sorted(l));print(m(0,N))
"
4398166,ALDS1_5_B,"# def merge(arr, l, mid, r):
#     L = [arr[i] for i in range(l, mid)]
#     R = [arr[i] for i in range(mid, r)]
#     L.append(int(1e9 + 10))
#     R.append(int(1e9 + 10))
#     i, j = 0, 0
#     cnt = 0
#     for k in range(l, r):
#         if L[i] <= R[j]:
#             arr[k] = L[i]
#             i += 1
#         else:
#             arr[k] = R[j]
#             j += 1
#         cnt += 1
#     return cnt

# def mergeSort(arr, l, r):
#     cnt = 0
#     if l + 1 < r:
#         mid = (l + r) >> 1
#         cnt += mergeSort(arr, l, mid)
#         cnt += mergeSort(arr, mid, r)
#         cnt += merge(arr, l, mid, r)
#     return cnt

# triky

def count(l, r):
    cnt = 0
    if l + 1 < r:
        mid = (l + r) >> 1
        cnt += count(l, mid)
        cnt += count(mid, r)
        cnt += r - l
    return cnt

cnt = count(0, int(input()))
arr = list(map(int, input().split()))
arr.sort()
print(*arr)
print(cnt)
"
5825357,ALDS1_5_B,"def count(left, right):
    cnt = 0
    if left + 1 < right:
        mid = (left + right) // 2
        cnt += count(left, mid)
        cnt += count(mid, right)
        cnt += right - left
    return cnt


N = int(input())
*li, = map(int, input().split())
print(*sorted(li))
print(count(0, N))
"
5964790,ALDS1_5_B,"def merge(L,R):
    cnt = 0
    if L + 1 < R:
        mid = (L+R) // 2
        cnt += merge(L, mid)
        cnt += merge(mid, R)
        cnt += R-L
    return cnt


N = int(input())
*li, = map(int, input().split())
print(*sorted(li))
print(merge(0, N))

"
8497591,ALDS1_5_B,"import sys
sys.setrecursionlimit(10**6)

count = 0

def merge(L, R):
    global count
    j = 0
    for l in L:
        while j < len(R) and R[j] < l:
            yield R[j]
            j += 1
        yield l
    while j < len(R):
        yield R[j]
        j += 1
    count += len(L) + len(R)

def mergeSort(A):
    global count
    if len(A) == 1:
        return A
    elif len(A) == 2:
        count += 2
        a, b = A
        return [a, b] if a < b else [b, a]
    mid = len(A) // 2
    A[:] = list(merge(mergeSort(A[:mid]), mergeSort(A[mid:])))
    return A

def main():
    n = int(input())
    S = list(map(int, input().split()))
    
    sorted_list = mergeSort(S)
    
    print(*sorted_list)
    print(count)
    
if __name__ == ""__main__"":
    main()

"
8412302,ALDS1_5_B,"import sys
sys.setrecursionlimit(10**6)

def Merge(L, R):
    global ans
    j = 0
    for l in L:
        while j < len(R) and R[j] < l:
            yield R[j]
            j += 1
        yield l
    while j < len(R):
        yield R[j]
        j += 1
    ans += len(L) + len(R)

def MergeSort(A):
    global ans
    if len(A) == 1:
        return A
    elif len(A) == 2:
        ans += 2
        a, b = A
        return A if a < b else (b, a)
    mid = len(A) // 2
    A[:] = Merge(MergeSort(A[:mid]), MergeSort(A[mid:]))
    return A

ans = 0
n = int(input())
A = list(map(int, input().split()))
ANS = MergeSort(A)
print(*ANS)
print(ans)
"
8434189,ALDS1_5_B,"n = int(input())
S = list(map(int, input().split()))

def merge(A, left, mid, right):
    L = A[left:mid] + [float(""inf"")]
    R = A[mid:right] + [float(""inf"")]
    i, j = 0, 0
    count = 0  # インバージョン数をカウントする変数
    for k in range(left, right):
        if L[i] <= R[j]:
            A[k] = L[i]
            i += 1
        else:
            A[k] = R[j]
            j += 1
           
    return right - left


def merge_sort(A, left, right):
    count = 0
    if right - left > 1:
        mid = (left +right) // 2
        count += merge_sort(A, left, mid) + merge_sort(A, mid, right)
        count += merge(A,left, mid, right)
    return count


count = merge_sort(S, 0, n)
print(*S)
print(count)
"
8305275,ALDS1_5_B,"count = 0
def merge(data, l, m, r):
    global count
    count += r - l + 1
    l_data, r_data = data[l:m+1], data[m+1:r+1]
    l_data.append(float(""inf""))
    r_data.append(float(""inf""))
    i, j = 0, 0
    for k in range(l, r + 1):
        if l_data[i] <= r_data[j]:
            data[k] = l_data[i]
            i += 1
        else:
            data[k] = r_data[j]
            j += 1


def merge_sort(data, l, r):
    if l < r:
        m = (l + r) // 2
        merge_sort(data, l, m)
        merge_sort(data, m + 1, r)
        merge(data, l, m, r)


def main():
    n = int(input())
    data = [int(s) for s in input().split()]
    merge_sort(data, 0, n - 1)
    print(*data)
    print(count)


if __name__ == ""__main__"":
    main()

"
8518063,ALDS1_5_B,"def merge(A, left, mid, right):
    n1 = mid - left
    n2 = right - mid
    L = A[left:mid] + [float('inf')]
    R = A[mid:right] + [float('inf')]
    i = j = 0
    count = 0
    for k in range(left, right):
        count += 1
        if L[i] <= R[j]:
            A[k] = L[i]
            i += 1
        else:
            A[k] = R[j]
            j += 1
    return count

def mergeSort(A, left, right):
    if left + 1 < right:
        mid = (left + right) // 2
        count = mergeSort(A, left, mid)
        count += mergeSort(A, mid, right)
        count += merge(A, left, mid, right)
        return count
    return 0

n = int(input())
S = list(map(int, input().split()))

count = mergeSort(S, 0, n)
print("" "".join(map(str, S)))
print(count)

"
8839219,ALDS1_5_B,"max_value = 1000000000
global count


# Function to perform Merge Sort
def mergeSort(arr, left, right):
    global count
    if left + 1 < right:
        mid = (left + right) // 2  # Calculate the middle index of the current subarray
        mergeSort(arr, left, mid)  # Recursively sort the left half of the subarray
        mergeSort(arr, mid, right)  # Recursively sort the right half of the subarray
        merge(arr, left, mid, right)  # Merge the sorted left and right halves


# Function to merge two subarrays
def merge(arr, left, mid, right):
    global count
    L = arr[left:mid]  # Create a temporary array for the left subarray
    R = arr[mid:right]  # Create a temporary array for the right subarray
    L.append(max_value)  # Add a max value to the end of the left subarray
    R.append(max_value)  # Add a max value to the end of the right subarray
    i, j = 0, 0  # Initialize indices for left and right subarrays

    # Merge the two subarrays while comparing elements
    for k in range(left, right):
        if L[i] <= R[j]:
            arr[k] = L[i]
            i += 1
            count += 1  # Increment comparison count
        else:
            arr[k] = R[j]
            j += 1
            count += 1  # Increment comparison count


if __name__ == ""__main__"":
    n = int(input())  # Read the number of elements in the array
    A = list(map(int, input().split()))  # Read the array elements and store them in a list
    # Initialize comparison count
    count = 0
    mergeSort(A, 0, n)  # Call the mergeSort function with the input array
    print(*A, sep="" "")  # Print the sorted array
    print(count)  # Print the total number of comparisons
"
8967960,ALDS1_5_B,"cnt=0
def merge(A,B):
    global cnt
    sorted_list=[]

    sa=0
    sizeA=len(A)

    sb=0
    sizeB=len(B)

    while True:
        if sa>=sizeA:
            sorted_list.extend(B[sb:])
            cnt+=sizeB-sb
            break
        if sb>=sizeB:
            sorted_list.extend(A[sa:])
            cnt+=sizeA-sa
            break
        
        cnt+=1
        if A[sa]<B[sb]:
            sorted_list.append(A[sa])
            sa+=1
        else:
            sorted_list.append(B[sb])
            sb+=1
    
    return sorted_list

def mergeSort(A,left,right):
    if left+1<right:
        mid=(left+right)//2
        L=mergeSort(A,left,mid)
        R=mergeSort(A,mid,right)
        return merge(L,R)
    return [A[left]]

n=int(input())
s=list(map(int,input().split()))

print("" "".join([str(x) for x in mergeSort(s,0,n)]))
print(cnt)
"
9097233,ALDS1_5_B,"cnt = 0


def merge(A, left, mid, right):
    global cnt
    L = A[left:mid].copy()
    R = A[mid:right].copy()

    L.append(1e9)
    R.append(1e9)

    i = 0
    j = 0
    for k in range(left, right):
        if L[i] <= R[j]:
            cnt += 1
            A[k] = L[i]
            i += 1
        else:
            cnt += 1
            A[k] = R[j]
            j += 1


def mergeSort(A, left, right):
    if left+1 < right:
        mid = (left + right) // 2
        mergeSort(A, left, mid)
        mergeSort(A, mid, right)
        merge(A, left, mid, right)


n = int(input())
A = list(map(int, input().split()))

mergeSort(A, 0, n)

print(' '.join(str(num) for num in A))
print(cnt)

"
8979024,ALDS1_5_B,"n = int(input())
S = [int(i) for i in input().split()]
num = 0

def merge(S, left, mid, right):
    global num
    L = S[left:mid+1]
    R = S[mid+1:right+1]
    L.append(float(""inf""))
    R.append(float(""inf""))
    i = 0
    j = 0
    for k in range(left, right+1):
        num += 1
        if L[i] <= R[j]:
            S[k] = L[i]
            i = i + 1
        else:
            S[k] = R[j]
            j = j + 1

def merge_sort(S, left, right):
    if left >= right:
        return
    mid = (left + right)//2
    merge_sort(S, left, mid)
    merge_sort(S, mid+1, right)
    merge(S, left, mid, right)

merge_sort(S, 0, n-1)
print(*S)
print(num)
"
8539546,ALDS1_5_B,"debug = False
max_value = 1e9
global counts

def MergeSort(arr, left, right):
    global counts
    if left + 1 < right:
        mid = (left + right) // 2
        MergeSort(arr, left, mid)
        MergeSort(arr, mid, right)
        Merge(arr, left, mid, right)
    

def Merge(arr, left, mid, right):
    global counts
    if debug: print(left, mid, right)
    L = arr[left:mid]
    R = arr[mid:right]
    L.append(max_value)
    R.append(max_value)
    if debug:
        print(A)
        print(L)
        print(R)
    
    i, j = 0, 0
    for k in range(left, right):
        if L[i] <= R[j]:
            arr[k] = L[i]
            i += 1
            counts += 1
        else:
            arr[k] = R[j]
            j += 1
            counts += 1
        if debug:
            print(f""{counts}回目"")
            print(arr, L, R)

if __name__ == ""__main__"":        
    if debug:
        n = 10
        A = [random.randint(0, 100) for _ in range(n)]
    else:
        n = int(input())
        A = list(map(int, input().split()))
    counts = 0
    MergeSort(A, 0, len(A))
    print(*A, sep="" "")
    print(counts)
    # Merge(A, 0, int(len(A)/2), len(A))
"
8765601,ALDS1_5_B,"# aizu_ALDS1_5_B_MergeSort_a.py  

from collections import deque

def merge(A, l, m, r):
    global cnt
    
    L = deque(A[l:m])
    R = deque(A[m:r])
    L.append(float('inf'))
    R.append(float('inf'))
    
    for k in range(l,r):
        cnt += 1
        if L[0] <= R[0]:
            A[k] = L.popleft()
        else :
            A[k] = R.popleft()

def mergeSort(A, l, r):
    if l+1 < r:
        m = (l + r)//2
        mergeSort(A, l, m)
        mergeSort(A, m, r)
        merge(A, l, m, r)

n = int(input())
S = list( map(int,input().split()))

cnt = 0
mergeSort(S,0,n)

print(*S)
print(cnt)
"
8615628,ALDS1_5_B,"sum = 0
def merge(A, left, mid, right):
    global sum
    L = A[left:mid]+[2**31-1]
    R = A[mid:right]+[2**31-1]
    i = 0
    j = 0
    for k in range(left , right):
        sum += 1
        if(L[i] <= R[j]):
            A[k] = L[i]
            i += 1
        else:
            A[k] = R[j]
            j += 1
    
def mergeSort(A,left,right):
    if(left+1<right):
        mid = int((left + right) /2)
        mergeSort(A,left,mid)
        mergeSort(A,mid,right)
        merge(A,left,mid,right)

n = int(input())
S = list(map(int,input().strip().split()))
mergeSort(S,0,n)
for i in range(n-1):
    print(S[i],end=' ')
print(S[n-1])
print(sum)

"
8868647,ALDS1_5_B,"import math

def merge(A, left, mid, right):
    global count
    n1 = mid - left
    n2 = right - mid
    L = A[left:left+n1]
    R = A[mid:mid+n2]
    L.append(math.inf)
    R.append(math.inf)
    i = 0
    j = 0
    for k in range(left, right):
        if L[i] <= R[j]:
            A[k] = L[i]
            i += 1
            count += 1
        else:
            A[k] = R[j]
            j += 1
            count += 1

def mergeSort(A, left, right):
    if left+1 < right:
        mid = (left + right) // 2
        mergeSort(A, left, mid)
        mergeSort(A, mid, right)
        merge(A, left, mid, right)

n = int(input())
S = list(map(int, input().split()))
count = 0

mergeSort(S, 0, n)
for i in range(n):
    if i == n-1:
        print(S[i])
    else:
        print(S[i], end="" "")
print(count)

"
8494407,ALDS1_5_B,"n = int(input())
S = list(map(int,input().split()))
c = 0
def Merge(l: list, r: list) -> list:
    l.append(float(""inf""))
    r.append(float(""inf""))
    ans = []
    lc = 0
    rc = 0
    global c
    for i in range(len(r) + len(l) -2):
        c += 1
        if l[lc] <= r[rc]:
            ans.append(l[lc])
            lc += 1
        else:
            ans.append(r[rc])
            rc += 1
        #print(ans, l, r, lc, rc)
    return ans

def MergeSort(S):
    if len(S) == 1:
        return S
    l = S[:len(S)//2]
    r = S[len(S)//2:]
    l = MergeSort(l)
    r = MergeSort(r)
    return Merge(l, r)

print(*MergeSort(S))
print(c)

"
8427290,ALDS1_5_B,"count=0 #定义一个全局变量记录比较次数
def mergeSort(a,low,high):
    if low<high:
        mid=int((low+high)/2)
        mergeSort(a,low,mid)#分解数组
        mergeSort(a,mid+1,high)
        merge(a,low,high,mid)#合并数组

def merge(a,low,high,mid):
    global count #对全局变量的值进行改变时需要用global声明
    n1,n2=mid-low+1,high-mid
    l,r=a[low:mid+1],a[mid+1:high+1]
    i,j=0,0
    for k in range(low,high+1):
        if i<n1 and j<n2:
            count+=1
            if l[i]<=r[j]:
                a[k]=l[i]
                i+=1
            else:
                a[k]=r[j]
                j+=1
        else:
            break
    while i<n1:
        a[k]=l[i]
        k+=1
        i+=1
        count+=1
    while j<n2:
        a[k]=r[j]
        k+=1
        j+=1
        count+=1


# def merge(a,low,high,mid):
#     global count #对全局变量的值进行改变时需要用global声明
#     b=a[:] #若直接b=a，则会将a的地址赋给b，当改变a数组时b也会改变，因此不能直接赋值，需要用[:]将a中数组列出来再赋给b
#     i,j,k=low,mid+1,low
#     while(i<=mid and j<=high):
#         count+=1
#         if b[i]<=b[j]:#不断比较两个辅助数组
#             a[k]=b[i]
#             i+=1
#         else:
#             a[k]=b[j]
#             j+=1
#         k+=1
#     while i<=mid:#当有剩余元素没有参加比较时，将其依次赋值给a
#         count+=1
#         a[k]=b[i]
#         k+=1
#         i+=1
#     while j<=high:
#         count+=1
#         a[k]=b[j]
#         k+=1
#         j+=1

# # map()会根据提供的函数对指定序列做映射。
# b=input()#输入数组个数
# a = list(map(int, input("""").split()))#依次输入数组元素，将其分割后依次转换位int型
# # a=[8,5,9,2,6,3,7,1,10,4]
# mergeSort(a, 0, len(a)-1)
# # print(""排序后的数组为："", a)
# print(a)#输出排序后的数组
# print(count)#输出比较次数

n = int(input())
A = list(map(int, input().split()))
mergeSort(A, 0, n-1)
print(' '.join(str(a) for a in A))#转为字符串并以空格间隔
print(count)
"
8941458,ALDS1_5_B,"INF = 10**11
cnt = 0

def merge(A:list, mid:int, left:int, right:int):
    n1 = mid - left
    n2 = right - mid
    L = [0]*(n1+1)
    R = [0]*(n2+1)
    global cnt

    for i in range(n1):
        L[i] = A[left + i]
    for i in range(n2):
        R[i] = A[mid + i]
    
    L[n1] = INF
    R[n2] = INF
    i, j = 0, 0

    cnt += right-left
    for k in range(left, right):
        if L[i] <= R[j]:
            A[k] = L[i]
            i += 1
        else:
            A[k] = R[j]
            j += 1

def mergeSort(A:list, left:int, right:int):
    if left+1 < right:
        mid = (left + right) // 2
        mergeSort(A, left, mid)
        # print(""left-mid"", left, mid, A)
        mergeSort(A, mid, right)
        # print(""mid-right"", mid, right, A)
        merge(A, mid, left, right)
        # print(""merge"", A)

n = int(input())
A = list(map(int, input().split()))
mergeSort(A, 0, n)
print(*A)
print(cnt)
"
9138275,ALDS1_5_B,"import sys

n = int(input())
array = list(map(int, input().split()))


def merge(arr: list[int], left: int, mid: int, right: int):
    n1 = mid - left
    n2 = right - mid
    left_array: list[int] = []
    for l1 in range(0, n1):
        left_array.append(arr[l1 + left])
    right_array: list[int] = []
    for r1 in range(0, n2):
        right_array.append(arr[r1 + mid])
    left_array.append(sys.maxsize)
    right_array.append(sys.maxsize)

    l2 = 0
    r2 = 0
    for k in range(left, right):
        if left_array[l2] <= right_array[r2]:
            arr[k] = left_array[l2]
            l2 += 1
        else:
            arr[k] = right_array[r2]
            r2 += 1
    return l2 + r2


def merge_sort(arr: list[int], left: int, right: int):
    count = 0
    if left + 1 < right:
        mid = (left + right) // 2
        count += merge_sort(arr, left, mid)
        count += merge_sort(arr, mid, right)
        return merge(arr, left, mid, right) + count
    else:
        return 0


merge_count = merge_sort(array, 0, n)
print("" "".join(map(str, array)))
print(merge_count)

"
9029197,ALDS1_5_B,"n = int(input())
S = list(map(int,input().split()))
BIGNUM = 10000000000
cnt = 0

def merge(S,left,mid,right):
    global cnt
    n1 = mid - left
    n2 = right - mid
    L = []
    R = []
    for i in range(n1):
        L.append(S[left+i])
    for i in range(n2):
        R.append(S[mid+i])
    L.append(BIGNUM)
    R.append(BIGNUM)
    i = 0
    j = 0
    for k in range(left,right):
        if L[i] <= R[j]:
            S[k] = L[i]
            i += 1
        else:
            S[k] = R[j]
            j += 1
    cnt += i
    cnt += j

def mergesort(S,left,right):
    if left+1 < right:
        mid = (left+right)//2
        mergesort(S,left,mid)
        mergesort(S,mid,right)
        merge(S,left,mid,right)
        
        
mergesort(S,0,n)
print(*S)
print(cnt)
"
8692867,ALDS1_5_B,"import sys
input = sys.stdin.readline

MAX = 500000
SENTINEL = 2000000000

L = [None]*(MAX//2+2)
R = [None]*(MAX//2+2)
cnt = 0

def merge(A, n ,left, mid, right, cnt):
    n1 = mid - left
    n2 = right - mid
    for i in range(n1):
        L[i] = A[left + i]
    for i in range(n2):
        R[i] = A[mid + i]
    L[n1] = R[n2] = SENTINEL
    i, j = 0, 0
    for k in range(left, right):
        cnt += 1
        if L[i] <= R[j]:
            A[k] = L[i]
            i += 1
        else:
            A[k] = R[j]
            j += 1
    return cnt

def mergeSort(A, n, left, right, cnt):
    if left+1 < right:
        mid = (left + right)//2
        cnt = mergeSort(A, n, left, mid, cnt)
        cnt = mergeSort(A, n, mid, right, cnt)
        cnt = merge(A, n, left, mid, right, cnt)
    return cnt

n = int(input())

A = list(map(int, input().split()))

cnt = mergeSort(A, n, 0, n, cnt)

print(' '.join(map(str, A)))
print(cnt)
"
8535904,ALDS1_5_B,"#import sys

def merge(a, left, mid, right):
	global count
	nl, nr = mid - left, right - mid

	l, r = [0] * (nl + 1), [0] * (nr + 1)
	for i in range(nl):
		l[i] = a[left + i]
	for i in range(nr):
		r[i] = a[mid + i]
	l[-1] = r[-1] = 1_000_000_001	#sentinel

	lindex = rindex = 0
	for i in range(left, right):
		if l[lindex] < r[rindex]:
			a[i] = l[lindex]
			lindex += 1
		else:
			a[i] = r[rindex]
			rindex += 1
		count += 1

def merge_sort(a, left, right):
	if left + 1 < right:
		mid = (left + right) // 2
		merge_sort(a, left, mid)
		merge_sort(a, mid, right)
		merge(a, left, mid, right)

#sys.setrecursionlimit(100)
count = 0
n = int(input())
arr = list(map(int, input().split()))
merge_sort(arr, 0, n)
print(*arr)
print(count)
"
8770108,ALDS1_5_B,"INFTY = 10 ** 10

def merge(A, left, mid, right):
    global count
    n1 = mid - left
    n2 = right - mid
    L = [0] * (n1+1)
    R = [0] * (n2+1)
    for i in range(n1):
        L[i] = A[left+i]
    for i in range(n2):
        R[i] = A[mid+i]
    L[n1] = INFTY
    R[n2] = INFTY
    i = 0
    j = 0
    for k in range(left, right):
        count += 1
        if L[i] <= R[j]:
            A[k] = L[i]
            i += 1
        else:
            A[k] = R[j]
            j += 1
            
def merge_sort(A, left, right):
    if left+1 < right:
        mid = (left + right) // 2
        merge_sort(A, left, mid)
        merge_sort(A, mid, right)
        merge(A, left, mid, right)
        
N = int(input())
A = list(map(int, input().split()))
count = 0
merge_sort(A, 0, N)
print(*A)
print(count)
"
8633866,ALDS1_5_B,"INF = float(""inf"")
cnt = 0

def merge(al, left, mid, right):
    n1 = mid - left
    n2 = right - mid
    l = [0] * (n1 + 1)
    r = [0] * (n2 + 1)
    for i in range(n1):
        l[i] = al[left + i]
    for i in range(n2):
        r[i] = al[mid + i]
    l[n1] = INF
    r[n2] = INF
    i = j = 0
    global cnt
    for k in range(left, right):
        cnt += 1
        if l[i] <= r[j]:
            al[k] = l[i]
            i += 1
        else:
            al[k] = r[j]
            j += 1

def merge_sort(al, left, right):
    if left + 1 < right:
        mid = (left + right) // 2
        merge_sort(al, left, mid)
        merge_sort(al, mid, right)
        merge(al, left, mid, right)

n = int(input())
sl = list(map(int, input().split()))
merge_sort(sl, 0, n)

print(*sl)
print(cnt)

"
8563701,ALDS1_5_B,"INFTY = 10**9 + 1

count = 0


def merge(a: list, left: int, mid: int, right: int) -> list:
    global count
    n1 = mid - left
    n2 = right - mid

    l = [a[left + i] for i in range(n1)]
    r = [a[mid + i] for i in range(n2)]
    l.append(INFTY)
    r.append(INFTY)

    i = j = 0
    for k in range(left, right):
        if l[i] <= r[j]:
            a[k] = l[i]
            i = i + 1
        else:
            a[k] = r[j]
            j = j + 1
        count = count + 1

    return a


def merge_sort(a: list, left: int, right: int) -> list:
    if left + 1 < right:
        mid = (left + right) // 2
        a = merge_sort(a, left, mid)
        a = merge_sort(a, mid, right)
        a = merge(a, left, mid, right)
        return a
    else:
        return a


n = int(input())
s = list(map(int, input().split()))

res = merge_sort(s, 0, n)
print(*res)
print(count)

"
8704324,ALDS1_5_B,"infinity = float(""inf"")
ans = 0

def merge(A,left,mid,right):
    global ans
    n1 = mid - left
    n2 = right - mid
    L = [0] * (n1 + 1)
    R = [0] * (n2 + 1)

    for i in range(n1):
        L[i] = A[left + i]
    for i in range(n2):
        R[i] = A[mid + i]
    
    L[n1] = infinity
    R[n2] = infinity
    i = 0
    j = 0

    for k in range(left,right):
        ans += 1
        if L[i] <= R[j]:
            A[k] = L[i]
            i += 1
        else:
            A[k] = R[j]
            j += 1

def mergeSort(A,left,right):
    if left + 1 < right:
        mid = (left + right) // 2
        mergeSort(A,left,mid)
        mergeSort(A,mid,right)
        merge(A,left,mid,right)

n = int(input())
s = list(map(int,input().split()))

mergeSort(s,0,n)
print(*s)
print(ans)
"
8320096,ALDS1_5_B,"global count
def merge(A, left, mid, right):
    global count
    n1 = mid - left
    n2 = right - mid
    L = list(range(n1+1))
    R = list(range(n2+1))
    for i in set(range(n1)):
        L[i] = A[left + i]
    for i in set(range(n2)):
        R[i] = A[mid + i]
    L[n1] = 10**10
    R[n2] = 10**10
    i = 0
    j = 0
    for k in range(left, right):
        if L[i] <= R[j]:
            A[k] = L[i]
            i += 1
        else:
            A[k] = R[j]
            j += 1
    count += i + j

def mergeSort(A, left, right):
    if left+1 < right:
        mid = (left + right) // 2
        mergeSort(A, left, mid)
        mergeSort(A, mid, right)
        merge(A, left, mid, right)

n = int(input())
S = list(map(int, input().split()))
count = 0
mergeSort(S, 0, n)
print(*S)
print(count)
"
9057935,ALDS1_5_B,"compare_cnt = 0

def merge(S: list[int], left: int, mid: int, right: int) -> None:
    global compare_cnt
    
    left_S = S[left:mid+1]
    right_S = S[mid+1:right+1]
    
    i, j, k = 0, 0, left
    while i < len(left_S) and j < len(right_S):
        if left_S[i] <= right_S[j]:
            S[k] = left_S[i]
            i += 1
        else:
            S[k] = right_S[j]
            j += 1
        k += 1
        compare_cnt += 1

    while i < len(left_S):
        S[k] = left_S[i]
        i += 1
        k += 1
        compare_cnt += 1

    while j < len(right_S):
        S[k] = right_S[j]
        j += 1
        k += 1
        compare_cnt += 1

def merge_sort(S: list[int], left: int, right: int) -> list[int]:
    if left >= right:
        return S
    
    mid = (left+right) // 2
    merge_sort(S, left, mid)
    merge_sort(S, mid+1, right)

    merge(S, left, mid, right)

    return S

if __name__ == '__main__':
    n = int(input())
    S = list(map(int, input().split()))
    sorted_S = merge_sort(S, 0, n-1)
    print(*sorted_S)
    print(compare_cnt)

"
8686663,ALDS1_5_B,"import math

def merge(A, left, mid, right):
    global cnt
    n1 = mid - left
    n2 = right - mid
    L = [A[left + i] for i in range(n1)]
    R = [A[mid + i] for i in range(n2)]
    L.append(math.inf)
    R.append(math.inf)
    
    i = 0
    j = 0
    for k in range(left, right):
        if L[i] <= R[j]:
            A[k] = L[i]
            i += 1
        else:
            A[k] = R[j]
            j += 1
        cnt += 1
            
def mergeSort(A, left, right):
    if left + 1 < right:
        mid = (left + right) // 2
        mergeSort(A,left, mid)
        mergeSort(A, mid, right)
        merge(A,left, mid, right)
    return A
        
n = int(input())
A = list(map(int, input().split(' ')))

cnt = 0
B = mergeSort(A, 0, n)
print(' '.join(list(map(str, A))))
print(cnt)
"
8494471,ALDS1_5_B,"def merge(A, left, mid, right):
    global cnt
    n1 = mid - left
    n2 = right - mid
    L = [None] * (n1+1)
    R = [None] * (n2+1)
    
    for i in range(n1):
        L[i] = A[left + i]
        
    for i in range(n2):
        R[i] = A[mid + i]
    
    L[n1] = 9999999999999
    R[n2] = 9999999999999
    i = 0
    j = 0
    for k in range(left, right):
        cnt += 1
        if L[i] <= R[j]:
            A[k] = L[i]
            i += 1
        else:
            A[k] = R[j]
            j = j + 1

def mergeSort(A, left, right):
    if left + 1 < right:
        mid = (left + right)//2
        mergeSort(A, left, mid)
        mergeSort(A, mid, right)
        merge(A, left, mid, right)
        
cnt = 0
n = int(input())
s = input().split(' ')
for i in range(n):
    s[i] = int(s[i])

mergeSort(s, 0, n)

for i in range(n-1):
    print(s[i], end = "" "")
print(s[n - 1])
print(cnt)
"
9002583,ALDS1_5_B,"# Your code here!
def merge(A, left, mid, right):
    global count
    n1 = mid - left + 1
    n2 = right - mid
    L = [0] * n1
    R = [0] * n2
    for i in range(n1):
        L[i] = A[left + i]
    for i in range(n2):
        R[i] = A[mid + i + 1]
    L.append(float('inf'))  # 無限大を末尾に追加
    R.append(float('inf'))  # 無限大を末尾に追加
    i = 0
    j = 0
    for k in range(left, right + 1):
        count += 1
        if L[i] <= R[j]:
            A[k] = L[i]
            i += 1
        else:
            A[k] = R[j]
            j += 1


def mergeSort(A, left, right):
    global count
    if left < right:
        mid = (left + right) // 2
        mergeSort(A, left, mid)
        mergeSort(A, mid + 1, right)
        merge(A, left, mid, right)
    return A


count = 0
N = int(input())
L = list(map(int, input().split()))
sorted_L = mergeSort(L, 0, N - 1)
print(*sorted_L)
print(count)
"
8463951,ALDS1_5_B,"n = int(input())
a = list(map(int, input().split()))
inf = int(1e9+2525)

def merge(left, mid, right):

    cmp = 0
    n1 = mid - left
    n2 = right - mid
    l = [i for i in range(n1+1)]
    r = [i for i in range(n2+1)]

    for i in range(n1):
        l[i] = a[left + i]

    for i in range(n2):
        r[i] = a[mid + i]

    l[n1] = inf
    r[n2] = inf

    i = 0
    j = 0

    for k in range(left, right):
        cmp += 1
        if l[i] <= r[j]:
            a[k] = l[i]
            i += 1
        else:
            a[k] = r[j]
            j += 1

    return cmp

def mergesort(left, right):
    res = 0
    if left + 1 < right:
        mid = (left + right) // 2
        res += mergesort(left, mid)
        res += mergesort(mid, right)
        res += merge(left, mid, right)

    return res

ans = mergesort(0, n)
print(*a)
print(ans)
"
8869543,ALDS1_5_B,"n = int(input())
s = list(map(int,input().split()))

def merge(a,left,mid,right):
    n1 = mid-left
    n2 = right-mid
    l = [0 for i in range(n1+1)]
    r = [0 for i in range(n2+1)]
    for i in range(n1):
        l[i]=a[left+i]
    for i in range(n2):
        r[i]=a[mid+i]
    l[n1]=float('inf')
    r[n2]=float('inf')
    i = 0
    j = 0
    cnt=0
    for k in range(left,right):
        if l[i]<=r[j]:
            a[k]=l[i]
            i+=1
        else:
            a[k]=r[j]
            j+=1
        cnt+=1
    return a,cnt

def mergesort(a,left,right):
    cnt=0
    if left+1<right:
        mid = (left+right)//2
        a, lcnt = mergesort(a,left,mid)
        a, rcnt = mergesort(a,mid,right)
        a, mcnt = merge(a,left,mid,right)
        cnt=lcnt+rcnt+mcnt
    return a,cnt
a,b = mergesort(s,0,n)
#print(mergesort(s,0,n))
print(*a)
print(b)
"
8706180,ALDS1_5_B,"def merge(left,mid,right):
    global cnt
    n1 = mid - left
    n2 = right - mid
    L = []
    R = []
    for i in range(n1):
       L.append(S[left+i])
    
    for j in range(n2):
       R.append(S[mid + j])
    L.append(10000000000000)
    R.append(10000000000000)
    i=0
    j=0
    for k in range(left,right):
       cnt += 1
       if L[i] <= R[j]:
          S[k] = L[i]
          i += 1
       else :
          S[k] = R[j]
          j += 1

def mergeSort(left,right):
   if left+1 < right:
    mid = (left + right)//2
    mergeSort(left, mid)
    mergeSort(mid, right)
    merge(left, mid, right)




n = int(input())
S = list(map(int,input().split()))
cnt = 0

mergeSort(0,n)

for i in range(n):
   if i == n-1:
      print(S[i])
   else :
    print(S[i],end="" "")
print(cnt)
"
8491974,ALDS1_5_B,"# Merge Sort
def merge(A, left, mid, right):
  global cnt
  n1 = mid - left
  n2 = right - mid
  L = [None] * (n1 + 1)
  R = [None] * (n2 + 1)
  for i in range(n1):
    L[i] = A[left + i]
  for i in range(n2):
    R[i] = A[mid + i]
  L[n1] = 10000000000000
  R[n2] = 10000000000000
  i = 0
  j = 0
  for k in range(left, right):
    cnt += 1
    if L[i] <= R[j]:
      A[k] = L[i]
      i += 1
    else:
      A[k] = R[j]
      j += 1
    
def mergesort(A, left, right):
  left = int(left)
  right = int(right)
  if left + 1 < right:
    mid = (left + right) // 2
    mergesort(A, left, mid)
    mergesort(A, mid, right)
    merge(A, left, mid, right)
    
cnt = 0
n = int(input())
S = input().split(' ')
for i in range(n):
  S[i] = int(S[i])

mergesort(S, 0, n)

for i in range(n-1):
  print(S[i], end = ' ')
print(S[n-1])
print(cnt)
"
9144911,ALDS1_5_B,"n = int(input())
S = list(map(int, input().split("" "")))

counter = 0
def merge(A, left, mid, right):
    global counter
    n1 = mid - left;
    n2 = right - mid;
    L = [None for _ in range(n1+1)]
    R = [None for _ in range(n2+1)]
    for i in range(n1):
        L[i] = A[left + i]
    for i in range(n2):
        R[i] = A[mid + i]
    L[n1] = 1000000000000
    R[n2] = 1000000000000
    i = 0
    j = 0
    for k in range(left, right):
        counter += 1
        if L[i] <= R[j]:
            A[k] = L[i]
            i += 1
        else:
            A[k] = R[j]
            j += 1

def mergeSort(A, left, right):
    if left+1 < right:
        mid = (left + right)//2;
        mergeSort(A, left, mid)
        mergeSort(A, mid, right)
        merge(A, left, mid, right)

mergeSort(S, 0, n)
print(*S, sep="" "")
print(counter)
"
8609408,ALDS1_5_B,"global cnt
cnt = 0


def merge(A, left, mid, right):
    global cnt
    
    n1 = mid - left
    n2 = right - mid
    L = []
    R = []
    for i in range(n1):
        L.append(A[left + i])
    for i in range(n2):
        R.append(A[mid + i])
    i = 0
    j = 0
    k = left  # Initialize the index for the merged array
    while i < n1 and j < n2:
        if L[i] <= R[j]:
            cnt += 1
            A[k] = L[i]
            i = i + 1
        else:
            cnt += 1
            A[k] = R[j]
            j = j + 1
        k = k + 1

    # Copy the remaining elements of L, if any
    while i < n1:
        cnt += 1
        A[k] = L[i]
        i = i + 1
        k = k + 1

    # Copy the remaining elements of R, if any
    while j < n2:
        cnt += 1
        A[k] = R[j]
        j = j + 1
        k = k + 1

    return A
            
def mergeSort(A, left, right):

    if left+1 < right:
        mid = (left + right)//2
        mergeSort(A, left, mid)
        mergeSort(A, mid, right)
        merge(A, left, mid, right)

n = int(input())
A = list(map(int, input().split()))

left = 0
right = n

mergeSort(A, left, right)
for i in range(n):
    if i != n-1:
        print(str(A[i])+"" "",end = """")
    else:
        print(A[i])
print(cnt)
"
9059591,ALDS1_5_B,"import math
def merge(A, left, mid, right):
    n1 = mid - left
    n2 = right - mid
    # L[0...n1], R[0...n2] を生成
    L = [i for i in range(n1 + 1)]
    R = [i for i in range(n2 + 1)]
    for i in range(n1):
        L[i] = A[left + i]
    for i in range(n2):
        R[i] = A[mid + i]
    L[n1] = math.inf
    R[n2] = math.inf
    i = 0
    j = 0
    global cnt
    for k in range(left, right):
        cnt += 1
        if L[i] <= R[j]:
            A[k] = L[i]
            i += 1
        else:
            A[k] = R[j]
            j += 1
    
def mergeSort(A, left, right):
    if left + 1 < right:
        mid = (left + right) // 2
        mergeSort(A, left, mid)
        mergeSort(A, mid, right)
        merge(A, left, mid, right)

n = int(input())
s = list(map(int, input().split()))
cnt = 0
mergeSort(s,0,n)
print(f""{' '.join(map(str, s))}\n{cnt}"")
"
8730464,ALDS1_5_B,"def merge(A,l,m,r):
    global ct
    n1 = m-l
    n2 = r-m
    L = [i for i in range(n1+1)]
    R = [i for i in range(n2+1)] 
    for i in range(n1):
        L[i] = A[l+i]
    for i in range(n2):
        R[i] = A[m+i]
    L[-1] = R[-1] = float('inf')
    i = j = 0
    for k in range (l,r):
        if L[i] <= R[j]:
            A[k] = L[i]
            i = i+1
        else: 
            A[k] = R[j]
            j = j+1
        ct += 1
        
def mergeSort(A,l,r):
    if l+1 < r:
        m = (l+r)//2
        mergeSort(A,l,m)
        mergeSort(A,m,r)
        merge(A,l,m,r)

n = int(input())
*s, = map(int, input().split())
ct = 0
mergeSort(s,0,n)
print(*s)
print(ct)
"
8931308,ALDS1_5_B,"k=0
def f(index_left,index_right,lis):  #右が左以上であればTrueを返す関数
    global k 
    k+=1
    if lis[index_right]>=lis[index_left]:
        return True
    return False

def MergeSort(lis,left=0,right=-1):
    if right==-1:right=len(lis)
    if right-left==1:
        return True
    mid=(left+right)//2
    MergeSort(lis,left,mid)
    MergeSort(lis,mid,right)

    exlis=[]
    for i in range(left,mid):
        exlis.append(lis[i])
    for i in reversed(range(mid,right)):
        exlis.append(lis[i])
    
    index_left=0
    index_right=len(exlis)-1
    for i in range(left,right):
        if f(index_left,index_right,exlis): #右が左以上であればTrueを返す関数
            lis[i]=exlis[index_left]
            index_left+=1
        else:
            lis[i]=exlis[index_right]
            index_right-=1

N=int(input())
A=list(map(int,input().split()))
MergeSort(A)

print(*A)
print(k)
"
8275990,ALDS1_5_B,"x = 0

def ShowList(l):
    for i in range(len(l)):
        if i < len(l)-1:
            print(l[i],end="" "")
        else:
            print(l[i])

def merge(A,left,mid,right):
    n1 = mid -left
    n2 = right - mid
    L = [0 for i in range(n1 + 1)]
    R = [0 for i in range(n2 + 1)]
    for i in range(n1):
        L[i] = A[left + i]
    for i in range(n2):
        R[i] = A[mid + i]

    L[n1] = float(""infinity"")
    R[n2] = float(""infinity"")
    i = 0
    j = 0
    for k in range(left,right):
        global x
        x += 1
        if L[i] <= R[j]:
            A[k] = L[i]
            i += 1
        else:
            A[k] = R[j]
            j += 1

def mergeSort(A,left,right):
    if left+1 < right:
        mid = (left + right)//2
        mergeSort(A, left, mid)
        mergeSort(A, mid, right)
        merge(A, left, mid, right)

n = int(input())
A = list(map(int,input().split()))

L = 0
R = n

mergeSort(A,L,R)
ShowList(A)
print(x)
"
3003025,ALDS1_5_B,"n = int(input())
A = list(map(int, input().split()))
count = 0


def merge(A, l, m, r):
    L = A[l:m] + [10 ** 9 + 1]
    R = A[m:r] + [10 ** 9 + 1]
    i, j = 0, 0
    for k in range(l, r):
        if L[i] <= R[j]:
            A[k] = L[i]
            i += 1
        else:
            A[k] = R[j]
            j += 1
    global count
    count += r - l


def mergeSort(A, l, r):
    if r - l > 1:
        m = (l + r) // 2
        mergeSort(A, l, m)
        mergeSort(A, m, r)
        merge(A, l, m, r)


mergeSort(A, 0, n)
print("" "".join(list(map(str, A))))
print(count)

"
5329442,ALDS1_5_B,"comp = 0
def m(L, R):
    global comp
    j = 0
    for l in L:
        while j < len(R) and R[j] < l:
            yield R[j]
            j += 1
        yield l
    while j < len(R):
        yield R[j]
        j += 1
    comp += len(L) + len(R)
def merge(A):
    global comp
    if len(A) == 1:
        return A
    if len(A) == 2:
        comp += 2
        a, b = A
        return A if a < b else (b, a)
    mid = len(A) // 2
    A[:] = m(merge(A[:mid]), merge(A[mid:]))
    return A

n, *A = map(int, open(0).read().split())
B = merge(A)
print(*B)
print(comp)
"
6706030,ALDS1_5_B,"comp = 0
def m(L, R):
    global comp
    j = 0
    for l in L:
        while j < len(R) and R[j] < l:
            yield R[j]
            j += 1
        yield l
    while j < len(R):
        yield R[j]
        j += 1
    comp += len(L) + len(R)
def merge(A):
    global comp
    if len(A) == 1:
        return A
    if len(A) == 2:
        comp += 2
        a, b = A
        return A if a < b else (b, a)
    mid = len(A) // 2
    A[:] = m(merge(A[:mid]), merge(A[mid:]))
    return A

n, *A = map(int, open(0).read().split())
B = merge(A)
print(*B)
print(comp)

"
3351040,ALDS1_5_B,"def merge(A, left, mid, right):
    L = A[left:mid] + [2147483648]
    R = A[mid:right] + [2147483648]
    i = 0
    j = 0
    for k in range(left, right):
        if L[i] <= R[j]:
            A[k] = L[i]
            i += 1
        else:
            A[k] = R[j]
            j += 1
    global c
    c += right - left


def mergeSort(A, left, right):
    if left + 1 < right:
        mid = (left + right) // 2
        mergeSort(A, left, mid)
        mergeSort(A, mid, right)
        merge(A, left, mid, right)


c = 0
n = int(input())
A = list(map(int, input().split()))
mergeSort(A, 0, n)
print("" "".join(map(str, A)))
print(c)

"
6095995,ALDS1_5_B,"import sys
sys.setrecursionlimit(10**6)

def Merge(L, R):
    global ans
    j = 0
    for l in L:
        while j < len(R) and R[j] < l:
            yield R[j]
            j += 1
        yield l
    while j < len(R):
        yield R[j]
        j += 1
    ans += len(L) + len(R)

def MergeSort(A):
    global ans
    if len(A) == 1:
        return A
    elif len(A) == 2:
        ans += 2
        a, b = A
        return A if a < b else (b, a)
    mid = len(A) // 2
    A[:] = Merge(MergeSort(A[:mid]), MergeSort(A[mid:]))
    return A

ans = 0
n = int(input())
A = list(map(int, input().split()))
ANS = MergeSort(A)
print(*ANS)
print(ans)

"
7606833,ALDS1_5_B,"comp = 0
def m(L, R):
    global comp
    j = 0
    for l in L:
        while j < len(R) and R[j] < l:
            yield R[j]
            j += 1
        yield l
    while j < len(R):
        yield R[j]
        j += 1
    comp += len(L) + len(R)
def merge(A):
    global comp
    if len(A) == 1:
        return A
    if len(A) == 2:
        comp += 2
        a, b = A
        return A if a < b else (b, a)
    mid = len(A) // 2
    A[:] = m(merge(A[:mid]), merge(A[mid:]))
    return A

n, *A = map(int, open(0).read().split())
B = merge(A)
print(*B)
print(comp)
"
2727567,ALDS1_5_B,"def m(L,R):
 T=[]
 for l in L[::-1]:
  while R and R[-1]>l:T+=[R.pop()]
  T+=[l]
 return R+T[::-1]
def d(A):
 l=len(A);global c;c+=l
 s=l//2;return m(d(A[:s]),d(A[s:]))if l>1 else A
def s():
 print(*d(list(map(int,input().split()))))
 print(c)
if'__main__'==__name__:c=-int(input());s()
"
5988261,ALDS1_5_B,"
value = 0

def join(Left, Right):
    global value
    m = 0
    
    for n in Left:
        while m < len(Right) and Right[m] < n:
            yield Right[m]
            m += 1
        yield n
    
    while m < len(Right):
        yield Right[m]
        m += 1
    
    value += len(Left) + len(Right)
    
    
def merge(A):
    global value
    
    if len(A) == 1:
        return A
        
    elif len(A) == 2:
        value += 2
        a, b = A
        if a < b:
            return A
        else:
            return (b, a)
        
    middle = len(A) // 2
    A[:] = join(merge(A[:middle]), merge(A[middle:]))
    return A
    
    

n, *A = map(int, open(0).read().split())
SortedArray = merge(A)
print(*SortedArray)
print(value)

"
7537392,ALDS1_5_B,"import sys
sys.setrecursionlimit(10**6)

def Merge(L, R):
    global ans
    j = 0
    for l in L:
        while j < len(R) and R[j] < l:
            yield R[j]
            j += 1
        yield l
    while j < len(R):
        yield R[j]
        j += 1
    ans += len(L) + len(R)

def MergeSort(A):
    global ans
    if len(A) == 1:
        return A
    elif len(A) == 2:
        ans += 2
        a, b = A
        return A if a < b else (b, a)
    mid = len(A) // 2
    A[:] = Merge(MergeSort(A[:mid]), MergeSort(A[mid:]))
    return A

ans = 0
n = int(input())
A = list(map(int, input().split()))
ANS = MergeSort(A)
print(*ANS)
print(ans)
"
4016084,ALDS1_5_B,"def m(L,R):
 T=[]
 for l in L[::-1]:
  while R and R[-1]>l:T+=[R.pop()]
  T+=[l]
 return R+T[::-1]
def d(A):
 l=len(A);global c;c+=l
 s=l//2;return m(d(A[:s]),d(A[s:]))if l>1 else A
def s():
 print(*d(list(map(int,input().split()))))
 print(c)
if'__main__'==__name__:c=-int(input());s()

"
8309823,ALDS1_5_C,"import math

def vertices(n, i, p, q):
    if n == 0:
        return [(q)]
    a = 100 / 3 ** (i + 1)
    s = ((2 * p[0] + q[0]) / 3, (2 * p[1] + q[1]) / 3)
    t = ((p[0] + 2 * q[0]) / 3, (p[1] + 2 * q[1]) / 3)
    if p[0] < q[0]:
        if p[1] < q[1]:
            u = (t[0] - a, t[1])
        elif p[1] == q[1]:
            u = ((s[0] + t[0]) / 2, s[1] + a * math.sqrt(3) / 2)
        else:
            u = (s[0] + a, s[1])
    else:
        if p[1] < q[1]:
            u = (s[0] - a, s[1])
        elif p[1] == q[1]:
            u = ((s[0] + t[0]) / 2, s[1] - a * math.sqrt(3) / 2)
        else:
            u = (t[0] + a, t[1])
    if i == n - 1:
        return [s, u, t, q]
    return vertices(n, i + 1, p, s) + vertices(n, i + 1, s, u) + vertices(n, i + 1, u, t) + vertices(n, i + 1, t, q)

n = int(input())
print(""{:.8f} {:.8f}"".format(0, 0))
for v in vertices(n, 0, (0, 0), (100, 0)):
    print(""{:.8f} {:.8f}"".format(v[0], v[1]))
"
8322085,ALDS1_5_C,"def kock(n, p1, p2):
    cos = 1/2
    sin = (3**(1/2))/2
    if n == 0:
        return
    s = [(2*p1[0] + 1*p2[0])/3, (2*p1[1] + 1*p2[1])/3]
    t = [(1*p1[0] + 2*p2[0])/3, (1*p1[1] + 2*p2[1])/3]
    u = [(t[0]-s[0])*cos - (t[1]-s[1])*sin + s[0], (t[0]-s[0])*sin + (t[1]-s[1])*cos + s[1]]
    kock(n-1, p1, s)
    print(f'{s[0]:.8f}', f'{s[1]:.8f}')
    kock(n-1, s, u)
    print(f'{u[0]:.8f}', f'{u[1]:.8f}')
    kock(n-1, u, t)
    print(f'{t[0]:.8f}', f'{t[1]:.8f}')
    kock(n-1, t, p2)

n = int(input())
p1 = [0, 0]
p2 = [100, 0]
print(f'{p1[0]:.8f}', f'{p1[1]:.8f}')
kock(n, p1, p2)
print(f'{p2[0]:.8f}', f'{p2[1]:.8f}')
"
8412398,ALDS1_5_C,"from math import sqrt
q3 = sqrt(3)
fmt = ""%.8f %.8f""
def koch(x0, y0, x1, y1, c):
    if c == n:
        return (fmt % (x0, y0),)
    xp = (x0*2 + x1) / 3
    yp = (y0*2 + y1) / 3

    xq = (x0 + x1*2) / 3
    yq = (y0 + y1*2) / 3

    dx = (x1 - x0) / 6
    dy = (y1 - y0) / 6

    xr = xp + (dx - dy * q3)
    yr = yp + (dx * q3 + dy)

    return koch(x0, y0, xp, yp, c+1) + koch(xp, yp, xr, yr, c+1) + koch(xr, yr, xq, yq, c+1) + koch(xq, yq, x1, y1, c+1)
n = int(input())
print(*koch(0, 0, 100, 0, 0)+(fmt % (100, 0),), sep='\n')
"
8444165,ALDS1_5_C,"def koch_snowflake(x1, y1, x2, y2, depth):
    if depth == 0:
        print(f""{x1:.8f} {y1:.8f}"")
    else:
        # 計算中点座標
        x3 = (2 * x1 + x2) / 3
        y3 = (2 * y1 + y2) / 3
        x4 = (x1 + 2 * x2) / 3
        y4 = (y1 + 2 * y2) / 3
        # 頂点Pの座標
        x = (x3 + x4) / 2 - ((y4 - y3) * (3 ** 0.5) / 2)
        y = (y3 + y4) / 2 + ((x4 - x3) * (3 ** 0.5) / 2)
        
        # 再帰的に各部分を描画
        koch_snowflake(x1, y1, x3, y3, depth - 1)
        koch_snowflake(x3, y3, x, y, depth - 1)
        koch_snowflake(x, y, x4, y4, depth - 1)
        koch_snowflake(x4, y4, x2, y2, depth - 1)

# コッホ曲線の開始点と終了点
x1, y1 = 0, 0
x2, y2 = 100, 0

# 再帰の深さ n を入力として受け取る
n = int(input())

# コッホ曲線を描画
koch_snowflake(x1, y1, x2, y2, n)

print(f""{x2:.8f} {y2:.8f}"")

"
8503412,ALDS1_5_C,"import math

def koch(n, p1_x, p1_y, p2_x, p2_y):

    if n == 0:
        return
    # p1, p2から三角形の頂点s, t, uを求める
    # ベクトル演算で線分（p1,p2）を3等分する
    # s = p1 + 1/3*(p2 - p1)
    # t = p1 + 2/3*(p2 - p1) 
    s_x = (2 * p1_x + p2_x) / 3
    s_y = (2 * p1_y + p2_y) / 3
    t_x = (p1_x + 2 * p2_x) / 3
    t_y = (p1_y + 2 * p2_y) / 3

    # 点uは、点sを起点として点tを反時計回りに60度回転した位置である
    u_x = (t_x - s_x) * math.cos(math.pi/3) - (t_y - s_y) * math.sin(math.pi/3) + s_x
    u_y = (t_x - s_x) * math.sin(math.pi/3) + (t_y - s_y) * math.cos(math.pi/3) + s_y

    koch(n-1, p1_x, p1_y, s_x, s_y)
    print('{:.08f} {:.08f}'.format(s_x, s_y))
    koch(n-1, s_x, s_y, u_x, u_y)
    print('{:.08f} {:.08f}'.format(u_x, u_y))
    koch(n-1, u_x, u_y, t_x, t_y)
    print('{:.08f} {:.08f}'.format(t_x, t_y))
    koch(n-1, t_x, t_y, p2_x, p2_y)
    
    return


def main():
    p1_x, p1_y = 0.0, 0.0
    p2_x, p2_y = 100.0, 0.0
    n = int(input())
    
    print('{:.08f} {:.08f}'.format(p1_x, p1_y))
    koch(n, p1_x, p1_y, p2_x, p2_y)
    print('{:.08f} {:.08f}'.format(p2_x, p2_y))

if __name__ == ""__main__"":
    main()
    
"
8539713,ALDS1_5_C,"import math

def kock(n, p1, p2):
    
    if n == 0:
        print(""{:.8f} {:.8f}"".format(*p1))
    else:
        s = ((p1[0]*2 + p2[0]*1) / 3, (p1[1]*2 + p2[1]*1) / 3)
        t = ((p1[0]*1 + p2[0]*2) / 3, (p1[1]*1 + p2[1]*2) / 3)
        u = ((t[0] - s[0])*math.cos(math.pi/3) - (t[1] - s[1])*math.sin(math.pi/3) + s[0], 
             (t[0] - s[0])*math.sin(math.pi/3) + (t[1] - s[1])*math.cos(math.pi/3) + s[1])
        kock(n-1, p1, s)
        kock(n-1, s, u)
        kock(n-1, u, t)
        kock(n-1, t, p2)
        
n = int(input())
p1 = (0, 0)
p2 = (100.0, 0)
kock(n, p1, p2)
print(""{:.8f} {:.8f}"".format(*p2))
"
8620925,ALDS1_5_C,"import math
n = int(input())
p1, p2 = [0,0], [100,0]
def koch(n, p1, p2):
    if n == 0:
        return
    # print('%.5f' %p1[0],"" "",'%.5f' %p1[1])
    s = [(2 * p1[0] + p2[0]) / 3, (2 * p1[1] + p2[1]) / 3]
    t = [(p1[0] + 2 * p2[0]) / 3, (p1[1] + 2 * p2[1]) / 3]
    
    u = [(t[0] - s[0]) * math.cos(math.pi / 3) - (t[1] - s[1]) * math.sin(math.pi / 3) + s[0], (t[0] - s[0]) * math.sin(math.pi / 3) + (t[1] - s[1]) * math.cos(math.pi / 3) + s[1]]
    
    koch(n-1, p1, s)
    print('%.8f' %s[0],"" "",'%.8f' %s[1])
    koch(n-1, s, u)
    print('%.8f' %u[0],"" "",'%.8f' %u[1])
    koch(n-1, u, t)
    print('%.8f' %t[0],"" "",'%.8f' %t[1])
    koch(n-1, t, p2)
    # print('%.8f' %p2[0],"" "",'%.8f' %p2[1])
print('%.8f' %p1[0],"" "",'%.8f' %p1[1])
koch(n, p1, p2)
print('%.8f' %p2[0],"" "",'%.8f' %p2[1])
"
9030627,ALDS1_5_C,"import math

n = int(input())
p1 = (0,0)
p2 = (100,0)

def koch(n,p1,p2):
    if n == 0:
        return
    
    sin60 = math.sin(math.radians(60))
    cos60 = math.cos(math.radians(60))
    p1x,p1y = p1
    p2x,p2y = p2
    
    sx = (2*p1x+p2x)/3
    sy = (2*p1y+p2y)/3
    tx = (p1x+2*p2x)/3
    ty = (p1y+2*p2y)/3
    ux = (tx-sx)*cos60-(ty-sy)*sin60+sx
    uy = (tx-sx)*sin60+(ty-sy)*cos60+sy
    
    s = (sx,sy)
    u = (ux,uy)
    t = (tx,ty)
    
    koch(n-1,p1,s)
    print(""{:.08f} {:.08f}"".format(*s))
    koch(n-1,s,u)
    print(""{:.08f} {:.08f}"".format(*u))
    koch(n-1,u,t)
    print(""{:.08f} {:.08f}"".format(*t))
    koch(n-1,t,p2)

print(""{:.08f} {:.08f}"".format(*p1))
koch(n,p1,p2)
print(""{:.08f} {:.08f}"".format(*p2))
"
8417092,ALDS1_5_C,"from math import radians, cos, sin

def cs(a): return enumerate([cos(a), sin(a)])

n = int(input())
z = [[0, 0, 0], [100, 0, 0]]
l = 100 / 3

for x in range(n):
    b = None
    for i, a in list(enumerate(z, 1))[::-1]:
        if b:
            c = [(b[j] - a[j]) / 3 for j in range(2)]
            z.insert(i, [a[j] + c[j] * 2     for j    in range(2)]               + [a[2]     ])
            z.insert(i, [a[j] + c[j] + l * m for j, m in cs(radians(a[2] + 60))] + [a[2] - 60])
            z.insert(i, [a[j] + c[j]         for j    in range(2)]               + [a[2] + 60])
        b = a
    l /= 3

for i in z: print(*i[:2])
"
8463981,ALDS1_5_C,"import math
n = int(input())
def solve(depth, l, r):
    if depth == 0: return
    x1, y1 = l
    x2, y2 = r
    s = (x1 +  (x2-x1)/3, y1 +  (y2-y1)/3)
    t = (x1 +2*(x2-x1)/3, y1 +2*(y2-y1)/3)

    u = (s[0] + (x2-x1)/3 * math.cos(math.radians(60)) - (y2-y1)/3 * math.sin(math.radians(60)),\
        (s[1] + (x2-x1)/3 * math.sin(math.radians(60)) + (y2-y1)/3 * math.cos(math.radians(60))))

    solve(depth-1, l, s)
    print(*s)
    solve(depth-1, s, u)
    print(*u)
    solve(depth-1, u, t)
    print(*t)
    solve(depth-1, t, r)

    return

print(0, 0)
solve(n, (0, 0), (100, 0))
print(100, 0)
"
8518013,ALDS1_5_C,"import math

def koch(n, p1, p2):
    if n == 0:
        return

    sx = (2 * p1[0] + 1 * p2[0]) / 3
    sy = (2 * p1[1] + 1 * p2[1]) / 3
    tx = (1 * p1[0] + 2 * p2[0]) / 3
    ty = (1 * p1[1] + 2 * p2[1]) / 3

    theta = math.radians(60)
    ux = (tx - sx) * math.cos(theta) - (ty - sy) * math.sin(theta) + sx
    uy = (tx - sx) * math.sin(theta) + (ty - sy) * math.cos(theta) + sy

    koch(n - 1, p1, [sx, sy])
    print(f""{sx} {sy}"")
    koch(n - 1, [sx, sy], [ux, uy])
    print(f""{ux} {uy}"")
    koch(n - 1, [ux, uy], [tx, ty])
    print(f""{tx} {ty}"")
    koch(n - 1, [tx, ty], p2)

n = int(input())
print(""0 0"")
koch(n, [0, 0], [100, 0])
print(""100 0"")

"
8563681,ALDS1_5_C,"import math


class Point:
    def __init__(self, x: float, y: float) -> None:
        self.x = x
        self.y = y

    def __str__(self) -> str:
        return f""{self.x} {self.y}""


def koch(depth: int, p1: Point, p2: Point) -> None:
    if depth == 0:
        return

    s = Point(p1.x * 2 / 3 + p2.x / 3, p1.y * 2 / 3 + p2.y / 3)
    t = Point(p1.x / 3 + p2.x * 2 / 3, p1.y / 3 + p2.y * 2 / 3)
    u = Point(
        s.x + (-s.x + t.x) / 2 - (-s.y + t.y) * math.sqrt(3) / 2, s.y + (-s.x + t.x) * math.sqrt(3) / 2 + (-s.y + t.y) / 2
    )
    koch(depth - 1, p1, s)
    print(s)
    koch(depth - 1, s, u)
    print(u)
    koch(depth - 1, u, t)
    print(t)
    koch(depth - 1, t, p2)


n = int(input())
p1 = Point(0.0, 0.0)
p2 = Point(100.0, 0.0)
print(p1)
koch(n, p1, p2)
print(p2)

"
8689540,ALDS1_5_C,"import math

n = int(input())

def kock(n, p1, p2):
    if n == 0:
        return
    
    sx = (2 * p1[0] + 1 * p2[0]) / 3
    sy = (2 * p1[1] + 1 * p2[1]) / 3
    tx = (1 * p1[0] + 2 * p2[0]) / 3
    ty = (1 * p1[1] + 2 * p2[1]) / 3
    ux = (tx - sx) * math.cos(math.radians(60)) - (ty - sy) * math.sin(math.radians(60)) + sx
    uy = (tx - sx) * math.sin(math.radians(60)) + (ty - sy) * math.cos(math.radians(60)) + sy
    s = [sx, sy]
    t = [tx, ty]
    u = [ux, uy]
    
    kock(n - 1, p1, s)
    print(' '.join(list(map(str, s))))
    kock(n - 1, s, u)
    print(' '.join(list(map(str, u))))
    kock(n - 1, u, t)
    print(' '.join(list(map(str, t))))
    kock(n - 1, t, p2)
    
p1 = [0, 0]
p2 = [100, 0]

print(' '.join(list(map(str, p1))))
kock(n, p1, p2)
print(' '.join(list(map(str, p2))))
"
8704497,ALDS1_5_C,"import math

def rot60(s, t):
    v = t - s
    a = 1/2 + complex(0,(math.sqrt(3)/2))
    return v * a + s

def pr(p):
    x = p.real
    y = p.imag
    print('%.10f %.10f'%(x, y))

def dfs(p1, p2, n):
    if n == 0:
        return
    

    s = (p2 - p1) * (1/3) + p1
    t = (p2 - p1) * (2/3) + p1
    u = rot60(s, t)
    dfs(p1, s, n - 1)
    pr(s)
    dfs(s, u, n - 1)
    pr(u)
    dfs(u, t, n - 1)
    pr(t)
    dfs(t, p2, n -1)
    
n = int(input())
s = (0 + 0j)
t = (100 + 0j)
pr(s)
dfs(s, t, n) 
pr(t)


"
8731971,ALDS1_5_C,"from math import sin,cos,radians
r = radians(60)

def kock(n,p1,p2):
    if n == 0:
        return
    s,t = [[((2-j)*p1[i]+(1+j)*p2[i])/3 for i in range(2)] for j in range(2)]
    u = [(t[0]-s[0])*cos(r)-(t[1]-s[1])*sin(r)+s[0], (t[0]-s[0])*sin(r)+(t[1]-s[1])*cos(r)+s[1]]
    kock(n-1, p1, s)
    print(f'{s[0]:.8f} {s[1]:.8f}')
    kock(n-1, s, u)
    print(f'{u[0]:.8f} {u[1]:.8f}')
    kock(n-1, u, t)
    print(f'{t[0]:.8f} {t[1]:.8f}')
    kock(n-1, t, p2)
    
print('0.00000000 0.00000000')
kock(int(input()), [0,0], [100,0])
print('100.00000000 0.00000000')
"
8763106,ALDS1_5_C,"import math
def koch(p1,p2,n):
    if(n==0):
        return
    s=[(2*p1[0]+p2[0])/3,(2*p1[1]+p2[1])/3]
    t=[(p1[0]+2*p2[0])/3,(p1[1]+2*p2[1])/3]
    u=[(t[0]-s[0])*math.cos(math.pi/3)-(t[1]-s[1])*math.sin(math.pi/3)+s[0],
       (t[0]-s[0])*math.sin(math.pi/3)+(t[1]-s[1])*math.cos(math.pi/3)+s[1]]
    
    koch(p1,s,n-1)
    print(f'{s[0]} {s[1]}')
    koch(s,u,n-1)
    print(f'{u[0]} {u[1]}')
    koch(u,t,n-1)
    print(f'{t[0]} {t[1]}')
    koch(t,p2,n-1)

n=int(input())
ps=[0,0]
pe=[100,0]
print(f'{ps[0]} {ps[1]}')
koch(ps,pe,n)
print(f'{pe[0]} {pe[1]}')
"
8767700,ALDS1_5_C,"# aizu_ALDS1_5_C_KochCurve.py  

from math import sqrt

def koch(p,q):
    s = [(p[0]*2+q[0])/3,(p[1]*2+q[1])/3]
    t = [(p[0]+q[0]*2)/3,(p[1]+q[1]*2)/3]

    z = [t[0]-s[0],t[1]-s[1]]
    u = [b*z[0]-a*z[1],a*z[0]+b*z[1]]
    x = [u[0]+s[0],u[1]+s[1]]
    return s,t,x

def solve(n,p,q):
    if n == 0:return
    s,t,x = koch(p,q)
    
    solve(n-1,p,s)
    solve(n-1,s,x)
    solve(n-1,x,t)
    solve(n-1,t,q)
    if n ==1:
        print(*p)
        print(*s)
        print(*x)
        print(*t)
        #print()

n = int(input())
a = sqrt(3)/2
b = 1/2
p,q = [0.00,0.0],[100.0,0.0]
ans = [p,q]
if n ==0:
    print(*p)
    print(*q)
    exit()
solve(n,p,q)
print(*q)
"
8778739,ALDS1_5_C,"import math

def kock(n, p1, p2):
    if n == 0:
        return
    s = [0, 0]
    t = [0, 0]
    u = [0, 0]
    s[0] = (2*p1[0] + 1*p2[0]) / 3
    s[1] = (2*p1[1] + 1*p2[1]) / 3
    t[0] = (1*p1[0] + 2*p2[0]) / 3
    t[1] = (1*p1[1] + 2*p2[1]) / 3
    u[0] = (t[0]-s[0])*math.cos(math.radians(60)) - (t[1]-s[1])*math.sin(math.radians(60)) + s[0]
    u[1] = (t[0]-s[0])*math.sin(math.radians(60)) + (t[1]-s[1])*math.cos(math.radians(60)) + s[1]
    
    kock(n-1, p1, s)
    print(*s)
    kock(n-1, s, u)
    print(*u)
    kock(n-1, u, t)
    print(*t)
    kock(n-1, t, p2)
    
n = int(input())
p1 = [0, 0]
p2 = [100, 0]
print(*p1)
kock(n, p1, p2)
print(*p2)
"
8828599,ALDS1_5_C,"import math

def koch(n, p1, p2):
    if n == 0:
        return 

    s = ((2 * p1[0] + 1 * p2[0]) / 3, (2 * p1[1] + 1 * p2[1]) / 3)
    t = ((1 * p1[0] + 2 * p2[0]) / 3, (1 * p1[1] + 2 * p2[1]) / 3)

    u = ((t[0] - s[0]) * math.cos(math.radians(60)) - (t[1] - s[1]) * math.sin(math.radians(60)) + s[0],
         (t[0] - s[0]) * math.sin(math.radians(60)) + (t[1] - s[1]) * math.cos(math.radians(60)) + s[1])

    koch(n-1, p1, s)
    print(*s)
    koch(n-1, s, u)
    print(*u)
    koch(n-1, u, t)
    print(*t)
    koch(n-1, t, p2)

n = int(input())
p1 = (0.0, 0.0)
p2 = (100.0, 0.0)
print(*p1)
koch(n, p1, p2)
print(*p2)
"
8870831,ALDS1_5_C,"import math
n = int(input())

def kock(n,p1x,p1y,p2x,p2y):
    if n==0:
        return
    sx = (2*p1x+p2x)/3
    sy = (2*p1y+p2y)/3
    tx = (p1x+2*p2x)/3
    ty = (p1y+2*p2y)/3
    ux = sx + (tx-sx)*math.cos(math.pi/3)-(ty-sy)*math.sin(math.pi/3)
    uy = sy + (tx-sx)*math.sin(math.pi/3)+(ty-sy)*math.cos(math.pi/3)
    #print(p1x,p1y)
    kock(n-1,p1x,p1y,sx,sy)
    print(sx,sy)
    kock(n-1,sx,sy,ux,uy)
    print(ux,uy)
    kock(n-1,ux,uy,tx,ty)
    print(tx,ty)
    kock(n-1,tx,ty,p2x,p2y)
    #print(p2x,p2y)

print(0,0)
kock(n,0,0,100,0)
print(100,0)
"
8886650,ALDS1_5_C,"import math
class Point():
    def __init__(self,x,y):
        self.x = x
        self.y = y

def Koch(n,a,b):
    th = math.radians(60)
    if n== 0:
        return
    
    s = Point(0,0)
    t = Point(0,0)
    u = Point(0,0)

    s.x = (2.0*a.x + 1.0*b.x) / 3.0
    s.y = (2.0*a.y + 1.0*b.y) / 3.0

    t.x = (1.0*a.x + 2.0*b.x) / 3.0
    t.y = (1.0*a.y + 2.0*b.y) / 3.0

    u.x = (t.x - s.x) * math.cos(th) - (t.y - s.y) * math.sin(th) + s.x
    u.y = (t.x - s.x) * math.sin(th) + (t.y - s.y) * math.cos(th) + s.y

    Koch(n-1,a,s)
    print(""{:.8f} {:.8f}"".format(s.x,s.y))
    Koch(n-1,s,u)
    print(""{:.8f} {:.8f}"".format(u.x,u.y))
    Koch(n-1,u,t)
    print(""{:.8f} {:.8f}"".format(t.x,t.y))
    Koch(n-1,t,b)

def main():
    n = int(input())

    a = Point(0,0)
    b = Point(100,0)

    print(""{:.8f} {:.8f}"".format(a.x,a.y))
    Koch(n,a,b)
    print(""{:.8f} {:.8f}"".format(b.x,b.y))

main()

"
8911789,ALDS1_5_C,"#  u.x = (t.x + s.x)/2 - 3**0.5*(t.y-s.y)*0.5
#     u.y = (t.y + s.y)/2 + 3**0.5*(t.x-s.x)*0.5
class Point:
    def __init__(self,x,y):
        self.x = x
        self.y = y
    
n = int(input())

def koch_curve(p1,p2,cnt):
    if cnt == n:
        return
    x1 = p1.x
    x2 = p2.x
    y1 = p1.y
    y2 = p2.y
    sx = (2*x1 + x2)/3
    sy = (2*y1 + y2)/3
    tx = (x1 + 2*x2)/3
    ty = (y1 + 2*y2)/3
    ux = (tx + sx)/2 - 3**0.5*(ty - sy)*0.5
    uy = (ty + sy)/2 + 3**0.5*(tx - sx)*0.5
    s = Point(sx,sy)
    t = Point(tx,ty)
    u = Point(ux,uy)
    koch_curve(p1,s,cnt+1)
    print(s.x,s.y)
    koch_curve(s,u,cnt+1)
    print(u.x,u.y)
    koch_curve(u,t,cnt+1)
    print(t.x,t.y)
    koch_curve(t,p2,cnt+1)

p1 = Point(0,0)
p2 = Point(100,0)
print(0,0)
koch_curve(p1,p2,0)
print(100,0)

    
"
8941594,ALDS1_5_C,"import math
def make_plots(p1:tuple[float, float], p2:tuple[float, float]) -> list[tuple[float, float]]:
    # print(p1, p2)
    diff_x = p2[0] - p1[0]
    diff_y = p2[1] - p1[1]
    s = (p1[0] + diff_x / 3, p1[1] + diff_y / 3)
    t = (p1[0] + 2*diff_x / 3, p1[1] + 2*diff_y / 3)
    mid = ((p1[0]+p2[0])/2, (p1[1]+p2[1])/2)
    # print(""mid"",mid)
    before = (mid[0]-s[0], mid[1]-s[1])
    # print(""before"",before)
    after = (before[0] - math.sqrt(3)*before[1], math.sqrt(3)*before[0] + before[1])
    # print(""after"",after)
    u = (s[0] + after[0], s[1] + after[1])
    return [p1, s, u, t, p2]


def go_depth(plots:list[tuple[float, float]], n:int):
    rec = []
    for i in range(len(plots)-1):
        x = plots[i]
        y = plots[i+1]
        # print(""xy"",x, y, make_plots(x, y))
        if i == 0:
            rec.extend(make_plots(x, y))
        else:
            rec.extend(make_plots(x, y)[1:])
    return rec

n = int(input())
plots = [(0., 0.), (100., 0.)]
for idx in range(n):
    # print(idx, plots)
    plots = go_depth(plots, idx)

for plot in plots:
    print(f""{plot[0]:.5f} {plot[1]:.5f}"")
"
8979719,ALDS1_5_C,"import math

n = int(input())
def kock(n, p1, p2):
    if n == 0:
        return
    s=[(2*p1[0]+1*p2[0])/3, (2*p1[1]+1*p2[1])/3]
    t=[(1*p1[0]+2*p2[0])/3, (1*p1[1]+2*p2[1])/3]
    u=[(t[0]-s[0])*math.cos(math.pi/3)-(t[1]-s[1])*math.sin(math.pi/3)+s[0], (t[0]-s[0])*math.sin(math.pi/3)+(t[1]-s[1])*math.cos(math.pi/3)+s[1]]
    kock(n-1, p1, s)
    print(*s)
    kock(n-1, s, u)
    print(*u)
    kock(n-1, u, t)
    print(*t)
    kock(n-1, t, p2)

p1=[0,0]
p2=[100,0]
print(*p1)
kock(n, p1, p2)
print(*p2)
"
8988935,ALDS1_5_C,"import math

th: float = math.radians(60)

class Point:
    def __init__(self, x, y) -> None:
        self.x = x
        self.y = y

def kock(n: int, a: Point, b: Point):
    if n == 0:
        return
    s_x: float = (2 * a.x + 1 * b.x) / 3
    s_y: float = (2 * a.y + 1 * b.y) / 3
    t_x: float = (1 * a.x + 2 * b.x) / 3
    t_y: float = (1 * a.y + 2 * b.y) / 3
    u_x: float = (t_x - s_x) * math.cos(th) - (t_y - s_y) * math.sin(th) + s_x
    u_y: float = (t_x - s_x) * math.sin(th) + (t_y - s_y) * math.cos(th) + s_y

    s: Point = Point(s_x, s_y)
    t: Point = Point(t_x, t_y)
    u: Point = Point(u_x, u_y)

    kock(n - 1, a, s)
    print(s.x, s.y)
    kock(n - 1, s, u)
    print(u.x, u.y)
    kock(n - 1, u, t)
    print(t.x, t.y)
    kock(n - 1, t, b)

if __name__ == ""__main__"":
    n: int = float(input())

    a: Point = Point(0, 0)
    b: Point = Point(100, 0)

    print(a.x, a.y)
    kock(n, a, b)
    print(b.x, b.y)

"
8999904,ALDS1_5_C,"import math

d = int(input())


def koch(d, p1x, p1y, p2x, p2y):
    if d == 0:
        return
    sx = (2 * p1x + 1 * p2x) / 3
    sy = (2 * p1y + 1 * p2y) / 3
    tx = (1 * p1x + 2 * p2x) / 3
    ty = (1 * p1y + 2 * p2y) / 3

    ux = (tx - sx) * math.cos(math.pi / 3) - \
        (ty - sy) * math.sin(math.pi / 3) + sx
    uy = (tx - sx) * math.sin(math.pi / 3) + \
        (ty - sy) * math.cos(math.pi / 3) + sy

    koch(d-1, p1x, p1y, sx, sy)
    print(f'{sx:.8f} {sy:.8f}')
    koch(d-1, sx, sy, ux, uy)
    print(f'{ux:.8f} {uy:.8f}')
    koch(d-1, ux, uy, tx, ty)
    print(f'{tx:.8f} {ty:.8f}')
    koch(d-1, tx, ty, p2x, p2y)


def main():
    p1x = 0.0
    p1y = 0.0
    p2x = 100.0
    p2y = 0.0
    print(f'{p1x:.8f} {p1y:.8f}')
    koch(d, p1x, p1y, p2x, p2y)
    print(f'{p2x:.8f} {p2y:.8f}')


main()

"
9033772,ALDS1_5_C,"import math

def rot60(s, t):
    v = t - s
    a = 1/2 + complex(0,(math.sqrt(3)/2))
    return v * a + s

def pr(p):
    x = p.real
    y = p.imag
    print('%.10f %.10f'%(x, y))

def dfs(p1, p2, n):
    if n == 0:
        return
    

    s = (p2 - p1) * (1/3) + p1
    t = (p2 - p1) * (2/3) + p1
    u = rot60(s, t)
    dfs(p1, s, n - 1)
    pr(s)
    dfs(s, u, n - 1)
    pr(u)
    dfs(u, t, n - 1)
    pr(t)
    dfs(t, p2, n -1)
    
n = int(input())
s = (0 + 0j)
t = (100 + 0j)
pr(s)
dfs(s, t, n) 
pr(t)
"
9059684,ALDS1_5_C,"import math
class point:
    def __init__(self, x, y) -> None:
        self.x: float = x
        self.y: float = y
    def show(self) -> None:
        print(f""{self.x} {self.y}"")

def divide(p1: point, p2: point, a, b) -> point:
    x = (b * p1.x + a * p2.x) / (a + b)
    y = (b * p1.y + a * p2.y) / (a + b)
    return point(x, y)
def difference(p1:point, p2:point) -> float:
    return math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2)

def sin(degree):return math.sin(math.radians(degree))
def cos(degree):return math.cos(math.radians(degree))

def kochCurve(p1:point, p2:point, m):
    if m == n:
        p1.show()
        return
    s = divide(p1, p2, 1, 2)
    t = divide(p1, p2, 2, 1)
    temp = point(t.x - s.x, t.y - s.y)
    u = point(s.x + temp.x * cos(60) - temp.y * sin(60), s.y + temp.y * cos(60) + temp.x * sin(60))
    m+=1
    kochCurve(p1, s, m)
    kochCurve(s, u, m)
    kochCurve(u, t, m)
    kochCurve(t, p2, m)
    
n = int(input())
kochCurve(point(float(0),float(0)), point(float(100), float(0)), 0)
point(float(100), float(0)).show()
"
9203746,ALDS1_5_C,"def vector_plus(vector1,vector2):
    vector3=[]
    for i in range(2):
        vector3.append(vector1[i]+vector2[i])
    return vector3
def vector_minus(vector1,vector2):
    vector3=[]
    for i in range(2):
        vector3.append(vector1[i]-vector2[i])
    return vector3
def vector_mul(vector,x):
    vector2=[]
    for i in range(len(vector)):
        vector2.append(vector[i]*x)
    return vector2
def coch_top(vector1,vector2):
    vector=vector_mul(vector_minus(vector2,vector1),1/3)
    vector_60=[]
    vector_60.append((1/2)*vector[0]-3**(1/2)/2*vector[1])
    vector_60.append((3**(1/2)/2)*vector[0]+1/2*vector[1])
    vector3=vector_plus(vector1,vector)
    vector4=vector_plus(vector1,vector_mul(vector,2))
    a=[vector1,vector3,vector_plus(vector3,vector_60),vector4,vector2]
    return a
def kurikaesi(a,n):
    if n==0:
        return a
    else: 
        b=[]
        for i in range(len(a)-1):
            k=coch_top(a[i],a[i+1])
            if i==0:
                b=b+k
            else:
                del k[0]
                b=b+k
        return kurikaesi(b,n-1)
n=int(input())
solve_list=kurikaesi([[0,0],[100,0]],n)
for i in range(len(solve_list)):
    print(solve_list[i][0],solve_list[i][1])
"
1613327,ALDS1_5_C,"import math

c60 = math.cos(math.radians(60))
s60 = math.sin(math.radians(60))

def koch(d, p1, p2):
    """""" Print the coordinates of the vertices of Koch Curve.
    d is the depth of recursion.
    p1, p2 are coordinates of end point of the initial state.
    """"""
    if d == 0:
        return

    sx = (2 * p1[0] + p2[0]) / 3
    sy = (2 * p1[1] + p2[1]) / 3

    tx = (p1[0] + 2 * p2[0]) / 3
    ty = (p1[1] + 2 * p2[1]) / 3

    dx = tx - sx
    dy = ty - sy

    ux = dx * c60 - dy * s60 + sx
    uy = dx * s60 + dy * c60 + sy

    koch(d - 1, p1, (sx, sy))
    print(""{0:.8f} {1:.8f}"".format(sx, sy))

    koch(d - 1, (sx, sy), (ux, uy))
    print(""{0:.8f} {1:.8f}"".format(ux, uy))

    koch(d - 1, (ux, uy), (tx, ty))
    print(""{0:.8f} {1:.8f}"".format(tx, ty))

    koch(d - 1, (tx, ty), p2)


n = int(input())

ax = 0
ay = 0

bx = 100
by = 0

print(""{0:.8f} {1:.8f}"".format(ax, ay))
koch(n, (ax, ay), (bx, by))
print(""{0:.8f} {1:.8f}"".format(bx, by))
"
2283578,ALDS1_5_C,"# coding=utf-8
import math


def divide_segment(left, right):
    """"""divide segment

    Args:
        left: left edge coordinate
        right: right edge coordinate

    Returns:
        divided points
    """"""
    delta_x_quarter = (right[0] - left[0]) / 3.0
    delta_y_quarter = (right[1] - left[1]) / 3.0

    delta_x_quarter_rotated = (delta_x_quarter - math.sqrt(3) * delta_y_quarter) / 2.0
    delta_y_quarter_rotated = (math.sqrt(3) * delta_x_quarter + delta_y_quarter) / 2.0

    s = [left[0] + delta_x_quarter, left[1] + delta_y_quarter]
    t = [left[0] + delta_x_quarter * 2.0, left[1] + delta_y_quarter * 2.0]
    u = [s[0] + delta_x_quarter_rotated, s[1] + delta_y_quarter_rotated]

    return s, t, u


def make_coch_curve(depth, left, right):
    """"""make coch curve with depth iteration_number between point left, right
    each vertices positions are printed

    Args:
        depth: depth
        left: left edge point
        right: right edge point

    Returns:
        None
    """"""
    print(""{0:2.8f} {1:2.8f}"".format(left[0], left[1]))
    if depth == 0:
        print(""{0:2.8f} {1:2.8f}"".format(right[0], right[1]))
    else:
        make_coch_curve_recursively(depth-1, left, right)


def make_coch_curve_recursively(depth, left, right):
    """"""recursion part of coch curve

    Args:
        depth: depth
        left: left edge coordinate
        right: right edge coordinate

    Returns:
        None
    """"""
    # get coordinate of divided points
    s, t, u = divide_segment(left, right)

    if depth == 0:
        print(""{0:2.8f} {1:2.8f}"".format(s[0], s[1]))
        print(""{0:2.8f} {1:2.8f}"".format(u[0], u[1]))
        print(""{0:2.8f} {1:2.8f}"".format(t[0], t[1]))
        print(""{0:2.8f} {1:2.8f}"".format(right[0], right[1]))
    else:
        make_coch_curve_recursively(depth - 1, left, s)
        make_coch_curve_recursively(depth - 1, s, u)
        make_coch_curve_recursively(depth - 1, u, t)
        make_coch_curve_recursively(depth - 1, t, right)


def main():
    depth = int(input().strip())
    make_coch_curve(depth, left=[0.0, 0.0], right=[100.0, 0.0])


if __name__ == '__main__':
    main()
"
2472165,ALDS1_5_C,"from math import sqrt
q3 = sqrt(3)
fmt = ""%.8f %.8f""
def koch(x0, y0, x1, y1, c):
    if c == n:
        return (fmt % (x0, y0),)
    xp = (x0*2 + x1) / 3
    yp = (y0*2 + y1) / 3

    xq = (x0 + x1*2) / 3
    yq = (y0 + y1*2) / 3

    dx = (x1 - x0) / 6
    dy = (y1 - y0) / 6

    xr = xp + (dx - dy * q3)
    yr = yp + (dx * q3 + dy)

    return koch(x0, y0, xp, yp, c+1) + koch(xp, yp, xr, yr, c+1) + koch(xr, yr, xq, yq, c+1) + koch(xq, yq, x1, y1, c+1)
n = int(input())
print(*koch(0, 0, 100, 0, 0)+(fmt % (100, 0),), sep='\n')
"
2532657,ALDS1_5_C,"n = int(input())
r3 = 3 ** 0.5
A = (0.0, 0.0)
B = (100.0, 0.0)

def koch(n, A, B):
    if n == 0:
        return

    C1 = ((2 * A[0] + B[0]) / 3, (2 * A[1] + B[1]) / 3)
    C3 = ((A[0] + 2 * B[0]) / 3, (A[1] + 2 * B[1]) / 3)
    X, Y = C3[0] - C1[0], C3[1] - C1[1]
    C2 = (C1[0] + (X - Y * r3) / 2, C1[1] + (X * r3 + Y) / 2)

    koch(n - 1, A, C1)
    print(""{:.5f} {:.5f}"".format(C1[0], C1[1]))
    koch(n - 1, C1, C2)
    print(""{:.5f} {:.5f}"".format(C2[0], C2[1]))
    koch(n - 1, C2, C3)
    print(""{:.5f} {:.5f}"".format(C3[0], C3[1]))
    koch(n - 1, C3, B)

print(""{:.5f} {:.5f}"".format(A[0], A[1]))
koch(n, A, B)
print(""{:.5f} {:.5f}"".format(B[0], B[1]))
"
2710765,ALDS1_5_C,"d=[0j,100+0j]
for _ in[0]*int(input()):
 p=[d[0]]
 for i in range(len(d)-1):
  a,b=d[i],d[i+1]
  r=(b-a)/3
  p+=[a+r,a+r+r*(1+3**.5*1j)/2,b-r,b]
 d=p
for e in d:print(e.real,e.imag)
"
3116952,ALDS1_5_C,"def koch_curve(n, x1, y1, x2, y2):
    if n == 0:
        return [(x1, y1)]
    s_x = (2 * x1 + x2) / 3
    s_y = (2 * y1 + y2) / 3
    t_x = (x1 + 2 * x2) / 3
    t_y = (y1 + 2 * y2) / 3
    # 回転行列を用いて
    u_x = (t_x - s_x) * .5 - (t_y - s_y) * (3 ** .5 / 2) + s_x
    u_y = (t_x - s_x) * (3 ** .5 / 2) + (t_y - s_y) * .5  + s_y
    ret = koch_curve(n - 1, x1, y1, s_x, s_y) + \
        koch_curve(n - 1, s_x, s_y, u_x, u_y) + \
        koch_curve(n - 1, u_x, u_y, t_x, t_y) + \
        koch_curve(n - 1, t_x, t_y, x2, y2)
    return ret
for x, y in koch_curve(int(input()), 0, 0, 100, 0):
    print('{:.8f} {:.8f}'.format(x, y))
print('{:.8f} {:.8f}'.format(100, 0))
"
3174179,ALDS1_5_C,"import math


def koch(k, p1, p2):
    if k==0:
        print('{0:.8f} {1:.8f}'.format(p1[0],p1[1]))

    s = [p1[0]*2/3+p2[0]/3, p1[1]*2/3+p2[1]/3]
    u = [(p1[0]+p2[0])/2+(p1[1]-p2[1])*math.sqrt(3)/6,
         (p1[1]+p2[1])/2+(p2[0]-p1[0])*math.sqrt(3)/6]
    t = [p1[0]/3+p2[0]*2/3, p1[1]/3+p2[1]*2/3]
    if k==1:
        print('{0:.8f} {1:.8f}'.format(p1[0],p1[1]))
        print('{0:.8f} {1:.8f}'.format(s[0],s[1]))
        print('{0:.8f} {1:.8f}'.format(u[0],u[1]))
        print('{0:.8f} {1:.8f}'.format(t[0],t[1]))
    elif k>0:
        koch(k-1,p1,s)
        koch(k-1,s,u)
        koch(k-1,u,t)
        koch(k-1,t,p2)
    if k==n:
        print('{0:.8f} {1:.8f}'.format(p2[0],p2[1]))

n = int(input())
koch(n, [0,0],[100,0])
"
3220309,ALDS1_5_C,"import math
sqrt3 = math.sqrt(3.0)

def koch_curve(n, i, pt1, pt2, pt_array):
    if i > n:
        return
    pt1x, pt1y = pt1
    pt2x, pt2y = pt2
    pts = (2/3 * pt1x + 1/3 * pt2x, 2/3 * pt1y + 1/3 * pt2y)
    ptt = (1/3 * pt1x + 2/3 * pt2x, 1/3 * pt1y + 2/3 * pt2y)
    ptx = ptt[0] - pts[0]
    pty = ptt[1] - pts[1]
    ptu = (1/2 * (ptx - sqrt3 * pty) + pts[0], 1/2 * (sqrt3 * ptx + pty) + pts[1])

    koch_curve(n, i+1, pt1, pts, pt_array)
    pt_array.append(pts)
    koch_curve(n, i+1, pts, ptu, pt_array)
    pt_array.append(ptu)
    koch_curve(n, i+1, ptu, ptt, pt_array)
    pt_array.append(ptt)
    koch_curve(n, i+1, ptt, pt2, pt_array)
    return

def main():
    n = int(input())
    pt_array = []
    begin = (0.0, 0.0)
    end = (100.0, 0.0)
    pt_array.append(begin)
    koch_curve(n, 1, begin, end, pt_array)
    pt_array.append(end)
    for pt in pt_array:
        print(""{:.6f} {:.6f}"".format(pt[0], pt[1]))

main()
"
3259406,ALDS1_5_C,"def next_koch(n):
    turn60 = 0.5 + 3 ** 0.5 * 0.5j
    n_next = [n[0]]
    for i in range(1, len(n)):
        s = (n[i - 1] * 2 + n[i]) / 3
        t = (n[i - 1] + n[i] * 2) / 3
        u = (t - s) * turn60 + s
        n_next +=[s, u, t, n[i]]
    return n_next

p1 = 0 + 0j
p2 = 100 + 0j
koch = [p1, p2]

n = int(input())
for i in range(n):
    koch = next_koch(koch)

for z in koch:
    print(""{:.8f} {:.8f}"".format(z.real, z.imag))

"
3432276,ALDS1_5_C,"import math

def koch(n,p1x,p1y,p2x,p2y):
    if n == 0:
        return
    
    sx = (2*p1x+1*p2x)/3
    sy = (2*p1y+1*p2y)/3
    tx = (1*p1x+2*p2x)/3
    ty = (1*p1y+2*p2y)/3
    theta = math.pi/3  #180[deg] == math.pi[rad]
    ux = math.cos(theta)*(tx-sx) - math.sin(theta)*(ty-sy)+sx
    uy = math.sin(theta)*(tx-sx) + math.cos(theta)*(ty-sy)+sy

    koch(n-1, p1x, p1y, sx, sy)
    print(""{:.5f} {:.5f}"".format(sx, sy))
    koch(n-1, sx, sy, ux, uy)
    print(""{:.5f} {:.5f}"".format(ux, uy))
    koch(n-1, ux, uy, tx, ty)
    print(""{:.5f} {:.5f}"".format(tx, ty))
    koch(n-1, tx, ty, p2x, p2y)

n = int(input())
p1x,p1y = 0.0,0.0
p2x,p2y = 100.0,0.0
print(""{:.5f} {:.5f}"".format(p1x, p1y))
koch(n, p1x, p1y, p2x, p2y)
print(""{:.5f} {:.5f}"".format(p2x, p2y))

"
3700465,ALDS1_5_C,"from math import sqrt
q3 = sqrt(3)
fmt = ""%.8f %.8f""
def koch(x0, y0, x1, y1, c):
    if c == n:
        return (fmt % (x0, y0),)
    xp = (x0*2 + x1) / 3
    yp = (y0*2 + y1) / 3
 
    xq = (x0 + x1*2) / 3
    yq = (y0 + y1*2) / 3
 
    dx = (x1 - x0) / 6
    dy = (y1 - y0) / 6
 
    xr = xp + (dx - dy * q3)
    yr = yp + (dx * q3 + dy)
 
    return koch(x0, y0, xp, yp, c+1) + koch(xp, yp, xr, yr, c+1) + koch(xr, yr, xq, yq, c+1) + koch(xq, yq, x1, y1, c+1)
n = int(input())
print(*koch(0, 0, 100, 0, 0)+(fmt % (100, 0),), sep='\n')

"
3785364,ALDS1_5_C,"import math

def koch_curve(p1_x,p1_y,p2_x,p2_y,c):
	s_x = (p2_x + 2*p1_x) / 3
	s_y = (p2_y + 2*p1_y) / 3
	t_x = (2*p2_x + p1_x) / 3
	t_y = (2*p2_y + p1_y) / 3
	u_x = (math.cos(math.pi/3) * ( t_x - s_x ) - math.sin(math.pi/3) * ( t_y - s_y)) + s_x
	u_y = (math.sin(math.pi/3) * ( t_x - s_x ) + math.cos(math.pi/3) * ( t_y - s_y)) + s_y
	if c > 1:
		koch_curve(p1_x,p1_y,s_x,s_y,c-1)
		koch_curve(s_x,s_y,u_x,u_y,c-1)
		koch_curve(u_x,u_y,t_x,t_y,c-1)
		koch_curve(t_x,t_y,p2_x,p2_y,c-1)
	else:
		print(""%.8f %.8f"" % (p1_x,p1_y))
		print(""%.8f %.8f"" % (s_x, s_y))
		print(""%.8f %.8f"" % (u_x, u_y))
		print(""%.8f %.8f"" % (t_x, t_y))

if __name__ == '__main__':
	n = int(input())
	if n == 0:
		print(""%.8f %.8f"" % (0,0))
		print(""%.8f %.8f"" % (100,0))
	else:
		koch_curve(0,0,100,0,n)
		print(""%.8f %.8f"" % (100,0))
"
3919382,ALDS1_5_C,"def next_koch(n):
    turn60 = 0.5 + 3 ** 0.5 * 0.5j
    n_next = [n[0]]
    for i in range(1, len(n)):
        s = (n[i - 1] * 2 + n[i]) / 3
        t = (n[i - 1] + n[i] * 2) / 3
        u = (t - s) * turn60 + s
        n_next +=[s, u, t, n[i]]
    return n_next

p1 = 0 + 0j
p2 = 100 + 0j
koch = [p1, p2]

n = int(input())
for i in range(n):
    koch = next_koch(koch)

for z in koch:
    print(""{:.8f} {:.8f}"".format(z.real, z.imag))
"
3959208,ALDS1_5_C,"import math

def koch(n,p1x,p1y,p2x,p2y):
    if n == 0:
        return
    
    sx = (2*p1x+1*p2x)/3
    sy = (2*p1y+1*p2y)/3
    tx = (1*p1x+2*p2x)/3
    ty = (1*p1y+2*p2y)/3
    theta = math.pi/3  #180[deg] == math.pi[rad]
    ux = math.cos(theta)*(tx-sx) - math.sin(theta)*(ty-sy)+sx
    uy = math.sin(theta)*(tx-sx) + math.cos(theta)*(ty-sy)+sy

    koch(n-1, p1x, p1y, sx, sy)
    print(""{:.8f} {:.8f}"".format(sx, sy))
    koch(n-1, sx, sy, ux, uy)
    print(""{:.8f} {:.8f}"".format(ux, uy))
    koch(n-1, ux, uy, tx, ty)
    print(""{:.8f} {:.8f}"".format(tx, ty))
    koch(n-1, tx, ty, p2x, p2y)

n = int(input())
p1x,p1y = 0.0,0.0
p2x,p2y = 100.0,0.0
print(""{:.8f} {:.8f}"".format(p1x, p1y))
koch(n, p1x, p1y, p2x, p2y)
print(""{:.8f} {:.8f}"".format(p2x, p2y))

"
4213586,ALDS1_5_C,"import math

def coh(n, p1, p2, pt_list, m):
    if n>m:
        return 
    x1, y1 = p1
    x2, y2 = p2
    
    nx, ny = -(y2-y1), x2-x1

    xs, ys = x1 + (x2-x1)/3, y1 + (y2-y1)/3
    xu, yu = (x1+x2)/2 + nx*math.sqrt(3)/2/3 , (y1+y2)/2 + ny*math.sqrt(3)/2/3  
    xt, yt = x1 + (x2-x1)*2/3, y1 + (y2-y1)*2/3
    
    ps = xs, ys
    pu = xu, yu
    pt = xt, yt
    
    coh(n+1, p1, ps, pt_list, m)
    pt_list += [ps]
    coh(n+1, ps, pu, pt_list, m)
    pt_list += [pu]
    coh(n+1, pu, pt, pt_list, m)
    pt_list += [pt]
    coh(n+1, pt, p2, pt_list, m)

m = int(input())
pt_list = [(0,0)]
coh(1, (0,0), (100,0), pt_list, m)
pt_list += [(100,0)]
for xy in pt_list:
    print('%.9f %.9f'%(xy[0], xy[1]))
"
4426632,ALDS1_5_C,"def next_math(n):
    turn60 = 0.5 + 3 ** 0.5 * 0.5j
    n_next = [n[0]]
    for i in range(1, len(n)):
        s = (n[i - 1] * 2 + n[i]) / 3
        t = (n[i - 1] + n[i] * 2) / 3
        u = (t - s) * turn60 + s
        n_next +=[s, u, t, n[i]]
    return n_next

p1 = 0 + 0j
p2 = 100 + 0j
math = [p1, p2]

n = int(input())
for i in range(n):
    math = next_math(math)

for z in math:
    print(""{:.8f} {:.8f}"".format(z.real, z.imag))
"
4442900,ALDS1_5_C,"from math import sqrt
q3 = sqrt(3)
fmt = ""%.8f %.8f""
def koch(x0, y0, x1, y1, c):
    if c == n:
        return (fmt % (x0, y0),)
    xp = (x0*2 + x1) / 3
    yp = (y0*2 + y1) / 3

    xq = (x0 + x1*2) / 3
    yq = (y0 + y1*2) / 3

    dx = (x1 - x0) / 6
    dy = (y1 - y0) / 6

    xr = xp + (dx - dy * q3)
    yr = yp + (dx * q3 + dy)

    return koch(x0, y0, xp, yp, c+1) + koch(xp, yp, xr, yr, c+1) + koch(xr, yr, xq, yq, c+1) + koch(xq, yq, x1, y1, c+1)
n = int(input())
print(*koch(0, 0, 100, 0, 0)+(fmt % (100, 0),), sep='\n')
"
4513343,ALDS1_5_C,"def kochfunc(n1, x1, y1, x2, y2):   #関数作成
    if n1 > n-1:                      #breakの条件
        return 
    
    root3 = 1.732050807
    sx = (x1*2 + x2)/3 ; sy  = (y1*2 + y2)/3 
    tx = (x1 + x2*2)/3 ; ty  = (y1 + y2*2)/3
    
    vx = tx-sx; vy = ty-sy
    ux = sx + (vx - vy*root3)/2
    uy = sy + (vx*root3 + vy)/2
    
    kochfunc(n1+1, x1, y1, sx, sy)      #再帰関数
    print('{:.8f}'.format(sx), '{:.8f}'.format(sy))
    kochfunc(n1+1, sx, sy, ux, uy)
    print('{:.8f}'.format(ux), '{:.8f}'.format(uy))
    kochfunc(n1+1, ux, uy, tx, ty)
    print('{:.8f}'.format(tx), '{:.8f}'.format(ty))
    kochfunc(n1+1, tx, ty, x2, y2)
    
n = int(input())    
print('{:.8f}'.format(0), '{:.8f}'.format(0))    
kochfunc(0, 0, 0, 100, 0)
print('{:.8f}'.format(100), '{:.8f}'.format(0))
"
4582303,ALDS1_5_C,"import math

def plot(x,y):
    print(f'{x:.8f} {y:.8f}')
    
def Koch(n,x1,y1,x2,y2):
    if n==0:
        plot(x1,y1)
        return
    sx=(2*x1+x2)/3
    sy=(2*y1+y2)/3
    tx=(x1+2*x2)/3
    ty=(y1+2*y2)/3
    ux=(tx-sx)*(1/2)-(ty-sy)*(math.sqrt(3)/2)+sx
    uy=(tx-sx)*(math.sqrt(3)/2)+(ty-sy)*(1/2)+sy
    Koch(n-1,x1,y1,sx,sy)
    Koch(n-1,sx,sy,ux,uy)
    Koch(n-1,ux,uy,tx,ty)
    Koch(n-1,tx,ty,x2,y2)

n=int(input())
Koch(n, 0,0, 100,0)
plot(100,0)
"
4603390,ALDS1_5_C,"#(41)コッホ曲線

import math

def plot(x,y):
     print(f'{x:.8f} {y:.8f}')
     
def Koch(n, x1,y1, x2,y2):
     if n==0:
          plot(x1,y1)
          return
     sx=(2*x1+x2)/3
     sy=(2*y1+y2)/3
     tx=(x1+2*x2)/3
     ty=(y1+2*y2)/3
     ux=(tx-sx)*(1/2)-(ty-sy)*(math.sqrt(3)/2)+sx
     uy=(tx-sx)*(math.sqrt(3)/2)+(ty-sy)*(1/2)+sy
     Koch(n-1, x1,y1, sx,sy)
     Koch(n-1, sx,sy, ux,uy)
     Koch(n-1, ux,uy, tx,ty)
     Koch(n-1, tx,ty, x2,y2)
n=int(input())
Koch(n, 0,0, 100,0)
plot(100,0)
"
4644744,ALDS1_5_C,"from math import sqrt
q3 = sqrt(3)
fmt = ""%.8f %.8f""
def koch(x0, y0, x1, y1, c):
    if c == n:
        return (fmt % (x0, y0),)
    xp = (x0*2 + x1) / 3
    yp = (y0*2 + y1) / 3

    xq = (x0 + x1*2) / 3
    yq = (y0 + y1*2) / 3

    dx = (x1 - x0) / 6
    dy = (y1 - y0) / 6

    xr = xp + (dx - dy * q3)
    yr = yp + (dx * q3 + dy)

    return koch(x0, y0, xp, yp, c+1) + koch(xp, yp, xr, yr, c+1) + koch(xr, yr, xq, yq, c+1) + koch(xq, yq, x1, y1, c+1)
n = int(input())
print(*koch(0, 0, 100, 0, 0)+(fmt % (100, 0),), sep='\n')
"
4645523,ALDS1_5_C,"import math
def plot(x,y):
    print(f'{x:.8f} {y:.8f}')
def koch(n,x1,y1,x2,y2):
    if n==0:
        plot(x1,y1)
        return
    sx = (2*x1+x2)/3
    sy = (2*y1+y2)/3
    tx = (x1+2*x2)/3
    ty = (y1+2*y2)/3
    ux = (tx-sx)*(1/2)-(ty-sy)*(math.sqrt(3)/2)+sx
    uy = (tx-sx)*(math.sqrt(3)/2)+(ty-sy)*(1/2)+sy
    koch(n-1,x1,y1,sx,sy)
    koch(n-1,sx,sy,ux,uy)
    koch(n-1,ux,uy,tx,ty)
    koch(n-1,tx,ty,x2,y2)
    
n=int(input())
koch(n,0,0,100,0)
plot(100,0)


    
"
4646587,ALDS1_5_C,"import math

def plot(x,y):
    print(f'{x:.8f} {y:.8f}')

def koch(n, x1,y1,x2,y2):
    if n==0:
        plot(x1,y1)
        return
    sx=(2*x1+x2)/3
    sy=(2*y1+y2)/3
    tx=(x1+2*x2)/3
    ty=(y1+2*y2)/3
    ux=(tx-sx)*(1/2)-(ty-sy)*(math.sqrt(3)/2)+sx
    uy=(tx-sx)*(math.sqrt(3)/2)+(ty-sy)*(1/2)+sy
    koch(n-1, x1,y1, sx,sy)
    koch(n-1, sx,sy, ux,uy)
    koch(n-1, ux,uy, tx,ty)
    koch(n-1, tx,ty, x2,y2)
    
    
n=int(input())
koch(n, 0,0, 100,0)
plot(100,0)
"
4666610,ALDS1_5_C,"import math

def plot(x,y):
    print(f'{x:.8f} {y:.8f}')

def Koch(n, x1,y1, x2,y2):
    if n==0:
        plot(x1,y1)
        return
    
    sx=(2*x1+x2)/3
    sy=(2*y1+y2)/3
    tx=(x1+2*x2)/3
    ty=(y1+2*y2)/3
    ux=(tx-sx)*(1/2)-(ty-sy)*(math.sqrt(3)/2)+sx
    uy=(ty-sy)*(1/2)+(tx-sx)*(math.sqrt(3)/2)+sy
    
    Koch(n-1, x1,y1, sx,sy)
    Koch(n-1, sx,sy, ux,uy)
    Koch(n-1, ux,uy, tx,ty)
    Koch(n-1, tx,ty, x2,y2)

n=int(input())

Koch(n, 0,0, 100,0)
plot(100,0)

"
4678677,ALDS1_5_C,"from math import sqrt
q3 = sqrt(3)
fmt = ""%.8f %.8f""
def koch(x0, y0, x1, y1, c):
    if c == n:
        return (fmt % (x0, y0),)
    xp = (x0*2 + x1) / 3
    yp = (y0*2 + y1) / 3

    xq = (x0 + x1*2) / 3
    yq = (y0 + y1*2) / 3

    dx = (x1 - x0) / 6
    dy = (y1 - y0) / 6

    xr = xp + (dx - dy * q3)
    yr = yp + (dx * q3 + dy)

    return koch(x0, y0, xp, yp, c+1) + koch(xp, yp, xr, yr, c+1) + koch(xr, yr, xq, yq, c+1) + koch(xq, yq, x1, y1, c+1)
n = int(input())
print(*koch(0, 0, 100, 0, 0)+(fmt % (100, 0),), sep='\n')
"
4683597,ALDS1_5_C,"from math import sqrt
q3 = sqrt(3)
fmt = ""%.8f %.8f""
def koch(x0, y0, x1, y1, c):
    if c == n:
        return (fmt % (x0, y0),)
    xp = (x0*2 + x1) / 3
    yp = (y0*2 + y1) / 3

    xq = (x0 + x1*2) / 3
    yq = (y0 + y1*2) / 3

    dx = (x1 - x0) / 6
    dy = (y1 - y0) / 6

    xr = xp + (dx - dy * q3)
    yr = yp + (dx * q3 + dy)

    return koch(x0, y0, xp, yp, c+1) + koch(xp, yp, xr, yr, c+1) + koch(xr, yr, xq, yq, c+1) + koch(xq, yq, x1, y1, c+1)
n = int(input())
print(*koch(0, 0, 100, 0, 0)+(fmt % (100, 0),), sep='\n')
"
4691547,ALDS1_5_C,"import math

def plot(x,y):
    print(f'{x:.8f} {y:.8f}')

def Koch(n, x1, y1, x2, y2):
    if n == 0:
        plot(x1, y1)
        return
    sx = (2 * x1 + 1 * x2)/3
    sy = (2 * y1 + 1 * y2)/3
    tx = (1 * x1 + 2 * x2)/3
    ty = (1 * y1 + 2 * y2)/3
    ux = (tx - sx) * (1/2) - (ty - sy) * (math.sqrt(3)/2) + sx
    uy = (tx - sx) * (math.sqrt(3)/2) + (ty - sy) * (1/2) + sy
    Koch(n-1, x1,y1, sx,sy)
    Koch(n-1, sx,sy, ux,uy)
    Koch(n-1, ux,uy, tx,ty)
    Koch(n-1, tx,ty, x2,y2)

n = int(input())
Koch(n, 0,0, 100,0)
plot(100,0)
"
4713430,ALDS1_5_C,"import math
cos60 = math.cos(math.pi*60/180)
sin60 = math.sin(math.pi*60/180)
#add_triangle
# input: start(x, y) end(x, y)
def add_triangle(start, end):
    x1 = (2*start[0] + end[0]) / 3
    x3 = (start[0] + 2*end[0]) / 3
    y1 = (2*start[1] + end[1]) / 3
    y3 = (start[1] + 2*end[1]) / 3
    x2 = x1 + (x3-x1)*cos60 - (y3-y1)*sin60
    y2 = y1 + (x3-x1)*sin60 + (y3-y1)*cos60
    return [(x1,y1), (x2,y2), (x3,y3)]

#koch_recursion
#input list [(x1,y1),(x2,y2),(x3,y3)...]
def koch_recursion(list1):
    output = []
    for i in range(len(list1)-1):
        output.append(list1[i])
        output += add_triangle(list1[i], list1[i+1])
    output.append(list1[len(list1)-1])
    return output

#Koch  call koch_recursion(0, 100)
def Koch(start, end, n):
    output = [start, end]
    for i in range(n):
        output = koch_recursion(output)
    for x, y in output:
        print(""{:.8f} {:.8f}"".format(x, y))

n = int(input())
Koch((0,0), (100,0), n)
"
4730996,ALDS1_5_C,"import math

c60 = math.cos(math.radians(60))
s60 = math.sin(math.radians(60))

def koch(d, p1, p2):
    """""" Print the coordinates of the vertices of Koch Curve.
    d is the depth of recursion.
    p1, p2 are coordinates of end point of the initial state.
    """"""
    if d == 0:
        return

    sx = (2 * p1[0] + p2[0]) / 3
    sy = (2 * p1[1] + p2[1]) / 3

    tx = (p1[0] + 2 * p2[0]) / 3
    ty = (p1[1] + 2 * p2[1]) / 3

    dx = tx - sx
    dy = ty - sy

    ux = dx * c60 - dy * s60 + sx
    uy = dx * s60 + dy * c60 + sy

    koch(d - 1, p1, (sx, sy))
    print(""{0:.8f} {1:.8f}"".format(sx, sy))

    koch(d - 1, (sx, sy), (ux, uy))
    print(""{0:.8f} {1:.8f}"".format(ux, uy))

    koch(d - 1, (ux, uy), (tx, ty))
    print(""{0:.8f} {1:.8f}"".format(tx, ty))

    koch(d - 1, (tx, ty), p2)


n = int(input())

ax = 0
ay = 0

bx = 100
by = 0

print(""{0:.8f} {1:.8f}"".format(ax, ay))
koch(n, (ax, ay), (bx, by))
print(""{0:.8f} {1:.8f}"".format(bx, by))
"
4754534,ALDS1_5_C,"import math
cos = math.cos(math.radians(60))
sin = math.sin(math.radians(60))

def koch(count, p1x, p1y, p2x, p2y):
    global cos
    global sin
    if count == 0:
        return
    sx, sy = (2*p1x + p2x)/3, (2*p1y + p2y)/3
    tx, ty = (p1x + 2*p2x)/3, (p1y + 2*p2y)/3
    ux, uy = cos*(sx + tx) - sin*(ty - sy), sin*(tx - sx) + cos*(sy + ty)

    koch(count-1, p1x ,p1y, sx, sy)
    print(sx, sy)
    koch(count-1, sx, sy, ux, uy)
    print(ux, uy)
    koch(count-1, ux, uy, tx, ty)
    print(tx, ty)
    koch(count-1, tx, ty, p2x, p2y)

n = int(input())
print(0, 0)
koch(n, 0, 0, 100, 0)
print(100, 0)
"
4760934,ALDS1_5_C,"import math
def plot(x,y):
    print(f'{x:.8f} {y:.8f}')
def koch(n,x1,y1,x2,y2):
    if n==0:
        plot(x1,y1)
        return
    sx=(2*x1+x2)/3
    sy=(2*y1+y2)/3
    tx=(x1+2*x2)/3
    ty=(y1+2*y2)/3
    ux=(tx-sx)*(1/2)-(ty-sy)*(math.sqrt(3)/2)+sx
    uy=(tx-sx)*(math.sqrt(3)/2)+(ty-sy)*(1/2)+sy
    koch(n-1,x1,y1,sx,sy)
    koch(n-1,sx,sy,ux,uy)
    koch(n-1,ux,uy,tx,ty)
    koch(n-1,tx,ty,x2,y2)
    
n=int(input())
koch(n,0,0,100,0)
plot(100,0)



"
4761281,ALDS1_5_C,"import math

def plot(x,y):
    print(f'{x:.8f} {y:.8f}')
    
def Koch(n, x1,y1,x2,y2):
    if n == 0: 
        plot(x1,y1)        
        return
    sx = (2 * x1 + x2) / 3
    sy = (2 * y1 + y2) / 3
    tx = (x1 + 2 * x2) / 3
    ty = (y1 + 2 * y2) / 3
    ux = (tx-sx)*(1/2)-(ty-sy)*(math.sqrt(3)/2)+sx
    uy = (tx-sx)*(math.sqrt(3)/2)+(ty-sy)*(1/2)+sy
    Koch(n-1, x1, y1, sx, sy)
    Koch(n-1, sx, sy, ux, uy)
    Koch(n-1, ux, uy, tx, ty)
    Koch(n-1, tx, ty, x2, y2)

n = int(input())
Koch(n, 0, 0, 100, 0)
plot(100,0)
"
4765691,ALDS1_5_C,"import math

def plot(x,y):
    print(f'{x:.8f} {y:.8f}')
    
def koch(n,x1,y1,x2,y2):
    if n==0:
        plot(x1,y1)
        return
    sx=(2*x1+x2)/3
    sy=(2*y1+y2)/3
    tx=(x1+2*x2)/3
    ty=(y1+2*y2)/3
    ux=(tx-sx)*(1/2)-(ty-sy)*(math.sqrt(3)/2)+sx
    uy=(tx-sx)*(math.sqrt(3)/2)+(ty-sy)*(1/2)+sy
    koch(n-1,x1,y1,sx,sy)
    koch(n-1,sx,sy,ux,uy)
    koch(n-1,ux,uy,tx,ty)
    koch(n-1,tx,ty,x2,y2)

n=int(input())
koch(n,0,0,100,0)
plot(100,0)
"
8423595,ALDS1_5_D,"def m(x, n):
    global c
    if n <= 64:
        y = [x.pop()]
        for i in x[::-1]:
            n = 0
            for j in y:
                if i < j: break
                n += 1
            c += n
            y.insert(n, i)
        return y
    l = n // 2
    y = m(x[l:], n - l)
    x = m(x[:l], l)
    n = 0
    for j in y:
        while n < l and x[n] < j: n += 1
        c += l - n
    return sorted(x + y)

n = int(input())
c = 0
m([int(s) for s in input().split()], n)
print(c)
"
8621351,ALDS1_5_D,"
sentinel = 1000000001

def merge(A, left, mid, right):
    
    L = A[left:mid]
    n1 = len(L)
    L.append(sentinel)
    R = A[mid:right]
    R.append(sentinel)
    i = 0
    j = 0
    cnt = 0
    for k in range(left, right):
        if L[i] <= R[j]:
            A[k] = L[i]
            i += 1
        else:
            A[k] = R[j]
            j += 1
            cnt += n1 - i
    return cnt

def mergeSort(A, left, right):
    if left + 1 < right:
        mid = (left + right) // 2
        cnt1 = mergeSort(A, left, mid)
        cnt2 = mergeSort(A, mid, right)
        cnt3 = merge(A, left, mid, right)
        return cnt1 + cnt2 + cnt3
    else:
        return 0
        
n = int(input())
A = list(map(int, input().split()))

left = 0
right = n
mid = (left + right) // 2

print(mergeSort(A, left, right))
"
8704560,ALDS1_5_D,"sentinel = 1000000001

def merge(A, left, mid, right):
    L = A[left:mid]
    n1 = len(L)
    L.append(sentinel)
    R = A[mid:right]
    R.append(sentinel)
    i = 0
    j = 0
    cnt = 0
    for k in range(left, right):
        if L[i] <= R[j]:
            A[k] = L[i]
            i += 1
        else:
            A[k] = R[j]
            j += 1
            cnt += n1 - i
    return cnt

def mergeSort(A, left, right):
    if left + 1 < right:
        mid = (left + right) // 2
        cnt1 = mergeSort(A, left, mid)
        cnt2 = mergeSort(A, mid, right)
        cnt3 = merge(A, left, mid, right)
        return cnt1 + cnt2 + cnt3
    else:
        return 0


n = int(input())
S = list(map(int, input().split()))

cnt = 0

n_ivs =  mergeSort(S, 0, n)

print(n_ivs)

"
9203735,ALDS1_5_D,"n = int(input())
a = [0] * n
a = list(map(int, input().split()))
W = [0] * n

def swap(l, r, a):
    b = a[l]
    a[l] = a[r]
    a[r] = b

def merge_and_count(l, r, a, W):
    if l + 1 >= r:
        return 0
    elif l + 2 == r:
        if a[l] < a[l + 1]:
            return 0
        swap(l, l + 1, a)
        return 1
    m = (l + r) // 2
    cl = merge_and_count(l, m, a, W)
    cr = merge_and_count(m, r, a, W)
    c = 0
    i = l
    j = m
    k = l
    while i < m and j < r:
        if a[i] < a[j]:
            W[k] = a[i]
            i += 1
            k += 1
        else:
            W[k] = a[j]
            j += 1
            k += 1
            c += m - i
    while i < m:
        W[k] = a[i]
        k += 1
        i += 1
    while j < r:
        W[k] = a[j]
        k += 1
        j += 1
    a[l:r] = W[l:r]
    return cl + c + cr

print(merge_and_count(0, n, a, W))
"
8256222,ALDS1_5_D,"import math

count = 0
def mergesort(L):
    global count
    n = len(L)
    if n == 1:
        return L
    n_left = n//2
    n_right = n-(n//2)
    L_left,L_right = L[:(n//2)],L[(n//2):]
    sorted_left = mergesort(L_left)
    sorted_right = mergesort(L_right)
    sorted_left.append(float('inf'))
    sorted_right.append(float('inf'))
    sorted_L = []
    i,j =0,0
    for _ in range(n):
        if sorted_left[i] <= sorted_right[j]:
            sorted_L.append(sorted_left[i])
            i += 1
        else:
            sorted_L.append(sorted_right[j])
            count += (n_left - i)
            j += 1
            
    return sorted_L

    
N = int(input())
L = list(map(int,input().split()))

L = mergesort(L)
print(count)
            
"
9158166,ALDS1_5_D,"class Bit:
    def __init__(self, n):
        self.size = n
        self.tree = [0] * (n + 1)
  
    def sum(self, i):
        s = 0
        while i > 0:
            s += self.tree[i]
            i -= i & -i
        return s
  
    def add(self, i, x):
        while i <= self.size:
            self.tree[i] += x
            i += i & -i
 
m = int(input())
ppp = [*map(int,input().split())]
pppi = sorted(range(len(ppp)), key=ppp.__getitem__)

bit = Bit(m)
ans = 0
 
for i, p in enumerate(pppi):
    p += 1
    ans += i - bit.sum(p)
    bit.add(p, 1)
 
print(ans)
"
8283664,ALDS1_5_D,"

def Merge(S,left,mid,right):
    #グローバル宣言
    global cnt
    #
    L = S[left:mid] + [10 ** 9]
    R = S[mid:right] +[10 ** 9]

    i = 0
    j = 0

    for k in range(left,right):
        #Lの配列のi番目とRの配列のj番目がどっちが小さいか比較
        if L[i] <= R[j]:
            S[k] = L[i]
            i += 1
        else:
            cnt += len(L)-1 - i
            S[k] = R[j]
            j += 1

          

n = int(input())
S = list(map(int,input().split()))
cnt = 0


def MergeSort(S,left,right):

    if left +1< right:

        mid = (left + right)//2
        MergeSort(S,left,mid)
        MergeSort(S,mid,right)
        Merge(S,left,mid,right)

MergeSort(S,0,n)
print(cnt)
        

"
8876672,ALDS1_5_D,"def inversions(a):
  if len(a) == 1:
    return 0
  n = len(a)
  al, ar = a[:n//2], a[n//2:]
  pl, pr = 0, 0
  ans = 0
  ans += inversions(al) # al becomes sorted
  ans += inversions(ar) # ar becomes sorted
  for i in range(n):
    if pr == n - n // 2 or (pl != n // 2 and al[pl] <= ar[pr]):
      a[i] = al[pl]
      ans += pr
      pl += 1
    else:
      a[i] = ar[pr]
      pr += 1
  return ans

n = int(input())
a = list(map(int, input().split()))
print(inversions(a))
"
8981530,ALDS1_5_D,"n=int(input())
A=list(map(int, input().split()))

count=0
def merge(A, left, mid, right):
    global count
    L=A[left:mid+1]
    R=A[mid+1:right+1]
    L.append(float(""inf""))
    R.append(float(""inf""))
    i, j =0, 0
    mid_temp = ((left-left)+(right-left))//2
    for k in range(left, right+1):
        if L[i] <= R[j]:
            A[k] = L[i]
            i+=1
        else:
            A[k] = R[j]
            count+=mid_temp - i + 1
            j+=1
def mergesort(A, left, right):
    if left>=right:
        return
    mid=(left+right) // 2
    mergesort(A, left, mid)
    mergesort(A, mid+1, right)
    merge(A, left, mid, right)
mergesort(A, 0, n-1)
print(count)

"
8765330,ALDS1_5_D,"# aizu_ALDS1_5_D_NumberInversions_b.py  

class BIT:
    # 長さN+1の配列を初期化
    def __init__(self, N):
        self.size = N
        self.bit = [0]*(N+1)

    # i番目までの和を求める
    def sum(self, i):
        res = 0
        while i > 0:
            res += self.bit[i] # フェニック木のi番目の値を加算
            i -= -i & i # 最も右にある1の桁を0にする
        return res

    # i番目の値にxを足して更新する
    def add(self, i, x):
        while i <= self.size:
            self.bit[i] += x # フェニック木のi番目にxを足して更新
            i += -i & i # 最も右にある1の桁に1を足す

n = int(input())
A = list( map(int,input().split()))
B = sorted(A)
B = { a:i for i,a in enumerate(B,1)}
A = [B[a] for a in A]

bit=BIT(n)
ans = 0
for i,a in enumerate(A):
    ans += i - bit.sum(a-1)
    bit.add(a,1)

print(ans)
"
8911957,ALDS1_5_D,"n = int(input())
A = list(map(int,input().split()))
cnt = 0

def merge(left,mid,right):
    global cnt
    L = A[left:mid] + [1e10]
    R = A[mid:right] + [1e10]
    i = j = 0
    for k in range(left,right):
        if L[i] <= R[j]:
            A[k] = L[i]
            i += 1
        
        else:
            A[k] = R[j]
            j += 1
            cnt += (len(L)-1-i)

def mergeSort(left,right):
    if left + 1 < right:
        mid = (left + right)//2
        mergeSort(left,mid)
        mergeSort(mid,right)
        merge(left,mid,right)

mergeSort(0,n)
print(cnt)
"
8686796,ALDS1_5_D,"n = int(input())
l = list(map(int,input().split()))
s = list(set(l))
s.sort()
d = {}
for i in range(len(s)):
  d[s[i]] = i
l = [d[i] for i in l]
#bit

bit = [0 for i in range(n + 1)]
     

def sum(i):
  s = 0
  while i >= 1:
    s += bit[i]
    i -= i & -i
  return s

def add(i,x):
  while i < n+1:
    bit[i] += x
    i += i & -i
ans = 0    
for i in range(n):
  add(l[i]+1,1)
  ans += i-sum(l[i])
print(ans)
  
  

"
8778814,ALDS1_5_D,"def merge(a, left, mid, right):
    cnt = 0
    n1 = mid - left
    n2 = right - mid
    l = [0] * (n1 + 1)
    r = [0] * (n2 + 1)
    for i in range(n1):
        l[i] = a[left + i]
    for i in range(n2):
        r[i] = a[mid + i]
    l[n1] = 1000000001
    r[n2] = 1000000001
    i = j = 0
    for k in range(left, right):
        if l[i] <= r[j]:
            a[k] = l[i]
            i += 1
        else:
            a[k] = r[j]
            j += 1
            cnt += n1 - i
    return cnt


def merge_sort(a, left, right):
    if left + 1 < right:
        mid = left + (right - left) // 2
        cnt1 = merge_sort(a, left, mid)
        cnt2 = merge_sort(a, mid, right)
        cnt3 = merge(a, left, mid, right)
        return cnt1 + cnt2 + cnt3
    else:
        return 0
        
N = int(input())
arr = list(map(int, input().split()))
count = merge_sort(arr, 0, N)
print(count)
"
8533800,ALDS1_5_D,"# https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_5_D

# bubbleSort(A)
#   cnt = 0 // 反転数
#   for i = 0 to A.length-1
#     for j = A.length-1 downto i+1
#       if A[j] < A[j-1]
# 	swap(A[j], A[j-1])
# 	cnt++

#   return cnt
import math


def merge(A, left, mid, right):
    cnt = 0
    n1 = mid - left
    n2 = right - mid

    L = []
    R = []

    for i in range(n1):
        L.append(A[left + i])

    for i in range(n2):
        R.append(A[mid + i])

    L.append(math.inf)
    R.append(math.inf)

    i = 0
    j = 0

    for k in range(left, right):
        if L[i] <= R[j]:
            A[k] = L[i]
            i = i + 1
        else:
            A[k] = R[j]
            j = j + 1
            cnt += (n1 - i)
    return cnt


def merge_sort(A, left, right):
    if left + 1 < right:
        mid = (left + right)//2
        v1 = merge_sort(A, left, mid)
        v2 = merge_sort(A, mid, right)

        v3 = merge(A, left, mid, right)
        return v1 + v2 + v3
    else:
        return 0


if __name__ == ""__main__"":
    N = int(input())
    A = list(map(int, input().split()))

    print(merge_sort(A, 0, len(A)))

"
8412572,ALDS1_5_D,"from bisect import bisect_right

class Fenwick_Tree:
    def __init__(self, n):
        self.n = n
        self.data = [0] * n

    def add(self, p, x):
        p += 1
        while p <= self.n:
            self.data[p - 1] += x
            p += p & -p

    def sum(self, l, r):
        '''範囲[l, r)(lからr-1まで)の総和を求める'''
        return self._sum(r) - self._sum(l)

    def _sum(self, r):
        '''範囲[0, r)(0からr-1まで)の総和を求める'''
        s = 0
        while r > 0:
            s += self.data[r - 1]
            r -= r & -r
        return s

n = int(input())
A = list(map(int, input().split()))
sortA = sorted(A)
for i in range(n):
    ind = bisect_right(sortA, A[i])
    A[i] = ind
A.reverse()

ans = 0
FT = Fenwick_Tree(n + 10)
for i in range(n):
    ans += FT._sum(A[i] + 1)
    FT.add(A[i], 1)
print(ans)

"
9103046,ALDS1_5_D,"def merge(A, left, mid, right):
    cnt = 0

    L = A[left:mid].copy()
    R = A[mid:right].copy()

    n1 = len(L)

    i = 0
    j = 0
    for k in range(left, right):
        if i < len(L) and j < len(R):
            if L[i] <= R[j]:
                A[k] = L[i]
                i += 1
            elif j < len(R):
                A[k] = R[j]
                j += 1
                cnt += (n1 - i)
        elif j >= len(R):
            A[k] = L[i]
            i += 1
        else:
            A[k] = R[j]
            j += 1

    return cnt


def mergeSort(A, left, right):
    if left+1 < right:
        mid = (left + right) // 2
        v1 = mergeSort(A, left, mid)
        v2 = mergeSort(A, mid, right)
        v3 = merge(A, left, mid, right)

        return v1 + v2 + v3
    else:
        return 0


n = int(input())
A = list(map(int, input().split()))

ans = mergeSort(A, 0, n)

print(ans)

"
8830012,ALDS1_5_D,"sum = 0
cnt = 0
def merge(A, left, mid, right):
    global sum,cnt 
    L = A[left:mid]+[2**31-1]
    R = A[mid:right]+[2**31-1]
    i = 0
    j = 0
    for k in range(left , right):
        sum += 1
        if(L[i] <= R[j]):
            A[k] = L[i]
            i += 1
        else:
            A[k] = R[j]
            cnt+=len(L)-i-1
            j += 1
    
def mergeSort(A,left,right):
    if(left+1<right):
        mid = int((left + right) /2)
        mergeSort(A,left,mid)
        mergeSort(A,mid,right)
        merge(A,left,mid,right)

n = int(input())
S = list(map(int,input().strip().split()))
mergeSort(S,0,n)
print(cnt)

"
8508937,ALDS1_5_D,"count = 0

def merge(left, right):
    global count
    sorted_list =[]
    left_index = 0
    right_index = 0

    while left_index < len(left) and right_index < len(right):
        if left[left_index] <= right[right_index]:
            sorted_list.append(left[left_index])
            left_index += 1
        else:
            sorted_list.append(right[right_index])
            right_index += 1
            count += len(left) - left_index

    if left:
        sorted_list.extend(left[left_index:])
    if right:
        sorted_list.extend(right[right_index:])

    return sorted_list

def margeSort(aList):
    if len(aList) <= 1:
        return aList
    
    mid = len(aList) // 2
    left = aList[:mid]  # 左側のリスト
    right = aList[mid:] # 右側のリスト
    # print ('(1) left: {}, right: {}'.format(left, right))

    left = margeSort(left)
    right = margeSort(right)
    # print ('(2) left: {}, right: {}'.format(left, right))
    
    return list(merge(left, right))

def main():
    n = int(input())
    S = list(map(int, input().split()))
    
    margeSort(S)
    print(count)
    
if __name__ == ""__main__"":
    main()

"
8690226,ALDS1_5_D,"import math

def merge(A, left, mid, right):
    n1 = mid - left
    n2 = right - mid
    L = [A[left + i] for i in range(n1)]
    R = [A[mid + i] for i in range(n2)]
    L.append(math.inf)
    R.append(math.inf)
    
    i = 0
    j = 0
    cnt = 0
    for k in range(left, right):
        if L[i] <= R[j]:
            A[k] = L[i]
            i += 1
        else:
            A[k] = R[j]
            j += 1
            cnt += mid - left - i
    return cnt
            
def mergeSort(A, left, right):
    cnt = 0
    if left + 1 < right:
        mid = (left + right) // 2
        cnt += mergeSort(A,left, mid)
        cnt += mergeSort(A, mid, right)
        cnt += merge(A,left, mid, right)
    return cnt
        
n = int(input())
A = list(map(int, input().split(' ')))

cnt = mergeSort(A, 0, n)
print(cnt)
"
8941762,ALDS1_5_D,"cnt = 0
INF = 10**11

def merge(A:list, start:int, mid:int, end:int):
    n1 = mid-start
    n2 = end-mid
    global cnt

    P = [A[i] for i in range(start, mid)]+[INF]
    Q = [A[i] for i in range(mid, end)]+[INF]
    i, j = 0, 0
    for k in range(start, end):
            if P[i] >= Q[j]:
                A[k] = Q[j]
                j += 1
                cnt += len(P) - i - 1
            else:
                A[k] = P[i]
                i += 1

def calc_rev(A:list, start:int, end:int):
    mid = (start + end) // 2
    if start + 1 < end:
        calc_rev(A, start, mid)
        calc_rev(A, mid, end)
        merge(A, start, mid, end)

n = int(input())
A = list(map(int, input().split()))
calc_rev(A, 0, n)
# print(*A)
print(cnt)

"
9017674,ALDS1_5_D,"class BinaryIndexedTree:
    def __init__(self, n):
        self.n = n
        self.tree = [0] * (n + 1)

    def prefix_sum(self, i):
        res = 0
        while i > 0:
            res += self.tree[i]
            i -= i & -i
        return res

    def add(self, i, x):
        i += 1
        while i <= self.n:
            self.tree[i] += x
            i += i & -i

    def range_sum(self, l, r):
        return self.prefix_sum(r) - self.prefix_sum(l)


N: int = int(input())
A = list(map(int, input().split()))

rank = {a: i for i, a in enumerate(sorted(set(A)))}

bit = BinaryIndexedTree(N + 1)
ans = 0
for i in range(N):
    ans += bit.range_sum(rank[A[i]], N + 1)
    bit.add(rank[A[i]], 1)

print(ans)

"
9059772,ALDS1_5_D,"import math
def merge(A, left, mid, right):
    n1 = mid - left
    n2 = right - mid
    # L[0...n1], R[0...n2] を生成
    L = [A[left + i] for i in range(n1)] + [math.inf] 
    R = [A[mid + i] for i in range(n2)] + [math.inf]
    i = 0
    j = 0
    global cnt
    for k in range(left, right):
        if L[i] <= R[j]:
            A[k] = L[i]
            i += 1
        else:
            A[k] = R[j]
            j += 1
            cnt += len(L)-i-1
   
def mergeSort(A, left, right):
    if left + 1 < right:
        mid = (left + right) // 2
        mergeSort(A, left, mid)
        mergeSort(A, mid, right)
        merge(A, left, mid, right)
        
n = int(input())
A = list(map(int, input().split()))
cnt = 0
mergeSort(A, 0, n)
print(cnt)
"
8762939,ALDS1_5_D,"def merge(A,l,m,r):
    global cnt
    n1 = m-l
    n2 = r-m
    L = [i for i in range(n1+1)]
    R = [i for i in range(n2+1)] 
    for i in range(n1):
        L[i] = A[l+i]
    for i in range(n2):
        R[i] = A[m+i]
    L[-1] = R[-1] = float('inf')
    i = j = 0
    for k in range (l,r):
        if L[i] <= R[j]:
            A[k] = L[i]
            i += 1
        else: 
            A[k] = R[j]
            j += 1
            cnt += n1-i
        
def mergeSort(A,l,r):
    if l+1 < r:
        m = (l+r)//2
        mergeSort(A,l,m)
        mergeSort(A,m,r)
        merge(A,l,m,r)

n = int(input())
*A, = map(int, input().split())
cnt = 0
mergeSort(A,0,n)
print(cnt)
"
8322182,ALDS1_5_D,"global count
def merge(A, left, mid, right):
    global count
    n1 = mid - left
    n2 = right - mid
    L = list(range(n1+1))
    R = list(range(n2+1))
    for i in set(range(n1)):
        L[i] = A[left + i]
    for i in set(range(n2)):
        R[i] = A[mid + i]
    L[n1] = 10**10
    R[n2] = 10**10
    i = 0
    j = 0
    for k in range(left, right):
        if L[i] <= R[j]:
            A[k] = L[i]
            i += 1
        else:
            A[k] = R[j]
            j += 1
            count += n1 - i

def mergeSort(A, left, right):
    if left+1 < right:
        mid = (left + right) // 2
        mergeSort(A, left, mid)
        mergeSort(A, mid, right)
        merge(A, left, mid, right)

n = int(input())
S = list(map(int, input().split()))
count = 0
mergeSort(S, 0, n)
print(count)

"
5220473,ALDS1_5_D,"def inversion_number(a: list) -> int:
    """"""a(0 or 1-indexedで座圧済)の転倒数を求める""""""
    n = len(a)
    tree = [0] * (n + 1)
    res = n * (n - 1) // 2
    for i in a:
        s = 0
        j = i - 1
        while j >= 0:
            s += tree[j]
            j = (j & (j + 1)) - 1
        res -= s
        while i < n:
            tree[i] += 1
            i |= i + 1
    return res


def compress(arr):
    return list(map({e: i for i, e in enumerate(sorted(set(arr)))}.__getitem__, arr))


import sys
input = sys.stdin.readline

n = int(input())
a = compress(list(map(int, input().split())))
print(inversion_number(a))

"
7433239,ALDS1_5_D,"def count(an, sn) -> int:
    assert len(an) == len(sn)

    if len(an) < 2:
        return 0

    mid = len(sn) // 2
    s = sn[mid]

    ret = 0
    smaller = []
    larger = []

    for a in an:
        if a < s:
            smaller.append(a)
            ret += len(larger)
        else:
            larger.append(a)

    return ret + count(smaller, sn[:mid]) + count(larger, sn[mid:])


if __name__ == ""__main__"":
    n = int(input())
    an = list(map(int, input().split()))
    sn = list(sorted(an))

    print(str(count(an, sn)))

"
6467705,ALDS1_5_D,"""""""
転倒数
a が座標圧縮されていることを仮定している（順列でなくてもよい）。
""""""
def inversion(a):
    def getsum(i): #閉区間
        s = 0; i += 1
        while i > 0:
            s += data[i]
            i -= i & -i
        return s
    def add(i,x):
        i += 1
        while i <= n:
            data[i] += x
            i += i & -i

    n = len(a)
    data = [0]*(n+1)
    v = n*(n-1)//2
    for ai in a:
        v -= getsum(ai)
        add(ai,1)
    return v

n = int(input())
*a, = map(int,input().split())
sa = sorted(a)
za = {x:i for i,x in enumerate(sa)}
for i in range(n):
    a[i] = za[a[i]]
ans = inversion(a)
print(ans)
    


"
7988083,ALDS1_5_D,"_ = input()
arr = list(map(int, input().split()))

def merge_sort(arr):
  def sort(begin, end):
    nonlocal num_swaps

    # Recursion
    mid = (begin + end) >> 1
    if begin + 1 < mid:
      sort(begin, mid)
    if mid + 1 < end:
      sort(mid, end)

    # Merge
    l_arr, r_arr = arr[begin:mid] + [infinite_liked_num], arr[mid:end] + [infinite_liked_num]
    l_i, r_i = 0, 0
    l_arr_len = mid - begin
    for i in range(begin, end):
      l_val, r_val = l_arr[l_i], r_arr[r_i]
      if l_val <= r_val:
        arr[i] = l_val
        l_i += 1
      else:
        num_swaps += l_arr_len - l_i
        arr[i] = r_val
        r_i += 1

  infinite_liked_num = 2 ** 63
  num_swaps = 0
  sort(0, len(arr))
  return arr, num_swaps

print(merge_sort(arr)[1])
"
6365649,ALDS1_5_D,"import sys
readline = sys.stdin.readline
write = sys.stdout.write

N = int(readline())
*A, = map(int, readline().split())

data = [0]*(N+1)
def add(k, v):
    while k <= N:
        data[k] += v
        k += k & -k
def get(k):
    s = 0
    while k:
        s += data[k]
        k -= k & -k
    return s


ans = N*(N-1)//2
for a in map({a: i+1 for i, a in enumerate(sorted(A))}.__getitem__, A):
    ans -= get(a)
    add(a, 1)
write(""%d\n"" % ans)



"
7795362,ALDS1_5_D,"import sys
readline = sys.stdin.readline
write = sys.stdout.write

N = int(readline())
*A, = map(int, readline().split())

data = [0]*(N+1)
def add(k, v):
    while k <= N:
        data[k] += v
        k += k & -k
def get(k):
    s = 0
    while k:
        s += data[k]
        k -= k & -k
    return s


ans = N*(N-1)//2
for a in map({a: i+1 for i, a in enumerate(sorted(A))}.__getitem__, A):
    ans -= get(a)
    add(a, 1)
write(""%d\n"" % ans)
"
3184136,ALDS1_5_D,"import sys
readline = sys.stdin.readline
write = sys.stdout.write

N = int(readline())
*A, = map(int, readline().split())

data = [0]*(N+1)
def add(k, v):
    while k <= N:
        data[k] += v
        k += k & -k
def get(k):
    s = 0
    while k:
        s += data[k]
        k -= k & -k
    return s


ans = N*(N-1)//2
for a in map({a: i+1 for i, a in enumerate(sorted(A))}.__getitem__, A):
    ans -= get(a)
    add(a, 1)
write(""%d\n"" % ans)


"
7576277,ALDS1_5_D,"import sys
readline = sys.stdin.readline
write = sys.stdout.write

N = int(readline())
*A, = map(int, readline().split())

data = [0]*(N+1)
def add(k, v):
    while k <= N:
        data[k] += v
        k += k & -k
def get(k):
    s = 0
    while k:
        s += data[k]
        k -= k & -k
    return s


ans = N*(N-1)//2
for a in map({a: i+1 for i, a in enumerate(sorted(A))}.__getitem__, A):
    ans -= get(a)
    add(a, 1)
write(""%d\n"" % ans)

"
7608343,ALDS1_5_D,"import sys
readline = sys.stdin.readline
write = sys.stdout.write

N = int(readline())
*A, = map(int, readline().split())

data = [0]*(N+1)
def add(k, v):
    while k <= N:
        data[k] += v
        k += k & -k
def get(k):
    s = 0
    while k:
        s += data[k]
        k -= k & -k
    return s


ans = N*(N-1)//2
for a in map({a: i+1 for i, a in enumerate(sorted(A))}.__getitem__, A):
    ans -= get(a)
    add(a, 1)
write(""%d\n"" % ans)


"
6313684,ALDS1_5_D,"N = int(input())
*A, = map(int, input().split())

data = [0] * (N + 1)
def add(k, v):
    while k <= N:
        data[k] += v
        k += k & -k
def get(k):
    s = 0
    while k:
        s += data[k]
        k -= k & -k
    return s

ans = N * (N - 1) // 2
for a in map({a: i+1 for i, a in enumerate(sorted(A))}.__getitem__, A):
    ans -= get(a)
    add(a, 1)
print(ans)
"
4729647,ALDS1_5_D,"import sys,queue,math,copy,itertools,bisect,collections,heapq

def main():
    LI = lambda : [int(x) for x in sys.stdin.readline().split()]
    NI = lambda : int(sys.stdin.readline())

    n = NI()
    A = LI()
    S = sorted(A)

    bit = [0] * (n+1)

    def bit_add(i,x):
        while i <= n:
            bit[i] += x
            i += i & (-i)

    def bit_sum(i):
        ret = 0
        while i > 0:
            ret += bit[i]
            i -= i & (-i)
        return ret

    ans = 0
    for i,x in enumerate(A):
        z = bisect.bisect_left(S,x) + 1
        bit_add(z,1)
        ans += z - bit_sum(z)
    print (ans)

if __name__ == '__main__':
    main()
"
5826449,ALDS1_5_D,"N = int(input())
*A, = map(int, input().split())

data = [0]*(N+1)
def add(k, v):
    while k <= N:
        data[k] += v
        k += k & -k
def get(k):
    s = 0
    while k:
        s += data[k]
        k -= k & -k
    return s


ans = N*(N-1)//2
for a in map({a: i+1 for i, a in enumerate(sorted(A))}.__getitem__, A):
    ans -= get(a)
    add(a, 1)
print(ans)
"
3567599,ALDS1_5_D,"class BinaryIndexedTree(object):
    __slots__ = [""tree"", ""size""]

    def __init__(self, size: int):
        self.tree = [0]*(size+1)
        self.size = size+1

    def add(self, index: int, value: int):
        tree = self.tree

        while index < len(tree):
            tree[index] += value
            index += index & -index

    def sum(self, index: int):
        tree, result = self.tree, 0

        while index:
            result += tree[index]
            index -= index & -index

        return result


def solve(A):
    bit = BinaryIndexedTree(len(A)+1)
    ans = 0
    for i, n in enumerate(A):
        ans += i - bit.sum(n-1)
        bit.add(n, 1)

    return ans


if __name__ == ""__main__"":
    input()
    a = list(map(int, input().split()))
    d = {n: i for i, n in enumerate(sorted(a), start=1)}
    a = [d[n] for n in a]
    print(solve(a))
"
4279634,ALDS1_5_D,"INF = 10**9 + 1
def merge(A: list, left: int, mid: int, right: int) -> int:
    '''
    2つの配列をmergeする関数

    Aはこのプログラムで処理する配列。
    left, mid, rightはAのindex。
    '''
    cnt = 0  # mergeするときに何回反転するか
    n1 = mid-left  # 右の方の配列のlen (反転数を計算するときにこいつを使う)
    # n2 = right-mid  # 左の方の配列のlen ぶっちゃけいらない

    L = A[left:mid]  # python sliceはshallow copyらしい
    L.append(INF)  # 番兵
    R = A[mid:right]
    R.append(INF)  # 番兵

    i_l, i_r = 0, 0  # LとRのコントロール用idx
    for k in range(left, right):
        # L,Rの先頭を比較していって小さい方をAに打ち込む
        if L[i_l] <= R[i_r]:
            A[k] = L[i_l]
            i_l += 1
        else:
            A[k] = R[i_r]
            i_r += 1
            cnt += n1-i_l  # ここが重要 反転したときだけ反点数を足し込んでいく
    return cnt


def merge_sort(A: list, left: int, right: int):
    '''
    マージソートをしつつ、反転数を再帰的に計算する。

    ここではマージを再帰的に適応し反転数をどんどん上に伝播させていく仕組み
    '''
    if left + 1 >= right:  # 終了条件
        return 0

    mid = (left+right)//2
    v1 = merge_sort(A, left, mid)  # 右左にも再帰的にmerge_sortを適応
    v2 = merge_sort(A, mid, right)
    v3 = merge(A, left, mid, right)  # 右左整ったらmerge

    return v1+v2+v3


n = int(input())
A = list(map(int, input().split()))
print(merge_sort(A, 0, n))
"
3905200,ALDS1_5_D,"# AOJ ALDS1_5_D ""The Number of Inversions""
# 転倒数をO(NlogN)で求める

N = int(input())
A = list(map(int, input().split()))

# binary indexed tree
bit = [0 for _ in range(N+1)]

# 0からiまでの区間和
# 立っているビットを下から処理
def query_sum(i):
    s = 0
    while i > 0:
        s += bit[i]
        i -= i & -i
    return s

# i番目の要素にxを足す
# 覆ってる区間すべてに足す
def add(i, x):
    while i <= N:
        bit[i] += x
        i += i & -i

# 座標圧縮
ind_to_co = sorted(A)
co_to_ind = {}
for i, x in enumerate(ind_to_co):
    co_to_ind[x] = i+1

# それまでに「i<=jかつai<=aj」となっているものをBITに加えていく
ans = 0
for j, a in enumerate(A):
    ind_a = co_to_ind[a]
    ans += j - query_sum(ind_a)
    add(ind_a, 1)

print(ans)
"
3919484,ALDS1_5_D,"# ぶっちゃけアイデアを理解するのが難しかった。
# 詳細な解説は本を読もう
# 長さ2の配列ならば反転数をもとめるのは一瞬
# 2つの配列をソートしながらマージするときについでに反転数が求まるのが鍵で、これを実装に組み込む

INF = 10**9 + 1


def merge(A: list, left: int, mid: int, right: int) -> int:
    '''
    2つの配列をmergeする関数

    Aはこのプログラムで処理する配列。
    left, mid, rightはAのindex。
    '''
    cnt = 0  # mergeするときに何回反転するか
    n1 = mid-left  # 右の方の配列のlen (反転数を計算するときにこいつを使う)
    # n2 = right-mid  # 左の方の配列のlen ぶっちゃけいらない

    L = A[left:mid]  # python sliceはshallow copyらしい
    L.append(INF)  # 番兵
    R = A[mid:right]
    R.append(INF)  # 番兵

    i_l, i_r = 0, 0  # LとRのコントロール用idx
    for k in range(left, right):
        # L,Rの先頭を比較していって小さい方をAに打ち込む
        if L[i_l] <= R[i_r]:
            A[k] = L[i_l]
            i_l += 1
        else:
            A[k] = R[i_r]
            i_r += 1
            cnt += n1-i_l  # ここが重要 反転したときだけ反点数を足し込んでいく
    return cnt


def merge_sort(A: list, left: int, right: int):
    '''
    マージソートをしつつ、反転数を再帰的に計算する。

    ここではマージを再帰的に適応し反転数をどんどん上に伝播させていく仕組み
    '''
    if left + 1 >= right:  # 終了条件
        return 0

    mid = (left+right)//2
    v1 = merge_sort(A, left, mid)  # 右左にも再帰的にmerge_sortを適応
    v2 = merge_sort(A, mid, right)
    v3 = merge(A, left, mid, right)  # 右左整ったらmerge

    return v1+v2+v3


n = int(input())
A = list(map(int, input().split()))
print(merge_sort(A, 0, n))

"
4339420,ALDS1_5_D,"INF = 10**9 + 1
def merge(A: list, left: int, mid: int, right: int) -> int:
  cnt = 0
  n1 = mid - left

  L = A[left:mid]
  L.append(INF)
  R = A[mid:right]
  R.append(INF)

  i_l, i_r = 0, 0
  for k in range(left, right):
    if L[i_l] <= R[i_r]:
      A[k] = L[i_l]
      i_l += 1
    else:
      A[k] = R[i_r]
      i_r += 1
      cnt += n1 - i_l
  return cnt

def merge_sort(A: list, left: int, right: int):
  if left + 1 >= right:
    return 0

  mid = (left + right) // 2
  v1 = merge_sort(A, left, mid)
  v2 = merge_sort(A, mid, right)
  v3 = merge(A, left, mid, right)

  return v1 + v2 + v3

n = int(input())
A = list(map(int, input().split()))
print(merge_sort(A, 0, n))

"
5483889,ALDS1_5_D,"from bisect import bisect_left as bl

def solve():
    n = int(input())
    a = [int(i) for i in input().split()]
    b = sorted(a)
    c = [0] * n
    
    for i in range(n):
        c[i] = bl(b, a[i]) + 1
    
    max_n = 1
    while max_n < n: max_n <<= 1
    bit = [0] * (max_n + 1)
    
    def add(i, x):
        while i <= max_n:
            bit[i] += x
            i += i & -i
    
    def sum_a(i):
        res = 0
        while i > 0:
            res += bit[i]
            i -= i & -i
        return res
    
    ans = 0
    for i in range(n):
        ans += i - sum_a(c[i])
        add(c[i], 1)
        #print(ans, bit)
    
    return ans

print(solve())

"
6078129,ALDS1_5_D,"#RSQ
n = int(input())
a = list(map(int,input().split()))
sa = sorted(a)
dict = {sa[i]:i+1 for i in range(n)}
a = [dict[a[i]] for i in range(n)]
#n:数列の長さ
BIT = [0 for i in range(n+1)]
def add(i,x):
    while i<=n:
        BIT[i]+=x
        i += (i&-i)
#xまでの和をとる
def getSum(x):
    i = x
    gs = 0
    while i>0:
        gs+=BIT[i]
        i -= (i&-i)
    return gs
ans = 0
for i in reversed(range(n)):
    ans+=getSum(a[i])
    add(a[i],1)
print(ans)
"
2713553,ALDS1_5_D,"def g(A,l,m,r):
 global c
 L,R=A[l:m]+[1e9],A[m:r]+[1e9]
 i=j=0
 for k in range(l,r):
  if L[i]<R[j]:A[k]=L[i];i+=1;c+=j
  else:A[k]=R[j];j+=1
def s(A,l,r):
 if l+1<r:m=(l+r)//2;s(A,l,m);s(A,m,r);g(A,l,m,r)
c=0
n=int(input())
A=list(map(int,input().split()))
s(A,0,n)
print(c)
"
3789490,ALDS1_5_D,"def g(A,l,m,r):
 global c
 L,R=A[l:m]+[1e9],A[m:r]+[1e9]
 i=j=0
 for k in range(l,r):
  if L[i]<R[j]:A[k]=L[i];i+=1;c+=j
  else:A[k]=R[j];j+=1
def s(A,l,r):
 if l+1<r:m=(l+r)//2;s(A,l,m);s(A,m,r);g(A,l,m,r)
c=0
n=int(input())
A=list(map(int,input().split()))
s(A,0,n)
print(c)
"
4442972,ALDS1_5_D,"def g(A,l,m,r):
    global c
    L, R = A[l:m]+[1e9] , A[m:r]+[1e9]
    i=j=0
    for k in range(l,r):
        if L[i]<R[j]:
            A[k]=L[i]
            i+=1
            c+=j
        else:
            A[k]=R[j]
            j+=1
def s(A,l,r):
    if l+1<r:
        m=(l+r)//2
        s(A,l,m)
        s(A,m,r)
        g(A,l,m,r)
c=0
n=int(input())
A=list(map(int,input().split()))
s(A,0,n)
print(c)
"
5313894,ALDS1_5_D,"def merge(A, left, mid, right):
    INF = 10**10
    L = A[left:mid] + [INF]
    R = A[mid:right] + [INF]
    n1 = len(L) - 1

    i = 0
    j = 0
    cnt = 0
    for k in range(left, right):
        if L[i] <= R[j]:
            A[k] = L[i]
            i += 1
        else:
            A[k] = R[j]
            j += 1
            cnt += n1 - i
    return cnt


def mergeSort(A, left, right):
    if left + 1 < right:
        mid = (left + right) // 2
        cnt_L = mergeSort(A, left, mid)
        cnt_R = mergeSort(A, mid, right)
        return merge(A, left, mid, right) + cnt_L + cnt_R
    return 0


n = int(input())
A = list(map(int, input().split()))
ans = mergeSort(A, 0, n)
print(ans)

"
7179567,ALDS1_5_D,"import sys
input = sys.stdin.readline

n = int(input())
a = list(map(int, input().split()))

def merge(a, left, mid, right):
    global counter
    l = a[left:mid] + [10**9+1]
    r = a[mid:right] + [10**9+1]
    i = 0
    j = 0
    for k in range(left, right):
        if l[i] <= r[j]:
            a[k] = l[i]
            i += 1
            counter += j
        else:
            a[k] = r[j]
            j += 1

def mergeSort(a, left, right):
    if left+1 < right:
        mid = (left+right)//2
        mergeSort(a, left, mid)
        mergeSort(a, mid, right)
        merge(a, left, mid, right)

if __name__ == '__main__':
    counter = 0

    mergeSort(a, 0, n)
    print(counter)

"
3117508,ALDS1_5_D,"n = int(input())
A = [(i + 1, int(j)) for i, j in enumerate(input().split())]
A.sort(key=lambda x: -x[1])

class BIT:
    def __init__(self, n):
        self.data = [0] * (n + 1)
    def add(self, i, x):
        while i <= n:
            self.data[i] += x
            # 区間の長さ
            i += i & -i

    def get(self, i):
        s = 0
        while i:
            s += self.data[i]
            i -= i & -i
        return s

b = BIT(n)
ans = 0
for i, j in A:
    ans += b.get(i)
    b.add(i, 1)
print(ans)
"
4047513,ALDS1_5_D,"INF = int(1e18)

def merge(A, left, mid, right):
    L = A[left:mid]
    n1 = len(L)
    R = A[mid:right]
    L.append(INF)
    R.append(INF)
    i, j, count = 0, 0, 0
    for k in range(left, right):
        if L[i] <= R[j]:
            A[k] = L[i]
            i += 1
        else:
            A[k] = R[j]
            j += 1
            # Lで超える分がひっくり返す回数 (?)
            count += n1 - i
    return count

def merge_sort(A, left, right):
    if left + 1 < right:
        mid = (left + right) // 2
        c1 = merge_sort(A, left, mid)
        c2 = merge_sort(A, mid, right)
        c3 = merge(A, left, mid, right)
        return c1 + c2 + c3
    else:
        return 0

if __name__ == '__main__':
    n = int(input())
    A = list(map(int, input().split()))
    c = merge_sort(A, 0, n)
    print(c)
"
4163708,ALDS1_5_D,"# 長さ1の配列ならば反転数は0
# 2つの配列をソートしながらマージするときについでに反転数が求まるのが鍵で、これを実装に組み込む

INF = 10**9 + 1
def merge(A: list, left: int, mid: int, right: int) -> int:
    '''
    2つの配列をmergeする関数

    Aはこのプログラムで処理する配列。
    left, mid, rightはAのindex。
    '''
    cnt = 0  # mergeするときに何回反転するか
    n1 = mid-left  # 右の方の配列のlen (反転数を計算するときにこいつを使う)
    # n2 = right-mid  # 左の方の配列のlen ぶっちゃけいらない

    L = A[left:mid]  # python sliceはshallow copyらしい
    L.append(INF)  # 番兵
    R = A[mid:right]
    R.append(INF)  # 番兵

    i_l, i_r = 0, 0  # LとRのコントロール用idx
    for k in range(left, right):
        # L,Rの先頭を比較していって小さい方をAに打ち込む
        if L[i_l] <= R[i_r]:
            A[k] = L[i_l]
            i_l += 1
        else:
            A[k] = R[i_r]
            i_r += 1
            cnt += n1-i_l  # ここが重要 反転したときだけ反点数を足し込んでいく
    return cnt


def merge_sort(A: list, left: int, right: int):
    '''
    マージソートをしつつ、反転数を再帰的に計算する。

    ここではマージを再帰的に適応し反転数をどんどん上に伝播させていく仕組み
    '''
    if left + 1 >= right:  # 終了条件
        return 0

    mid = (left+right)//2
    v1 = merge_sort(A, left, mid)  # 右左にも再帰的にmerge_sortを適応
    v2 = merge_sort(A, mid, right)
    v3 = merge(A, left, mid, right)  # 右左整ったらmerge

    return v1+v2+v3


n = int(input())
A = list(map(int, input().split()))
print(merge_sort(A, 0, n))
"
4238231,ALDS1_5_D,"INF = int(1e9)
def merge(A, left, mid, right):
    n1 = mid - left
    n2 = right - mid
    n = len(A)
    L = A[left:mid] + [INF] 
    R = A[mid:right] + [INF]
    i = 0
    j = 0
    cnt = 0
    for k in range(left, right):
        if L[i] <= R[j]:
            A[k] = L[i]
            i = i + 1
        else:
            A[k] = R[j]
            j = j + 1
            cnt = cnt + n1 - i
    return cnt

def mergeSort(A, left, right):
    if left+1 < right:
        mid = (left+right)//2
        cnt1 = mergeSort(A, left, mid)
        cnt2 = mergeSort(A, mid, right)
        cnt3 = merge(A, left, mid, right)
        return (cnt1 + cnt2 + cnt3)
    else: 
        return 0

def main():
    n = int(input())
    a = [int(i) for i in input().split()]
    ans = mergeSort(a, 0, n)
    print(ans)
main()
"
4984250,ALDS1_5_D,"import math

n = int(input())
A = list(map(int, input().split()))

def mergeSort(A, left, right):
    if left+1 < right:
        mid = math.floor((left + right) / 2)
        cntL = mergeSort(A, left, mid)
        cntR = mergeSort(A, mid, right)
        return merge(A, left, mid, right) + cntL + cntR
    return 0

def merge(A, left,mid, right):
    n1 = mid - left
    n2 = right - mid
    cnt = 0
    L = A[left:mid] +[2000000000]
    R = A[mid:right]+[2000000000]

    i = 0
    j = 0
    for k in range(left, right):
        if(L[i] <= R[j]):
            A[k] = L[i]
            i += 1
        else:
            cnt += n1 - i
            A[k] = R[j]
            j += 1
    return cnt
    
ans = mergeSort(A, 0, n)
print(ans)
"
5181343,ALDS1_5_D,"#転倒数(==はカウントしない)
#1-origin
#comp==1で座標圧縮する
def rev_num(N,a,comp):

	def ADD(x,y):#A[x]+=y
		while x<=nn:
			BIT[x-1]+=y
			x+=x&(-x)
	def SUM(l):#A[1]からA[l]までの和
		ret=0
		while l>=1:
			ret+=BIT[l-1]
			l-=l&(-l)
		return ret

	#座標圧縮
	if comp==1:
		b=sorted(list(set(a)))
		c={}
		for i in range(len(b)):
			c[b[i]]=i
		for i in range(N):
			a[i]=c[a[i]]

	nn=max(a)+1
	BIT=[0]*nn

	ans=0
	for i in range(N):
		ADD(a[i]+1,1)
		ans+=i+1-SUM(a[i]+1)

	return ans

n=int(input())
a=list(map(int,input().split()))

print(rev_num(n,a,1))
"
5440932,ALDS1_5_D,"import sys
sys.setrecursionlimit(10**7)
INF=float('INF')
def merge(l,m,r):
    global cnt
    L=a[l:m]+[INF]
    R=a[m:r]+[INF]
    i,j=0,0
    for k in range(l,r):
        if L[i]<=R[j]:
            a[k]=L[i]
            i+=1
            cnt+=j
        else:
            a[k]=R[j]
            j+=1

def mergeSort(l,r):
    if l+1<r:
        m=(l+r)//2
        mergeSort(l,m)
        mergeSort(m,r)
        merge(l,m,r)

N=int(input())
a=list(map(int,input().split()))
cnt=0
mergeSort(0,N)

print(cnt)
"
5759511,ALDS1_5_D,"def merge(A, left, mid, right):
    global c
    L, R = A[left:mid] + [1e9], A[mid:right] + [1e9]
    i = j = 0
    for k in range(left, right):
        if L[i] < R[j]:
            A[k] = L[i]; i += 1; c += j
        else:
            A[k] = R[j]; j += 1
def merge_sort(A, left, right):
    if left + 1 < right:
        mid = (left + right) // 2
        merge_sort(A, left, mid)
        merge_sort(A, mid, right)
        merge(A, left, mid, right)
c = 0
n = int(input())
A = list(map(int, input().split()))
merge_sort(A, 0, n)
print(c)

"
7536575,ALDS1_5_D,"# 5_D.py

from math import inf

def number_of_inverse(a):
    def merge(left, mid, right):
        nonlocal inverse

        L = a[left:mid] + [inf]
        R = a[mid:right] + [inf]
        i, j = 0, 0
        for k in range(left, right):
            if L[i] <= R[j]:
                a[k] = L[i]
                i += 1
            else:
                inverse += mid + j - k
                a[k] = R[j]
                j += 1

    def rec(left, right):
        if left + 1 < right:
            mid = (left + right) // 2
            rec(left, mid)
            rec(mid, right)
            merge(left, mid, right)

    inverse = 0
    rec(0, len(a))
    return inverse

n = int(input())
a = [int(e) for e in input().split()]
print(number_of_inverse(a))

"
2690145,ALDS1_5_D,"INF = float(""inf"")
cnt = 0
def merge(A, left, mid, right):
    global cnt
    L = A[left: mid] + [INF]
    R = A[mid: right] + [INF]
    i = j = 0
    for k in range(left, right):
        if L[i] <= R[j]:
            A[k] = L[i]
            cnt += j
            i += 1
        else:
            A[k] = R[j]
            j += 1
def mergeSort(A, left, right):
    if left + 1 < right:
        mid = (left + right) // 2
        mergeSort(A, left, mid)
        mergeSort(A, mid, right)
        merge(A, left, mid, right)
n = int(input())
S = list(map(int, input().split()))
mergeSort(S, 0, n)
print(cnt)

"
3994878,ALDS1_5_D,"# alds1_5_d
INF = 1e11

def merge(A, left, mid, right):
    n_inv = 0
    L = A[left:mid] + [INF]
    R = A[mid:right] + [INF]
    len_L = len(L) - 1

    i = 0
    j = 0
    for k in range(left, right):
        if L[i] <= R[j]:
            A[k] = L[i]
            i += 1
        else:
            A[k] = R[j]
            j += 1
            n_inv += len_L - i
    return n_inv


def merge_sort(A, left, right):
    if left + 1 < right:
        mid = (left + right) // 2
        inv_l = merge_sort(A, left, mid)
        inv_r = merge_sort(A, mid, right)
        return merge(A, left, mid, right) + inv_l + inv_r
    return 0

if __name__ == ""__main__"":
    n = int(input())
    A = [int(i) for i in input().split()]
    print(merge_sort(A, 0, n))
"
4096639,ALDS1_5_D,"def merge(s, left, mid, right):
    global count
    n1 = mid - left
    n2 = right - mid
    L = s[left:mid] + [1000000001]
    R = s[mid:right] + [1000000001]

    i = 0
    j = 0
    for k in range(left,right):
        if L[i] <= R[j]:
            s[k] = L[i]
            i += 1
        else:
            s[k] = R[j]
            j += 1
            count += (n1 -i)

def mergesort(s, left, right):
    if left + 1 < right:
        mid = (left + right) // 2
        mergesort(s, left, mid)
        mergesort(s, mid, right)
        merge(s, left, mid, right)

n = int(input())
count = 0
s = list(map(int, input().split()))
mergesort(s, 0, n)
print(count)

"
4443534,ALDS1_5_D,"INF = 10**9 + 1
def merge(A: list, left: int, mid: int, right: int) -> int:
    '''
    2つの配列をmergeする関数

    Aはこのプログラムで処理する配列。
    left, mid, rightはAのindex。
    '''
    cnt = 0  # mergeするときに何回反転するか
    n1 = mid-left  # 右の方の配列のlen (反転数を計算するときにこいつを使う)
    # n2 = right-mid  # 左の方の配列のlen ぶっちゃけいらない

    L = A[left:mid]  # python sliceはshallow copyらしい
    L.append(INF)  # 番兵
    R = A[mid:right]
    R.append(INF)  # 番兵

    i_l, i_r = 0, 0  # LとRのコントロール用idx
    for k in range(left, right):
        # L,Rの先頭を比較していって小さい方をAに打ち込む
        if L[i_l] <= R[i_r]:
            A[k] = L[i_l]
            i_l += 1
        else:
            A[k] = R[i_r]
            i_r += 1
            cnt += n1-i_l  # ここが重要 反転したときだけ反点数を足し込んでいく
    return cnt


def merge_sort(A: list, left: int, right: int):
    '''
    マージソートをしつつ、反転数を再帰的に計算する。

    ここではマージを再帰的に適応し反転数をどんどん上に伝播させていく仕組み
    '''
    if left + 1 >= right:  # 終了条件
        return 0

    mid = (left+right)//2
    v1 = merge_sort(A, left, mid)  # 右左にも再帰的にmerge_sortを適応
    v2 = merge_sort(A, mid, right)
    v3 = merge(A, left, mid, right)  # 右左整ったらmerge

    return v1+v2+v3


n = int(input())
A = list(map(int, input().split()))
print(merge_sort(A, 0, n))
"
7151017,ALDS1_5_D,"INF=10**10
def merge(A, left, mid, right):
    L=A[left:mid]+[INF]
    R=A[mid:right]+[INF]
    n0=mid-left
    i=0
    j=0
    num_inversions=0
    for k in range(left,right):
        if L[i]<=R[j]:
            A[k]=L[i]
            i+=1
        else:
            A[k]=R[j]
            j+=1
            num_inversions+=n0-i
    return num_inversions

def mergeSort(A,left,right):
    if left+1<right:
        mid=(left+right)//2
        num_inversions0=mergeSort(A,left,mid)
        num_inversions1=mergeSort(A,mid,right)
        return merge(A,left,mid,right)+num_inversions0+num_inversions1
    return 0

n=int(input())
S=list(map(int,input().split()))
num_inversions=mergeSort(S,0,n)
print(num_inversions)
    
    
"
3209394,ALDS1_5_D,"import sys  # {{{
import os
import time
import re
from pydoc import help
import string
import math
from operator import itemgetter
from collections import Counter
from collections import deque
from collections import defaultdict as dd
import fractions
from heapq import heappop, heappush, heapify
import array
from bisect import bisect_left, bisect_right, insort_left, insort_right
from copy import deepcopy as dcopy
import itertools
# }}}

# pre-defined{{{
sys.setrecursionlimit(10**7)
INF = 10**20
GOSA = 1.0 / 10**10
MOD = 10**9+7
ALPHABETS = [chr(i) for i in range(ord('a'), ord('z')+1)]  # can also use string module
def LI(): return [int(x) for x in sys.stdin.readline().split()]
def LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]
def LF(): return [float(x) for x in sys.stdin.readline().split()]
def LS(): return sys.stdin.readline().split()
def I(): return int(sys.stdin.readline())
def F(): return float(sys.stdin.readline())
def DP(N, M, first): return [[first] * M for n in range(N)]
def DP3(N, M, L, first): return [[[first] * L for n in range(M)] for _ in range(N)]
from inspect import currentframe
def dump(*args):
    names = {id(v):k for k,v in currentframe().f_back.f_locals.items()}
    print(', '.join(names.get(id(arg),'???')+' => '+repr(arg) for arg in args), file=sys.stderr)
# }}}

def local_input():# {{{
    from pcm.utils import set_stdin
    import sys
    from pathlib import Path
    parentdir = Path(os.path.dirname(__file__)).parent
    inputfile = parentdir.joinpath('test/sample-1.in')
    if len(sys.argv) == 1:
        set_stdin(inputfile)
# }}}

# 5
# 3 5 2 1 4
def cum(i):
    res = 0
    while i>0:
        res += bit[i]
        i -= i&-i
    return res

def add(i, x):
    while i<=N:
        bit[i] += x
        i += i&-i

def pos(a):
    return i

def solve():
    global N,A,bit
    N = int(input())
    A = list(map(int, input().split()))
    bit = [0]*(N+1)

    B = list(set(A))
    B.sort()
    B = [-1] + B

    res = 0
    for i in range(N):
        j = bisect_left(B, A[i])
        res += cum(j)
        add(j, 1)

    print(N*(N-1)//2-res)

    return 0

if __name__ == ""__main__"":# {{{
    try:
        local_input()
    except:
        pass
    solve()
# vim: set foldmethod=marker:}}}

"
8941808,ALDS1_6_A,"n = int(input())
A = list(map(int, input().split()))

C = [0]*(max(A)+1)
for a in A:
    C[a] += 1

B = []
for i in range(len(C)):
    B.extend([i]*C[i])
print(*B)
"
8320968,ALDS1_6_A,"def main():
    n = int(input())
    # 元のデータ.
    a = [int(s) for s in input().split()]
    # 並び替え後のデータ.
    b = [0 for i in range(n)]
    m = max(a) + 1
    # カウンター.
    c = [0 for i in range(m)]
    # c[a[i]]:= a[i] に一致する要素の数.
    for i in range(n):
        c[a[i]] += 1
    i = 0
    for j in range(m):
        for k in range(c[j]):
            b[i] = j
            i += 1
    print(*b)


if __name__ == ""__main__"":
    main()

"
6435363,ALDS1_6_A,"import sys
from itertools import repeat

# READ_FROM_FILE = True
READ_FROM_FILE = False


def main():
    if READ_FROM_FILE:
        f = open('test0.txt', 'r')
    else:
        f = sys.stdin

    f.readline()
    a_list = list(map(int, f.readline().split()))
    k = 10_001
    c_list = [0] * k

    for a in a_list:
        c_list[a] += 1

    b_list = []
    for i, c in enumerate(c_list):
        if c > 0:
            b_list += repeat(str(i), c)

    print(' '.join(b_list))

    if READ_FROM_FILE:
        f.close()
    return


if __name__ == '__main__':
    main()

"
4148856,ALDS1_6_A,"def counting_sort():
    input()
    C = [0]*(10000+1)
    b = []
    for a in map(int, input().split()):
        C[a] += 1
    for i, c in enumerate(C):
        b += [str(i)]*c
    print(' '.join(b))
        
if __name__ == ""__main__"":
    counting_sort()
"
2727590,ALDS1_6_A,"def s():
 input()
 C=[0]*10001
 for a in map(int,input().split()):C[a]+=1
 B=[];i=0
 for k in C:B+=[str(i)]*k;i+=1
 print(' '.join(B))
if'__main__'==__name__:s()
"
3789492,ALDS1_6_A,"def s():
 input()
 C=[0]*10001
 for a in map(int,input().split()):C[a]+=1
 B=[];i=0
 for k in C:B+=[str(i)]*k;i+=1
 print(' '.join(B))
if'__main__'==__name__:s()
"
8899330,ALDS1_6_A,"import itertools as it

def main() -> None:
    #lines: list = [i.strip() for i in input_data.split(sep=""\n"")]
    lines: list = [i.strip() for i in open(0).readlines()]
    dataCount: int = int(lines[0])
    dataArray: list[int] = [int(i) for i in lines[1].split(sep="" "")]

    print("" "".join([f""{i}"" for i in countingSort(dataCount, dataArray)]))
    pass


def countingSort(dataCount: int, dataArray: list[int]) -> list[int]:
    result: list[int] = [0] * (max(dataArray) + 1)

    for i in dataArray:
        result[i] += 1

    result = [*it.accumulate(result)]

    resultArray: list[int] = [None] * dataCount
    for i in reversed(dataArray):
        result[i] -= 1
        resultArray[result[i]] = i

    return(resultArray)


if __name__ == ""__main__"":
    main()
"
2534229,ALDS1_6_A,"n = int(input())
A = list(map(int, input().split()))
B = []
C = [0] * 10001
for x in A:
    C[x] += 1
for i, k in enumerate(C):
    B += [str(i)] * k
print("" "".join(B))
"
3182882,ALDS1_6_A,"import sys
readline = sys.stdin.readline
write = sys.stdout.write

from itertools import repeat

N = int(readline())
L = 10001

C = [0]*L;
for a in map(int, readline().split()):
    C[a] += 1


ans = []
for i, c in enumerate(C):
    if c:
        ans.extend(repeat(str(i), c))
write("" "".join(ans))
write(""\n"")

"
5265508,ALDS1_6_A,"n = int(input())
data = list(map(int, input().split()))
maximum = max(data)
sorted_list = [0] * (maximum + 1)
for i in data:
    sorted_list[i] += 1

output = """"

for i in range(maximum + 1):
    if sorted_list[i] != 0:
        output += f""{i} "" * sorted_list[i]

print(output[:len(output) - 1])
"
5461951,ALDS1_6_A,"n = int(input())
c = [0] * 10001

for j in map(int, input().split()): c[j] += 1

b = []
i = 0
for j in range(10001): b += [str(j)] * c[j]

print(' '.join(b))


"
5074139,ALDS1_6_A,"n = int(input())
c = [0] * 10001

for j in map(int, input().split()): c[j] += 1

b = []
i = 0
for j in range(10001): b += [str(j)] * c[j]

print(' '.join(b))

"
6372086,ALDS1_6_A,"import sys
readline = sys.stdin.readline
write = sys.stdout.write

from itertools import repeat

N = int(readline())
L = 10001

C = [0]*L;
for a in map(int, readline().split()):
    C[a] += 1


ans = []
for i, c in enumerate(C):
    if c:
        ans.extend(repeat(str(i), c))
write("" "".join(ans))
write(""\n"")

"
7795443,ALDS1_6_A,"import sys
readline = sys.stdin.readline
write = sys.stdout.write

from itertools import repeat

N = int(readline())
L = 10001

C = [0]*L;
for a in map(int, readline().split()):
    C[a] += 1


ans = []
for i, c in enumerate(C):
    if c:
        ans.extend(repeat(str(i), c))
write("" "".join(ans))
write(""\n"")

"
6796114,ALDS1_6_A,"n = int(input())
A = list(map(int, input().split()))
B = []
C = [0] * 10001

for l in A:
    C[l] += 1

for i, k in enumerate(C):
    B += [str(i)] * k
print("" "".join(B))
"
8412764,ALDS1_6_A,"n = int(input())
A = [int(x) for x in input().split()]
A.sort()
print(' '.join(map(str, A)))
"
8880470,ALDS1_6_A,"n = int(input())
s = [*map(int, input().split())]

print(*sorted(s))
"
8728805,ALDS1_6_A,"def counting_sort(arr):

    max_val = max(arr)
    count_arr = [0] * (max_val + 1)

    for num in arr:
        count_arr[num] += 1


    for i in range(1, len(count_arr)):
        count_arr[i] += count_arr[i - 1]

    output_arr = [0] * len(arr)

    for num in reversed(arr):
        count_arr[num] -= 1
        output_arr[count_arr[num]] = num

    return output_arr
n = list(map(int, input().split()))
example_sequence = list(map(int, input().split()))
sorted_sequence = counting_sort(example_sequence)
print(' '.join(map(str, sorted_sequence)))

"
6794845,ALDS1_6_A,"n = int(input())

A = list(map(int, input().split()))

B = []

C = [0] * 10001
for j in A:
    C[j] += 1
for i, k in enumerate(C):
    B += [str(i)] * k
print("" "".join(B))
"
5291826,ALDS1_6_A,"n = int(input())
A = list(map(int, input().split()))
B = [0] * (max(A) + 1)

for i in A:
    B[i] += 1

out = """"

for i in range(max(A) + 1):
    if B[i]:
        out += (str(i) + "" "") * B[i]

print(out[ : len(out) - 1])
"
8920109,ALDS1_6_A,"def counting_sort(A):
    C = [0]*(max(A) + 1)
    
    for a in A:
        C[a] += 1
    
    for i in range(1,len(C)):
        C[i] = C[i-1] + C[i]
    
    ans = [0]*len(A)
    for a in A:
        ans[C[a] - 1] = a
        C[a] -= 1
    print(*ans)

n = int(input())
A = list(map(int,input().split()))

counting_sort(A)

"
9085766,ALDS1_6_A,"def counting_sort(nums: list[int], k: int) -> list[int]:
    buckets = [[] for _ in range(k + 1)]

    for num in nums:
        buckets[num].append(num)

    sorted_list = []
    for bucket in buckets:
        for num in bucket:
            sorted_list.append(num)

    return sorted_list


if __name__ == ""__main__"":
    n = int(input())
    nums = list(map(int, input().split()))
    print(*counting_sort(nums, max(nums)))
"
8525431,ALDS1_6_A,"def countingSort(A, k):
    n = len(A)
    C = [0] * (k + 1)
    B = [0] * n

    for j in range(n):
        C[A[j]] += 1

    for i in range(1, k + 1):
        C[i] += C[i - 1]

    for j in range(n - 1, -1, -1):
        B[C[A[j]] - 1] = A[j]
        C[A[j]] -= 1

    return B

n = int(input())
A = list(map(int, input().split()))

sorted_A = countingSort(A, max(A))
print("" "".join(map(str, sorted_A)))

"
8630446,ALDS1_6_A,"def CountingSort(A, B, k):
    C = [0] * k
    
    for j in range(len(A)):
        C[A[j]] += 1
    
    for i in range(1,k):
        C[i] = C[i] + C[i-1]
    
    for j in range(len(A)-1,-1,-1):
        B[C[A[j]]-1] = A[j]
        C[A[j]] -= 1
    return B
        
n = int(input())
A = list(map(int,input().split()))
B = [0]*n
k = max(A) + 1
B = CountingSort(A, B, k)
print("" "".join(map(str, B)))
"
8831125,ALDS1_6_A,"def CountingSort(A, k):
    n = len(A)
    B = [0] * n
    C = [0] * (k+1) 

    for j in range(n):
        C[A[j]] += 1

    for i in range(1, k+1):
        C[i] = C[i] + C[i-1]

    for j in range(n-1, -1, -1): 
        B[C[A[j]]-1] = A[j]  
        C[A[j]] -= 1
    return B

n = int(input())
A = list(map(int, input().split()))
k = max(A)
print(*CountingSort(A, k))
"
8566113,ALDS1_6_A,"def counting_sort(a: list, k: int, n: int) -> list:
    c = [0] * (k + 1)

    for j in range(0, n):
        c[a[j]] = c[a[j]] + 1

    for i in range(1, k + 1):
        c[i] = c[i] + c[i - 1]

    b = [0] * n
    for j in range(n - 1, -1, -1):
        b[c[a[j]] - 1] = a[j]
        c[a[j]] = c[a[j]] - 1

    return b


n = int(input())
a = list(map(int, input().split()))

MAX = 10000

print(*counting_sort(a, MAX, n))

"
8525324,ALDS1_6_A,"def counting_sort(a):
    if not a:
        return a

    max_value = max(a)
    min_value = min(a)
    n = max_value - min_value + 1

    c = [0] * n

    # c[i]にiの出現数を記録する
    for val in a:
        c[val - min_value] += 1

    # c[i]にi以下の要素の出現数を記録する
    for i in range(1, n):
        c[i] += c[i - 1]

    result = [0] * len(a)

    for val in reversed(a):
        result[c[val - min_value] - 1] = val
        c[val - min_value] -= 1

    return result


def main():
    n = int(input())
    a = list(map(int, input().split()))

    sorted_a = counting_sort(a)
    print(*sorted_a)


if __name__ == ""__main__"":
    main()

"
8685431,ALDS1_6_A,"def counting_sort(al, k):
    c = [0] * (k + 1)
    for a in al:
        c[a] += 1
    for i in range(1, k + 1):
        c[i] += c[i - 1]
    res = [-1] * len(al)
    for a in al[::-1]:
        res[c[a] - 1] = a
        c[a] -= 1
    return res

n = int(input())
al = list(map(int, input().split()))
k = max(al)
ans = counting_sort(al, k)
print(*ans)

"
8862555,ALDS1_6_A,"def ContingSort(A,B,n):
    k = 10000
    C = [0]*k
    for i in range(n):
        C[A[i]]+=1
    for i in range(1,k):
        C[i] = C[i-1]+C[i]
    for i in reversed(range(n)):
        B[C[A[i]]-1] = A[i]
        C[A[i]]-=1

n = int(input())
S = list(map(int,input().strip().split()))
B = [0]*n
ContingSort(S,B,n)
C = ' '.join(str(n) for n  in B)
print(C)
"
5055647,ALDS1_6_A,"from collections import Counter

def main():
    n = int(input())
    a = list(map(int, input().split()))
    cnt = Counter(a)
    res = []
    for i in range(10000):
        res.extend([i] * cnt[i])
    print("" "".join(map(str, res)))

main()

"
7849665,ALDS1_6_A,"import sys


def counting_sort(nums):
    C = [0] * 10001
    result = []
    for x in nums:
        C[x] += 1
    for i, k in enumerate(C):
        result += [i] * k
    return result


def main():
    n = int(input())
    (*nums,) = map(int, input().split())
    result = counting_sort(nums)
    sys.stdout.write(f""{' '.join(map(str, result))}\n"")


if __name__ == ""__main__"":
    input = sys.stdin.buffer.readline
    main()

"
9062551,ALDS1_6_A,"def CountingSort(A, B, k):
    C = [0 for _ in range(k+1)]
    # C[i] に i の出現数を記録する
    for i in range(n):
        C[A[i]] += 1
    # C[i] に i 以下の数の出現数を記録する
    for i in range(1, k+1):
        C[i] = C[i] + C[i - 1] 
    for i in range(n-1, -1, -1):
        B[C[A[i]]-1] = A[i]
        C[A[i]] -= 1
n = int(input())
A = list(map(int, input().split()))
B = [0 for _ in range(n)]
CountingSort(A, B, max(A))
print("" "".join(map(str, B)))

"
9100767,ALDS1_6_A,"def countingSort(A):
    C = [0 for _ in range(max(A)+1)]
    for elt in A:
        C[elt] += 1
    for idx in range(1, len(C)):
        C[idx] += C[idx-1]

    B = [0 for _ in range(len(A))]
    for idx in range(len(A) - 1, -1, -1):
        B[C[A[idx]]-1] = A[idx]
        C[A[idx]] -= 1
        idx -= 1

    return B


n = int(input())
A = list(map(int, input().split()))

B = countingSort(A)
print(' '.join(str(b) for b in B))

"
8759600,ALDS1_6_A,"# aizu_ALDS1_6_A_CountingSort.py  

from itertools import accumulate

def CountingSort(A,k):
    n = len(A)
    C = [0]*(k+1) # カウント用list
    for a in A: C[a] += 1
    C = list(accumulate(C))

    B = [-1]*n
    for j in range(n-1,-1,-1):
        B[C[A[j]]-1] = A[j]
        C[A[j]] -= 1
    return B

n = int(input())
A = list(map(int,input().split()))

B = CountingSort(A,max(A))
print(*B)
"
8778959,ALDS1_6_A,"MAX_ELEM = 10000

def counting_sort(A, B, k):
    C = [0] * (k+1)
    for i in range(len(A)):
        C[A[i]] += 1
    
    for i in range(1, k+1):
        C[i] = C[i] + C[i-1]
        
    for j in range(len(A)-1, -1, -1):
        B[C[A[j]]-1] = A[j]
        C[A[j]] -= 1
        
N = int(input())
A = list(map(int, input().split()))
B = [0] * N
counting_sort(A, B, MAX_ELEM)
print(*B)
"
8981624,ALDS1_6_A,"n=int(input())
A=list(map(int, input().split()))
def countingsort(A, B, k):
    C=[0]*(k+1)
    for j in range(n):
        C[A[j]]+=1
    for i in range(1, k+1):
        C[i] = C[i] + C[i-1]
    for l in range(n-1, -1, -1):
        B[C[A[l]]-1] = A[l]
        C[A[l]]-=1
B=[0]*n
k=max(A)
countingsort(A, B, k)
print(*B)
"
9030883,ALDS1_6_A,"n = int(input())
A = list(map(int,input().split()))
B = [0]*n
k = 10000
def csort(A,B,k):
    global n
    C = [0]*(k+1)
    for i in range(n):
        C[A[i]] += 1
    for i in range(1,k+1):
        C[i] += C[i-1]
    for j in reversed(range(n)):
        B[C[A[j]]-1] = A[j]
        C[A[j]] -= 1
    return B
print(*csort(A,B,k))
"
6851672,ALDS1_6_A,"def CountingSort(A, k):
    counter = [0] * (k + 1)

    for a in A:
        counter[a] += 1

    out = []
    for idx, c in enumerate(counter):
        out += [idx] * c
    return out


n = int(input())
A = list(map(int, input().split()))
out = CountingSort(A, 10_000)
print("" "".join(map(str, out)))

"
8708147,ALDS1_6_A,"n = int(input())
a = list(map(int,input().split()))
b = [0] * n

def CountingSort(a,b,k):
    count = [0] * (k+1)
    
    for j in range(n):
        count[a[j]] += 1
    
    for i in range(1,k+1):
        count[i] += count[i-1]
    
    for j in range(n-1,-1,-1):
        b[count[a[j]]-1] = a[j]
        count[a[j]] -= 1

    return b

ans = CountingSort(a,b,max(a))
print(*ans)
"
8839923,ALDS1_6_A,"n=int(input())
A=list(map(int,input().split()))
B=[0]*n # Bをn個の0で初期化する
k=max(A)
def CountingSort(A,B,k):
    C=[0]*(k+1)
    for i in range(0,k+1):
        C[i]=0
    for j in range(0,n):
        C[A[j]]+=1
    for i in range(1,k+1):
        C[i]=C[i]+C[i-1]
    for j in range(n-1,-1,-1): # jをn-1から0まで逆順に繰り返す
        B[C[A[j]]-1]=A[j] # BのCのAのj番目の要素の値-1番目の要素にAのj番目の要素の値を代入する
        C[A[j]]-=1 # CのAのj番目の要素の値に1を減算する
    return B
print(*CountingSort(A,B,k)) # Bを出力する
"
8764221,ALDS1_6_A,"n = int(input())
B = [0 for i in range(n)]
def CountingSort(A):
    k = max(A)+1
    C = [0 for i in range(k)]
    for i in range(n):
        C[A[i]] += 1
    for i in range(1,k):
        C[i] = C[i]+C[i-1]
    for j in reversed(range(n)):
        B[C[A[j]]-1] = A[j]
        C[A[j]] -= 1
    print(*B)


*A, = map(int, input().split())
CountingSort(A)
"
8699916,ALDS1_6_A,"def CountingSort():
    C = [0 for _ in range(max(A) + 1)]
    
    for j in range(len(A)):
        C[A[j]] += 1
        
    for i in range(1, max(A) + 1):
        C[i] = C[i] + C[i - 1]
        
    for j in reversed(range(len(A))):
        B[C[A[j]]] = A[j]
        C[A[j]] -= 1
    
k = int(input())
A = list(map(int, input().split(' ')))
B = ['*' for _ in range(k+1)]
CountingSort()
print(' '.join(list(map(str, B[1:]))))
"
8702386,ALDS1_6_A,"import sys
input = sys.stdin.readline

n = int(input())

A = [None] + list(map(int, input().split()))
B = [None]*(n+1)

C = [0] * 10001

k = 10000

for j in range(n):
    C[A[j+1]] += 1

for i in range(1, k+1):
    C[i] += C[i-1]

for j in range(1, n+1):
    B[C[A[j]]] = A[j]
    C[A[j]] -= 1

print(' '.join(map(str, B[1:])))
"
8273769,ALDS1_6_A,"n = int(input())
A = list(map(int,input().split()))

def CountingSort(A, B, k):
    C = [0]*k
    for i in range(k):
        C[i] = 0

    for j in range(n):
        C[A[j]] += 1
    
    for i in range(k):
        C[i] = C[i] + C[i-1]
    
    for jp in range(n):
        j2 = n-jp-1
        #print(j2)
        B[C[A[j2]]] = A[j2]
        C[A[j2]] -= 1

    return B
B = [0]*(n+1)

print(*CountingSort(A, B, 10001)[1:])
"
8731712,ALDS1_6_A,"def CountingSort(A):
    n = len(A)-1
    k = max(A[1:])+1
    C = [0 for i in range(k)]
    B = [None for i in range(len(A))]
 
    # C[i] に i の出現数を記録する
    for j in range(1,n+1):
        C[A[j]] += 1

    # C[i] に i 以下の数の出現数を記録する
    for i in range(1,k):
        C[i] = C[i] + C[i-1]

    for j in range(n,0,-1):
        B[C[A[j]]] = A[j]
        C[A[j]] -= 1
    
    return B[1:]

n = int(input())
A = input()
a = list(map(int,A.split()))
a.insert(0,None)


b_sorted = CountingSort(a)
print(*b_sorted,sep="" "")
"
8015474,ALDS1_6_A,"def counting_sort(arr):
  min_arr, max_arr = min(arr), max(arr)
  len_cnts = max_arr - min_arr + 1
  len_arr = len(arr)
  cnts = [0] * len_cnts
  for a in arr:
    cnts[a - min_arr] += 1
  arr_sorted = []
  for i in range(len_cnts):
    arr_sorted += [i + min_arr] * cnts[i]
  return arr_sorted

_ = input()
arr = list(map(int, input().split()))
print(' '.join(map(str, counting_sort(arr))))
"
8355762,ALDS1_6_A,"n = int(input())
A = list(map(int,input().split()))

B = []
B = [0 for _ in range(n)]
C = []
C = [0 for _ in range(max(A) + 1)]

for i in range(n):
    C[A[i]] += 1

for i in range(1,len(C)):
    C[i] += C[i-1]  


  
for i in range(n-1,-1,-1):
    B[C[A[i]] -1] =  A[i]
    C[A[i]] -= 1

print(*B)
"
9050639,ALDS1_6_A,"from typing import List

VMAX: int = 10000

C: List[int] = [0] * (VMAX + 1)

if __name__ == ""__main__"":
    n: int = int(input())
    A: List[int] = [int(param) for param in input().split()]
    B: List[int] = [None] * n

    for i in range(n):
        C[A[i]] = C[A[i]] + 1

    for i in range(1, VMAX + 1):
        C[i] = C[i] + C[i - 1]

    for j in range(n - 1, -1, -1):
        B[C[A[j]] - 1] = A[j]
        C[A[j]] = C[A[j]] - 1
    
    result = ' '.join(str(i) for i in B)
    print(result)
"
8295810,ALDS1_6_A,"def ShowList(l):
    for i in range(len(l)):
        if i < len(l)-1:
            print(l[i],end="" "")
        else:
            print(l[i])

def CountingSort(n,A,k):
    B = [0 for i in range(n)]
    C = [0 for i in range(k)]

    for i in A:
        C[i] += 1

    for i in range(1,k):
        C[i] += C[i-1]

    for j in range(1,n+1):
        j = n - j
        B[C[A[j]]-1] = A[j]
        C[A[j]] -= 1
    return B

n = int(input())
A = list(map(int,input().split()))

ShowList(CountingSort(n,A,max(A)+1))
"
8322405,ALDS1_6_A,"n = int(input())
A = list(map(int, input().split()))
B = [0]*n
M = max(A)
C = [0]*(M+1)

for i in set(range(n)):
    C[A[i]] += 1
for i in set(range(1, M+1)):
    C[i] += C[i-1]
for i in range(n-1, -1, -1):
    B[C[A[i]]-1] = A[i]
    C[A[i]] -= 1

print(*B)
"
4088872,ALDS1_6_A,"def count_sort(arr):
    max_num = max(arr)
    min_num = min(arr)

    count = [0] * (max_num - min_num + 1)
    for ele in arr:
        count[ele - min_num] += 1
    return [ele for ele, cnt in enumerate(count, start=min_num) for _ in range(cnt)]

n=int(input())
S=list(map(int,input().split()))
S=count_sort(S)
print(' '.join(list(map(str,S))))
"
8418322,ALDS1_6_A,"n = int(input())
a = [int(s) for s in input().split()]
b = [0] * n
k = 10000
d = {i: 0 for i in range(k + 1)}
d[0] = -1
for i in a: d[i] += 1
for i in range(k): d[i + 1] += d[i]
for i in range(n):
    b[d[a[i]]] = a[i]
    d[a[i]] -= 1

print(*b)
"
4156432,ALDS1_6_A,"def countingsort(a):
    max_num = max(a)
    min_num = min(a)
    count = [0]*(max_num - min_num + 1)
    for ele in a:
        count[ele - min_num] += 1

    return [ele for ele,cnt in enumerate(count,start = min_num) for _ in range(cnt)]

        

n = int(input())
A = [int(s) for s in input().split()]
print("" "".join(map(str,countingsort(A))))
"
4522803,ALDS1_6_A,"n=int(input())
nums=list(map(int,input().split()))

def counting_sort(nums,n):
    max_nums=max(nums)
    basket=[0 for i in range(max_nums+1)]
    for i in range(n):
        key=nums[i]
        basket[key]+=1

    answer=[]
    for i in range(len(basket)):
        if basket[i]!=0:
            for j in range(basket[i]):
                answer.append(i)
    return answer

answer=counting_sort(nums,n)
print(' '.join(map(str,answer)))

"
5266974,ALDS1_6_A,"from itertools import repeat

n = int(input())
arr = list(map(int, input().split()))

max_l = 10001
c = [0] * max_l

for num in arr:
    c[num] += 1

ans = []
for i, num in enumerate(c):
    if num != 0:
        ans.extend(repeat(str(i), num))
print(*ans)

"
2123645,ALDS1_6_A,"# -*- coding: utf-8 -*-
def CountingSort(array,maxval):
    m=maxval+1
    count=[0]*m
    for a in array:
        count[a]+=1
    i=0
    for a in range(m):
        for c in range(count[a]):
            array[i]=a
            i+=1
    return array

if __name__ == '__main__':
    maxval = 2000000
    n = int(input())
    a = [int(i) for i in input().split()]
    print("" "".join([str(s) for s in CountingSort(a,max(a))]))
"
6439365,ALDS1_6_A,"def countingsort(A, K):
    C = [0]*(K+1)
    for a in A:
        C[a] += 1 
    
    res = []
    for k, c in enumerate(C):
        if c > 0:
            res.extend([k]*c)
    return res


n = int(input())
K = 10000
A = list(map(int, input().split()))
B = countingsort(A, K)
print(*B)
"
4890642,ALDS1_6_A,"BIG_NUM = 10001

# 計数ソート
def countingSort(A, B, k):
    # カウンタリストCを初期化
    C = [0 for _ in range(k)]
    for num in A:
        C[num] += 1
    B_ind = 0
    for ind,num in enumerate(C):
        if num:
            B[B_ind:B_ind+num] = [ind]*num
            B_ind += num


n = int(input())
A = list(map(int,input().split()))

ans = [0 for _ in range(n)]
countingSort(A, ans, BIG_NUM)
print(*ans)
"
4296793,ALDS1_6_A,"N = int(input())
A = list(map(int, input().split()))

M = [0]*10001
for a in A:
    M[a] += 1

first = True
for i, m in enumerate(M):
    if m > 0:
        if first:
            print(*([i]*m), end='')
            first = False
        else:
            print(' ', end='')
            print(*([i]*m), end='')
print()

"
4575444,ALDS1_6_A,"import sys
def input():
    return sys.stdin.readline()[:-1]

input()
C = [0]*10_001

for a in map(int, input().split()):
    C[a] += 1
    
B = []
i = 0
for c in C:
    B += [i]*c
    i += 1
print(*B)
"
8412809,ALDS1_6_B,"def partition(A, p, r):
    x = A[r]
    i = p
    for j in range(p, r):
        if A[j] <= x:
            A[i], A[j] = A[j], A[i]
            i += 1
    A[i], A[r] = A[r], A[i]
    return i

n = int(input())
A = list(map(int, input().split()))
q = partition(A, 0, n-1)
print(' '.join(map(str, A[:q])), end=' ')
print(f""[{A[q]}]"", end=' ')
print(' '.join(map(str, A[q+1:])))

"
8563756,ALDS1_6_B,"def partition(a: list, p: int, r: int) -> (list, int):
    x = a[r]
    i = p - 1
    for j in range(p, r):
        if a[j] <= x:
            i = i + 1
            tmp = a[j]
            a[j] = a[i]
            a[i] = tmp
    tmp = a[i + 1]
    a[i + 1] = a[r]
    a[r] = tmp
    return a, i + 1


n = int(input())
a = list(map(int, input().split()))

res, r = partition(a, 0, n - 1)
print("" "".join(list(map(str, res[:r]))) + f"" [{res[r]}] "" + "" "".join(list(map(str, res[r + 1 :]))))

"
8706493,ALDS1_6_B,"def partion(p, r):
    x = A[r]
    i = p-1
    for j in range(p, r):
        if A[j] <= x:
            i += 1
            tmp = A[i]
            A[i] = A[j]
            A[j] = tmp
    tmp = A[i+1]
    A[i+1] = A[r]
    A[r] = tmp
    return i+1

n = int(input())
A = list(map(int, input().split(' ')))

pb = partion(0, n-1)
A = list(map(str, A))
A[pb] = '[' + A[pb] + ']'
print(' '.join(A))

"
8779008,ALDS1_6_B,"def partition(A, p, r):
    x = A[r]
    i = p - 1
    for j in range(p, r):
        if A[j] <= x:
            i = i + 1
            A[i], A[j] = A[j], A[i]
    A[i+1], A[r] = A[r], A[i+1]
    return i+1

N = int(input())
arr = list(map(int, input().split()))
base = partition(arr, 0, N-1)
print(*arr[0:base], end="" "")
print(""[{}]"".format(arr[base]), end="" "")
print(*arr[base+1:])
"
8842563,ALDS1_6_B,"n = int(input())
A = [int(x) for x in input().split()]


def partition(A, p, r):
    x = A[r]
    i = p
    for j in range(p, r):
        if A[j] <= x:
            A[i], A[j] = A[j], A[i]
            i += 1

    A[i], A[r] = A[r], A[i]

    return i

r = partition(A, 0, n - 1)

ans = [str(x) for x in A]
ans[r] = '[{}]'.format(ans[r])
print(' '.join(ans))
"
8941857,ALDS1_6_B,"def partition(A, p, r):
    x = A[r]
    i = p-1
    for j in range(p, r):
        if A[j] <= x:
            i += 1
            A[i], A[j] = A[j], A[i]
            # print(*A)
    A[i+1], A[r] = A[r], A[i+1]
        # print(*A)
    return i+1

n = int(input())
A = list(map(int, input().split()))
q = partition(A, 0, n-1)
A[q] = f""[{A[q]}]""
print(*A)


"
9062574,ALDS1_6_B,"def partition(A, p, r):
    x = A[r]
    i = p-1
    for j in range(p, r):
        if A[j] <= x:
            i += 1
            A[i], A[j] = A[j], A[i]
    A[i+1], A[r] = A[r], A[i+1]
    return i+1
        
n = int(input())
A = list(map(int, input().split()))
rtn = partition(A, 0, n-1)
print(f""{' '.join(map(str, A[:rtn]))} [{A[rtn]}] {' '.join(map(str, A[rtn+1:]))}"")
"
9097331,ALDS1_6_B,"def partition(A, p, r):
    x = A[r]
    i = p-1
    for j in range(p, r):
        if A[j] <= x:
            i += 1
            A[i], A[j] = A[j], A[i]
    A[i+1], A[r] = A[r], A[i+1]

    return i+1


n = int(input())
A = list(map(int, input().split()))

idx = partition(A, 0, n-1)
print(' '.join(str(num) for num in A[:idx]), end='')
print(f' [{A[idx]:d}] ', end='')
print(' '.join(str(num) for num in A[idx+1:]))

"
9117527,ALDS1_6_B,"def partition(A, p, r):
    x = A[r]
    i = p - 1
    for j in range(p, r):
        if A[j] <= x:
            i += 1
            A[i], A[j] = A[j], A[i]
    A[i + 1], A[r] = A[r], A[i + 1]
    return i + 1

n = int(input())
al = list(map(int, input().split()))
# Aを破壊的処理するので注意
q = partition(A=al, p=0, r=n - 1)
ans = "" "".join([f""[{al[i]}]"" if i == q else f""{al[i]}"" for i in range(n)])
print(ans)

"
8322469,ALDS1_6_B,"def main():
    n = int(input())
    data = [int(s) for s in input().split()]
    le, m = -1, n - 1
    for i in range(n - 1):
        if data[i] <= data[m]:
            le += 1
            data[le], data[i] = data[i], data[le]
    data[le+1], data[m] = data[m], data[le+1]
    m = le + 1
    print(*data[:m], end="" "")
    print(""[{}]"".format(data[m]), end="" "")
    print(*data[m+1:])


if __name__ == ""__main__"":
    main()

"
8323592,ALDS1_6_B,"n = int(input())
A = list(map(int, input().split()))
x = A[-1]
i = -1
for j in range(n-1):
    if A[j] <= x:
        i += 1
        A[i], A[j] = A[j], A[i]
A[i+1], A[-1] = A[-1], A[i+1]
print(*A[:i+1], f""[{A[i+1]}]"", *A[i+2:])
"
8454047,ALDS1_6_B,"n = int(input())
l = list(map(int,input().split()))
x = l[n-1]
j = -1
for i in range(n):
    if l[i] <= x:
        j += 1
        l[i],l[j] = l[j],l[i]
print("" "".join( f""[{name}]"" if  i == j else str(name)  for i,name in enumerate(l)))
 
"
8518132,ALDS1_6_B,"def Partition(A, p, r):
    x = A[r]
    i = p - 1
    for j in range(p, r):
        if A[j] <= x:
            i += 1
            A[i], A[j] = A[j], A[i]
    A[i + 1], A[r] = A[r], A[i + 1]
    return i + 1

n = int(input())
A = list(map(int, input().split()))
ind = Partition(A, 0, n - 1)

A = list(map(str, A))
A[ind] = '[' + A[ind] + ']'
print(*A)
"
8522767,ALDS1_6_B,"n = int(input())
A = list(map(int,input().split()))

x = A[-1]
p = 0
for i in range(n):
    if A[i] <= x:
        A[p], A[i] = A[i], A[p]
        p += 1
    else:
        pass
    #print(A, p, i, A[i], x)
#print(A)
A[p-1] = ""["" + str(A[p-1]) + ""]""
print(*A)
"
8535685,ALDS1_6_B,"def partition(A, p, r):
    for i in range(p, r):
        if A[i] <= A[r]:
            A[i], A[p] = A[p], A[i]
            p += 1
    A[p], A[r] = A[r], A[p]
    
    return p

def main():
    n = int(input())
    A = list(map(int, input().split()))
    
    p = partition(A, 0, n-1)

    A = list(map(str, A))
    A[p] = '[' + A[p] + ']'
    print(*A)
    
if __name__ == ""__main__"":
    main()

"
8708282,ALDS1_6_B,"def partition(a,p,r):
    x = a[r]
    i = p - 1
    for j in range(p,r):
        if a[j] <= x:
            i += 1
            a[i],a[j] = a[j],a[i]
    a[i+1],a[r] = a[r],a[i+1]
    return i + 1

n = int(input())
a = list(map(int,input().split()))
q = partition(a,0,n-1)

a = list(map(str,a))
a[q] = ""["" + a[q] + ""]""
print(*a)
"
8729218,ALDS1_6_B,"def partition(arr, low, high):
    pivot = arr[high]
    i = low - 1
    for j in range(low, high):
        if arr[j] <= pivot:
            i = i + 1
            arr[i], arr[j] = arr[j], arr[i]
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1

n = int(input())
example_sequence = list(map(int, input().split()))

partition_index = partition(example_sequence, 0, n-1)

formatted_output = []
for i, num in enumerate(example_sequence):
    if i == partition_index:
        formatted_output.append(f'[{num}]')
    else:
        formatted_output.append(str(num))

print(' '.join(formatted_output))
"
8729717,ALDS1_6_B,"def partition(A, p, r):
    x = A[r]
    i = p-1
    for j in range(p,r):
        if A[j] <= x:
            i = i+1
            A[i], A[j] = A[j], A[i]
    A[i+1], A[r] = A[r], A[i+1]
    return i+1

n = int(input())
Array = input()
a = list(map(int,Array.split()))

p = partition(a,0,n-1)

print(*a[0:p],sep="" "",end="" "")
print(f""[{a[p]}]"",end="" "")
print(*a[p+1:n],sep="" "")
"
8760414,ALDS1_6_B,"# aizu_ALDS1_6_B_Partition.py  

def partition(A,p,r): # A[r]:基準
    x = A[r]
    i = p-1
    for j in range(p,r):
        if A[j] <= x:
            i += 1
            A[i],A[j] = A[j],A[i]
    A[i+1],A[r] = A[r],A[i+1]
    return i +1

n = int(input())
A = list(map(int,input().split()))

ret = partition(A,0,len(A)-1)
print(*A[:ret],'['+str(A[ret])+']',*A[ret+1:])
"
8791872,ALDS1_6_B,"def partion(A,p,r):
    x = A[r]
    i = p-1
    for j in range(p,r):
        if A[j] <= x:
            i += 1
            A[i],A[j] = A[j],A[i]
    A[i+1],A[r] = '['+str(A[r])+']',A[i+1]
    return print(*A)
    
n = int(input())
*A, = map(int, input().split())
partion(A,0,n-1)
"
8963135,ALDS1_6_B,"def main():
    n = int(input())
    num = list(map(int, input().split()))
    
    x = num[-1]
    a = 0
    memo = 0

    for i in range(n):
        if num[i] <= x:
            num[a], num[i] = num[i], num[a]
            if num[a] == x:
                memo = a
            a += 1

    for i in range(n - 1):
        if memo == i:
            print(f""[{x}]"", end="" "")
        else:
            print(num[i], end="" "")
    if memo == n - 1:
        print(f""[{x}]"")
    else:
        print(num[-1])

if __name__ == ""__main__"":
    main()

"
8988827,ALDS1_6_B,"n=int(input())
A=list(map(int, input().split()))

def partition(A, p, r):
    x=A[r]
    i=p-1
    for j in range(p, r):
        if A[j] <= x:
            i+=1
            A[i], A[j]=A[j], A[i]
    A[i+1], A[r]=A[r], A[i+1]
    return A, i+1

A, ref_index=partition(A, 0, n-1)
print(*A[:ref_index], end='')
print(f' [{A[ref_index]}] ', end='')
print(*A[ref_index+1:])
"
8989482,ALDS1_6_B,"from typing import List

def partition(A: List[int], n: int):
    r: int = n - 1
    x: int = A[r]
    i: int = -1
    t: int = None

    for j in range(r):
        if A[j] <= x:
            i = i + 1
            t = A[i]
            A[i] = A[j]
            A[j] = t
    
    t = A[i + 1]
    A[i + 1] = A[r]
    A[r] = t

    return i + 1


if __name__ == ""__main__"":
    n: int = int(input())
    A: List[int] = list(map(int, input().split()))

    q: int = partition(A, n)

    B: List[str] = list(map(str, A))

    for i in range(n):
        if i == q:
            B[i] = f""[{B[i]}]""
    
    print("" "".join(B))

"
9030947,ALDS1_6_B,"n = int(input())
A = list(map(int,input().split()))
def partition(A,p,r):
    x = A[n-1]
    i = p-1
    for j in range(p,r):
        if A[j] <= x:
            i += 1
            y = A[i]
            A[i] = A[j]
            A[j] = y
    z = A[i+1]
    A[i+1] = ""[{}]"".format(x)
    A[n-1] = z
    return A
print(*partition(A,0,n-1))
"
8423944,ALDS1_6_B,"from collections import deque

input()
a = [int(s) for s in input().split()]
b = deque()
m = a.pop()

for x in a:
    if x > m: b.append(x)
    else:
        print(x, end=' ')
        b.rotate(-1)
b.rotate(-1)
print(f'[{m}]', *b)
"
8632254,ALDS1_6_B,"def partition(A,p,r):
    x = A[r]
    i = p
    for j in range(p,r):
        if A[j] <= x:
            A[i], A[j] = A[j], A[i]
            i = i+1
    A[i], A[r] = A[r], A[i]
    return i
    
n = int(input())
*A, = map(int, input().split())

idx = partition(A,0,n-1)

print(*(str(x) if i != idx else ""[%d]"" % x for i, x in enumerate(A)))
"
8853425,ALDS1_6_B,"def partition(A, p, r):
    x = A[r]
    i = p-1
    for j in range(p, r):
        if A[j] <= x:
            i += 1
            A[i], A[j] = A[j], A[i]
    A[i+1], A[r] = A[r], A[i+1]
    return i+1

def print_flag(A, flag):
    for i in range(len(A)):
        if i == flag:
            print(f'[{A[i]}]', end = ' ')
        elif i == len(A)-1:
            print(A[i], end = '')
        else:
            print(A[i], end = ' ')
    print()
n = int(input())
A = list(map(int, input().split()))

flag = partition(A, 0, n-1)
print_flag(A, flag)
"
8943133,ALDS1_6_B,"def partition(A,p,r):
    x = A[r]
    i = p-1
    for j in range(p,r):
        if(A[j]<=x):
            i = i+1
            A[j],A[i]=A[i],A[j]
    A[i+1],A[r]=A[r],A[i+1]
    return i+1

n = int(input())
S = list(map(int,input().strip().split()))
m = partition(S,0,n-1)
for i in range(m):
    print(S[i],end=' ')
print(""[""+str(S[m])+""]"",end=' ')
for i in range(m+1,n-1):
    print(S[i],end=' ')
print(S[n-1])
"
8968013,ALDS1_6_B,"def partition(A,p,r):
    x=A[r-1]
    i=p
    for y in range(p,r-1):
        if A[y]<=x:
            tmp=A[i]
            A[i]=A[y]
            A[y]=tmp
            i+=1
    tmp=A[i]
    A[i]=A[r-1]
    A[r-1]=tmp
    return i

n=int(input())
A=list(map(int,input().split()))

i=partition(A,0,len(A))
for j,x in enumerate(A[:-1]):
    if i==j:
        print(""["",x,""]"",sep="""",end="" "")
    else:
        print(x,end="" "")

if i==len(A)-1:
    print(A[-1])
else:
    print(A[-1])
"
9084122,ALDS1_6_B,"def partition(arr, low, high):
    pivot = arr[high]
    i = low - 1
    for j in range(low, high):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1


n = int(input())
list = list(map(int, input().split()))
value = partition(list, 0, len(list) - 1)
for i in range(n):
    if i == value:
        print(f""[{list[i]}]"", end=' ')
    elif i == n - 1:
        print(list[i])
    else:
        print(list[i], end=' ')


"
9161674,ALDS1_6_B,"n = int(input())
array = list(map(int, input().split()))

def partition(arr: list[int], start: int, end: int):
    x = arr[end]
    i = start - 1
    for j in range(start, end):
        if arr[j] <= x:
            i += 1
            a_i = arr[i]
            arr[i] = arr[j]
            arr[j] = a_i
    a_i1 = arr[i + 1]
    arr[i + 1] = arr[end]
    arr[end] = a_i1
    return i + 1

result_index = partition(array, 0, n - 1)
result_string = """"
for n_i in range(0, n):
    if n_i == result_index:
        result_string += ""["" + str(array[n_i]) + ""]"" + "" ""
    else:
        result_string += str(array[n_i]) + "" ""
result_string = result_string.strip()
print(result_string)

"
8522761,ALDS1_6_B,"def partition(A, p, r):
    x = A[r]
    i = p - 1
    for j in range(p, r):
        if A[j] <= x:
            i += 1
            a = A[i]
            A[i] = A[j]
            A[j] = a
    b = A[i+1]
    A[i+1] = A[r]
    A[r] = b
    return i + 1

n = int(input())
A = input().split(' ')
for i in range(n):
    A[i] = int(A[i])
    
q = partition(A,0,n - 1)

for i in range(n - 1):
    if i == q:
        print('[', end = """")
        print(A[q], end = """")
        print(']', end = "" "")
    else:
        print(A[i], end = "" "")
print(A[n-1])
"
8735635,ALDS1_6_B,"n = int(input())
A = list(map(int,input().split()))

x = A[len(A)-1]
r = len(A)-1
p = 0
i = 0
index = A.count(x)
cnt = 0

for j in range(p,len(A)):
    if A[j] <= x:
        A[i],A[j] = A[j],A[i]
        i+=1
    #print(A)

#A[i+1],A[r] = A[r],A[i+1]
        
for i in range(len(A)):
    if i == len(A)-1:
        print(A[i])
    elif A[i] == x:
        cnt+=1
        if cnt == index:
           print(""[{}]"".format(A[i]),end="" "")
        else :
            print(A[i],end="" "")
    else :
        print(A[i],end="" "")

"
9062423,ALDS1_6_B,"def partition(A: list[int], left: int, right: int) -> int:
    pivot_value = A[right]

    i = left
    for j in range(left, right):
        if A[j] <= pivot_value:
            A[i], A[j] = A[j], A[i]
            i += 1
    
    A[i], A[right] = A[right], A[i]
    return i
            

if __name__ == '__main__':
    n = int(input())
    A = list(map(int, input().split()))
    p = partition(A, 0, n-1)

    for i in range(n):
        if i == 0:
            if i == p:
                print(""["", end="""")
                print(A[i], end="""")
                print(""]"", end="""")
            else:
                print(A[i], end="""")
        else:
            if i == p:
                print("" ["", end="""")
                print(A[i], end="""")
                print(""]"", end="""")
            else:
                print("""", A[i], end="""")
    print()
            
"
2512046,ALDS1_6_B,"def partition(A, p, r):
    x = A[r-1]
    i = p-1

    for j in range(p,r-1):
        if A[j] <= x:
            i = i + 1
            A[i],A[j] = A[j],A[i]

    A[i+1],A[r-1] = A[r-1],A[i+1]

    print(""{0} [{1}] {2}"".format("" "".join(map(str,A[:i+1])),str(A[i+1]),"" "".join(map(str,A[i+2:]))))

    return



if __name__ == '__main__':
    cnt = int(input())
    A = list(map(int,input().split()))
    p = 0
    r = len(A)
    partition(A,p,r)
"
2670166,ALDS1_6_B,"def partition(A,p,r):
    x=A[r]
    i=p-1
    for j in range(p,r):
        if A[j]<=x:
            i+=1
            A[i],A[j]=A[j],A[i]
    A[i+1],A[r]=A[r],A[i+1]
    return i+1

n=int(input())
A=list(map(int,input().split()))
k=partition(A,0,len(A)-1)
front="" "".join(map(str,A[:k]))
back="" "".join(map(str,A[k+1:]))
ans=front+"" [""+str(A[k])+""] ""+back
print(ans)
"
2727592,ALDS1_6_B,"def s():
 n=int(input())-1
 A=list(map(int,input().split()))
 i=0
 for j in range(n):
  if A[j]<=A[-1]:A[i],A[j]=A[j],A[i];i+=1
 A[i],A[n]=A[n],A[i]
 print("" "".join(map(str,A[:i]))+"" [""+str(A[i])+""] ""+"" "".join(map(str,A[i+1:])))
if'__main__'==__name__:s()
"
2865203,ALDS1_6_B,"#!/usr/bin/python3
# -*- coding: utf-8 -*-

# Aizu Online Judge. Partition
import sys

def partition(A, p, r):
    x = A[r]
    i = p-1
    for n in range (p,r):
        if A[n] <= x:
            i += 1
            A[i], A[n] = A[n], A[i]
    A[i+1], A[r] = A[r], A[i+1]
    print(' '.join(map(str,A[:i+1])), end= ' ')
    print('[', A[i+1], ']', sep='', end='')
    if i+1 != r:
        print(' ', end='')
    print(' '.join(map(str,A[i+2:])))


n = int(sys.stdin.readline())
A = list(map(int, sys.stdin.readline().split()))
partition(A, 0, n-1)

"
3304604,ALDS1_6_B,"def partition(A, p, r):
  x = A[r]
  i = p-1
  for j in range(p,r):
    if A[j] <= x:
      i = i+1
      A[i], A[j] = A[j], A[i]
  A[i+1],A[r] = A[r], A[i+1]
  return i+1

n = int(input())
A = list(map(int, input().split()))
mid = partition(A,0,n-1)
print(' '.join(map(str,A[:mid])),'['+str(A[mid])+']',' '.join(map(str,A[mid+1:])))
"
3309278,ALDS1_6_B,"def InputData():
    
    sequence_len = int(input())
    sequence = list(map(int, input().split("" "")))

    return sequence_len, sequence

def partition(sequence, p, r):
    x = sequence[r]
    i = p - 1
    # sequence[j]
    for j in range(p, r):
        if sequence[j] <= x:
            # print(sequence[j])
            i += 1
            sequence[i], sequence[j]= sequence[j], sequence[i]
    
    sequence[i+1], sequence[r] = sequence[r], sequence[i+1]
    return i+1

def PrintOut(sequence):
    print(' '.join( map(str, sequence)))

def main():
    [sequence_len, sequence] = InputData()
    q = partition(sequence, 0, sequence_len-1)
    sequence[q] = ""["" + str(sequence[q]) + ""]""
    PrintOut(sequence)

if __name__==""__main__"":
    main()
"
3352740,ALDS1_6_B,"def partition(lst,start,last):
    x = lst[last]
    i = start
    for j in range(start,last):
        if lst[j] <= x:
            lst[i],lst[j] = lst[j],lst[i]
            i += 1
    lst[i],lst[last] = lst[last],lst[i]
    return i

n = int(input())
n_lst = list(map(int,input().split()))
p = partition(n_lst,0,n-1)
str_lst = list(map(str,n_lst))
str_lst[p] = '['+str_lst[p]+']'
print(' '.join(str_lst))
"
4012298,ALDS1_6_B,"def partition(A, p, r):
    key = A[r]
    i = p
    for j in range(p, r):
        # 把小的放在左边
        if A[j] <= key:
            A[i], A[j] = A[j], A[i]
            i += 1
    # 最后交换key值
    A[r], A[i] = A[i], A[r]
    return i


if __name__ == '__main__':
    n = int(input())
    numlist = [int(num) for num in input().split(' ')]
    index = partition(numlist, 0, len(numlist) - 1)
    out = str(numlist[0:index]).replace(',', '').replace('[', '').replace(']', '') \
        + ' [' + str(numlist[index]) + '] '\
        + str(numlist[index + 1:]).replace(',', '').replace('[', '').replace(']', '')
    print(out)
"
4072547,ALDS1_6_B,"""""""
パーティションを作成する
""""""
def partition(A, p, r):
    x = A[r]
    i = p-1 #A[i+1], A[i+2],,,がxより大きくなるようにしたい
    #jはxより大きいを指す
    for j in range(p, r):
        if A[j] <= x:
            i += 1
            A[j], A[i] = A[i], A[j]
        else:
            pass #何もできない
    A[i+1], A[r] = A[r], A[i+1]
    return i+1, A #交換したあとのxのインデックスを返す


n = int(input())
a = list(map(int, input().split()))
index, a = partition(a, 0, n-1)
a = list(map(str, a))
a[index] = ""["" + str(a[index]) + ""]""
print(' '.join(a))


"
4167907,ALDS1_6_B,"#インプットdata
input_n = int(input())
input_a = list(map(int, input().split()))
position = -1

#Partitionアルゴリズム
def partition(list, n):
    x = list[n-1]
    i = 0
    for j in range(n-1):
        if list[j] <= x:
            list[i], list[j] = list[j], list[i]
            i += 1
    list[i], list[n-1] = list[n-1], list[i]
    return i

#実行結果
position = partition(input_a, input_n)
print("" "".join(map(str, input_a[0:position])), end="""")
print(f"" [{input_a[position]}] "", end="""")
print("" "".join(map(str, input_a[position+1:])))
"
4367589,ALDS1_6_B,"def partition(a,p,r)->int:
    x = a[r]
    i = p-1
    for j in range(p,r):
        if a[j]<=x:
            i+=1
            a[i],a[j] = a[j],a[i]
    a[i+1],a[r] = a[r],a[i+1]
    return i+1

def main():
    n = int(input())
    a = list(map(int,input().split()))
    index = partition(a,0,n-1)
    print (' '.join(map(str,a[:index])),end=' ')
    print ('[%d]'%a[index],end=' ')
    print (' '.join(map(str,a[index+1:])))


if __name__ == '__main__':
    main()


"
4379512,ALDS1_6_B,"n = int(input())
A = list(map(int,input().split()))

def partition(A,p,r):

    x = A[r]

    i = p-1

    for j in range(p,r):
        if A[j] <= x:
            i += 1
            tmp = A[j]
            A[j] = A[i]
            A[i] = tmp
    tmp = A[i+1]
    A[i+1] = x
    A[r] = tmp

    return i+1


y = partition(A,0,n-1)
A = list(map(str,A))
A[y] = ""[""+A[y]+""]""

print("" "".join(A))


"
4687711,ALDS1_6_B,"def partition(a,p,r):
    x = a[r]
    i = p
    for j in range(p,r):
        if x>=a[j]:
            a[i],a[j] = a[j],a[i]
            i+=1
    a[r],a[i] = a[i],a[r]
    return i

n = int(input())
a = list(map(int,input().split()))

m = partition(a,0,n-1)
print(' '.join(map(str,a[0:m]))+' ['+str(a[m])+'] ' +' '.join(map(str,a[m+1:])))
"
4726769,ALDS1_6_B,"def partition(A,p,r):
    x = A[r]
    i = p-1
    for j in range(p,r,1):
        if A[j] <= x:
            i += 1
            temp = A[i]
            A[i] = A[j]
            A[j] = temp

    A[r] = A[i+1]
    A[i+1] = x
    return i+1

def main():
    n = int(input())
    A = list(map(int,input().split()))

    q = partition(A,0,n-1)

    #A = map(str,A)
    A[q] = '[' + str(A[q]) + ']'
    A = map(str,A)
    print(' '.join(A))


main()

"
4942055,ALDS1_6_B,"def partition(A, p, r):
    x = A[r-1]
    i = p-1
    for j in range(p, r):
        if A[j] <= x:
            i = i+1
            A[i], A[j] = A[j], A[i]
    return i

n = int(input())
A = list(map(int, input().split()))

x_ind = partition(A, 0, n)
A[x_ind] = f""[{A[x_ind]}]""
print("" "".join(map(str, A)))
"
4996383,ALDS1_6_B,"def partition(A, p, r):
    x = A[r]
    i = p-1
    for j in range(p, r):
        if A[j] <= x:
            i = i+1
            A[i], A[j] = A[j], A[i]
    A[i+1], A[r] = A[r], A[i+1]
    return i+1

n = int(input())
A = list(map(int, input().split()))
i = partition(A, 0, n-1)
A = list(map(str, A))
A[i] = '['+A[i]+']'
print(' '.join(A))
"
5055707,ALDS1_6_B,"def partition(a, p, r):
    ptt = a[r]
    i = p
    for j in range(p, r):
        if a[j] <= ptt:
            a[i], a[j] = a[j], a[i]
            i += 1
    a[r], a[i] = a[i], a[r]
    return a, i

def main():
    n = int(input())
    a = list(map(int, input().split()))
    a, i = partition(a, 0, len(a)-1)
    a = list(map(str, a))
    a[i] = ""["" + a[i] + ""]""
    print("" "".join(a))

main()
"
5159829,ALDS1_6_B,"#partition
def partition(A,p):
    x=A[len(A)-1]
    i=p-1
    for j in range(p,len(A)-1):
        if A[j]<=x:
            i=i+1
            A[i],A[j]=A[j],A[i]

    A[i+1],A[len(A)-1]=A[len(A)-1],A[i+1]
    return i+1


n=int(input())
A=list(map(int,input().split()))

q=partition(A,0)

A_str=list(map(str,A))
A_str[q]=""[""+A_str[q]+""]""
string="" "".join(A_str)
print(string)

"
5288552,ALDS1_6_B,"# Partition

def partition(A,p,r):
    x = A[r]
    i = p -1
    for j in range(p,r):
        if A[j] <= x:
            i = i+1
            A[i],A[j] = A[j],A[i]
    A[i+1],A[r] = A[r],A[i+1]
    return (A,i+1)

if __name__ == ""__main__"":
    n = int(input())
    A = list(map(int,input().split("" "")))
    p = 0
    i = 0
    r = n-1
    A,i = partition(A,p,r)
    A = list(map(str,A))
    A[i] = ""["" + A[i] + ""]""

    print("" "".join(A))
"
5291230,ALDS1_6_B,"def partition(a, start, stop):
    x = a[stop]
    index = start - 1
    for j in range(start, stop):
        if a[j] <= x:
            index += 1
            a[index], a[j] = a[j], a[index]
    a[index + 1], a[stop] = a[stop], a[index + 1]

    return index + 1


n = int(input())
input_digits = list(map(int, input().split()))

i = partition(input_digits, 0, n - 1)
input_digits[i] = ""["" + str(input_digits[i]) + ""]""
print("" "".join(map(str, input_digits)))


"
6313730,ALDS1_6_B,"def partition(a, p, r):
    x = a[r]
    i = p - 1
    for j in range(p, r):
        if a[j] <= x:
            i = i + 1
            a[i], a[j] = a[j], a[i]
    a[i + 1], a[r] = a[r], a[i + 1]
    return(i + 1)

n = int(input())
a = list(map(int, input().split()))

i = partition(a, 0, n - 1)
a[i] = ""["" + str(a[i]) + ""]""
print("" "".join(map(str, a)))

"
6386297,ALDS1_6_B,"def partition(A, p, r):
    x = A[r]
    i = p-1
    for j in range(p,r):
        if A[j] <= x:
            i = i+1
            #A[i] と A[j] を交換
            A[i],A[j] = A[j],A[i]
    #A[i+1] と A[r] を交換
    A[i+1],A[r] = A[r],A[i+1]
    return i+1

n = int(input())
A = list(map(int,input().split()))
r = n-1
par = partition(A,0,r)

print(' '.join(map(str,A[:par])),end = ' ')
print(f'[{A[par]}]',end = ' ')
print(' '.join(map(str,A[par+1:])))

"
7271939,ALDS1_6_B,"def partition(A, p, r):
    x = A[r]
    i = p-1
    for j in range(p, r):
        if A[j] <= x:
            i += 1
            A[i], A[j] = A[j], A[i]
    A[i+1], A[r] = A[r], A[i+1]
    return i+1

def main():
    N = int(input())
    A = list(map(int, input().split()))
    idx = partition(A, 0, len(A)-1)
    A[idx] = ""[%d]"" % A[idx]
    print("" "".join(map(str,A)))

if __name__ == '__main__':
    main()

"
7849783,ALDS1_6_B,"import sys


def partition(nums, low, high):
    i = low - 1
    pivot = nums[high]
    for j in range(low, high):
        if nums[j] <= pivot:
            i += 1
            nums[i], nums[j] = nums[j], nums[i]
    nums[i + 1], nums[high] = nums[high], nums[i + 1]
    return i + 1


def main():
    n = int(input())
    (*nums,) = map(int, input().split())
    p = partition(nums, 0, n - 1)
    sys.stdout.write(f""{' '.join(map(str, nums[:p]))} [{nums[p]}] {' '.join(map(str, nums[p+1:]))}\n"")


if __name__ == ""__main__"":
    input = sys.stdin.buffer.readline
    main()

"
8134001,ALDS1_6_B,"n = int(input())
S = list(map(int, input().split()))


def partition(A, p, r):
    x = A[r]
    i = p - 1
    for j in range(p, r):
        if A[j] <= x:
            i += 1
            A[i], A[j] = A[j], A[i]
    A[r] = ""["" + str(A[r]) + ""]""
    A[i + 1], A[r] = A[r], A[i + 1]
    print("" "".join(map(str, A)))
    return i + 1


partition(S, 0, n - 1)

"
8521255,ALDS1_6_B,"def partition(p, r):
  x = A[r]
  i = p - 1
  for j in range(p, r):
    if A[j] <= x:
      i += 1
      A[i], A[j] = A[j], A[i]
  A[i + 1], A[r] = A[r], A[i + 1]
  return i + 1

n = int(input())
A = list(map(int,input().split("" ""))) 

q = partition(0, n - 1)

for i in range(n):
  if i:
    print(' ', end = '')
  if i == q:
    print('[', end = '')
  print(A[i], end = '')
  if i == q:
    print(']', end = '')

print()
"
8414506,ALDS1_6_C,"import sys
readline = sys.stdin.readline
writelines = sys.stdout.writelines
N = int(input())
A = []
D = {}
for i in range(N):
    v, d = readline().split()
    A.append((v, int(d)))
    D.setdefault(int(d), []).append(v)

def partition(A, p, r):
    x = A[r]
    i = p
    for j in range(p, r):
        if A[j][1] <= x[1]:
            A[i], A[j] = A[j], A[i]
            i += 1
    A[i], A[r] = A[r], A[i]
    return i

def quicksort(A, p, r):
    if p < r:
        q = partition(A, p, r)
        quicksort(A, p, q-1)
        quicksort(A, q+1, r)

D = {k: iter(v).__next__ for k, v in D.items()}

quicksort(A, 0, N-1)
ok = 1
for v, d in A:
    if D[d]() != v:
        ok = 0
ans = ['Stable\n' if ok else 'Not stable\n']
for v, d in A:
    ans.append(""%s %d\n"" % (v, d))
writelines(ans)
"
8523103,ALDS1_6_C,"import sys
readline = sys.stdin.readline
writelines = sys.stdout.writelines
N = int(input())
A = []
D = {}
for i in range(N):
    v, d = readline().split()
    A.append((v, int(d)))
    D.setdefault(int(d), []).append(v)

def partition(A, p, r):
    x = A[r]
    i = p
    for j in range(p, r):
        if A[j][1] <= x[1]:
            A[i], A[j] = A[j], A[i]
            i += 1
    A[i], A[r] = A[r], A[i]
    return i

def quicksort(A, p, r):
    if p < r:
        q = partition(A, p, r)
        quicksort(A, p, q-1)
        quicksort(A, q+1, r)

D = {k: iter(v).__next__ for k, v in D.items()}

quicksort(A, 0, N-1)
ok = 1
for v, d in A:
    if D[d]() != v:
        ok = 0
ans = ['Stable\n' if ok else 'Not stable\n']
for v, d in A:
    ans.append(""%s %d\n"" % (v, d))
writelines(ans)


"
8989045,ALDS1_6_C,"n=int(input())
A=[]
for i in range(n):
    simbol, num=input().split()
    A.append([simbol, int(num)])
original_A=A[:]

def partition(A, p, r):
    global flag
    x=A[r][1]
    i=p-1
    for j in range(p, r):
        if A[j][1] <= x:
            i+=1
            A[i], A[j]=A[j], A[i]
    A[i+1], A[r]=A[r], A[i+1]
    return i+1

def quicksort(A, p, r):
    if p < r:
        q = partition(A, p, r)
        quicksort(A, p, q-1)
        quicksort(A, q+1, r)

A_stable = sorted(A, key = lambda x:x[1])
quicksort(A, 0, n-1)
print(""Stable"" if A == A_stable else ""Not stable"")
for i in A:
    print(*i)
"
8523730,ALDS1_6_C,"def partition(A, p, r):
    x = A[r][1]
    i = p - 1
    for j in range(p, r):
        if A[j][1] <= x:
            i += 1
            a = A[i]
            A[i] = A[j]
            A[j] = a
    b = A[i+1]
    A[i+1] = A[r]
    A[r] = b
    return i + 1

def quicksort(A, p, r):
    if p < r:
        q = partition(A,p,r)
        quicksort(A, p, q-1)
        quicksort(A, q+1, r)
        
            
    

n = int(input())
A = [None]*n
B = [None]*n
for i in range(n):
    s = input().split(' ')
    suit = s[0]
    value = int(s[1])
    A[i] = (suit, value)
    B[i] = (suit,value)

quicksort(A,0,n-1)
    
B = sorted(B, key = lambda X: X[1])

flag = 0
for i in range(n):
    if B[i][0] != A[i][0]:
        flag = 1
        print(""Not stable"")
        break

if flag == 0:
    print(""Stable"")

for i in range(n):
    print(A[i][0],A[i][1])
"
8526084,ALDS1_6_C,"def partition(A, p, r):
    x = A[r][0]
    i = p-1
    for j in range(p, r):
        if A[j][0] <= x:
            i = i+1
            A[i], A[j] = A[j], A[i]
    A[i+1], A[r] = A[r], A[i+1]
    return i+1

def quicksort(A, p, r):
    if p < r:
        q = partition(A, p, r)
        quicksort(A, p, q-1)
        quicksort(A, q+1, r)

n = int(input())
C = []

for i in range(n):
    s, i = input().split()
    i = int(i)
    C.append([i, s])
C2 = C[:]
D = dict()
for i in range(n):
    D[str(C2[i][0])+C2[i][1]] = i

quicksort(C, 0, n-1)

def x():
    i = 0
    while i < n:
        j = i+1
        while j<n and C[j][0] == C[i][0]:
            if D[str(C[j-1][0])+C[j-1][1]] > D[str(C[j][0])+C[j][1]]:
                #print(C2[i], C2[])
                print(""Not stable"")
                return 1
            j += 1
        i = j
    print(""Stable"")
    return 0
x()

for i in range(n):
    print(C[i][1], C[i][0])

"
8842656,ALDS1_6_C,"import sys
sys.setrecursionlimit(10**6)

def Partition(A, p, r):
    x = A[r][1]
    i = p - 1
    for j in range(p, r):
        if A[j][1] <= x:
            i += 1
            A[i], A[j] = A[j], A[i]
    A[i + 1], A[r] = A[r], A[i + 1]
    return i + 1

def QuickSort(A, p, r):
    if p < r:
        q = Partition(A, p, r)
        QuickSort(A, p, q - 1)
        QuickSort(A, q + 1, r)

n = int(input())
C = [list(input().split()) for _ in range(n)]
for i in range(n):
    C[i][1] = int(C[i][1])

sortC = sorted(C, key=lambda x: x[1])
QuickSort(C, 0, n - 1)
if C == sortC:
    print(""Stable"")
else:
    print(""Not stable"")
for i in range(n):
    print(*C[i])

"
8968042,ALDS1_6_C,"def partition(A,p,r):
    x=A[r-1]
    i=p
    for y in range(p,r-1):
        if A[y][1]<=x[1]:
            tmp=A[i]
            A[i]=A[y]
            A[y]=tmp
            i+=1
    tmp=A[i]
    A[i]=A[r-1]
    A[r-1]=tmp
    return i

def quickSort(A,p,r):
    if p<r:
        q=partition(A,p,r)
        quickSort(A,p,q)
        quickSort(A,q+1,r)

n=int(input())
trump=[(lambda x:[x[0],int(x[1])])(input().split()) for _ in range(n)]
trump_origin=trump[:]
trump_origin.sort(key=lambda x:x[1])

quickSort(trump,0,len(trump))

print(""Not stable"" if trump!=trump_origin else ""Stable"")
for x in trump:
    print(*x)
"
9031287,ALDS1_6_C,"n = int(input())
A = []
for i in range(n):
    m,num = input().split()
    A.append((m,int(num),i))

def partition(p,r):
    global A
    x = A[r]
    i = p-1
    for j in range(p,r):
        if A[j][-2] <= x[-2]:
            i += 1
            A[i],A[j] = A[j],A[i]
    A[i+1],A[r] = A[r],A[i+1]
    return i+1

def quicksort(p,r):
    if p < r:
        q = partition(p,r)
        quicksort(p,q-1)
        quicksort(q+1,r)
    else:
        return 

quicksort(0,n-1)
FLG = True

for i in range(1,n):
    if A[i][-2] == A[i-1][-2] and A[i][-1] < A[i-1][-1]:
        FLG = False
        break
if FLG:
    print(""Stable"")
else:
    print(""Not stable"")

for i in range(n):
    print(A[i][0],A[i][1])


"
9117531,ALDS1_6_C,"def partition_k0(A, p, r):
    x = A[r][0]
    i = p - 1
    for j in range(p, r):
        if A[j][0] <= x:
            i += 1
            A[i], A[j] = A[j], A[i]
    A[i + 1], A[r] = A[r], A[i + 1]
    return i + 1

def quick_sort(A, p, r):
    if p < r:
        q = partition_k0(A, p, r)
        quick_sort(A, p, q - 1)
        quick_sort(A, q + 1, r)

n = int(input())
l = []
for i in range(n):
    tmp = input().split()
    suit, num = tmp[0], int(tmp[1])
    l.append((num, i, suit))
quick_sort(l, 0, n - 1)
state = ""Stable""
ans = []
for i in range(n):
    bef_num, bef_idx, _ = l[i - 1]
    num, idx, suit = l[i]
    if i != 0:
        if bef_num == num and bef_idx > idx:
            state = ""Not stable""
    ans.append((suit, num))
print(state)
for an in ans:
    print(*an)

"
8708337,ALDS1_6_C,"import sys
sys.setrecursionlimit(10**6)

def Partition(A, p, r):
    x = A[r][1]
    i = p - 1
    for j in range(p, r):
        if A[j][1] <= x:
            i += 1
            A[i], A[j] = A[j], A[i]
    A[i + 1], A[r] = A[r], A[i + 1]
    return i + 1

def QuickSort(A, p, r):
    if p < r:
        q = Partition(A, p, r)
        QuickSort(A, p, q - 1)
        QuickSort(A, q + 1, r)

n = int(input())
C = [list(input().split()) for _ in range(n)]
for i in range(n):
    C[i][1] = int(C[i][1])

sortC = sorted(C, key=lambda x: x[1])
QuickSort(C, 0, n - 1)
if C == sortC:
    print(""Stable"")
else:
    print(""Not stable"")
for i in range(n):
    print(*C[i])


"
8965639,ALDS1_6_C,"def partition(A,p,r):
    x = A[r][1]
    i = p-1
    for j in range(p,r):
        if(A[j][1]<=x):
            i = i+1
            A[j],A[i]=A[i],A[j]
    A[i+1],A[r]=A[r],A[i+1]
    return i+1

def quicksort(A,p,r):
    if (p<r):
        q = partition(A,p,r)
        quicksort(A,p,q-1)
        quicksort(A,q+1,r)

n = int(input())
A = [[s,int(m)] for s,m in [input().split() for i in range(n)]]
As = sorted(A, key=lambda x:x[1])
quicksort(A,0,n-1)
if(A == As):
    print(""Stable"")
else:
    print(""Not stable"")
for i in range(n):
    print(A[i][0],end=' ')
    print(A[i][1]) 
"
8326215,ALDS1_6_C,"def partition(A, p, r):
    x = A[r][1]
    i = p - 1
    for j in range(p, r):
        if A[j][1] <= x:
            i += 1
            A[i], A[j] = A[j], A[i]
    A[i+1], A[r] = A[r], A[i+1]
    return i+1
def quickSort(A, p, r):
    if p < r:
        q = partition(A, p, r)
        quickSort(A, p, q-1)
        quickSort(A, q+1, r)

n = int(input())
A = []
for i in range(n):
    x = list(input().split())
    x[1] = int(x[1])
    x.append(i)
    A.append(x)
quickSort(A, 0, n-1)
c = 0
for i in range(n-1):
    if A[i][1] == A[i+1][1]:
        if A[i][2] > A[i+1][2]:
            c += 1
            break
if c > 0:
    print(""Not stable"")
else:
    print(""Stable"")
for i in range(n):
    print(*A[i][0:2])
"
9062628,ALDS1_6_C,"def partition(A, p, r):
    x = A[r][1]
    i = p-1
    for j in range(p, r):
        if A[j][1] <= x:
            i += 1
            A[i], A[j] = A[j], A[i]
    A[i+1], A[r] = A[r], A[i+1]
    return i+1
def quickSort(A, p, r):
    if p < r:
        q = partition(A, p, r)
        quickSort(A, p ,q-1)
        quickSort(A, q+1, r)

# Stableかどうかのチェック
def check(A, ans):
    for i in range(len(A)):
        for j in range(i+1, len(A)):
            if A[i][1] == A[j][1]:
                for a in range(len(ans)):
                    if A[i][0] == ans[a][0] and A[i][1] == ans[a][1]:
                        for b in range(a+1, len(ans)):
                            if A[j][0] == ans[b][0] and A[j][1] == ans[b][1]:
                                # 同じ順番だった
                                break
                        else: return False  
                        break                 
    return True

n = int(input())
A = [input().split() for _ in range(n)]
for a in A:
    a[1] = int(a[1])
ans = A.copy()
quickSort(ans, 0, n-1)
if check(A, ans): print(""Stable"")
else: print(""Not stable"")
for a in ans: print(a[0], a[1])
"
8543605,ALDS1_6_C,"# パーティション
def partition(A, p, r):
    pivot_value = A[r][1]
    i = p - 1
    
    for j in range(p, r):
        if A[j][1] < pivot_value or A[j][1] == pivot_value:
            i += 1
            A[i], A[j] = A[j], A[i]


    A[i+1], A[r] = A[r], A[i+1]
    return i+1

# クイックソート
def quick_sort(cards, p, r):
    if len(cards) <= 1:
        return cards

    if p < r:
        q = partition(cards, p, r)
        quick_sort(cards, p, q-1)
        quick_sort(cards, q+1, r)
    return cards

def is_stable(original, sorted_cards):
    for i in range(1, len(sorted_cards)):
        if sorted_cards[i - 1][1] == sorted_cards[i][1] and original.index(sorted_cards[i - 1]) > original.index(sorted_cards[i]):
            return False
    return True

def main():
    n = int(input())
    cards = [input().split() for _ in range(n)]
    
    original_cards = cards.copy()
    for i in range(len(cards)):
        cards[i][1] = int(cards[i][1])
        original_cards[i][1] = int(original_cards[i][1])
        
    sorted_cards = quick_sort(cards, 0, n-1)

    if is_stable(original_cards, sorted_cards):
        print(""Stable"")
    else:
        print(""Not stable"")

    for card in sorted_cards:
        print(""{} {}"".format(card[0], card[1]))

if __name__ == ""__main__"":
    main()

"
8636567,ALDS1_6_C,"n = int(input())
A = [[str(suit), int(num)] for suit, num in [input().split() for _ in range(n)]]

def partition(A, p, r):
    i = p - 1
    for j in range(p,r):
        if A[j][1] <= A[r][1]:
            i += 1
            A[i], A[j] = A[j], A[i]
    A[i+1], A[r] = A[r], A[i+1]
    return i+1
    
def quick_sort(A, p, r):
    if p < r:
        q = partition(A, p, r)
        quick_sort(A, p, q-1)
        quick_sort(A, q+1, r)
    
A_stable = sorted(A, key=lambda x:x[1])
quick_sort(A, 0, n-1)
print(""Stable"" if A == A_stable else ""Not stable"")
for x in A:
    print(*x)
"
8941905,ALDS1_6_C,"def partition(A, p, r):
    x = A[r][1]
    i = p-1
    for j in range(p, r):
        if A[j][1] <= x:
            i += 1
            A[i], A[j] = A[j], A[i]
            # print(*A)
    A[i+1], A[r] = A[r], A[i+1]
        # print(*A)
    return i+1

def quickSort(A, p, r):
    if p < r:
        q = partition(A, p, r)
        quickSort(A, p, q-1)
        quickSort(A, q+1, r)

def make_sort_dic(A:list) -> dict[str, list]:
    sort_dic = {}
    for a in A:
        mark = a[0]
        num = int(a[1])
        if num not in sort_dic:
            sort_dic[num] = [mark]
        else:
            sort_dic[num].append(mark)
    return sort_dic

def is_equivalent_dic(dic1:dict, dic2:dict) -> bool:
    for k in dic1.keys():
        for m1, m2 in zip(dic1[k], dic2[k]):
            if m1 != m2:
                return False
    return True

n = int(input())
A = [input().split() for _ in range(n)]
A = [[a[0], int(a[1])] for a in A]

ref_dic = make_sort_dic(A)
quickSort(A, 0, n-1)
new_dic = make_sort_dic(A)

if is_equivalent_dic(ref_dic, new_dic):
    print(""Stable"")
else:
    print(""Not stable"")
    
for mark, num in A:
    print(f""{mark} {num}"")


# q = partition(A, 0, n-1)
# A[q] = f""[{A[q]}]""
# print(*A)


"
8792047,ALDS1_6_C,"def partion(A,p,r):
    x = A[r][-1]
    i = p-1
    for j in range(p,r):
        if A[j][-1] <= x:
            i += 1
            A[i],A[j] = A[j],A[i]
    A[i+1],A[r] = A[r],A[i+1]
    return i+1


def quickSort(A,p,r):
    if p < r:
        q = partion(A,p,r)
        quickSort(A,p,q-1)
        quickSort(A,q+1,r)

n = int(input())
*A, = [input().split() for i in range(n)]
B = A.copy()
for i in range(n):
    A[i][-1] = int(A[i][-1])
quickSort(A,0,n-1)
for i in range(n-1):
    if A[i][-1] == A[i+1][-1]:
        if B.index(A[i]) > B.index(A[i+1]):
            print('Not stable')
            break
    if i == n-2:
        print('Stable')
for i in range(n):
    print(*A[i])
"
8853671,ALDS1_6_C,"class Card:
    def __init__(self, suit, value, original_order):
        self.suit = suit
        self.value = value
        self.original_order = original_order  # 追加: カードの元の順序を保持

def partition(A, p, r):
    x = A[r].value
    i = p - 1
    for j in range(p, r):
        if A[j].value <= x:
            i += 1
            A[i], A[j] = A[j], A[i]
    A[i+1], A[r] = A[r], A[i+1]
    return i + 1

def quick_sort(A, p, r):
    if p < r:
        q = partition(A, p, r)
        quick_sort(A, p, q-1)
        quick_sort(A, q+1, r)

n = int(input())
cards = [Card(suit, int(value), i) for i, (suit, value) in enumerate(input().split() for _ in range(n))]
original_cards = cards.copy()

quick_sort(cards, 0, n-1)

# 安定性を確認
stable = all((cards[i].value != cards[i+1].value) or (cards[i].original_order <= cards[i+1].original_order) for i in range(n-1))

# 出力
print(""Stable"" if stable else ""Not stable"")

for card in cards:
    print(card.suit, card.value)

"
8731656,ALDS1_6_C,"# from icecream import ic

def numDict(A):
    numDict = {}
    for i in A:
        if i[1] not in numDict:
            numDict[i[1]] = i[0]
        else:
            numDict[i[1]] += i[0]
    return numDict

def isStable(Original:list, Sorted:list):
    return True if numDict(Original) == numDict(Sorted) else False

def partition(A, p, r):
    x = A[r][1]
    i = p-1
    for j in range(p,r):
        if A[j][1] <= x:
            i = i+1
            A[i], A[j] = A[j], A[i]
    A[i+1], A[r] = A[r], A[i+1]
    return i+1

def quickSort(A, p, r):
    if p < r:
        q = partition(A, p, r)
        quickSort(A, p, q-1)
        quickSort(A, q+1, r)

Length = int(input())

card_default = []
card = []

for i in range(Length):
    Array = input()
    a = list(map(str,Array.split()))
    a[1] = int(a[1])
    card_default.append(a)
    card.append(a)


# ic(card_default)

quickSort(card,0,len(card)-1)
# ic(card)
# ic(isStable(card_default,card))

print(""Stable"") if isStable(card_default, card) == True else print(""Not stable"")
for i in card:
    print(*i,sep="" "")
"
8425269,ALDS1_6_C,"r = int(input())
a = [[i if i in 'CDHS' else int(i) for i in input().split()] for _ in range(r)]
b = sorted(a, key = lambda x: x[1])
q = [(0, r - 1)]

while q:
    i, _ = p, r = q.pop()
    x = a[r][1]
    for j in range(p, r):
        if a[j][1] <= x:
            a[i], a[j] = a[j], a[i]
            i += 1
    a[i], a[r] = a[r], a[i]

    if i > p + 1: q.append((p, i - 1))
    if r > i + 1: q.append((i + 1, r))

print('Stable' if a == b else 'Not stable')
for i in a: print(*i)
"
8779177,ALDS1_6_C,"""""""
def partition(A, B, C, p, r):
    x = A[r]
    i = p - 1
    for j in range(p, r):
        if A[j] <= x:
            i = i + 1
            A[i], A[j] = A[j], A[i]
            B[i], B[j] = B[j], B[i]
            C[i], C[j] = C[j], C[i]
    A[i+1], A[r] = A[r], A[i+1]
    B[i+1], B[r] = B[r], B[i+1]
    C[i+1], C[r] = C[r], C[i+1]
    return i+1
    
def quick_sort(A, B, C, p, r):
    if p < r:
        q = partition(A, B, C, p, r)
        quick_sort(A, B, C, p, q-1)
        quick_sort(A, B, C, q+1, r)
    
N = int(input())
picture = [""0""] * N
number = [""0""] * N
input_index = [0] * N
flag = True

for i in range(N):
    picture[i], number[i] = input().split()
    int(number[i])
    input_index[i] = i

quick_sort(number, picture, input_index, 0, N-1)

for i in range(1, N):
    if number[i] == number[i-1] and input_index[i] < input_index[i-1]:
        flag = False
        break

if not flag:
    print(""Not stable"")
else:
    print(""Stable"")
for i in range(N):
    print(""{} {}"".format(picture[i], number[i]))
""""""
import heapq
from collections import deque
from enum import Enum
import sys
import math
from _heapq import heappush, heappop
import copy

BIG_NUM = 2000000000
HUGE_NUM = 99999999999999999
MOD = 1000000007
EPS = 0.000000001
#sys.setrecursionlimit(3**12)


class TRAMP:
    def __init__(self,arg_mark,arg_number,arg_input_index):
        self.mark = arg_mark
        self.number = arg_number
        self.input_index = arg_input_index

N = int(input())
table = []
for input_index in range(N):
    mark,number = map(str,input().split())
    table.append(TRAMP(mark,int(number),input_index))

def Partition(left,right):
    global table
    i = left-1
    pivot = table[right].number
    for start in range(left,right):
        if table[start].number <= pivot:
            i += 1
            table[i],table[start] = table[start],table[i]
    table[i+1],table[right] = table[right],table[i+1]
    return i+1

def quickSort(left,right):
        if left < right:
            q = Partition(left,right)
            quickSort(left,q-1)
            quickSort(q+1,right)

quickSort(0, N-1)
stable_FLG = True

for i in range(1,N):
    if table[i].number == table[i-1].number and table[i].input_index < table[i-1].input_index:
        stable_FLG = False
        break

if stable_FLG:
    print(""Stable"")
else:
    print(""Not stable"")

for i in range(N):
    print(""%s %d""%(table[i].mark,table[i].number))
"
8680449,ALDS1_6_C,"
def quicksort(left,right):

    x = int(l[right][1])
    j = left

    if left > right:
        return
   

    for i in range(left,right):
        if int(l[i][1]) <= x:
            l[i],l[j] = l[j],l[i] 
            j += 1
    
    l[j],l[right] = l[right],l[j]

    
    quicksort(left,j-1)
    quicksort(j+1,right)

def f():
    j = 0
    copy = l[0][1]
    for i in range(n):

        if l[i][1] != copy:
            j = 0

        while(1):
            if l[i][1] == l_copy[j][1]:
                if l[i][0] != l_copy[j][0]:
                    return False
                else:
                    break
            j += 1
        j += 1
        copy = l[i][1]
    
    return True


n = int(input())
l = []
l_copy = []

for i in range(n):
    smp = input().split()
    l.append(smp)

    l_copy.append(smp)


quicksort(0,n-1)

    

if f():
    print(""Stable"")
else:
    print(""Not stable"")

for i in range(n):
    print(*l[i])


        


"
8709384,ALDS1_6_C,"def partion(p, r):
    x = int(A[r][1])
    i = p-1
    for j in range(p, r):
        if int(A[j][1]) <= x:
            i += 1
            A[i], A[j] = A[j], A[i]
    A[i+1], A[r] = A[r], A[i+1]
    return i+1

def quickSort(p, r):
    if p < r:
        q = partion(p, r)
        quickSort(p, q-1)
        quickSort(q+1, r)


def stableCheck(n):
    for i in range(1, n):
        if A[i-1][1] == A[i][1] and S.index(A[i-1]) > S.index(A[i]):
            print('Not stable')
            return
    print('Stable')
            
n = int(input())
A = [input().split(' ') for _ in range(n)]
S = A[:]

quickSort(0, n-1)
stableCheck(n)
for a in A:
    print(' '.join(list(map(str, a))))
"
8775992,ALDS1_6_C,"# aizu_ALDS1_6_C_QuickSort.py  

from copy import deepcopy

def partition(A,p,r): # A[r]:基準
    x = A[r][1]
    i = p-1
    for j in range(p,r):
        if A[j][1] <= x:
            i += 1
            A[i],A[j] = A[j],A[i]
    A[i+1],A[r] = A[r],A[i+1]
    return i +1

def quick_sort(A,p,r):
    if p < r:
        q = partition(A,p,r)
        quick_sort(A,p,q-1)
        quick_sort(A,q+1,r)
    
n = int(input())
A = []
for _ in range(n):
    a,b = input().split()
    A.append([a,int(b)] )

original = deepcopy(A)
original.sort(key = lambda x:x[1])

quick_sort(A,0,len(A)-1)
print('Stable' if original == A else 'Not stable')
for a,b in A:
    print(a,b)
"
9084254,ALDS1_6_C,"# def quickSort(alist):
#     quickSortHelper(alist, 0, len(alist) - 1)
#
#
# def quickSortHelper(alist, left, right):
#     if left < right:
#         splitpoint = partition(alist, left, right)
#         quickSortHelper(alist, left, splitpoint - 1)
#         quickSortHelper(alist, splitpoint + 1, right)
#
#
# def partition(alist, left, right):
#     pivotvalue = alist[left]
#     leftIndex = left + 1
#     rightIndex = right
#     done = False
#     while not done:
#         while leftIndex <= rightIndex and alist[leftIndex] <= pivotvalue:
#             leftIndex += 1
#         while alist[rightIndex] >= pivotvalue and rightIndex >= leftIndex:
#             rightIndex -= 1
#         if rightIndex < leftIndex:
#             done = True
#         else:
#             alist[leftIndex], alist[rightIndex] = alist[rightIndex], alist[leftIndex]
#     alist[left], alist[rightIndex] = alist[rightIndex], alist[left]
#     return rightIndex

card = {}

n = int(input())

for i in range(n):
    num = input().split()
    key = num[0]
    values = int(num[1])
    card[i] = {""key"": key, ""values"": values, ""index"": i}


def partition(arr, low, high):
    pivot = arr[high][""values""]
    i = low - 1
    for j in range(low, high):
        if arr[j][""values""] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1


def quick_sort(card, low, high):
    if low < high:
        p = partition(card, low, high)
        quick_sort(card, low, p - 1)
        quick_sort(card, p + 1, high)


def is_stable(card):
    for i in range(len(card) - 1):
        if card[i][""values""] == card[i + 1][""values""]:
            if card[i + 1][""index""] < card[i][""index""]:
                return False
    return True


# list = [54, 26, 93, 17, 77, 31, 44, 18, 55, 20, 77, 88]
quick_sort(card, 0, len(card) - 1)
if is_stable(card):
    print(""Stable"")
else:
    print(""Not stable"")
for i in range(n):
    print(card[i][""key""], card[i][""values""])


"
8521253,ALDS1_6_C,"n = int(input())
A = [None] * n  # 比較用
B = [None] * n # クイックソート用
  
# カードを格納
for i in range(n):
  S = input().split(' ')
  A[i] = [S[0], int(S[1])]
  B[i] = [S[0], int(S[1])]
  
# クイックソート用
def partition(A, p, r):
  """"""ALDS1_6_B の疑似コードに基づく関数""""""
  i = p - 1
  for j in range(p, r):
    if A[j][1] <= A[r][1]:
      i += 1
      A[i], A[j] = A[j], A[i]
  A[i + 1], A[r] = A[r], A[i + 1]
  return i + 1
  
def quickSort(A, p, r):
  ""再帰によるクイックソート""
  if p < r:
    q = partition(A, p, r)
    quickSort(A, p, q - 1)
    quickSort(A, q + 1, r)
    



stable = 1  # 安定かどうかのフラグ




quickSort(B, 0, n - 1)

A = sorted(A, key = lambda x:x[1])


for i in range(n):
  if A[i][0] != B[i][0]:
    stable = 0  # 安定でない
    
if stable == 1:
  print(""Stable"")
else:
  print(""Not stable"")

for i in range(n):
  print(B[i][0], B[i][1])
"
8322607,ALDS1_6_C,"def partition(data, hd, tl):
    bf_pvt, pvt = hd - 1, tl
    for i in range(hd, tl):
        if int(data[i][1]) <= int(data[pvt][1]):
            bf_pvt += 1
            data[bf_pvt], data[i] = data[i], data[bf_pvt]
    data[bf_pvt+1], data[pvt] = data[pvt], data[bf_pvt+1]
    return bf_pvt + 1


def quicksort(data, hd, tl):
    if hd < tl:
        pvt = partition(data, hd, tl)
        quicksort(data, hd, pvt - 1)
        quicksort(data, pvt + 1, tl)


def str_orders(data):
    result = {}
    for d in data:
        if d[1] in result:
            result[d[1]].append(d[0])
        else:
            result[d[1]] = [d[0]]
    return result


def main():
    n = int(input())
    data = [input().split() for i in range(n)]
    so_0 = str_orders(data)
    quicksort(data, 0, n - 1)
    so_1 = str_orders(data)
    if so_0 == so_1:
        print(""Stable"")
    else:
        print(""Not stable"")
    for i in range(n):
        print(*data[i])


if __name__ == ""__main__"":
    main()

"
2712613,ALDS1_6_C,"import sys
def t(A,p,r):
 x=A[r][1];i=p-1
 for j in range(p,r):
  if A[j][1]<=x:i+=1;A[i],A[j]=A[j],A[i]
 A[i+1],A[r]=A[r],A[i+1]
 return i+1
def k(A,p,r):
 if p<r:q=t(A,p,r);k(A,p,q-1);k(A,q+1,r)
def s(A):
 for i in range(n-1):
  if A[i][1]==A[i+1][1]and A[i][2]>A[i+1][2]:return'Not s'
 return'S'
n=int(input())
A=[(e[0],int(e[2:]),i)for i,e in enumerate(sys.stdin)]
k(A,0,n-1)
print(s(A)+'table')
print('\n'.join(f'{a} {b}'for a,b,_ in A))
"
6695760,ALDS1_6_C,"import sys

# READ_FROM_FILE = True
READ_FROM_FILE = False


def partition(a_list, p, r):
    x = a_list[r][0]
    i = p - 1
    for j in range(p, r):
        if a_list[j][0] <= x:
            i += 1
            a_list[i], a_list[j] = a_list[j], a_list[i]

    i += 1
    a_list[i], a_list[r] = a_list[r], a_list[i]
    return i


def quiq_sort(a_list, p, r):
    if p < r:
        q = partition(a_list, p, r)
        quiq_sort(a_list, p, q - 1)
        quiq_sort(a_list, q + 1, r)
    return


def main():
    if READ_FROM_FILE:
        f = open('test0.txt', 'r')
    else:
        f = sys.stdin

    n = int(f.readline())
    a_list = []
    for i in range(n):
        suit, a = f.readline().split()
        a = int(a)
        a_list.append((a, suit, i))

    quiq_sort(a_list, 0, n - 1)
    for i in range(n - 1):
        if a_list[i][0] == a_list[i + 1][0] and a_list[i][2] > a_list[i + 1][2]:
            print('Not stable')
            break
    else:
        print('Stable')

    result = [suit + f' {a}' for a, suit, _ in a_list]
    print('\n'.join(result))

    if READ_FROM_FILE:
        f.close()
    return


if __name__ == '__main__':
    main()

"
6583653,ALDS1_6_C,"import sys
def partition(A,p,r):
    x=A[r][1]
    i=p-1
    for j in range(p,r):
        if A[j][1]<=x:
            i=i+1
            A[i],A[j]=A[j],A[i]
    A[i+1],A[r]=A[r],A[i+1]
    return i+1
    
def quicksort(A,p,r):
    if p<r:
        q=partition(A,p,r)
        quicksort(A,p,q-1)
        quicksort(A,q+1,r)
        
def s(A):
 for i in range(n-1):
  if A[i][1]==A[i+1][1]and A[i][2]>A[i+1][2]:return'Not s'
 return'S'        
        
n=int(input())
A=[(e[0],int(e[2:]),i)for i,e in enumerate(sys.stdin)]
quicksort(A,0,n-1)
print(s(A)+'table')
print('\n'.join(f'{a} {b}'for a,b,_ in A))
"
8028717,ALDS1_6_C,"import sys

def partition(A, p, r):
    x = A[r][1]
    i = p - 1
    for j in range(p, r):
        if A[j][1] <= x:
            i += 1
            A[i], A[j] = A[j], A[i]
    A[i+1], A[r] = A[r], A[i+1]
    
    return i + 1

def quick_sort(A, p, r):
    if p < r:
        q = partition(A, p, r)
        quick_sort(A, p, q-1)
        quick_sort(A, q+1, r)

def solve(A):
    for i in range(n -1):
        if A[i][1] == A[i+1][1] and A[i][2] > A[i+1][2]:
            return 'Not stable'
    return 'Stable'

n = int(input())
A = [(e[0], int(e[2:]), i) for i, e in enumerate(sys.stdin)]

quick_sort(A, 0, n-1)
print(solve(A))
print('\n'.join(f'{a} {b}' for a,b,_ in A))
"
3789494,ALDS1_6_C,"import sys
def t(A,p,r):
 x=A[r][1];i=p-1
 for j in range(p,r):
  if A[j][1]<=x:i+=1;A[i],A[j]=A[j],A[i]
 A[i+1],A[r]=A[r],A[i+1]
 return i+1
def k(A,p,r):
 if p<r:q=t(A,p,r);k(A,p,q-1);k(A,q+1,r)
def s(A):
 for i in range(n-1):
  if A[i][1]==A[i+1][1]and A[i][2]>A[i+1][2]:return'Not s'
 return'S'
n=int(input())
A=[(e[0],int(e[2:]),i)for i,e in enumerate(sys.stdin)]
k(A,0,n-1)
print(s(A)+'table')
print('\n'.join(f'{a} {b}'for a,b,_ in A))
"
2692893,ALDS1_6_C,"import sys
readline = sys.stdin.readline
def partition(A, p, r):
    x = A[r][1]
    i = p - 1
    for j in range(p, r):
        if A[j][1] <= x:
            i += 1
            A[i], A[j] = A[j], A[i]
    A[i + 1], A[r] = A[r], A[i + 1]
    return i + 1
def quicksort(A, p, r):
    if p < r:
        q = partition(A, p, r)
        quicksort(A, p, q - 1)
        quicksort(A, q + 1, r)
def isStable(A):
    for i in range(0, len(A) - 1):
        if A[i][1] == A[i + 1][1]:
            if A[i][2] > A[i + 1][2]:
                return ""Not stable""
    return ""Stable""
n = int(input())
f = lambda a, i: (a[0], int(a[1]), i)
A = [f(readline().split(), i) for i in range(n)]
quicksort(A, 0, n - 1)
print(isStable(A))
print(""\n"".join(f""{a} {b}"" for a, b, c in A))

"
9063201,ALDS1_6_C,"class Card:
    def __init__(self, mark: str, num: int):
        self.mark = mark
        self.num = num

def partition(A: list[Card], left: int, right: int) -> int:
    pivot_value = A[right].num
    
    i = left
    for j in range(left, right):
        if A[j].num <= pivot_value:
            A[i], A[j] = A[j], A[i]
            i += 1

    A[i], A[right] = A[right], A[i]
    
    return i

def quick_sort(A: list[Card], left: int, right: int) -> list[Card]:
    if left >= right:
        return A
    
    mid = partition(A, left, right)
    quick_sort(A, left, mid-1)
    quick_sort(A, mid+1, right)
    
    return A

def merge(A: list[Card], left: int, mid: int, right: int) -> None:
    left_A = A[left:mid+1]
    right_A = A[mid+1: right+1]
    i, j, k = 0, 0, left
    while i < len(left_A) and j < len(right_A):
        if left_A[i].num <= right_A[j].num:
            A[k] = left_A[i]
            i += 1
        else:
            A[k] = right_A[j]
            j += 1
        k += 1
    
    while i < len(left_A):
        A[k] = left_A[i]
        i += 1
        k += 1
    
    while j < len(right_A):
        A[k] = right_A[j]
        j += 1
        k += 1

def merge_sort(A: list[Card], left: int, right: int) -> list[Card]:
    if left >= right:
        return A
    
    mid = (left+right) // 2
    merge_sort(A, left, mid)
    merge_sort(A, mid+1, right)
    
    merge(A, left, mid, right)
    
    return A

if __name__ == '__main__':
    n = int(input())
    A = []
    for i in range(n):
        mark, number = input().split()
        A.append(Card(mark=mark, num=int(number)))
    B = [a for a in A]

    quick_sort(A, 0, n-1)
    merge_sort(B, 0, n-1)    
    
    is_stable = True
    for i in range(n):
        if A[i].mark != B[i].mark:
            is_stable = False
            break
    if is_stable:
        print(""Stable"")
    else:
        print(""Not stable"")
    
    for card in A:
        print(card.mark, card.num)
"
7849767,ALDS1_6_C,"import sys


def partition(nums, low, high):
    i = low - 1
    pivot = nums[high][1]
    for j in range(low, high):
        if nums[j][1] <= pivot:
            i += 1
            nums[i], nums[j] = nums[j], nums[i]
    nums[i + 1], nums[high] = nums[high], nums[i + 1]
    return i + 1


def quick_sort(nums, low, high):
    if low < high:
        p = partition(nums, low, high)
        quick_sort(nums, low, p - 1)
        quick_sort(nums, p + 1, high)


def main():
    n = int(input())
    nums = []
    for i in range(n):
        a, b = input().decode().strip().split()
        nums.append((a, int(b), i))
    quick_sort(nums, 0, n - 1)
    for i in range(1, n):
        if nums[i - 1][1] == nums[i][1] and nums[i - 1][2] > nums[i][2]:
            sys.stdout.write(""Not stable\n"")
            break
    else:
        sys.stdout.write(""Stable\n"")
    nums = ""\n"".join(map(lambda x: f""{x[0]} {x[1]}"", nums))
    sys.stdout.write(f""{nums}\n"")


if __name__ == ""__main__"":
    input = sys.stdin.buffer.readline
    main()

"
6151488,ALDS1_6_C,"import sys


def partition(A, p, r):
	x = A[r][1]
	i = p-1
	for j in range(p, r):
		if A[j][1] <= x:
			i += 1
			A[i], A[j] = A[j], A[i]
	A[i+1], A[r] = A[r], A[i+1]
	return i+1


def quicksort(A, p, r):
	if p < r:
		q = partition(A, p, r)
		quicksort(A, p, q-1)
		quicksort(A, q+1, r)


input = sys.stdin.readline
n = int(input())
A = []
for i in range(0, n):
	input = sys.stdin.readline
	a, b = input().split()
	A.append((a, int(b)))
B = A.copy()
quicksort(A, 0, n-1)
B.sort(key=lambda x: x[1])
print(""Stable"") if A == B else print(""Not stable"")
A = [f'{a[0]} {a[1]}' for a in A]
print('\n'.join(A))

"
4020515,ALDS1_6_C,"def partition(A, p, r):
    x = A[r][1]
    i = p - 1
    for j in range(p, r):
        if A[j][1] <= x:
            i += 1
            A[i], A[j] = A[j], A[i]
    A[i + 1], A[r] = A[r], A[i + 1]
    return i + 1


def quicksort(A, p, r):
    if p < r:
        q = partition(A, p, r)
        quicksort(A, p, q - 1)
        quicksort(A, q + 1, r)


n, *D = open(0).read().split()
n = int(n)
A = [(D[2 * i], int(D[2 * i + 1]), i) for i in range(n)]
quicksort(A, 0, n - 1)
stable = True
for i in range(n-1):
    if A[i][1] == A[i + 1][1] and A[i][2] > A[i + 1][2]:
        stable = False
print('Stable' if stable else 'Not stable')
A = [(a[0], a[1]) for a in A]
print('\n'.join(map(lambda x: ' '.join(map(str, x)), A)))

"
4907567,ALDS1_6_C,"import sys


def partition_for_second_element(array, first, end):
    criteria = array[end][1]
    i_ins = first
    for i_cur in range(first, end):
        if array[i_cur][1] <= criteria:
            # swap
            array[i_ins], array[i_cur] = array[i_cur], array[i_ins]
            i_ins += 1
    # swap
    array[i_ins], array[end] = array[end], array[i_ins]
    return i_ins


def quick_sort(array, first, end):
    if first < end:
        criteria_idx = partition_for_second_element(array, first, end)
        quick_sort(array, first, criteria_idx - 1)
        quick_sort(array, criteria_idx + 1, end)


def shcd_order(cards):
    orders = {}
    for card in cards:
        if card[1] not in orders:
            orders[card[1]] = [card[0]]
        else:
            orders[card[1]].append(card[0])
    return orders


def is_identical_order(prev_orders, after_orders):
    for key, value in prev_orders.items():
        if after_orders[key] != value:
            return False
    return True


def main():
    input_lines = sys.stdin.readlines()
    n = int(input_lines[0].rstrip())
    cards = [(x.split()[0], int(x.split()[1])) for x in input_lines[1:]]
    prev_orders = shcd_order(cards)
    quick_sort(cards, 0, n-1)
    after_orders = shcd_order(cards)

    if is_identical_order(prev_orders, after_orders):
        print('Stable')
    else:
        print('Not stable')

    [print(x[0], x[1]) for x in cards]

    return


main()

"
3222067,ALDS1_6_C,"import sys


def partition_for_second_element(array, first, end):
    criteria = array[end][1]
    i_ins = first
    for i_cur in range(first, end):
        if array[i_cur][1] <= criteria:
            array[i_ins], array[i_cur] = array[i_cur], array[i_ins]     # swap
            i_ins += 1
    array[i_ins], array[end] = array[end], array[i_ins]     # swap
    return i_ins


def quick_sort(array, first, end):
    #print(""quick_sort"",first,end,array)
    if first < end:
        criteria_idx = partition_for_second_element(array, first, end)
        quick_sort(array, first, criteria_idx - 1)
        quick_sort(array, criteria_idx + 1, end)


def shcd_order(cards):
    orders = {}
    for card in cards:
        if card[1] not in orders:
            orders[card[1]] = [card[0]]
        else:
            orders[card[1]].append(card[0])
    return orders


def is_identical_order(prev_orders, after_orders):
    for key, value in prev_orders.items():
        if after_orders[key] != value:
            return False
    return True


def main():
    input_lines = sys.stdin.readlines()
    n = int(input_lines[0].rstrip())
    cards = [(x.split()[0], int(x.split()[1])) for x in input_lines[1:]]
    prev_orders = shcd_order(cards)
    quick_sort(cards, 0, n-1)
    after_orders = shcd_order(cards)
    if is_identical_order(prev_orders, after_orders):
        print('Stable')
    else:
        print('Not stable')
    [print(x[0], x[1]) for x in cards]
    return


main()
"
6810736,ALDS1_6_C,"import sys

input = sys.stdin.readline
n = int(input())
A = []
for i in range(n):
    a, b = input().split()
    A.append((a, int(b)))
B = sorted(A, key=lambda x: x[1])


def partition(ary, p, r):
    x = ary[r][1]
    i = p - 1
    for j in range(p, r):
        if ary[j][1] <= x:
            i += 1
            ary[i], ary[j] = ary[j], ary[i]
    ary[i+1], ary[r] = ary[r], ary[i+1]

    return i+1


def quicksort(ary, p, r):
    if p < r:
        q = partition(ary, p, r)
        quicksort(ary, p, q-1)
        quicksort(ary, q+1, r)


quicksort(A, 0, n-1)

print('Stable' if A == B else 'Not stable')
for i in range(n):
    print(*A[i])
"
4895996,ALDS1_6_C,"import sys
n = int(input())

def partition(A, p, r):        
        x = A[r][1]
        i = p - 1
        for j in range(p, r):
                if A[j][1] <= x:
                        i += 1
                        A[i], A[j] = A[j], A[i]
        A[i+1], A[r] = A[r], A[i+1]
        return i+1

def quicksort(A, p = 0, r = n-1):
        if p < r:
                q = partition(A, p, r)
                quicksort(A, p, q-1)
                quicksort(A, q+1, r)

A = sys.stdin.readlines()
A = list(map(lambda x: (x[0], int(x[2:-1])), A))
B = sorted(A, key = lambda x : x[1])
quicksort(A)
if A == B:
        print(""Stable"")
else:
        print(""Not stable"")
for i in A:
        print(i[0], end = "" "")
        print(i[1])
"
6368823,ALDS1_6_C,"from sys import stdin

n = int(stdin.readline())
cards = []
num_idx = {}
num_list = {} #画数の絵柄を出現順に記録するためのdict

for _ in range(n):
    suit, num  = stdin.readline().split()
    num = int(num)
    cards.append((suit, num))
    if num not in num_idx:
        num_idx[num] = 0
        num_list[num] = []
    
    num_list[num].append(suit)


def partition(A, p, r):
    pivot = A[r][1]
    i = p - 1
    for j in range(p, r):
        if A[j][1] <= pivot:
            i += 1
            A[j], A[i] = A[i], A[j]
                
    A[i+1], A[r] = A[r], A[i+1]
    return i+1



def quick_sort(cards):
    def _quick_sort(cards, start, end):
        if start < end:
            partition_index = partition(cards, start, end)
            _quick_sort(cards, partition_index+1, end)
            _quick_sort(cards, start, partition_index-1)
    _quick_sort(cards, 0, len(cards)-1)

quick_sort(cards)


is_stable = True

for suit, num in cards:
    if num_list[num][num_idx[num]] != suit:
        is_stable = False
        break
    num_idx[num] += 1

print('Stable' if is_stable else 'Not stable')
for card in cards:
    print(*card)
"
6436886,ALDS1_6_C,"def partition(A, p, r):
    x = A[r][1]
    i = p
    for j in range(p, r):
        if A[j][1] <= x:
            A[i], A[j] = A[j], A[i]
            i += 1
    A[i], A[r] = A[r], A[i]
    return i


def quicksort(A, p, r):
    if p < r:
        q = partition(A, p, r)
        quicksort(A, p, q-1)
        quicksort(A, q+1, r)


from sys import stdin 
input = stdin.readline 

n = int(input())
A = []
for _ in range(n):
    suit, num = input().split()
    A.append((suit, int(num)))
    
B = A.copy()
quicksort(B, 0, n - 1)

from collections import defaultdict 
order_A = defaultdict(list)
for s, num in A:
    order_A[num].append(s)
    
order_B = defaultdict(list)
for s, num in B:
    order_B[num].append(s)
    
stable = True 
for num in order_A:
    if order_A[num] != order_B[num]:
        stable = False 
        break 
    
if stable:
    print('Stable')
else:
    print('Not stable')
    
for b in B:
    print(*b)
"
4290993,ALDS1_6_C,"import sys,collections
n = int(sys.stdin.readline())
#A = list(map(int,sys.stdin.readline().split()))
A = [[x,int(y)] for x,y in [line.split() for line in sys.stdin.readlines()]]
d = {}
for i,p in enumerate(A):
  d[str(p)]=i
def partition(A,p,r):
  x = A[r][1] #pivod
  i = p    #high-start
  for j in range(p,r): #high-end
    if A[j][1] <= x:
      A[i],A[j] = A[j],A[i]
      i += 1
  A[i],A[r] = A[r],A[i]
  return i
def quicksort(A,p,r):
  if p < r:
    q = partition(A,p,r)
    quicksort(A,p,q-1)
    quicksort(A,q+1,r)
quicksort(A,0,len(A)-1)
for i in range(1,n):
  if A[i-1][1]==A[i][1] and d[str(A[i-1])] > d[str(A[i])]:
    print(""Not stable"")
    print(""\n"".join([p[0]+"" ""+str(p[1]) for p in A]))
    exit(0)
print(""Stable"")
print(""\n"".join([p[0]+"" ""+str(p[1]) for p in A]))
"
4622787,ALDS1_6_C,"import sys

sys.setrecursionlimit(10**6)


def partition(A, p, r):

    x = A[r][1]
    i = p - 1

    for j in range(p, r):
        if A[j][1] <= x:
            i += 1
            A[i], A[j] = A[j], A[i]

    A[i + 1], A[r] = A[r], A[i + 1]

    return i + 1


def quicksort(A, p, r):
    if p < r:
        q = partition(A, p, r)
        quicksort(A, p, q - 1)
        quicksort(A, q + 1, r)


def main():

    N = int(sys.stdin.readline().rstrip())

    A = []

    for i in range(N):
        m, n = sys.stdin.readline().rstrip().split()
        A.append((m, int(n), i))  # stable 確認用に index をつけておく

    quicksort(A, 0, N - 1)

    for i in range(1, N):
        if A[i][1] == A[i - 1][1]:
            if A[i][2] < A[i - 1][2]:
                print(""Not stable"")
                break
    else:
        print(""Stable"")

    for m, n, _ in A:
        print(m, n)


main()

"
4876605,ALDS1_6_C,"import sys
from collections import deque
input = sys.stdin.readline
sys.setrecursionlimit(2 * 10**6)


def inpl():
    return list(map(int, input().split()))


def partition(A, p, r):
    x = A[r][1]
    i = p - 1
    for j in range(p, r):
        if A[j][1] <= x:
            i += 1
            A[i], A[j] = A[j], A[i]
    A[i + 1], A[r] = A[r], A[i + 1]
    return i + 1


def quickSort(A, p, r):
    if p < r:
        q = partition(A, p, r)
        quickSort(A, p, q - 1)
        quickSort(A, q + 1, r)
    return


def isStable(stable_dict, A):
    for s, i in A:
        if s != stable_dict[i].popleft():
            return False
    return True


def main():
    n = int(input())
    stable_dict = {}
    A = []
    for _ in range(n):
        s, i = input().strip().split()
        i = int(i)
        A.append((s, i))
        if i not in stable_dict:
            stable_dict[i] = deque()
        stable_dict[i].append(s)

    quickSort(A, 0, n - 1)
    if isStable(stable_dict, A):
        print(""Stable"")
    else:
        print(""Not stable"")
    for a in A:
        print(*a)
    return


if __name__ == '__main__':
    main()

"
3567520,ALDS1_6_C,"def partition(A, p, r):
    x = A[r][0]
    i = p-1
    for j in range(p, r):
        if A[j][0] <= x:
            i += 1
            A[i], A[j] = A[j], A[i]

    A[i+1], A[r] = A[r], A[i+1]
    return i+1


def quicksort(A, p, r):
    if p < r:
        q = partition(A, p, r)
        quicksort(A, p, q-1)
        quicksort(A, q+1, r)


if __name__ == ""__main__"":
    import sys
    from operator import itemgetter
    n = int(input())
    cards1, cards2 = [], []
    for i, card in enumerate((l.strip()) for l in sys.stdin):
        cards1.append(card)
        cards2.append((int(card[2:]), i))

    quicksort(cards2, 0, n-1)
    print(""Stable"" if all(i1 < i2 for (n1, i1), (n2, i2) in zip(cards2, cards2[1:]) if n1 == n2)
          else ""Not stable"")
    print(*(cards1[i] for i in map(itemgetter(1), cards2)), sep=""\n"")
"
5426665,ALDS1_6_C,"import sys

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines

def partition(A, p, r):
    x = A[r][1]
    i = p-1
    for j in range(p, r):
        if A[j][1] <= x:
            i += 1
            A[i], A[j] = A[j], A[i]
    A[i+1], A[r] = A[r], A[i+1]
    A[i+1] = A[i+1]
    return i+1

def quickSort(A, p, r):
    if p < r:
        q = partition(A, p, r)
        quickSort(A, p, q-1)
        quickSort(A, q+1, r)

def solve(n, A):
    quickSort(A, 0, n-1)
    res = ""Stable""
    for i in range(n-1):
        if A[i][1] == A[i+1][1] and A[i][2] > A[i+1][2]:
            res = ""Not stable""
            break
    print(res)
    for a in A:
        print(a[0], a[1])
    
def main():
    n = int(readline())
    A = [readline().rstrip().split() + [i] for i in range(n)]
    for a in A:
        a[1] = int(a[1])
    solve(n, A)
    
if __name__ == '__main__':
    main()

"
4611783,ALDS1_6_C,"def partition(A, p, r):
    x = A[r][1]
    i = p-1
    for j in range(p,r):
        if A[j][1] <= x:
            i = i+1
            A[i],A[j] = A[j],A[i]
    A[i+1],A[r] = A[r],A[i+1]
    return i+1

def quickSort(A, p, r):
    if p < r:
        q = partition(A, p, r)
        quickSort(A, p, q-1)
        quickSort(A, q+1, r)
    return None
        
n = int(input())
A = [(i,int(j)) for i,j in [input().split() for i in range(n)]]
B = A.copy()
quickSort(A,0,n-1)
num = A[0][1]
pos = B.index(A[0])
ans = ""Stable""
for i in A[1:]:
    if i[1] != num:
        num = i[1]
        pos = B.index(i)
    else:
        if pos > B.index(i):
            ans = ""Not stable""
            break
        else:
            pos = B.index(i)
print(ans)
for i,j in A:
    print(i,j)
"
5461731,ALDS1_6_C,"def partition(A, p, r):
    x = A[r][1]
    i = p - 1
    for j in range(p, r):
        if A[j][1] <= x:
            i += 1
            A[i], A[j] = A[j], A[i]
    A[i + 1], A[r] = A[r], A[i + 1]
    return i + 1


def quicksort(A, p, r):
    if p < r:
        q = partition(A, p, r)
        quicksort(A, p, q - 1)
        quicksort(A, q + 1, r)


n, *D = open(0).read().split()
n = int(n)
A = [(D[2 * i], int(D[2 * i + 1]), i) for i in range(n)]
quicksort(A, 0, n - 1)
stable = True
for i in range(n-1):
    if A[i][1] == A[i + 1][1] and A[i][2] > A[i + 1][2]:
        stable = False
print('Stable' if stable else 'Not stable')
A = [(a[0], a[1]) for a in A]
print('\n'.join(map(lambda x: ' '.join(map(str, x)), A)))
"
3842410,ALDS1_6_C,"def partition(arr, p, r):
    x = arr[r][1]
    i = p - 1
    for j in range(p, r):
        if arr[j][1] <= x:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]

    arr[i+1], arr[r] = arr[r], arr[i+1]
    return i+1

def quick_sort(arr, p, r):
    if p < r:
        q = partition(arr, p, r)
        quick_sort(arr, p, q-1)
        quick_sort(arr, q+1, r)

num = int(input())
card_list = [input().split() for s in range(num)]
card_list = [(t[0], int(t[1])) for t in card_list]
cp_card_list = card_list[:]

quick_sort(card_list, 0, len(card_list) - 1)

is_stable = True
for i in range(len(card_list) - 1):
    if card_list[i][1] == card_list[i+1][1]:
        if cp_card_list.index(card_list[i]) > cp_card_list.index(card_list[i+1]):
            is_stable = False
            break

if is_stable:
    print(""Stable"")
else:
    print(""Not stable"")

for t in card_list:
    print(t[0], t[1])


"
5289886,ALDS1_6_C,"
import sys
readline = sys.stdin.readline
n = int(input())
A = []
for j in range(n):
    c,num = readline().split()
    m = [c,int(num)]
    A.append(m)



def Partitionsort(A,low,high):
    
    pivot = A[high][1]
    p = low -1
    for i in range(low,high):
        if A[i][1] <= pivot:
            p += 1
            A[p],A[i] = A[i],A[p]
    A[high], A[p+1] = A[p+1], A[high]
    return p+1

def QuickSort(A,low,high):
    if low < high:
        q = Partitionsort(A,low,high)
        QuickSort(A,low,q-1)
        QuickSort(A,q+1,high)
    


V = A.copy()
QuickSort(A,0,len(A)-1)

#printing stable or not
V.sort(key= lambda x:x[1])
k = 0
for i in range(0,len(A)):
    if A[i][0] == V[i][0]:
        k += 1
if k == len(A):
    print(""Stable"")
else:
    print(""Not stable"")

#printing A
for i in range(0,len(A)):
    m = A[i]
    print(*m)

"
8135784,ALDS1_6_C,"def partition(cards, p, r):
    x = cards[r][1]
    i = p - 1
    for j in range(p, r):
        if cards[j][1] <= x:
            i += 1
            cards[i], cards[j] = cards[j], cards[i]
    cards[i + 1], cards[r] = cards[r], cards[i + 1]
    return i + 1

def quicksort(cards, p, r):
    if p < r:
        q = partition(cards, p, r)
        quicksort(cards, p, q - 1)
        quicksort(cards, q + 1, r)

n = int(input())
cards = [input().split() for _ in range(n)]
cards = [(suit, int(number)) for suit, number in cards]

original_order = {card: i for i, card in enumerate(cards)}

quicksort(cards, 0, n - 1)

is_stable = all(original_order[cards[i]] < original_order[cards[i + 1]] for i in range(n - 1) if cards[i][1] == cards[i + 1][1])

print(""Stable"" if is_stable else ""Not stable"")
for card in cards:
    print(card[0], card[1])

"
1640280,ALDS1_6_C,"""""""Quick Sort.""""""

def partition(A, p, r):
    """"""Divide list A into A[p:q] whose elements aren't greater than A[q] and
    A[q+1:r] whose elements are greater than A[q].

    Each element of A is a list [x, y].
    x is a character of S, H, C or D (trump suits).
    y is a natural number.
    Sorting is done based on y numbers.
    
    Default value of p is 0.
    The number as a refernce of the division is A[r].
    
    Return the index q.
    """"""

    x = A[r][1]
    i = p - 1
    for j in range(p, r):
        if A[j][1] <= x:
            i += 1
            A[i], A[j] = A[j], A[i]
    A[i + 1], A[r] = A[r], A[i + 1]
    return i + 1


def quickSort(A, p, r):
    """"""Sort list A in ascending order with quick sort algorithm.

    Default value of p is 0 (the start index).
    r is 1 less than the length of A (the last index of A).
    """"""

    if p < r:
        q = partition(A, p, r)
        quickSort(A, p, q - 1)
        quickSort(A, q + 1, r)


def is_stable(A, B):
    """"""Check the stability of sorted list A.

    A is a sorted list.
    B is a original list.

    Return True or False.
    """"""

    cA = list(A)
    for x in B:
        i = cA.index(x)
        if i == 0:
            pass
        elif cA[i - 1][1] == x[1]:
            return False
        del cA[i]
    return True



import sys

r = int(sys.stdin.readline()) - 1

A = []

for x in sys.stdin.readlines():
    suit, num = x.split()
    num = int(num)
    A.append([suit, num])

B = list (A)

quickSort(A, 0, r)

if is_stable(A, B):
    print('Stable')
else:
    print('Not stable')

for x in A:
    print(*x)
"
2658843,ALDS1_6_C,"""""""Quick Sort.""""""
 
def partition(A, p, r):
    """"""Divide list A into A[p:q] whose elements aren't greater than A[q] and
    A[q+1:r] whose elements are greater than A[q].
 
    Each element of A is a list [x, y].
    x is a character of S, H, C or D (trump suits).
    y is a natural number.
    Sorting is done based on y numbers.
     
    Default value of p is 0.
    The number as a refernce of the division is A[r].
     
    Return the index q.
    """"""
 
    x = A[r][1]
    i = p - 1
    for j in range(p, r):
        if A[j][1] <= x:
            i += 1
            A[i], A[j] = A[j], A[i]
    A[i + 1], A[r] = A[r], A[i + 1]
    return i + 1
 
 
def quickSort(A, p, r):
    """"""Sort list A in ascending order with quick sort algorithm.
 
    Default value of p is 0 (the start index).
    r is 1 less than the length of A (the last index of A).
    """"""
 
    if p < r:
        q = partition(A, p, r)
        quickSort(A, p, q - 1)
        quickSort(A, q + 1, r)
 
 
def is_stable(A, B):
    """"""Check the stability of sorted list A.
 
    A is a sorted list.
    B is a original list.
 
    Return True or False.
    """"""
 
    cA = list(A)
    for x in B:
        i = cA.index(x)
        if i == 0:
            pass
        elif cA[i - 1][1] == x[1]:
            return False
        del cA[i]
    return True
 
 
 
import sys
 
r = int(sys.stdin.readline()) - 1
 
A = []
 
for x in sys.stdin.readlines():
    suit, num = x.split()
    num = int(num)
    A.append([suit, num])
 
B = list (A)
 
quickSort(A, 0, r)
 
if is_stable(A, B):
    print('Stable')
else:
    print('Not stable')
 
for x in A:
    print(*x)
"
3180412,ALDS1_6_C,"import sys

def Partition(A, p, r):
    x = A[r][1]
    i = p-1
    for j in range(p, r):
        if A[j][1] <= x:
            i += 1
            A[i], A[j] = A[j], A[i]
    A[i+1], A[r] = A[r], A[i+1]
    return i+1, A


def Quicksort(A, p, r):
    if p < r:
        q, A = Partition(A, p, r)
        A = Quicksort(A, p, q-1)
        A = Quicksort(A, q+1, r)
    return A

n = int(sys.stdin.readline())
cards = []
for _ in range(n):
    s,t = sys.stdin.readline().split()
    cards.append([s, int(t)])

orig = cards[:]
Quicksort(cards, 0, n-1)
mm=[c[0] for c in cards]
nn=[c[1] for c in cards]
cc=[]
for k in nn:
    if k in cc: continue
    cc.append(k)
    if nn.count(k)<=1: continue
    a=[]
    b=[]
    for o in orig:
        if o[1]==k:  a.append(o[0])
    for p in cards:
        if p[1]==k:  b.append(p[0])
    if a!=b:
        print('Not stable')
        break
else:
    print('Stable')

for c in cards:
    print(c[0],c[1])
"
4421492,ALDS1_6_C,"from sys import stdin
N=int(input())
num_list=[]
for i in range(N):
    line = list(stdin.readline().strip().split())
    num_list.append([line[0],int(line[1]),i])
def partition(A,p,r):
    x=A[r][1]
    i=p-1
    for j in range(p,r):
        if A[j][1]<=x:
            i+=1
            A[i],A[j]=A[j],A[i]
    A[i+1],A[r]=A[r],A[i+1]
    return i+1
def quicksort(A,p,r):
    if p<r:
        q=partition(A,p,r)
        quicksort(A,p,q-1)
        quicksort(A,q+1,r)
def check(A):
    for i in range(N-1):
        if A[i][1]==A[i+1][1]:
            if A[i][2]>A[i+1][2]:
                return 0
    return 1
quicksort(num_list,0,N-1)
if check(num_list):
    print(""Stable"")
else:print(""Not stable"")
for i in num_list:
    del i[2]
    print(*i)



"
2741503,ALDS1_6_C,"# Quick Sort #
def partition(A, p, r):
    x = A[r][1]
    i = p-1
    for k in range(p, r):
        if A[k][1] <= x:
            i += 1
            A[i], A[k] = A[k], A[i]
    A[i+1], A[r] = A[r], A[i+1]
    return i+1

def quick_sort(A, p, r):
    if p < r:
        q = partition(A, p, r)
        quick_sort(A, p, q-1)
        quick_sort(A, q+1, r)

def bubble_sort(c, n):
    x = c[:]
    for i in range(n):
        for k in range(n-1, i, -1):
            if x[k][1] < x[k-1][1]:
                x[k], x[k-1] = x[k-1], x[k]
    return x

def is_stable(_in, out):
    n = len(_in)
    for i in range(n):
        for k in range(i+1, n):
            for a in range(n):
                for b in range(a+1, n):
                    if _in[i][1] == _in[k][1] and _in[i] == out[b] and _in[k] == out[a]:
                        return False
    return True

n = int(input())
a = []
for i in range(n):
    mrk, num = input().split()
    num = int(num)
    a.append((mrk, num))
b = a[:]
quick_sort(b, 0, n-1)
if n > 10000:
    print(""Not stable"")
else:
    c = bubble_sort(a[:], n)
    if b == c:
        print(""Stable"")
    else:
        print(""Not stable"")
for i in b:
    print(*i)
"
3118673,ALDS1_6_C,"def partition(A, p, r):
    x = A[r][1]
    i = p - 1
    for j in range(p, r):
        if A[j][1] <= x:
            i += 1
            A[i], A[j] = A[j], A[i]
    A[i + 1], A[r] = A[r], A[i + 1]
    return i + 1

def quick_sort(A, p, r):
    if p < r:
        q = partition(A, p, r)
        # 左半分
        quick_sort(A, p, q - 1)
        # 右半分
        quick_sort(A, q + 1, r)
n = int(input())
A = []
for _ in range(n):
    a, b = input().split()
    A.append((a, int(b)))
ind = dict((e, i) for i, e in enumerate(A))
quick_sort(A, 0, n - 1)
for i in range(n - 1):
    if A[i][1] == A[i + 1][1]:
        if ind[A[i]] > ind[A[i + 1]]:
            print('Not stable')
            break
else:
    print('Stable')
for i in A:
    print(*i)
"
2402503,ALDS1_6_C,"import sys


def partition(A, p, r):
    x = A[r][1]
    i = p - 1
    for j in range(p, r):
        if A[j][1] <= x:
            i = i + 1
            temp = A[i]
            A[i] = A[j]
            A[j] = temp
    temp = A[i+1]
    A[i+1] = A[r]
    A[r] = temp
    return i+1


def quickSort(A, p, r):
    if p < r:
        q = partition(A, p, r)
        quickSort(A, p, q-1)
        quickSort(A, q+1, r)


def isStable(A):
    for i in range(0, len(A)-1):
        if A[i][1] == A[i+1][1]:
            if A[i][2] > A[i+1][2]:
                return False
    return True

if __name__ == ""__main__"":
    n = int(sys.stdin.readline())
    B = []
    for i in range(n):
        c = sys.stdin.readline().split()
        B.append([c[0], int(c[1]), i])
    quickSort(B, 0, n-1)
    if isStable(B):
        print(""Stable"")
    else:
        print(""Not stable"")
    for b in B:
        print(b[0], b[1])
"
2702241,ALDS1_6_C,"def decode():
    n = int(input())
    cards = []
    for i in range(n):
        [m, v] = input().split()
        cards.append((m, int(v), i))

    return n, cards


def partition(a, p, r):
    x = a[r][1]
    i = p - 1

    for j in range(p, r):
        if a[j][1] <= x:
            i += 1
            t = a[j]
            a[j] = a[i]
            a[i] = t
    t = a[i+1]
    a[i+1] = a[r]
    a[r] = t

    return i+1


def disp(cards):
    for (m, n, _) in cards:
        print(""{0} {1}"".format(m, n))


def quicksort(a, p, r):
    if p < r:
        q = partition(a, p, r)
        quicksort(a, p, q-1)
        quicksort(a, q+1, r)


def isstable(cards):
    for i in range(len(cards) - 1):
        if cards[i][1] == cards[i+1][1]:
            if cards[i][2] < cards[i+1][2]:
                pass
            else:
                return False
    return True

if __name__ == '__main__':
    n, cards = decode()

    quicksort(cards, 0, n-1)

    if isstable(cards):
        print(""Stable"")
    else:
        print(""Not stable"")

    disp(cards)
"
4574274,ALDS1_6_C,"import sys
def input():
    return sys.stdin.readline()[:-1]
    
n = int(input())
A = []

for i in range(n):
    a,num = input().split()
    A.append([a,int(num),i])
    
def partition(A,p,r):
    #import random
    #rand = 1+int(p+(r-p)*random.random())
    #A[rand],A[r] = A[r],A[rand]    
    x = A[r][1]
    i = p-1
    for j in range(p,r):
        if A[j][1]<= x:
            i += 1
            A[i],A[j] = A[j],A[i]
    A[i+1],A[r] = A[r],A[i+1]
    return i+1

def quickSort(A,p,r):
    if p<r:
        q = partition(A,p,r)
        quickSort(A,p,q-1)
        quickSort(A,q+1,r)
        
quickSort(A,0,n-1)

def check_stable(A):
    for i in range(n-1):
        if (A[i][1] == A[i+1][1]) & (A[i][2]>A[i+1][2]):
            return ""Not stable""
    return ""Stable""

print(check_stable(A))

for a,num,_ in A:
    print(*[a, num])
"
5934392,ALDS1_6_C,"import sys
input = sys.stdin.readline

def partition(a, p, r):
    """"""
    [p, r)の範囲の要素を, a[r]を基準に分裂させる.
    i:= [0, i)が, a[r]以下の要素となるようなi
    j:= [i, j)が, a[r]以上の要素となるようなj
    """"""
    x = a[r][1]
    i = p
    for j in range(p, r):
        if a[j][1] <= x:
            a[i], a[j] = a[j], a[i]
            i += 1
    a[i], a[r] = a[r], a[i]
    return i

def quicksort(a, p, r):
    if p < r:
        q = partition(a, p, r)
        quicksort(a, p, q-1)
        quicksort(a, q+1, r)

n = int(input())
a = []
for i in range(n):
    m, k = input().split()
    a.append([m, int(k), i])
quicksort(a, 0, n-1)

is_stable = ""Stable""
for i in range(n-1):
    if a[i][1] == a[i+1][1] and a[i][2] > a[i+1][2]:
        is_stable = ""Not stable""
print(is_stable)

for i in range(n):
    print(a[i][0], a[i][1])

"
1485994,ALDS1_6_C,"def partition(a, p, r):
    x = a[r][1]
    i = p - 1
    for j in range(p, r):
        if a[j][1] <= x:
            i = i + 1
            a[i], a[j] = a[j], a[i]
    a[i + 1], a[r] = a[r], a[i + 1]
    return i + 1


def quicksort(a, p, r):
    if p < r:
        q = partition(a, p, r)
        quicksort(a, p, q - 1)
        quicksort(a, q + 1, r)


def checkstable(a):
    for i in range(1, len(a)):
        if a[i - 1][1] == a[i][1]:
            if a[i - 1][2] > a[i][2]:
                return ""Not stable""
    return ""Stable""


import sys
n = int(input())
a = []
for i in range(n):
    suit, num = sys.stdin.readline().split()
    a += [[suit, int(num), i]]

quicksort(a, 0, len(a) - 1)
print(checkstable(a))

for line in a:
    print(line[0], line[1])
"
4466193,ALDS1_6_C,"def partition(A, p, r):
    x = A[r][1]
    i = p-1
    for j in range(p, r):
        if A[j][1] <= x:
            i += 1
            A[i],A[j] = A[j],A[i]
    A[i+1],A[r] = A[r],A[i+1]
    return i+1


def quicksort(A, p, r):
    if p < r:
        q = partition(A, p, r)
        quicksort(A, p, q-1)
        quicksort(A, q+1, r)


n = int(input())
A = [(t[0], int(t[1]), i) for t, i in [(input().split(), i) for i in range(n)]]
quicksort(A, 0, n-1)
notstable = any([True for i in range(1, n) if A[i][1] == A[i-1][1] and A[i][2] < A[i-1][2]])
print(""Not stable"" if notstable else ""Stable"")
for v in A:
    print(f""{v[0]} {v[1]}"")
"
7795117,ALDS1_6_C,"def is_stable(unsorted, sorted):
    for i in range(len(sorted)-1):
        if sorted[i][1] == sorted[i+1][1] and unsorted.index(sorted[i]) > unsorted.index(sorted[i+1]):
            return 'Not stable'
    return 'Stable'

def partition(A, p, r):
  pivot = A[r][1]
  i = p - 1
  for j in range(p, r):
    if A[j][1] <= pivot:
      i += 1
      A[i], A[j] = A[j], A[i]
  A[i+1], A[r] = A[r], A[i+1]
  return i + 1

def quick_sort(A, p, r):
  if p < r:
    q = partition(A, p, r)
    quick_sort(A, p, q-1)
    quick_sort(A, q+1, r)

n = int(input())
A = []
for _ in range(n):
    a, b = input().split()
    A.append((a, int(b)))
unsorted = A[:]
quick_sort(A, 0, len(A) - 1)
print(is_stable(unsorted, A))
for i in range(len(A)):
    print(A[i][0], A[i][1])
    
"
3047096,ALDS1_6_C,"def partition(A, p, r):
    x = A[r][1]
    i = p-1
    for j in range(p,r):
        if A[j][1] <= x:
            i = i+1
            A[i],A[j] = A[j],A[i]
    A[i+1],A[r] = A[r],A[i+1]
    return i+1

def quickSort(A, p, r):
    if p < r:
        q = partition(A, p, r)
        quickSort(A, p, q-1)
        quickSort(A, q+1, r)
    return None
        
n = int(input())
A = [(i,int(j)) for i,j in [input().split() for i in range(n)]]
B = A.copy()
quickSort(A,0,n-1)
num = A[0][1]
pos = B.index(A[0])
ans = ""Stable""
for i in A[1:]:
    if i[1] != num:
        num = i[1]
        pos = B.index(i)
    else:
        if pos > B.index(i):
            ans = ""Not stable""
            break
        else:
            pos = B.index(i)
print(ans)
for i,j in A:
    print(i,j)
"
3908606,ALDS1_6_C,"def partition(A, p, r):
    x = A[r][1]
    i = p - 1
    for j in range(p, r + 1):
        if A[j][1] <= x:
            i += 1
            A[i], A[j] = A[j], A[i]
    return i


def quicksort(A, p, r):
    if p < r:
        q = partition(A, p, r)
        quicksort(A, p, q - 1)
        quicksort(A, q + 1, r)


def makedic(A, n):
    d = {}
    for i in range(n):
        key = A[i][1]
        value = A[i][0]
        if key in d:
            d[key] += value
        else:
            d[key] = value
    return d

def main():
    N = int(input())
    A = []
    for i in range(N):
        a, v = input().split()
        v = int(v)
        A.append((a, v))

    sd = makedic(A, N)
    quicksort(A, 0, N - 1)
    ed = makedic(A, N)

    print('Stable' if sd == ed else 'Not stable')

    for l in A:
        print(l[0], l[1])

if __name__ == '__main__':
    main()




"
8429024,ALDS1_6_D,"input()
a = [int(s) for s in input().split()]
l = min(a)
a = dict(list(zip(sorted(a), a))[::-1])
c = 0

while a:
    m, n = a.popitem()
    k = 0
    while m != n:
        c += n
        n = a.pop(n)
        k += 1
    c += min(m * k, 2 * (m + l) + l * k)

print(c)
"
8520435,ALDS1_6_D,"while True:
    try:
        number          = int(input())
        original_data   = list(map(int,input().split()))
        sorted_data     = sorted(original_data)
        data_min        = sorted_data[0]

        checkd = [False]*number
        answer = 0
        for s in range(number):
            if original_data[s] == sorted_data[s] or checkd[s]:
                checkd[s] = True
                continue

            group_min = sorted_data[s]
            group_number = 1
            sums = 2*group_min
            o = s
            while original_data[o] != group_min:
                group_number += 1
                sums += original_data[o] 
                o = sorted_data.index(original_data[o])
                checkd[o] = True

            answer += sums +  min((group_number-3) * group_min ,(group_number + 1)*data_min)

        print(answer)
    except EOFError:break

"
8414622,ALDS1_6_D,"n = int(input())
A = list(map(int, input().split()))
sortA = sorted(A)

ans = 0
for i in range(n):
    x = A.index(sortA[i])
    j = 0
    while x > i:
        j += 1
        y = A.index(sortA[x])
        ans += A[y]
        A[x], A[y] = A[y], A[x]
        x = y
    ans += min(sortA[i] * j, sortA[i] * 2 + sortA[0] * (j + 2))
print(ans)
"
8710340,ALDS1_6_D,"n = int(input())
A = list(map(int, input().split()))
sortA = sorted(A)

ans = 0
for i in range(n):
    x = A.index(sortA[i])
    j = 0
    while x > i:
        j += 1
        y = A.index(sortA[x])
        ans += A[y]
        A[x], A[y] = A[y], A[x]
        x = y
    ans += min(sortA[i] * j, sortA[i] * 2 + sortA[0] * (j + 2))
print(ans)


"
8783612,ALDS1_6_D,"n = int(input())
A = list(map(int,input().split()))

sum = 0
B = sorted(A)
for i in range(n):
    x = A.index(B[i])
    j = 0
    while x > i:
        j += 1
        y = A.index(B[x])
        sum += A[y]
        A[x],A[y] = A[y],A[x]
        x = y
    a = B[i]* j 
    b = B[i] * 2 + B[0] * (j + 2)
    sum += min(a,b)



print(sum)
"
8795362,ALDS1_6_D,"ans = 0
n = int(input())
*l, = map(int, input().split())
S = sorted(l)
for i in range(n):
    x = l.index(S[i])
    c = 0
    while x > i:
        y = l.index(S[x])
        ans += l[y]
        c += 1
        l[x],l[y] = l[y],l[x]
        x = y
    ans += min(S[i]*c,S[i]*2+S[0]*(c+2))
print(ans)
"
8992016,ALDS1_6_D,"n = int(input())
A = list(map(int, input().split()))
sortA = sorted(A)

def solve(A, sortA):
    ans = 0
    min_num = sortA[0]
    for i in range(len(A)):
        x = sortA.index(A[i])
        if x == i:
            continue
        sum_cost = 0
        min_loop = 10**4 + 1
        j = i
        loop_count = 0
        while True:
            loop_count += 1
            sum_cost += A[j]
            min_loop = min(min_loop, A[j])
            if x == j:
                break
            A[j], A[x] = A[x], A[j]
            x = sortA.index(A[j])
        ans += min(sum_cost + (loop_count-2)*min_loop, sum_cost + min_loop + (loop_count+1)*min_num)
    return ans
    
print(solve(A, sortA))
"
9034935,ALDS1_6_D,"'''
コストはサイクル毎のグループで計算できる。

各サイクルのコストは、
・そのサイクルグループの最小値を除いた各要素の重さと、
・運び屋である最小値のコストの和である。
最小値のコストは、運び屋として
・そのサイクルグループの最小値w_sorted[grp_min]を使った場合のコストと、
・全体での最小値w_sorted[0]をサイクルの外から借りてきて使って返した場合のコストのうち、
小さい方を取る。
grp_chg_cntは各サイクルの長さ-1を表していて、
長さ1のサイクルではgrp_chg_cntがゼロなのでコストはゼロになる
（最初から正しい位置にある値は長さ1のサイクル）
ソートしたリストは返却しない、コスト計算結果だけを返却する
'''


n = int(input())
w_unsorted = [*map(int, input().split())]

# ソートして新たなリストを作る
w_sorted = sorted(w_unsorted) 

cost = 0

# n まで 0 から 1 ずつ ソート済リスト(w_sorted)の値 を見ていく
# n個のグループがあることになる
for grp_min_sorted_idx in range(n):
    # ①ソート済リストの一番小さい値（最小値）は、未ソートリストでは何番目か
    grp_min_unsorted_idx = w_unsorted.index(w_sorted[grp_min_sorted_idx])
    grp_chg_cnt = 0
    
    # grp_min_unsorted_idx(未ソートリストでは何番目か)が
    # 外側のソート済リストのインデックスより大きい間、くり返す
    # 言い換えれば未ソートリストのi番目にある文字が正しい位置に収まるまでくり返す
    while grp_min_unsorted_idx > grp_min_sorted_idx:

        # 入れ替え回数カウント
        grp_chg_cnt += 1 

        # 最小値ではない値（未ソートリストにある最小値の位置にある値）のインデックスを取得する
        # 上の①の順番にあるソート済みリストの値は 未ソートリストでは何番目か
        # 対象の数字を置き換えるとき置き換える相手はソートしたらそこにあるべき値にする
        # 動いた後の後釜を正しい位置に入れるようにする
        replace_target_unsorted_idx = w_unsorted.index(w_sorted[grp_min_unsorted_idx]) 

        # 動いた後の後釜の値をコスト（最小値以外のコスト）として加算する
        # そのサイクルの最小値を除いた各要素の重さを加算
        cost += w_unsorted[replace_target_unsorted_idx]

        # 未ソートリストの値を交換        
        w_unsorted[grp_min_unsorted_idx], w_unsorted[replace_target_unsorted_idx] = \
            w_unsorted[replace_target_unsorted_idx], w_unsorted[grp_min_unsorted_idx]
        
        grp_min_unsorted_idx = replace_target_unsorted_idx
    
    # 最小値のコストを算出する
    # 次の①②の小さい方
    # ①(最小値以外の総和) + サイクルグループの最小値 * 入れ替え回数
    # ②(最小値以外の総和) + (全体の最小値 * 入れ替え回数) + (サイクルグループの最小値 * 2) + (全体の最小値 * 2)
    # ②は、もし①のグループ内の並び替えを、グループ外も含む全体での最小値で、交換を行ったら、コストはどうなるかの値
    # (最小値以外の総和)は、上のループ内で加算済

    # cost += min(w_sorted[grp_min] * grp_chg_cnt, w_sorted[grp_min] * 2 + w_sorted[0] * (grp_chg_cnt + 2))
    cost += min(w_sorted[grp_min_sorted_idx] * grp_chg_cnt, 
               (w_sorted[0] * grp_chg_cnt) + w_sorted[grp_min_sorted_idx] * 2 + (w_sorted[0] * 2))
    
print(cost)

"
9036042,ALDS1_6_D,"n = int(input())
lst = list(map(int,input().split()))
lst_sort = sorted(lst)
FLG = [False]*n
x = min(lst)
ans = 0

def keisan(lst):
    global ans,x
    if len(lst) > 2:
        if min(lst)*(len(lst)-2) <= x*(len(lst)+1)+min(lst):
            ans = ans + sum(lst) + (len(lst)-2)*min(lst)
        else:
            ans = ans + sum(lst) + x*(len(lst)+1)+min(lst)
    else:
        ans = ans + sum(lst)

for i in range(n):
    if FLG[i] == True:
        continue
    if lst[i] == lst_sort[i]:
        FLG[i] = True
    else:
        lst2= []
        tmp = i
        lst2.append(lst[i])
        FLG[i] = True
        while True:
            tmp = lst_sort.index(lst[tmp])
            if tmp != i:
                lst2.append(lst[tmp])
                FLG[tmp] = True
            else:
                break
        keisan(lst2)

print(ans)
"
9062965,ALDS1_6_D,"def MinimumCostSort(A: list) -> int:
    cost = 0
    A_sorted = sorted(A)
    for i in range(len(A)):
        x = A.index(A_sorted[i])
        j = 0
        while x > i:
            j += 1
            y = A.index(A_sorted[x])
            cost += A[y]
            A[x], A[y] = A[y], A[x]
            x = y
        cost += min(A_sorted[i] * j, A_sorted[i] * 2 + A_sorted[0] * (j + 2))
    return cost

n = int(input())
w = list(map(int, input().split()))
print(MinimumCostSort(w))
"
9068133,ALDS1_6_D,"from typing import List
import sys

if __name__ == '__main__':
    n: int = int(input())
    A: List[int] = [int(param) for param in input().split()]
    B: List[int] = [num for num in A]

    B.sort()

    ans: int = 0

    V: List[bool] = [False] * n
    T: dict[int, int] = {}

    for i in range(n):
        T[B[i]] = i

    s: int = min(A)

    for i in range(n):
        if not V[i]:
            cur: int = i
            S: int = 0
            m: int = sys.maxsize
            an: int = 0

            while True:
                V[cur] = True
                an = an + 1
                v: int = A[cur]
                m = min(v, m)
                S = S + v
                cur = T[v]
                if V[cur]:
                    break
            
            ans = ans + min(S + (an - 2) * m, m + S + (an + 1) * s)

    print(ans)
"
9103660,ALDS1_6_D,"def solve(A):
    ans = 0
    s = min(A)

    V = [False for _ in range(len(A))]  # 訪問済みかどうか
    B = []
    for a in A:
        B.append(a)
    B = sorted(B)

    T = [0 for _ in range(max(A)+1)]
    for i in range(len(B)):
        T[B[i]] = i

    for i in range(len(A)):
        if (V[i]):
            continue
        cur = i  # 現在のサイクルの開始点
        S = 0
        m = max(A)
        an = 0  # サイクル内の要素数を記録
        while True:
            V[cur] = True  # 訪問済みにする
            an += 1
            v = A[cur]  # 現在の点の値
            m = min(m, v)  # 最小の要素を探す
            S += v  # サイクル内の要素数の総和を計算
            cur = T[v]  # サイクルの中、次の要素
            if (V[cur]):
                # サイクル一周回ったら、終了
                break
        ans += min((S+(an-2)*m), (m+S+(an+1)*s))

    return ans


n = int(input())
A = list(map(int, input().split()))

ans = solve(A)
print(ans)

"
2008136,ALDS1_6_D,"def solve(A, n):
    s = min(A)
    ans = 0

    B = A[:]
    V = [False for i in A]
    B = sorted(B)
    T = [0 for i in range(VMAX+1)]
    for i in range(n):
        T[B[i]] = i

    for i in range(n):
        if V[i]:
            continue
        cur = i
        S = 0
        m = VMAX
        an = 0

        while True:
            V[cur] = True
            an += 1
            v = A[cur]
            m = min(m, v)
            S += v
            cur = T[v]
            if V[cur]:
                break
        ans += min(S + (an - 2) * m, m + S + (an + 1) * s)
    return ans

MAX = 1000
VMAX = 10000


n = int(input())
A = list(map(int, input().split()))

ans = solve(A, n)
print(ans)
"
2178623,ALDS1_6_D,"

MAX_NUM = int(1E4 + 1)

if __name__ == '__main__':
    N = int(input())
    A = [int(i) for i in input().strip().split()]
    sorted_A = sorted(A)
    smallest = sorted_A[0]
    correct_pos = [0] * MAX_NUM
    flag_A = [False] * MAX_NUM
    for i, val in enumerate(sorted_A):
        correct_pos[val] = i

    ans = 0
    for i in range(len(A)):
        if flag_A[A[i]]:
            continue
        next_pos = i
        sum = 0
        m = 1E4
        an = 0
        while True:
            an += 1
            val = A[next_pos]
            sum += val
            m = min([m, val])
            flag_A[A[next_pos]] = True
            next_pos = correct_pos[val]
            if flag_A[A[next_pos]]:
                break
        ans += min([sum + (an - 2) * m, m + sum + (an + 1) * smallest])

    print(ans)
"
2691567,ALDS1_6_D,"# -*- coding: utf-8 -*-


if __name__ == '__main__':

    n = int(input())
    A = [int(a) for a in input().split("" "")]
    B = A.copy()
    B.sort()
    V = [False]*n
    T = {B[i]:i for i in range(n)}

    ans = 0
    s = min(A)

    for i in range(n):
        if V[i]:
            continue
        cur = i
        S = 0 # sum of weight
        m = 10000 # min of cycle(init max weight)
        an = 0 # length of cycle
        while not V[cur]:
            V[cur] = True
            an += 1
            v = A[cur]
            m = min(m, v)
            S += v
            cur = T[v]
        ans += min(S + (an - 2)*m, m + S + (an + 1)*s)

    print(ans)
"
2693808,ALDS1_6_D,"n = int(input())
A = list(map(int, input().split()))
s = min(A)
def solve():
    ans = 0
    V = [False] * n
    B = sorted(A)
    T = {B[i]: i for i in range(n)}
    for i in range(n):
        if V[i]:
            continue
        cur = i
        S = an = 0
        m = 10000
        while not V[cur]:
            V[cur] = True
            an += 1
            v = A[cur]
            m = min(m, v)
            S += v
            cur = T[v]
        ans += min(S + (an - 2) * m, m + S + (an + 1) * s)
    return ans
print(solve())

"
2702242,ALDS1_6_D,"def decode():
    n = int(input())
    w = [int(x) for x in input().split()]

    return n, w


def search(w, sw, swi):
    wi = w.index(sw[swi])
    cost = 0
    count = 0
    while wi != swi:
        tw = sw[wi]
        ti = w.index(tw)
        w[ti], w[wi] = w[wi], w[ti]
        cost += w[ti] + w[wi]
        count += 1
        wi = ti
    return cost, count


def search_min_cost(w):
    sorted_w = list(w)
    sorted_w.sort()

    min_w = sorted_w[0]
    cost = 0

    for i, sww in enumerate(sorted_w):
        tmp_cost, count = search(w, sorted_w, i)
        cost += min(tmp_cost, tmp_cost + (min_w + sww) * 2 - (sww - min_w) * count)

    return cost


if __name__ == '__main__':

    n, w = decode()
    print(search_min_cost(w))
"
2709676,ALDS1_6_D,"def calc_cost(hoge):
    cost = 0
    hoge_refer = sorted(hoge[:])
    #checker true means that this index have already looked.
    checker = [False] * len(hoge)
    #abs_min is minimum num in input array.
    abs_min = hoge_refer[0]
    #indexer -> key: sorted val, val: zero 2 n-1
    indexer = {hoge_refer[i]:i for i in range(len(hoge_refer))}
    
    for now_index in range(len(hoge)):
        if checker[now_index]:
            continue
        current = now_index
        size = 0
        sum_num = 0
        circle_min = 10 ** 4
        while True:
            checker[current] = True
            size += 1
            val = hoge[current]
            circle_min = min(circle_min, val)
            sum_num += val
            current = indexer[val]
            if checker[current]:
                break
        cost += min(sum_num+(size-2)*circle_min, circle_min+sum_num+(size+1)*abs_min)
    return cost
        
    
if __name__ == '__main__':
    _ = int(input())
    hoge = [int(x) for x in input().split()]
    print(calc_cost(hoge))
"
2714414,ALDS1_6_D,"input()
a=list(map(int,input().split()))
b=sorted(a)
c=0
for i in range(len(a)):
 x=a.index(b[i])
 j=0
 while x>i:
  j+=1
  y=a.index(b[x])
  c+=a[y]
  a[x],a[y]=a[y],a[x]
  x=y
 c+=min(b[i]*j,b[i]*2+b[0]*(j+2))
print(c)
"
2720035,ALDS1_6_D,"def solve():
    ans = 0

    B = A[:]
    V = [False] * n

    B.sort()
    for i in range(n):
        T[B[i]] = i
    for i in range(n):
        if V[i]:
            continue
        cur = i
        S = 0
        m = 10000  # 10**4
        an = 0
        while True:
            V[cur] = True
            an += 1
            v = A[cur]
            m = min(m, v)
            S += v
            cur = T[v]
            if V[cur]:
                break
        ans += min(S + (an - 2) * m, m + S + (an + 1) * s)
    return ans


if __name__ == '__main__':
    n = int(input())
    A = [int(i) for i in input().split()]
    s = min(A)
    s = min(s, 10000)
    T = [0] * (max(A)+1)
    ans = solve()
    print(ans)
"
2812008,ALDS1_6_D,"

SENTINEL = 10**9 + 1


def merge_sort(alist):
    """"""Sort alist using mergesort.
    Returns a tuple of the number of comparisons and sorted list.

    >>> merge_sort([8, 5, 9, 2, 6, 3, 7, 1, 10, 4])
    (34, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
    """"""
    def _sort(left, right):
        count = 0
        if left + 1 < right:
            mid = (left + right) // 2
            count += _sort(left, mid)
            count += _sort(mid, right)
            count += merge(left, mid, right)

        return count

    def merge(left, mid, right):
        count = 0
        ll = alist[left:mid] + [SENTINEL]
        rl = alist[mid:right] + [SENTINEL]

        i = j = 0
        for k in range(left, right):
            count += 1
            if ll[i] <= rl[j]:
                alist[k] = ll[i]
                i += 1
            else:
                alist[k] = rl[j]
                j += 1

        return count

    comp = _sort(0, len(alist))
    return (comp, alist)


def min_cost(li1, li2):
    """"""calculate minimum cost to transform li1 into li2.

    >>> min_cost([1, 5, 3, 4, 2], [1, 2, 3, 4, 5])
    7
    >>> min_cost([4, 3, 2, 1], [1, 2, 3, 4])
    10
    """"""
    def find_moves(i, j):
        start = i
        elems = [i]
        mincost = li1[i]
        minidx = 0

        while j != start:
            if mincost > li1[j]:
                mincost = li1[j]
                minidx = len(elems)
            elems.append(j)
            j = li2.index(li1[j])

        elems = elems[minidx+1:] + elems[:minidx+1]
        if 2 * (mincost + li1[mini]) < (len(elems) - 1) * (mincost - li1[mini]):
            elems.append(mini)
            elems.insert(0, mini)

        q = elems.pop()
        p = elems.pop()
        yield (p, q)
        while len(elems) > 0:
            q = p
            p = elems.pop()
            yield (p, q)


    def move(i, j):
        cost = 0
        for p, q in find_moves(i, j):
            li1[p], li1[q] = li1[q], li1[p]
            cost += li1[p] + li1[q]

        return cost

    assert len(li1) == len(li2)
    size = len(li1)
    totalcost = 0

    for i in reversed(range(size)):
        if li1[i] != li2[i]:
            mini = li1.index(li2[0])
            totalcost += move(li1.index(li2[i]), i)

    return totalcost


def run():
    _ = int(input())  # flake8: noqa
    li = [int(i) for i in input().split()]
    sli = li[:]
    (_, sli) = merge_sort(sli)

    print(min_cost(li, sli))


if __name__ == '__main__':
    run()

"
2886788,ALDS1_6_D,"def solve(A, n, s):
    ans = 0

    V = [False for i in range(n)] # 値が交換済みかどうか
    B = sorted(A)
    T = [None for i in range(10001)]
    for i in range(n):
        T[B[i]] = i
    for i in range(n):
        if V[i]: continue
        cur = i # カーソル(サークル内で動かす)
        S = 0 # サークル内の数字の総和
        m = 10000
        an = 0 # サークルに含まれる数字の数
        while True:
            V[cur] = True
            an += 1
            v = A[cur]
            m = min(m, v) # mがサークル内の数字の最小値
            S += v
            cur = T[v]
            if V[cur]: break
        ans += min(S + (an-2)*m, m+S+(an+1)*s)
    return ans

n = int(input())
A = list(map(int, input().split(' ')))
s = min(A)
ans = solve(A, n, s)
print(ans)
"
2910657,ALDS1_6_D,"#coding:utf-8
n = int(input())
A = list(map(int, input().split()))
B = A[:]
B.sort()
C = [True for i in range(n)]
minA = min(A)

j = 0
a = []
total = 0
for i in range(n):
    circle = []
    j = i
    while C[j]:
        C[j] = False
        j = B.index(A[j])
        circle.append(A[j])
    n_c = len(circle)
    if n_c == 2:
        total += (circle[0]+circle[1])
    if n_c > 2:
        minc = min(circle)
        cirSum = sum(circle)
        total += min( cirSum + (n_c-2) * minc , cirSum + minc + (n_c+1)*minA)
    a.append(circle)
    

print(total)

"
3065274,ALDS1_6_D,"def solve(a, n):
    vmax = 10000
    ans = 0
    all_min = min(a)
    b = sorted(a)
    v = [False] * n

    t = {}
    for i in range(n):
        t[b[i]] = i
    for i in range(n):
        if v[i]:
            continue
        cur = i
        w_sum = 0
        w_min = vmax
        an = 0
        while True:
            v[cur] = True
            an += 1
            v_cur = a[cur]
            w_min = min(w_min, v_cur)
            w_sum += v_cur
            cur = t[v_cur]
            if v[cur]:
                break
        ans += min(w_sum + (an-2) * w_min, w_min + w_sum + (an+1) * all_min)

    return ans


n = int(input())
a = [int(v) for v in input().split()]

ans = solve(a, n)
print(ans)
"
3185351,ALDS1_6_D,"N = int(input())
*W, = map(int, input().split())
C = {w: i for i, w in enumerate(W)}
W.sort()

ans = 0
S = []
used = [0]*N
for i in range(N):
    if used[i]:
        continue
    sq = []
    w = W[i]
    p = i; j = None
    while j != i:
        j = C[w]; w = W[j]
        used[j] = 1
        sq.append(w)
        p = j
    mi = min(sq); ln = len(sq)
    if ln >= 2:
        ans += sum(sq)
    S.append((mi, ln))
S.sort()
m, ln = S[0]
if ln >= 2:
    ans += (ln-2)*m
for mi, ln in S[1:]:
    if ln <= 2:
        continue
    ans += min(m+mi+ln*m, (ln-2)*mi)
print(ans)

"
3190988,ALDS1_6_D,"n=int(input())
data=list(map(int,input().split()))

sorted_data=sorted(data)
mindata=sorted_data[0]

data_dict={}
for i in range(n):
    data_dict[data[i]]=i#key：データに含まれる要素　value:そのデータのインデックス

sorted_data_dict={}
for i in range(n):
    sorted_data_dict[sorted_data[i]]=i


swap_cost=0


for x in sorted_data:
    if(sorted_data_dict[x]!=data_dict[x]):
        tmp_cost=0
        swap_num=0

        while(sorted_data_dict[x]!=data_dict[x]):
            ind1=data_dict[x]
            ind2=data_dict[sorted_data[ind1]]
            data_dict[x]=ind2
            data_dict[sorted_data[ind1]]=ind1
            tmp_cost+=x+sorted_data[ind1]
            swap_num+=1
        if( (x+mindata)*2 < swap_num*(x-mindata) ):
            tmp_cost+=(x+mindata)*2 - swap_num*(x-mindata)
        swap_cost+=tmp_cost

print(swap_cost)
"
3222429,ALDS1_6_D,"def main():
    n = int(input())
    array = [int(x) for x in input().split()]
    sorted_array = sorted(array)

    groups = []
    for i in range(len(array)):
        moving_src_val = array[i]
        if not moving_src_val:
            continue
        group = [moving_src_val]
        while True:
            moving_tgt_idx = sorted_array.index(moving_src_val)
            moving_tgt_val = array[moving_tgt_idx]
            if moving_tgt_val in group:
                break
            group.append(moving_tgt_val)
            array[moving_tgt_idx] = False
            moving_src_val = moving_tgt_val
        array[i] = False
        groups.append(group)

    #print(groups)

    min_cost = 0
    min_in_array = sorted_array[0]
    for group in groups:
        n_group = len(group)
        if n_group == 1:
            continue
        min_in_group = min(group)
        sum_without_min = sum(group) - min_in_group

        cost1 = (n_group - 1) * min_in_group
        cost2 = (n_group + 1) * min_in_array + 2 * min_in_group

        if cost1 < cost2:
            min_cost += cost1 + sum_without_min
        else:
            min_cost += cost2 + sum_without_min

    print(min_cost)
    return


main()
"
3285771,ALDS1_6_D,"def solve(a,n,mn,mx):
	ans=0
	V=[False]*n
	b=sorted(a)
	T=[0]*(mx+1)
	for i in range(n): T[b[i]]=i
	for i in range(n):
		if V[i]: continue
		cur=i
		sum=0
		cnt=0
		m=1<<30
		while True:
			V[cur]=True
			v=a[cur]
			cnt+=1
			sum+=v
			m=min(m,v)
			cur=T[v]
			if V[cur]: break
		ans+=min(sum+(cnt-2)*m,sum+m+(cnt+1)*mn)
	return ans

n=int(input())
a=list(map(int,input().split()))
mn=1<<30
mx=mn*-1
for i in range(n):
	mn=min(mn,a[i])
	mx=max(mx,a[i])
print(solve(a,n,mn,mx))

"
3287113,ALDS1_6_D,"def silly_sort(target):
    ranked = sorted(target)
    length = len(target)
    rings = [n for n in range(length)]
    all_cost = 0
    minimum = ranked[0]
    base_index = {}
    rank_index = {}
    for i, (t, r) in enumerate(zip(target, ranked)):
        base_index[t] = i
        rank_index[r] = i
    for i in range(length):
        if rings[i] != -1 and target[i] != ranked[i]:
            ring_sum = target[i]
            min_m = target[i]
            num_ring = 1
            next_index = rank_index[target[i]]
            next_num = target[next_index]
            while next_index != i:
                # print(i, next_index, target[i], min_m, ring_sum)
                num_ring += 1
                ring_sum += next_num
                min_m = min(min_m, next_num)
                rings[next_index] = -1
                next_index = rank_index[target[next_index]]
                next_num = target[next_index]
            # print(min((ring_sum + min_m * (num_ring - 2) ), (ring_sum + min_m + minimum * (num_ring + 1) ) ))
            all_cost += min((ring_sum + min_m * (num_ring - 2) ), (ring_sum + min_m + minimum * (num_ring + 1) ) )
        rings[i] = -1
    return all_cost

l = int(input())
t = [int(n) for n in input().split("" "")]
print(silly_sort(t))
"
3393809,ALDS1_6_D,"from sys import stdin

W_MAX = 10000

n = int(stdin.readline().rstrip())
w = [int(x) for x in stdin.readline().rstrip().split()]
min_w = min(w)
idx = {}
for i, wi in enumerate(sorted(w)):
    idx[wi] = i

isVisited = [False]*n
cost = 0
for i in range(n):
    if isVisited[i]:
        continue

    cur = i
    cyc = []
    min_cyc = W_MAX
    while not isVisited[cur]:
        isVisited[cur] = True
        cyc.append(w[cur])
        min_cyc = min(min_cyc, w[cur])
        cur = idx[w[cur]]

    cost += min(sum(cyc) + (len(cyc)-2)*min_cyc, sum(cyc) + (len(cyc)+1)*min_w + min_cyc)

print(cost)

"
3434810,ALDS1_6_D,"# Minimum cost sort

n = int(input())
*w, = map(int, input().split())
s = list(sorted(w))

si = [0] * 10001
for i, v in enumerate(s):
    si[v] = i

ans = 0
b = [False] * n
for i in range(n):
    if b[i]:
        continue
    j = i
    mw = w[i]
    z = 0
    nn = 0
    while b[j] == False:
        b[j] = True
        nn += 1
        mw = min(w[j], mw)
        z += w[j]
        j = si[w[j]]
    c = min((nn - 2) * mw + z, mw + z + (nn + 1) * s[0])
    ans += c

print(ans)
"
3438582,ALDS1_6_D,"n = int(input())
n_lst = list(map(int, input().split()))
sorted_lst = sorted(n_lst)
cost = 0

for i in range(n):
    a = n_lst.index(sorted_lst[i])
    j = 0
    while a > i:
        j += 1
        b = n_lst.index(sorted_lst[a])
        cost += n_lst[b]
        n_lst[a],n_lst[b] = n_lst[b],n_lst[a]
        a = b
    cost += min(sorted_lst[i]*j,sorted_lst[i]*2+sorted_lst[0]*(j+2))
print(cost)

"
3533157,ALDS1_6_D,"#最小コストソート

n = int(input())
a = list(map(int, input().split()))
b = sorted(a)
c = 0
for i in range(n-1):
    t = cnt = 0
    x = a.index(b[i])
    while x != i:
        y = a.index(b[x])
        a[x],a[y] = a[y],a[x];cnt += 1
        t += a[x] + a[y]
        x = y
    if cnt: c += min(t, (b[i]+b[0])*2 + t -(b[i]-b[0])*cnt)
print(c)

"
3567677,ALDS1_6_D,"def solve(A):
    correct_a = sorted(A)
    correct_index = {n: i for i, n in enumerate(correct_a)}
    ans, min_n = 0, correct_a[0]
    cycles = []
    used = [0]*len(A)
    for i in filter(lambda i: not used[i], range(len(A))):
        used[i] = 1
        cycle, next_i = [i], correct_index[A[i]]
        while next_i != i:
            cycle.append(next_i)
            used[next_i] = 1
            next_i = correct_index[A[next_i]]
        cycles.append(cycle)

    for cycle in cycles:
        if len(cycle) == 2:
            ans += correct_a[cycle[0]] + correct_a[cycle[1]]
        elif len(cycle) > 2:
            ans += (min(correct_a[cycle[0]]*(len(cycle)-1), correct_a[cycle[0]]*2 + min_n*(len(cycle)+1))
                    + sum(correct_a[i] for i in cycle[1:]))

    return ans


if __name__ == ""__main__"":
    input()
    a = list(map(int, input().split()))
    print(solve(a))
"
3656717,ALDS1_6_D,"# INPUT
n = int(input())
W = list(map(int, input().split()))


# PROCESS
cost = 0
W_sorted = sorted(W)
W_min = W_sorted[0]

for i in range(n - 1):
    cycle_min = W_sorted[i]
    cost_cycle_in = 0
    cnt_change = 0

    index_cycle_min = W.index(cycle_min)

    while index_cycle_min != i:
        cycle_change = W_sorted[index_cycle_min]
        index_cycle_change = W.index(cycle_change)

        W[index_cycle_min], W[index_cycle_change] = cycle_change, cycle_min
        cost_cycle_in += cycle_min + cycle_change

        cnt_change += 1
        index_cycle_min = index_cycle_change

    if cnt_change:
        cost_cycle_out = (
            cost_cycle_in
          + (cycle_min + W_min) * 2
          - (cycle_min - W_min) * cnt_change
        )

        cost += min(cost_cycle_in, cost_cycle_out)


# OUTPUT
print(cost)

"
3803885,ALDS1_6_D,"n = int(input())
wlist = list(map(int,input().split()))
wdic = {j:i for i,j in enumerate(wlist)}
wlist.sort()
cost = 0
used = [0]*n
res = []
for i in range(n):
    storage = []
    if used[i]:
        continue # next loop
    w = wlist[i]
    minimum = w
    used[i] = 1
    a = wdic[w]
    b = wlist[a]
    storage.append(w)
    while b not in storage:
        w = b
        used[a] = 1
        a = wdic[w]
        b = wlist[a]
        storage.append(w)
        #print(w,a,b,storage)
    ls = len(storage)
    cost += (sum(storage) - minimum)
    res.append((minimum,ls))
m,l = res[0]
if l>=2:
    cost += m*(l-1)
for minimum,ls in res[1:]:
    if ls>=2:
        cost += min(2*(m+minimum)+m*(ls-1), minimum*(ls-1))
    
print(cost)
"
3809591,ALDS1_6_D,"n = int(input())
A = list(map(int, input().split()))

B = sorted(A)
c = 0

for i in range(n-1):
    t = cnt = 0
    x = A.index(B[i])
    
    while x != i:
        y = A.index(B[x])
        A[x], A[y] = B[x], B[i]
        cnt += 1
        t += B[x] + B[i]
        x = y
    if cnt:
        c += min(t, (B[i]+B[0])*2+t-(B[i]-B[0])*cnt)
print(c)
"
3846422,ALDS1_6_D,"def calc_loop_cost(loop, min_w):
    if len(loop) == 1:
        return 0
    elif len(loop) == 2:
        return loop[0] + loop[1]
    else:
        cost1 = sum(loop) + (len(loop) - 2) * min(loop)
        cost2 = sum(loop) + min(loop) + (len(loop) + 1) * min_w
        return min(cost1, cost2)

n = int(input())
org_list = [int(s) for s in input().split()]
sorted_list = sorted(org_list)
check_list = [False] * n
loop_list = []
for i in range(n):
    if check_list[i]:
        continue

    loop = []
    check_list[i] = True
    loop.append(org_list[i])
    next_idx = sorted_list.index(org_list[i])
    while next_idx != i:
        check_list[next_idx] = True
        loop.append(org_list[next_idx])
        next_idx = sorted_list.index(org_list[next_idx])

    loop_list.append(loop)

min_w = sorted_list[0]
cost_sum = 0
for lp in loop_list:
    cost_sum += calc_loop_cost(lp, min_w)

print(cost_sum)
"
3875173,ALDS1_6_D,"MAX = 1000
VMAX = 10000


def main():
    n = int(input())
    
    a_s = list(map(int, input().split(' ')))
    minimum = min(a_s)

    ans = 0

    t_s = [0] * (VMAX+1)
    b_s = [a for a in a_s]
    v_s = [False for _ in range(n)]
    b_s = sorted(b_s)

    for i in range(n):
        t_s[b_s[i]] = i

    for i in range(n):
        if v_s[i]:
            continue
        cur = i
        S = 0
        m = VMAX
        a_n = 0

        while True:
            v_s[cur] = True
            a_n += 1
            v = a_s[cur]
            m = min(m, v)
            S += v
            cur = t_s[v]
            if v_s[cur]:
                break
        ans += min(S + (a_n-2)*m, m+S+(a_n+1)*minimum)
    
    print(ans)


if __name__ == '__main__':
    main()

"
3875481,ALDS1_6_D,"#最小コストソート
n = int(input())
A = list(map(int, input().split()))
#整列
B = sorted(A)
#サイクルに採用されたか否か
C = [0 for _ in range(n)]
CNT = 0
minA = B[0]

for i in range(n):
    #正しい位置にいるか
    if A[i] == B[i]:
        C[i] == 1
    #サイクルに採用済みか
    elif C[i] == 0:
        cyc = []
        ind = i
        #サイクル作成
        while C[ind] == 0:
            a = A[ind]
            cyc.append(a)
            C[ind] = 1
            ind = B.index(a)
        #2種のコスト計算
        mincyc = min(cyc)
        cost1 = sum(cyc) + (len(cyc) - 2) * mincyc
        cost2 = sum(cyc) + mincyc + (len(cyc) + 1) * minA
        if cost1 > cost2:
            CNT += cost2
        else:
            CNT += cost1
    else:
        pass
print(CNT)
"
3897193,ALDS1_6_D,"n = int(input())
W = list(map(int, input().split()))

W_org = W[:]
W_org_idx = {w:i for i, w in enumerate(W_org)}
W_srt = list(sorted(W[:]))
W_srt_idx = {w:i for i, w in enumerate(W_srt)}

#print(W_org)
#print(W_org_idx)
#print(W_srt)
#print(W_srt_idx)


def rec(idx, ret):
    if W_org[idx] in ret:
        return ret
    
    ret.append(W_org[idx])
    idx = W_srt_idx[W_org[idx]]
    return rec(idx, ret)

ans = 0
searched = set()
all_min_r = min(W_org)
for i in range(n):    
    if W_org[i] in searched:
        continue
    ret = rec(i, [])
    for r in ret:
        searched.add(r)
    
    if len(ret) == 1:
        continue
    elif len(ret) == 2:
        ans += sum(ret)
    else:
        #print(ret)
        min_r = min(ret)
        ans_a = sum(ret) + len(ret)*min_r - 2*min_r
        
        ans_b = 2*(all_min_r+min_r) + (sum(ret)-min_r+all_min_r) + len(ret)*all_min_r - 2*all_min_r
        ans += min(ans_a, ans_b)

print(ans)
        
    
    

"
3913946,ALDS1_6_D,"def solve(n, A):
    def cycles():
        V = [False] * n
        B = sorted(A)
        T = {B[i]: i for i in range(n)}
        C = []

        for i in range(n):
            if V[i]:
                continue
            cur = i
            cycle = []
            while not V[cur]:
                V[cur] = True
                cycle.append(cur)
                cur = T[A[cur]]
            C.append(cycle)

        return C

    ans = 0
    s = min(A)

    for cycle in cycles():
        S = sum([A[i] for i in cycle])
        m = min([A[i] for i in cycle])
        an = len(cycle)
        ans += min(S + (an - 2) * m, m + S + (an + 1) * s)

    return ans


def main():
    n = int(input())
    A = [int(x) for x in input().split()]

    print(solve(n, A))


main()

"
3919293,ALDS1_6_D,"VMAX = 10000

def minCostSort(A, n):
	global VMAX
	VMIN = min(A)
	ans = 0
	B = A.copy()
	B.sort()
	T = [0] * (VMAX + 1)
	for i in range(n):
		T[B[i]] = i
	V = [False] * n
	for i in range(n):
		if V[i]:
			pass
		else:
			index = i
			minv = VMAX
			count = 0
			cycleweight = 0
			while 1:
				V[index] = True
				count += 1
				value = A[index]
				minv = min(minv, value)
				cycleweight += value
				index = T[value]
				if V[index]:
					break
			ans += min(cycleweight + (count - 2) * minv, cycleweight + minv + (count + 1) * VMIN)
	return ans


if __name__ == ""__main__"":
	n = int(input())
	A = list(map(int, input().split()))
	print(minCostSort(A, n))
"
3924133,ALDS1_6_D,"# https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/6/ALDS1_6_D
# 本の解説がわかりやすい
# ここでは本には書いてないことの補足を意識しながらコメントを付けていく
WMAX = 10**4 + 1
n = int(input())
A = list(map(int, input().split()))
B = sorted(A)
is_visited = [False] * n  # 巡回管理用
next_idxs = {}  # Aの要素について、これのkeyを見れば、その数字がsort後にどの位置にあるのかわかるように対応させる
for i, b in enumerate(B):
    next_idxs[b] = i

m_A = min(A)  # globalで一番小さい要素

# ソート後の並び順から巡回可能なグループから答えを計算する
# グループ内の最小の要素をm, グループの和をS, グループ内の要素数をn2とする。
# 具体的には,m*(n2-2) + S もしくは m + S + (1+n2)*m_Aのうち小さい方
ans = 0
for i in range(n):
    if is_visited[i]:
        continue  # 巡回済みならば次へ
    cur = i  # 巡回制御用のidx #探索済みでないiが入るはず
    S = 0  # 合計管理用
    n2 = 0
    m = WMAX  # グループ内の最小値探索用
    while True:
        # まずはもろもろの値を更新
        is_visited[cur] = True
        S += A[cur]
        m = min(m, A[cur])
        n2 += 1
        # ここで次のidxを取得する
        cur = next_idxs[A[cur]]
        if is_visited[cur]:
            break  # もし一周したらおわり
    # ループ内で完結したほうがいいのか外から要素を変えいてきたほうがいいのか
    # 小さい方を採用して答えに足し込む
    ans += min(m*(n2-2)+S, m+S+(1+n2)*m_A)

print(ans)

"
3928393,ALDS1_6_D,"n = int(input())
w = list(map(int, input().split()))
b = w[:]
w.sort()
s = w[0]

class Solve():
    def __init__(self, w, b, s):
        self.w = w
        self.b = b
        self.s = s
        self.ans = 0
        self.v = [0] * n
    
    def sort(self):
        T = [0] * 10001
        for i in range(n):
            T[self.w[i]] = i
        for i in range(n):
            if self.v[i]:
                continue
            cur = i
            S = 0
            m = 10001
            an = 0
            while 1:
                self.v[cur] = 1
                an += 1
                l = self.b[cur]
                m = min(m, l)
                S += l
                cur = T[l]
                if self.v[cur]:
                    break
            self.ans += min(S + (an - 2) * m, S + m +(an + 1) * self.s)
        return self

cost = Solve(w, b, s).sort()
print(cost.ans)
"
3993698,ALDS1_6_D,"
def solve(A, N):
    answer = 0

    B = list(A)
    V = [False] * N
    T = [None] * 10001
    s = min(A)

    B.sort()

    # print(A)
    # print(B)

    for i in range(N):
        T[B[i]] = i

    for i in range(N):
        if V[i] is True:  # すでにカーソルが来ていたら飛ばす。
            continue

        cur = i  # カーソル
        S = 0
        m = 10000  # VMAX
        an = 0  # サイクルの長さ

        while True:
            V[cur] = True  # まずは今の位置を走査済みにする。
            an += 1  # サイクルの長さを増やす
            v = A[cur]  # 入力列の値
            m = min(m, v)  # このサイクルの最小値
            S += v  # 今の値の重さを足す。SはΣwi
            cur = T[v]  # 次のカーソルの位置を決める
            if V[cur]:  # 次のカーソルの位置がTrueなら
                break  # サイクルの始まりまで戻ってきたということ。

        # この状態で、
        # an = サイクルの長さ
        # S = wiの合計の重さ
        # m = このサイクルの最小値
        # の3つが分かっている。

        answer += min(S + (an - 2) * m, m + S + (an + 1) * s)

    return answer


N = int(input())
A = list(map(int, input().split()))

answer = solve(A, N)
print(answer)

"
4048989,ALDS1_6_D,"def min_cost(nums, n):
    sorted_list = sorted(nums)
    global_min = sorted_list[0]
    check_list = [False] * n
    cost = 0
    for start_idx in range(n):
        if check_list[start_idx]:
            pass
        else:
            start_num = nums[start_idx]
            cycle_idx = start_idx
            cycle_count = 0
            min_num = start_num
            w_sum = 0
            while True:
                check_list[cycle_idx] = True
                cycle_num = nums[cycle_idx]
                w_sum += cycle_num
                next_idx = sorted_list.index(cycle_num)
                min_num = min(min_num, cycle_num)
                if next_idx == start_idx:
                    break
                cycle_idx = next_idx
                cycle_count += 1
            if cycle_count >= 1:
                cost1 = w_sum + (cycle_count - 1) * min_num
                cost2 = w_sum + min_num + (cycle_count + 2) * global_min
                cost += min(cost1, cost2)
    return cost


def main():
    n = int(input())
    nums = list(map(int, input().split("" "")))
    cost = min_cost(nums, n)
    print(cost)


if __name__ == ""__main__"":
    main()

"
4067474,ALDS1_6_D,"def minimum_cost(A, m, k):
    """"""整数列 A を最小コストソートでソートした場合の総コストを返す。

    A 内の整数は 0 <= <= k のすべて異なる整数であり、
    m がその中で最小の数。
    """"""
    # A 内の整数 i の出現数を C[i] に記録していく。
    C = [0 for _ in range(0, k + 1)]
    for x in A:
        C[x] += 1
    
    # A 内の i 番目の整数のソート後の位置（0 起点）を C[i] に記録する。
    C[0] -= 1
    for i in range(1, k + 1):
        C[i] += C[i - 1]

    total_cost = 0
    n = len(A)
    for i in range(n):
        j = i
        length = 0
        sum_weight = 0
        cur_min = k + 1
        while C[A[j]] >= 0:
            length += 1
            sum_weight += A[j]
            if A[j] < cur_min:
                cur_min = A[j]
            z = C[A[j]]
            C[A[j]] = -1
            j = z
        if length >= 3:
            if cur_min > m:
                total_cost += min(sum_weight + cur_min * (length - 2),
                                  (sum_weight - cur_min) + m * (length - 1) + 2 * (m + cur_min))
            else:
                total_cost += sum_weight + cur_min * (length - 2)
        elif length == 2:
            total_cost += sum_weight

    return total_cost

if __name__ == '__main__':
    import sys

    n = int(input())
    A = list(map(int, sys.stdin.readline().split()))
    print(minimum_cost(A, min(A), max(A)))
"
4080203,ALDS1_6_D,"n = int(input())
A = list(map(int, input().split()))
B = sorted(A)
m_A = B[0]

next_idxs = {}
for i in range(n):
    next_idxs[B[i]] = i

ans = 0
is_visited = [False] * n

for i in range(n):
    if is_visited[i]:
        continue
    cur = i
    S = 0
    n2 = 0
    m = A[i]
    while True:
        is_visited[cur] = True
        S = S + A[cur]
        m = min(m, A[cur])
        n2 = n2 + 1
        cur = next_idxs[A[cur]]
        if is_visited[cur]:
            break
    ans = ans + min(m*(n2-2)+S, m + S + (n2+1)*m_A)

print(ans)
"
4158371,ALDS1_6_D,"def minimum_cost_sort():
    sorted_positions = {str(val):i for i, val in enumerate(sorted(W))}
    is_passed = [False]*n
    minimum_weight = min(W)
    ans = 0
    for i in range(n):
        if is_passed[i]:
            continue
        pointer = i
        total_weight = 0
        local_minimum_weight = 10000
        counter = 0
        while not is_passed[pointer]:
            is_passed[pointer] = True
            total_weight += W[pointer]
            local_minimum_weight = min(local_minimum_weight, W[pointer])
            pointer = sorted_positions[str(W[pointer])]
            counter += 1
        ans += min(total_weight+local_minimum_weight*(counter-2), total_weight+minimum_weight*(counter+1)+local_minimum_weight)
    print(ans)

if __name__ == ""__main__"":
    n = int(input())
    W = list(map(int, input().split()))
    minimum_cost_sort()
"
4163711,ALDS1_6_D,"WMAX = 10**4 + 1
n = int(input())
A = list(map(int, input().split()))
B = sorted(A)
is_visited = [False] * n  # 巡回管理用
next_idxs = {}  # Aの要素について、これのkeyを見れば、その数字がsort後にどの位置にあるのかわかるように対応させる
for i, b in enumerate(B):
    next_idxs[b] = i

m_A = min(A)  # globalで一番小さい要素

# ソート後の並び順から巡回可能なグループから答えを計算する
# グループ内の最小の要素をm, グループの和をS, グループ内の要素数をn2とする。
# 具体的には,m*(n2-2) + S もしくは m + S + (1+n2)*m_Aのうち小さい方
ans = 0
for i in range(n):
    if is_visited[i]:
        continue  # 巡回済みならば次へ
    cur = i  # 巡回制御用のidx #探索済みでないiが入るはず
    S = 0  # 合計管理用
    n2 = 0
    m = WMAX  # グループ内の最小値探索用
    while True:
        # まずはもろもろの値を更新
        is_visited[cur] = True
        S += A[cur]
        m = min(m, A[cur])
        n2 += 1
        # ここで次のidxを取得する
        cur = next_idxs[A[cur]]
        if is_visited[cur]:
            break  # もし一周したらおわり
    # ループ内で完結したほうがいいのか外から要素を変えいてきたほうがいいのか
    # 小さい方を採用して答えに足し込む
    ans += min(m*(n2-2)+S, m+S+(1+n2)*m_A)

print(ans)
"
4251858,ALDS1_6_D,"N = int(input())
*W, = map(int, input().split())
C = {w: i for i, w in enumerate(W)}
W.sort()

ans = 0
S = []
used = [0]*N
for i in range(N):
    if used[i]:
        continue
    sq = []
    w = W[i]
    p = i; j = None
    while j != i:
        j = C[w]; w = W[j]
        used[j] = 1
        sq.append(w)
        p = j
    mi = min(sq); ln = len(sq)
    if ln >= 2:
        ans += sum(sq)
    S.append((mi, ln))
S.sort()
m, ln = S[0]
if ln >= 2:
    ans += (ln-2)*m
for mi, ln in S[1:]:
    if ln <= 2:
        continue
    ans += min(m+mi+ln*m, (ln-2)*mi)
print(ans)


"
4263895,ALDS1_6_D,"import bisect


def sorted_index(A):
    # Aをソートした後のindexのリスト
    A_ = sorted(A)
    B = []
    for a in A:
        idx = bisect.bisect_left(A_, a)
        B.append(idx)
    return B


def cyclic_factorize(A):
    # Aを巡回置換分解する
    B = sorted_index(A)
    checked = [False] * len(A)
    cycle_lst = []
    for i, a in enumerate(A):
        if checked[i]:
            continue
        now = i
        checked[now] = True
        cycle = [a]
        next = B[now]
        while not checked[next]:
            now = next
            next = B[now]
            cycle.append(A[now])
            checked[now] = True
        cycle_lst.append(cycle)
    return cycle_lst


N = int(input())
*W, = map(int, input().split())
cycle_lst = cyclic_factorize(W)
ans = 0
global_min = min(W)
for cycle in cycle_lst:
    l = len(cycle)
    s = sum(cycle)
    local_min = min(cycle)
    ans += s + min((l - 2) * local_min, local_min + (l + 1) * global_min)
print(ans)
"
4272663,ALDS1_6_D,"
def solve(n,num_list,s):
    ans = 0
    # Vはループを確認する際に回ったかどうかをチェックする
    V = [False for _ in range(n)]
    
    # sorted_num_listでは数列の最終的なゴールを確認する
    sorted_num_list = sorted(num_list)

    # ゴールのインデックスを確認する
    T = [None for _ in range(10000+1)]
    for i in range(n):
        T[sorted_num_list[i]] = i

    # 全ての要素に対して
    for i in range(n):

        # Vが埋まっていれば前ループの要素サイクルで移動済みなので無視
        if V[i]:
            continue

        cur = i
        
        # Sは サイクル内のバリューの合計
        S = 0

        # mはサイクルの最小値
        m = 10000

        # anはサイクルの要素数
        an = 0

        # ここからサイクルごとのループに入る
        while True:
            V[cur] = True
            an += 1
            v = num_list[cur]
            m = min(m,v)
            S += v
            cur = T[v]
            if V[cur]:
                break
        ans += min(S + (an - 2)*m,m+S+(an+1)*s)
    return ans

# 移動先をリストとしてバリューをインデックスにして保管するやり方をマスターすべし，


if __name__ == ""__main__"":
    n = int(input())
    num_list = list(map(int,input().split()))
    s = min(num_list)
    ans = solve(n,num_list,s)
    print(ans)
"
4298331,ALDS1_6_D,"# Minimum Cost Sort
# 交換に重みwぶんコストがかかる

# N <= 1000
# a <= 10000

N = int(input())
A = list(map(int, input().split()))
origin = list(range(N))

B = sorted(zip(A, origin), key=lambda x: x[0])


class UnionFind():
    def __init__(self, n):
        self.g = [[i] for i in range(n)]

    def root(self, x):
        if self.is_root(x):
            return x

        self.g[x] = self.root(self.g[x])
        return self.g[x]

    def unite(self, x, y):
        x = self.root(x)
        y = self.root(y)

        if x == y:
            return False

        # yにxをくっつける
        if x < y:
            x, y = y, x
        self.g[y] += self.g[x]
        self.g[x] = y

        return True

    def size(self, x):
        return -self.root(x)

    def is_root(self, x):
        if type(self.g[x]) is list:
            return True
        return False


G = UnionFind(N)
for i, b in enumerate(B):
    G.unite(i, b[1])


min_g = min(A)
cost = 0
for i in range(N):
    if G.is_root(i):
        W = [A[j] for j in G.g[i]]
        n_w = len(W)
        sum_w = sum(W)
        min_w = min(W)

        cost1 = sum_w + min_w*(n_w-2)
        cost2 = cost1 + 2*(min_w + min_g) - (min_w-min_g)*(n_w-1)
        cost += min(cost1, cost2)

print(cost)

"
4300199,ALDS1_6_D,"n = int(input())
a =list(map(int,input().split()))
b = sorted(a)
c = 0
for i in range(n-1):
    t = cnt = 0
    x = a.index(b[i])
    while x != i:
        y = a.index(b[x])
        a[x],a[y] = b[x],b[i]
        cnt += 1
        t += b[x]+b[i]
        x =y
    if cnt:
        c+= min(t,(b[i]+b[0])*2+t-(b[i]-b[0])*cnt)

print(c)
"
4345368,ALDS1_6_D,"WMAX = 10 ** 4 + 1
n = int(input())
A = list(map(int, input().split()))  #1 5 3 4 2
B = sorted(A)  #1 2 3 4 5

is_visited = [False] * n
next_idxs = {}

for i, b in enumerate(B):
  next_idxs[b] = i

m_A = min(A)

ans = 0
for i in range(n):
  if is_visited[i]:
    continue
  cur = i
  S = 0
  n2 = 0
  m = WMAX
  while True:
    is_visited[cur] = True
    S += A[cur]
    m = min(m, A[cur])
    n2 += 1
    cur = next_idxs[A[cur]]
    if is_visited[cur]:
      break
  ans += min(m*(n2-2) + S, m+S+(1+n2)*m_A)

print(ans)

"
4395768,ALDS1_6_D,"n = int(input())
W = list(map(int, input().split()))

_W = W[:]
_W.sort()
m = _W[0]

C = [None for _ in range(_W[n - 1] + 1)]
V = [False for _ in range(_W[n - 1] + 1)]

for i in range(n):
    C[_W[i]] = W[i]

r = 0

for i in _W:
    if V[i]:
        continue
    nxt = C[i]
    V[i] = True
    if nxt == i or V[nxt]:
        continue
    sum_w = i
    min_w = i
    c = 1
    while V[nxt] is False:
        V[nxt] = True
        sum_w += nxt
        nxt = C[nxt]
        c += 1
    r += min(sum_w + (c - 2) * min_w, sum_w + min_w + (c + 1) * m)

print(r)

"
4408792,ALDS1_6_D,"n = int(input())
arr = list(map(int, input().split()))
idx = {}
for i, a in enumerate(sorted(arr)):
    idx[a] = i
visit = [False]*n
Min = min(arr)
ans = 0
for i in range(n):
    if visit[i]:
        continue
    visit[i] = True
    now = idx[arr[i]]
    tmp_min = arr[i]
    tot = tmp_min
    cnt = 1
    while now != i:
        visit[now] = True
        tot += arr[now]
        cnt += 1
        if tmp_min > arr[now]:
            tmp_min = arr[now]
        now = idx[arr[now]]
    ans += min(tot + (cnt - 2)*tmp_min, tot + tmp_min + (cnt + 1)*Min)
print(ans)
"
4413404,ALDS1_6_D,"n=int(input())
A=list(map(int, input().split()))

def cycle_search(i):
    next_search_ind=i
    ret=[]
    while 1:
        now_ind=next_search_ind
        next_search_ind=sorted_A.index(A[now_ind])
        ret.append(A[now_ind])
        cycle_searched[now_ind]=True
        if cycle_searched[next_search_ind]:
            break
    return ret


sorted_A=sorted(A)

cycles=[]
cycle_searched=[False]*n

for i in range(n):
    if cycle_searched[i] == False:
        cycles.append(cycle_search(i))

ans=0
min_A=sorted_A[0]
for cycle in cycles:
    cycle_len=len(cycle)
    if cycle_len == 1:
        continue
    else:
        ans1 = sum(cycle)+(cycle_len-2)*min(cycle)
        min_cycle=min(cycle)
        ans2 = sum(cycle)-min_cycle+min_A+(cycle_len-2)*min_A+2*(min_A+min_cycle)
        ans += min(ans1,ans2)

print(ans)
"
4430857,ALDS1_6_D,"n = int(input())
a = [int(_) for _ in input().split()]

done = {}
for i in range(n):
    done[a[i]] = 0
# print(done)

direct = {}
a_sorted = sorted(a)
for i in range(n):
    direct[a_sorted[i]] = i
# print(direct)

group_list = []
for i in range(n):
    if done[a[i]] == 1:
        continue
    else:
        f = a[i]
        done[f] = 1
        group = [f]
        n = f
        while a[direct[n]] != f:
            n = a[direct[n]]
            done[n] = 1
            group.append(n)
        group_list.append(group)
# print(group_list)

m = a_sorted[0]
cost = 0
while len(group_list) > 0:
    group = group_list.pop()
    if len(group) == 1:
        continue
    else:
        cost += min(sum(group) + (len(group) - 2) * min(group), sum(group) + min(group) + (len(group) + 1) * m)
print(cost)
"
8349280,ALDS1_7_A,"def main():
    n = int(input())

    childs = [[] for i in range(n)]
    for i in range(n):
        data = [int(s) for s in input().split()]
        if 0 < data[1]:
            childs[data[0]] = data[2:]

    parents = [-1 for i in range(n)]
    for i in range(n):
        for c in childs[i]:
            parents[c] = i

    root = 0
    for i in range(n):
        if parents[i] == -1:
            root = i
            break
    depths = [0 for i in range(n)]
    def depth(i):
        if childs[i]:
            for c in childs[i]:
                depths[c] = depths[i] + 1
                depth(c)
    depth(root)    

    def type(i):
        if parents[i] == -1:
            return ""root""
        if len(childs[i]) == 0:
            return ""leaf""
        return ""internal node""

    for i in range(n):
        print(""node {}: parent = {}, depth = {}, {}, {}"".format(i, parents[i], depths[i], type(i), childs[i]))


if __name__ == ""__main__"":
    main()

"
8855612,ALDS1_7_A,"n = int(input())
G = [[] for _ in range(n)]
parent = [-1]*n
for _ in range(n):
    u, k, *c = map(int, input().split())
    for v in c:
        G[u].append(v)
        parent[v] = u

root = parent.index(-1)
depth = [0]*n

def dfs(v, d):
    depth[v] = d
    for w in G[v]:
        dfs(w, d+1)

dfs(root, 0)

for u in range(n):
    if parent[u] == -1: type = 'root'
    elif len(G[u]) == 0: type = 'leaf'
    else: type = 'internal node'
    print(f'node {u}: parent = {parent[u]}, depth = {depth[u]}, {type}, {G[u]}')

"
8878366,ALDS1_7_A,"n = int(input())
parent=[-1 for i in range(n)]
children=[-1 for i in range(n)]
condition=[0 for i in range(n)]
depth=[0 for i in range(n)]
for i in range(n):
    s = list(map(int,input().split()))
    idx = s[0]
    children[idx]=s[2:]
    if children[idx]!=[]:
      for v in children[idx]:
         parent[v]=idx
for i in range(n):
    if children[i]==[]:
       condition[i]='leaf'
    elif children[i]!=[] and parent[i]!=-1:
       condition[i]='internal node'
    if parent[i]==-1:
       condition[i]='root'

def dfs(i,d):
    depth[i]=d
    for a in children[i]:
        dfs(a,d+1)
dfs(parent.index(-1),0)

for i in range(n):
    print('node %d: parent = %d, depth = %d, %s, %s'%(i,parent[i],depth[i],condition[i],children[i]))
"
8525461,ALDS1_7_A,"class Node:
    def __init__(self):
        self.parent = -1
        self.children = []

def set_depth(nodes, u, depth):
    for child in nodes[u].children:
        set_depth(nodes, child, depth + 1)
    nodes[u].depth = depth

def main():
    n = int(input())
    nodes = [Node() for _ in range(n)]

    for _ in range(n):
        info = list(map(int, input().split()))
        node_id = info[0]
        children_count = info[1]
        children = info[2:]
        for child in children:
            nodes[child].parent = node_id
            nodes[node_id].children.append(child)

    for i in range(n):
        if nodes[i].parent == -1:
            root = i
            break

    set_depth(nodes, root, 0)

    for i in range(n):
        node_type = ""leaf"" if not nodes[i].children else ""internal node""
        if nodes[i].parent == -1:
            node_type = ""root""
        print(f""node {i}: parent = {nodes[i].parent}, depth = {nodes[i].depth}, {node_type}, {nodes[i].children}"")

if __name__ == ""__main__"":
    main()

"
8742969,ALDS1_7_A,"# from icecream import ic

n = int(input())

treeDict = {}
for i in range(n):
    id, k, *c = map(int,input().split())
    treeDict[id] = c

# ic(treeDict)

def rootis(d,n):
    idsum = 0
    for i in range(n):
        for j in treeDict[i]:
            idsum += j
    return (n-1)*n//2 - idsum

typename = {}
for i in range(n):
    if len(treeDict[i]) == 0:
        typename[i] = ""leaf""
    else:
        typename[i] = ""internal node""

root = rootis(treeDict,n)
typename[root] = ""root""

parent = {i:-1 for i in range(n)}
for i in range(n):
    for j in treeDict[i]:
        parent[j] = i

depth = {i:0 for i in range(n)}
def parse(T,x):
    for i in T:
        depth[i] = x
        parse(treeDict[i],x+1)
parse(treeDict[root],1)

# ic(depth)

for i in range(n):
    print(f""node {i}: parent = {parent[i]}, depth = {depth[i]}, {typename[i]}, {treeDict[i]}"")
"
8769970,ALDS1_7_A,"def Depth(index):
    if tree[index][1] == 0:
         return 
    for i in range(2,len(tree[index])):
         depth[tree[index][i]] = depth[index] + 1
         Depth(tree[index][i])
      
n = int(input())
intput_data = []
tree  = []
parent = [-1 for i in range(n)]
depth = [0 for i in range(n)]
status = [""leaf"" for i in range(n)]
node = []
for i in range(n):
    input_data = list(map(int,input().split()))
    if input_data[1] != 0:
        node.append(input_data[0])
        status[input_data[0]] = ""internal node""
        for j in range(2,len(input_data)):
               # depth[input_data[j]] = depth[i] +1 後ろのfor文で回す
               # 後ろのfor 文で status の値を確定する
               # parentのでrootの場所が確定しているはず
                parent[input_data[j]] = input_data[0]
    tree.append(input_data)

tree = sorted(tree,key=lambda x:x[0])
node.sort()
root_index = parent.index(-1)
status[root_index] = ""root""
Depth(root_index)
for i in range(n):
     print(""node {0}: parent = {1}, depth = {2}, {3}, {4}"".format(i,parent[i],depth[i],status[i],tree[i][2:]))



"
9052115,ALDS1_7_A,"n = int(input())
lst =[[0,-1,0,""root"",[]] for i in range(n)]
for i in range(n):
    A = list(map(int,input().split()))
    lst[A[0]][0] = A[0]
    for j in range(2,A[1]+2):
        lst[A[0]][4].append(A[j])
        lst[A[j]][1] = A[0]

if n == 1:
    root_num = 0
else:
    for i in range(n):
        if lst[i][4] == []:
            lst[i][3] = ""leaf""
        elif lst[i][4] != [] and lst[i][1] != -1:
            lst[i][3] = ""internal node""
        elif lst[i][1] == -1:
            root_num = i

depth = 0
this_depth_lst = [i for i in lst[root_num][4]]
next_depth_lst = []

while True:
    depth +=1
    for i in this_depth_lst:
        lst[i][2] = depth
        next_depth_lst.extend(lst[i][4])
    this_depth_lst = [i for i in next_depth_lst]
    if next_depth_lst == []:
        break
    next_depth_lst.clear()
    
for i in range(n):
    print(""node %d: parent = %d, depth = %d, %s,""%(lst[i][0],lst[i][1],lst[i][2],lst[i][3]),lst[i][4])
"
8430616,ALDS1_7_A,"import collections

r = {i for i in range(int(input()))}
a = {}
for _ in list(r):
    i, _, *c = [int(s) for s in input().split()]
    a[i] = [i, -1, 0, c]
    r.difference_update(set(c))
q = collections.deque([a[r.pop()]])

while q:
    i, p, d, c = q.popleft()
    for y in [a[j] for j in c]:
        if y[1] == -1:
            y[1], y[2] = i, d + 1
            q.append(y)

for i, p, d, c in sorted(a.values()):
    b = 'root' if p == -1 else 'internal node' if c else 'leaf'
    print(f'node {i}: parent = {p}, depth = {d}, {b}, {c}')
"
8317825,ALDS1_7_A,"class Node:
  def __init__(self, pa=-1, chs=None):
    self.pa = pa
    self.chs = chs

n = int(input())
tree = {id:Node() for id in range(n)}
for _ in range(n):
  id, _, *chs = map(int, input().split())
  tree[id].chs = chs
  for ch in chs:
    tree[ch].pa = id

def set_depths(id, depth):
  tree[id].depth = depth
  for ch in tree[id].chs:
    set_depths(ch, depth+1)

for id in tree:
  if tree[id].pa == -1:
    set_depths(id, 0)
    break

for id, node in tree.items():
  kind = ""root"" if node.pa == -1 else ""internal node"" if node.chs else ""leaf""
  print(f""node {id}: parent = {node.pa}, depth = {node.depth}, {kind}, {node.chs}"")

"
8421775,ALDS1_7_A,"class Node:
    def __init__(self, pa=-1, chs=None):
        self.pa = pa
        self.chs = chs


n = int(input())
tree = {id:Node() for id in range(n)}
for _ in range(n):
    id, _, *chs = map(int, input().split())
    tree[id].chs = chs
    for ch in chs:
        tree[ch].pa = id
    
def set_depths(id, depth):
    tree[id].depth = depth
    for ch in tree[id].chs:
        set_depths(ch, depth+1)

for id in tree:
    if tree[id].pa == -1:
        set_depths(id,0)
        break
    
for id, node in tree.items():
    kind = ""root"" if node.pa == -1 else ""internal node"" if node.chs else ""leaf""
    print(f'node {id}: parent = {node.pa}, depth = {node.depth}, {kind}, {node.chs}')
"
8735283,ALDS1_7_A,"class Node:
    def __init__(self):
        self.parent = -1
        self.children = []

def set_depth(node, depth, depths):
    depths[node] = depth
    for child in nodes[node].children:
        set_depth(child, depth + 1, depths)

def print_node(node, depths):
    node_type = ""root"" if nodes[node].parent == -1 else (""leaf"" if len(nodes[node].children) == 0 else ""internal node"")
    print(f""node {node}: parent = {nodes[node].parent}, depth = {depths[node]}, {node_type}, {nodes[node].children}"")

n = int(input())
nodes = [Node() for _ in range(n)]
depths = [0] * n

for _ in range(n):
    data = list(map(int, input().split()))
    v, degree = data[0], data[1]
    for c in data[2:]:
        nodes[v].children.append(c)
        nodes[c].parent = v

root = next(i for i in range(n) if nodes[i].parent == -1)
set_depth(root, 0, depths)

for i in range(n):
    print_node(i, depths)

"
8801502,ALDS1_7_A,"# 参考 : pythonで木構造を実装してみた ~ 二分木と根付き木~ https://tech-shelf.hatenablog.com/entry/algorithm/tree
class node:
    def __init__(self):
        self.parent = -1
        self.children = []
        self.depth = -1
        self.type = None
    
def cal_depth(node_id, d = 0):
    Tree[node_id].depth = d
    for child in Tree[node_id].children:
        cal_depth(child, d+1)

N = int(input())
Tree = [node() for _ in range(N)]
# make_tree
for _ in range(N):
    #id, 子供の数, c_0~c_k
    tree_info = list(map(int, input().split()))
    node_id = tree_info[0]
    k = tree_info[1]
    if k > 0:
        children = tree_info[2:]
        Tree[node_id].children = children
        Tree[node_id].type = ""internal node""
    else:
        Tree[node_id].type = ""leaf""
        
    for child in Tree[node_id].children:
        Tree[child].parent = node_id
        
# search_root
root_id = [i for i,t in enumerate(Tree) if t.parent == -1][0]
Tree[root_id].type = ""root""
cal_depth(root_id)

#answer_output
for i, t in enumerate(Tree):
    print(""node {}: parent = {}, depth = {}, {}, {}"".format(i, t.parent, t.depth, t.type, t.children))
"
8274134,ALDS1_7_A,"N = int(input())
Adj = [[] for _ in range(N)]
leaf = set()
for i in range(N):
    id, k, *c = map(int,input().split())
    Adj[id] = c
    leaf |= set(c)
#print(Adj)
#print(leaf)
al = set(list(range(N)))
root = al - leaf
root = root.pop()

ans = [[0, 0, -1, ""x"", []] for i in range(N)]

ans[root] = [root, -1, 0, ""root"", Adj[root]]

for i in range(N):
    ans[i][0] = i
    if Adj[i] == [] and ans[i][3] != ""root"":
        ans[i][3] = ""leaf""
    elif ans[i][3] == ""x"":
        ans[i][3] = ""internal node""
    ans[i][4] = Adj[i]
    for a in Adj[i]:
        ans[a][1] = i
        if ans[i][2] != -1:
            ans[a][2] = ans[i][2] + 1
#print(*ans, sep=""\n"")

for i in range(N):
    for a in Adj[i]:
        ans[a][1] = i
        if ans[i][2] != -1:
            ans[a][2] = ans[i][2] + 1

#print(*ans, sep=""\n"")

for i in range(N):
    node = ans[i][0]
    parent = ans[i][1]
    depth = ans[i][2]
    type = ans[i][3]
    c = ans[i][4]
    print(f'node {node}: parent = {parent}, depth = {depth}, {type}, {c}')
"
8542892,ALDS1_7_A,"class Node:
    """"""
    ノードを表すクラス
    """"""
    def __init__(self) -> None:
        """"""
        ノードの初期化
        """"""
        self.parent: int = -1  # 親ノードのインデックス
        self.children: list[int] = []  # 子ノードのインデックスのリスト

def calculate_depth(node_id: int, depth: int = 0) -> None:
    """"""
    ノードの深さを計算する関数
    """"""
    Tree[node_id].depth = depth
    for child in Tree[node_id].children:
        calculate_depth(child, depth + 1)

debug_mode: bool = False  # デバッグモード
if debug_mode:
    N: int = 1
else:
    N: int = int(input())

Tree: list[Node] = [Node() for _ in range(N)]  # ツリーのリスト

for _ in range(N):
    if debug_mode:
        tree_info: list[int] = [0, 3, 1, 4, 10]
    else:
        tree_info: list[int] = list(map(int, input().split()))
    node_id: int = tree_info[0]
    k: int = tree_info[1]
    if k > 0:
        children: list[int] = tree_info[2:]
        Tree[node_id].children = children
        Tree[node_id].type = ""internal node""
    else:
        Tree[node_id].type = ""leaf""

    for child in Tree[node_id].children:
        Tree[child].parent = node_id

root_id: int = [i for i, t in enumerate(Tree) if t.parent == -1][0]  # ルートノードのインデックス
Tree[root_id].type = ""root""
calculate_depth(root_id)  # ルートからの深さを計算

for i, t in enumerate(Tree):
    print(f""node {i}: parent = {t.parent}, depth = {t.depth}, {t.type}, {t.children}"")  # 結果の出力

"
8546615,ALDS1_7_A,"def findDepthAndParent(key):
  d = 0
  p = -1
  k = key

  while 1:
    if k in P:
      if d == 0:
        p = P[k]
      k = P[k]
      d += 1
    else:
      return d, p

n = int(input())
T = []
P = {}
tmp = {
  ""node"": 0,
  ""parent"": -1,
  ""depth"": -1,
  ""type"": """",
  ""child"": []
}

for _ in range(n):
  line = list(map(int, input().split()))
  id = line[0]
  k = line[1]
  c = line[2:]

  t = tmp.copy()
  t[""node""] = id
  t[""child""] = c
  T.insert(id, t)

  if k:
    for j in c:
      P[j] = id

for t in T:
  d, p = findDepthAndParent(t[""node""])
  t[""parent""] = p
  t[""depth""] = d
  if p == -1:
    t[""type""] = ""root""
  elif len(t[""child""]) == 0:
    t[""type""] = ""leaf""
  else:
    t[""type""] = ""internal node""

  print(f'node {t[""node""]}: parent = {t[""parent""]}, depth = {t[""depth""]}, {t[""type""]}, {t[""child""]}')
"
8968129,ALDS1_7_A,"class Node:
    key=-1
    parent=-1
    children=[]
    depth=0
    node_type=""""

    def __str__(self):
        return ""node {}: parent = {}, depth = {}, {}, {}"".format(self.key,self.parent,self.depth,self.node_type,self.children)

n=int(input())

node={x:Node() for x in range(n)}
for x in [list(map(int,input().split())) for _ in range(n)]:
    node[x[0]].key=x[0]
    node[x[0]].children=x[2:]

    for child in node[x[0]].children:
        node[child].parent=x[0]

root=-1
for key in node:
    if node[key].parent==-1:
        root=key
        break

def calcDepth(key,depth=0):
    global node
    node[key].depth=depth

    if node[key].parent==-1:
        node[key].node_type=""root""
    elif node[key].children==[]:
        node[key].node_type=""leaf""
    else:
        node[key].node_type=""internal node""

    for child in node[key].children:
        calcDepth(child,depth+1)

calcDepth(root)

for key in node:
    print(node[key])
"
8994399,ALDS1_7_A,"class Node:
    def __init__(self, u):
        self.u=u
        self.parent=-1
        self.depth=0
        self.childs=[]
    def __str__(self):
        return f""node {self.u}: parent = {self.parent}, depth = {self.depth}, {self.nodetype()}, {self.childs}""
    
    def nodetype(self):
        if self.parent==-1:
            return ""root""
        if self.childs:
            return ""internal node""
        return ""leaf""

def adddepth(nodes, i):
    for c in nodes[i].childs:
        nodes[c].depth=nodes[i].depth+1
        adddepth(nodes, c)

u = int(input())
nodes=[Node(i) for i in range(u)]

for _ in range(u):
    id=list(map(int, input().split()))
    i=id[0]
    childs=id[2:]
    nodes[i].childs=childs
    for c in childs:
        nodes[c].parent=i
    adddepth(nodes, i)

for n in nodes:
    print(n)
"
8801983,ALDS1_7_A,"# aizu_ALDS1_7_A_RootedTrees.py  

class Node:
    def __init__(self,id=None,parent=-1,degree=0,type=None,children=[]):
        self.id = id
        self.parent = parent
        self.depth = 0
        self.type = type
        self.children = children
        self.degree = degree 

def calc_depth(id,depth):
    for c_id in rooted_tree[id].children:
        rooted_tree[c_id].depth = depth+1
        calc_depth(c_id,depth+1)

n = int(input())
rooted_tree = [ Node() for i in range(n)]

for _ in range(n):
    id,degree,*children = list(map(int,input().split()))
    rooted_tree[id].id = id
    rooted_tree[id].degree = degree
    if degree != 0: rooted_tree[id].children = children

for i in range(n):
    for c in rooted_tree[i].children:
        rooted_tree[c].parent = i

for i in range(n):
    if rooted_tree[i].degree > 0: rooted_tree[i].type = 'internal node'
    else: rooted_tree[i].type = 'leaf'

root_id = [i for i in range(n) if rooted_tree[i].parent==-1][0]
rooted_tree[root_id].type = 'root'

calc_depth(root_id,0)

for i in range(n):
    x = rooted_tree[i]
    ans = 'node '+ str(x.id)+': parent = '+str(x.parent)+','+' depth = '+str(x.depth) \
            +', '+x.type+', '+str(x.children)
    print(ans)
"
2715792,ALDS1_7_A,"import sys
def q(a,h):
 d[a]=h
 for b in t[a]:q(b,h+1)
t,p,d={},{},{}
n=int(input())
for e in sys.stdin:
 e=e.split()
 t[e[0]]=e[2:]
 for i in e[2:]:p[i]=e[0]
r=(set(t)-set(p)).pop()
p[r]='-1'
q(r,0)
print('\n'.join(f""node {i}: parent = {p[i]}, depth = {d[i]}, {'root'if'-1'==p[i]else'internal node'if t[i]else'leaf'}, [{', '.join(t[i])}]""for i in map(str,range(n))))
"
5306923,ALDS1_7_A,"import sys
def q(a,h):
 d[a]=h
 for b in t[a]:q(b,h+1)
t,p,d={},{},{}
n=int(input())
for e in sys.stdin:
 e=e.split()
 t[e[0]]=e[2:]
 for i in e[2:]:p[i]=e[0]
r=(set(t)-set(p)).pop()
p[r]='-1'
q(r,0)
print('\n'.join(f""node {i}: parent = {p[i]}, depth = {d[i]}, {'root'if'-1'==p[i]else'internal node'if t[i]else'leaf'}, [{', '.join(t[i])}]""for i in map(str,range(n))))

"
8610759,ALDS1_7_A,"n = int(input())

class Node():
    def __init__(self,id,c):
        self.parent = -1
        self.child = c
        self.id = id
        self.type = None
        self.depth = None

    def add_type(self,type):
        self.type = type
    
    def add_depth(self,depth):
        self.depth = depth
        for c in self.child:
            nodes[ids[c]].add_depth(self.depth+1)
nodes = []
ids = {}

for i in range(n):
    id, k, *c = map(int,input().split())
    node = Node(id,c)
    nodes.append(node)
    ids[id] = i

for node in nodes:
    for child in node.child:
        nodes[ids[child]].parent = node.id

for i in range(n):
    node = nodes[i]
    if node.parent == -1:
        node.add_type(""root"")
        root_idx = i
    elif node.child == []:
        node.add_type(""leaf"")
    else:
        node.add_type(""internal node"")

nodes[root_idx].add_depth(0)

for i in range(n):
    node = nodes[ids[i]]
    print(f""node {node.id}: parent = {node.parent}, depth = {node.depth}, {node.type}, {node.child}"")
"
9069024,ALDS1_7_A,"class Node:
    def __init__(self, id: int) -> None:
        self.id: int = id
        self.parent: int = -1
        self.children: list[int] = []
        self.type: str = """"
        self.depth = 0
    
    def setType(self):
        if self.parent == -1: self.type = ""root""
        elif len(self.children) == 0: self.type = ""leaf""
        else: self.type = ""internal node""
            
class RootedTrees:
    def __init__(self, n:int) -> None:
        self.tree: list[Node]= [Node(i) for i in range(n)]
    
    def addNode(self, info: list) -> None:
        id: int = info[0]
        children: list[int] = info[2:]
        self.tree[id].children = children
        for i in children:
            self.tree[i].parent = id
    
    def culcDepth(self):
        def culcDepth2(parent: int, depth: int):
            if parent == -1:
                return depth
            return culcDepth2(self.tree[parent].parent, depth + 1)
        for node in self.tree:
            node.setType()
            node.depth = culcDepth2(node.parent, 0)
    
    
    
    def output(self) -> None:
        for node in self.tree:
            print(f""node {node.id}: parent = {node.parent}, depth = {node.depth}, {node.type}, {node.children}"")    
       
n = int(input()) # nodeの数
tree = RootedTrees(n)
for _ in range(n):
    tree.addNode(list(map(int, input().split())))
tree.culcDepth()
tree.output()
"
8942633,ALDS1_7_A,"n = int(input())
tree = {}
visited = []
all_chidren = []
for _ in range(n):
    lis = list(map(int, input().split()))
    idx, k = lis[0], lis[1]
    C = []
    if k > 0:
        C = lis[2:]
    tree[idx] = C
    visited.append([idx, False])
    all_chidren.extend(C)

# print(all_chidren)
root = -1
all_chidren = set(all_chidren)
for i in range(n):
    idx = visited[i][0]
    if idx not in all_chidren:
        root = idx
        visited[0], visited[i] = visited[i], visited[0]

info = dict()

def search(idx:int, depth:int, parent:int):
    if visited[idx][1]:
        return
    visited[idx][1] = True

    tp = ""internal node""
    if depth == 0:
        tp = ""root""
    elif len(tree[idx]) == 0:
        tp = ""leaf""
    info[idx] = [parent, depth, tp, tree[idx]]


    for c in tree[idx]:
        search(c, depth+1, idx)

    return

# print(tree)
# print(visited[0][0])
search(visited[0][0], 0, -1)

sorted_lists = sorted(info.items())
for lis in sorted_lists:
    print(f""node {lis[0]}: parent = {lis[1][0]}, depth = {lis[1][1]}, {lis[1][2]}, {lis[1][3]}"")
"
9088738,ALDS1_7_A,"class TreeNode:
    def __init__(self):
        self.parent = -1#None
        self.left = None
        self.right = None
        self.degree = None
        self.id = None


def get_depth(u):
    d = 0
    while Tree[u].parent != -1:#is not None:
        u = Tree[u].parent
        d += 1
    return d


def print_children(u):
    c = Tree[u].left
    print(""["", end='')
    while c is not None:
        if Tree[c].right is not None:
            print(f""{c}, "", end='')
        else:
            print(c, end='')
        c = Tree[c].right
    print(""]"")


def node_type(u):
    if Tree[u].degree == 0:
        if Tree[u].parent == -1:
            return ""root""
        else:
            return ""leaf""
    elif Tree[u].degree != 0:
        if Tree[u].parent == -1:#is None:
            return ""root""
        else:
            return ""internal node""


Tree = [TreeNode() for _ in range(100000)]
n = int(input())
for i in range(n):
    item = list(map(int, input().split()))
    node_id = item[0]
    degree = item[1]
    children = item[2:]
    node_id_next = node_id
    Tree[node_id_next].degree = degree
    Tree[node_id_next].id = node_id
    for j in range(degree):
        if j == 0:
            Tree[node_id].left = children[j]
        else:
            Tree[node_id_next].right = children[j]
        Tree[children[j]].parent = node_id
        node_id_next = children[j]

for i in range(0, n):
    print(f""node {i}: parent = {Tree[i].parent}, depth = {get_depth(i)}, {node_type(i)}, "", end='')
    print_children(i)
    # print(get_depth(i), end=' ')
    # print_children(i)
    # print()


"
8709197,ALDS1_7_A,"import sys
input = sys.stdin.readline

from collections import defaultdict

NIL = -1

n = int(input())

T = defaultdict(lambda: {'p':NIL, 'l':NIL, 'r':NIL})
D = {}

for _ in range(n):
    id, k, *cc = map(int, input().split())
    if k != 0:
        T[id]['l'] = cc[0]
    else:
        T[id]['l'] = NIL
    r = NIL
    # cc[::-1]: この部分は、ccリスト（子ノードのIDが含まれる）を逆順にします。逆順にする理由は、各ノードの「右の兄弟」を効率的に設定するためです。
    for c in cc[::-1]:
        # ここで、子ノードcの親ノードpを現在のノードidに設定しています。
        T[c]['p'] = id
        # この行では、子ノードcの「右の兄弟」rを設定しています。初期にrはNILに設定されているため、一番最初の子ノード（実際には逆順での最後のノード）には右の兄弟がいないということになります。
        T[c]['r'] = r
        # 現在の子ノードcを次の繰り返しのために「右の兄弟」rとして保存します。これにより、次の子ノードの「右の兄弟」として前のノードが設定されます。
        r = c

# 木構造の中で、各ノードの深さを再帰的に計算している。
def rec(u, p):
    D[u] = p
    l = T[u]['l']
    while l != NIL:
        rec(l, p + 1)
        # ノードの処理が終わると、その子ノードの「右の兄弟」に移動します。これにより、同じ親を持つ全ての子ノードが処理されます。
        l = T[l]['r']

# このコードブロックは木構造の中でルートノード（親がいないノード）を見つけるために使用されています。
for i, value in T.items():
    if value['p'] == NIL:
        r = i
        break

rec(r, 0)

def print_children(u):
    c = T[u]['l']
    i = 0
    while c != NIL:
        if i == 0:
            i = 1
        else:
            print(', ', end='')
        print(str(c), end='')
        c = T[c]['r']

for u in range(n):
    value = T[u]
    print('node ' + str(u) + ': ', end='')
    print('parent = ' + str(value['p']) + ', ', end='')
    print('depth = ' + str(D[u]) + ', ',end='')
    if value['p'] == NIL:
        type = 'root'
    elif value['l'] == NIL:
        type = 'leaf'
    else:
        type = 'internal node'
    print(type + ', ', end = '')
    print('[',end = '')
    print_children(u)
    print(']')
"
8927831,ALDS1_7_A,"import sys
sys.setrecursionlimit(1000000)
n = int(input())
class TreeNode:
    def __init__(self):
        self.p = -1
        self.left_child = None
        self.right_sibling = None
        self.children = None
        self.depth = None

Nodes = [TreeNode() for _ in range(n)]

for i in range(n):
    details = list(map(int,input().split()))
    id = details[0]
    node = Nodes[id]
    node.children = details[2:] if details[1] else []
    node.left_child = node.children[0] if len(node.children) else None
    for c in range(len(node.children)):
        if c < details[1]-1:
            Nodes[node.children[c]].right_sibling = node.children[c+1]
        Nodes[node.children[c]].p = id


root = None
for i,node in enumerate(Nodes):
    if node.p == -1:
        root = i
        break

def calDepth(n,d):
    if n is None:
        return
    node = Nodes[n]
    node.depth = d
    calDepth(node.left_child,d+1)
    calDepth(node.right_sibling,d)

calDepth(root,0)

for i in range(n):
    category = """"
    if Nodes[i].p == -1:
        category = ""root""
    else:
        if len(Nodes[i].children) >= 1:
            category = ""internal node""
        else:
            category = ""leaf""
    print(""node ""+str(i)+"": parent = ""+str(Nodes[i].p)+"", depth = ""+str(Nodes[i].depth)+"", ""+category+"", ""+str(Nodes[i].children))


    
        
        
        
    
    
    
    
    
        
            
        
        
        
    
    
    

    
"
6313746,ALDS1_7_A,"import sys
def q(a, h):
 d[a] = h
 for b in t[a]:
     q(b,h+1)
t, p, d = {}, {}, {}
n = int(input())
for e in sys.stdin:
 e = e.split()
 t[e[0]] = e[2:]
 for i in e[2:]:
     p[i] = e[0]
r = (set(t) - set(p)).pop()
p[r] = '-1'
q(r, 0)
print('\n'.join(f""node {i}: parent = {p[i]}, depth = {d[i]}, {'root'if'-1'==p[i]else'internal node'if t[i]else'leaf'}, [{', '.join(t[i])}]""for i in map(str,range(n))))
"
8566400,ALDS1_7_A,"import sys

sys.setrecursionlimit(1000000)


class Node:
    def __init__(self) -> None:
        self.parent = None
        self.left_child = None
        self.right_sibling = None
        self.num = None

    def _set_depth(self, depth: int) -> None:
        self.depth = depth
        if self.right_sibling is not None:
            self.right_sibling._set_depth(depth)
        if self.left_child is not None:
            self.left_child._set_depth(depth + 1)

    def get_child(self) -> list:
        child_list = []
        node = self.left_child
        while node is not None:
            child_list.append(node.num)
            node = node.right_sibling
        return child_list


n = int(input())
node_list = [Node() for _ in range(n)]

for i in range(n):
    input_list = list(map(int, input().split()))
    node_list[input_list[0]].num = input_list[0]
    left = None
    for j in range(input_list[1]):
        child_num = input_list[2 + j]
        if j == 0:
            node_list[input_list[0]].left_child = node_list[child_num]
            left = node_list[child_num]
        else:
            left.right_sibling = node_list[child_num]
            left = node_list[child_num]
        node_list[child_num].parent = node_list[input_list[0]]

for i in range(n):
    if node_list[i].parent is None:
        node_list[i]._set_depth(0)

for i in range(n):
    if node_list[i].parent is None:
        node_type = ""root""
    elif node_list[i].left_child is None:
        node_type = ""leaf""
    else:
        node_type = ""internal node""

    print(
        f""node {node_list[i].num}: "",
        ""parent = {parent}, "".format(parent=-1 if node_list[i].parent is None else node_list[i].parent.num),
        f""depth = {node_list[i].depth}, "",
        f""{node_type}, "",
        f""{node_list[i].get_child()}"",
    )

"
8675555,ALDS1_7_A,"class Node():
    def __init__(self):
        self.parent = -1
        self.children = []
        self.depth = 0
        
global nodes

def cal_depth(node_id, arg_depth):
    nodes[node_id].depth = arg_depth
    for ch in nodes[node_id].children:
        cal_depth(ch, arg_depth+1)
        
n = int(input())

nodes = []

for i in range(n):
    node = Node()
    nodes.append(node)
    
for i in range(n):
    table = list(map(int, input().split()))
    node_id = table[0]
    num = table[1]
    for j in range(num):
        child_id = table[2+j]
        nodes[node_id].children.append(child_id)
        nodes[child_id].parent = node_id
        
for i in range(n):
    if nodes[i].parent == -1:
        cal_depth(i, 0)
        break
    
for i in range(n):
    print(""node %d: parent = %d, depth = %d, ""%(i,nodes[i].parent,nodes[i].depth),end="""")
    if nodes[i].parent == -1:
        print(""root,"",end = """")
    else:
        if len(nodes[i].children) == 0:
            print(""leaf,"",end = """")
        else: #節
            print(""internal node,"",end = """")
    print("" ["",end = """")
    print(', '.join(map(str,nodes[i].children)),end = """")
    print(""]"")
    
"
5426552,ALDS1_7_A,"import sys
def q(c,h):
 d[c]=h
 for b in t[c]:q(b,h+1)
t,p,d={},{},{}
n=int(input())
for e in sys.stdin:
 e=e.split()
 t[e[0]]=e[2:]
 for i in e[2:]:p[i]=e[0]
r=(set(t)-set(p)).pop()
p[r]='-1'
q(r,0)
print('\n'.join(f""node {i}: parent = {p[i]}, depth = {d[i]}, {'root'if'-1'==p[i]else'internal node'if t[i]else'leaf'}, [{', '.join(t[i])}]""for i in map(str,range(n))))

"
9107681,ALDS1_7_A,"class Node():
    def __init__(self, id):
        self.id = id
        self.parent = None
        self.children = []
        self.type = None
        self.depth = None

    def printNode(self):
        global nodes
        print(f'node {self.id}: ', end='')
        print(f'parent = {self.parent}, ', end='')
        print(f'depth = {self.depth}, ', end='')
        print(f'{self.type}, ', end='')

        str_children = ', '.join(str(child.id) for child in self.children)
        print(f""[{str_children}]"")


def getDepth(node: Node, depth):
    node.depth = depth
    for child in node.children:
        getDepth(child, depth+1)


n = int(input())
nodes = [Node(i) for i in range(n)]
for _ in range(n):
    node_info = list(map(int, input().split()))
    cur_node_id = node_info[0]
    num_children = node_info[1]

    for idx in range(num_children):
        child = nodes[node_info[2+idx]]
        nodes[cur_node_id].children.append(child)
        child.parent = cur_node_id

LEAVES = []
for node in nodes:
    if node.parent == None:
        node.parent = -1
        node.type = 'root'
        ROOT = node.id
    elif len(node.children) == 0:
        node.type = 'leaf'
        LEAVES.append(node)
    else:
        node.type = 'internal node'

getDepth(nodes[ROOT], 0)

sorted(nodes, key=lambda node: node.id)

for node in nodes:
    node.printNode()

"
8256368,ALDS1_7_A,"class Node:
    def __init__(self,number):
        self.number = number
        self.parent = -1
        self.depth = 0
        self.nodetype = 'root'
        self.children = [] 
        self.children_num = [] #表示用
        
    def be_a_child(self,parent,parent_num):
        self.parent = parent_num
        if self.children == []:
            self.nodetype = 'leaf'
        else:
            self.nodetype = 'internal node'
        self.deepen(parent)
        
    def deepen(self,parent):
        self.depth = parent.depth + 1
        for child in self.children:
            child.deepen(self)
            
    def be_a_parent(self,child,child_num):
        self.children.append(child)
        self.children_num.append(child_num)
        if self.nodetype == 'leaf':
            self.nodetype = 'internal node'
            
    
N = int(input())
Nodes = [Node(i) for i in range(N)]

for _ in range(N):
    L = list(map(int,input().split()))
    n = L[0]
    if L[1] > 0:
        for i in range(L[1]):
            c = L[i+2]
            Nodes[n].be_a_parent(Nodes[c],c)
            Nodes[c].be_a_child(Nodes[n],n)
            
for node in Nodes:
    print('node ' + str(node.number) + ':', end = ' ')
    print('parent = ' + str(node.parent),end = ', ')
    print('depth = ' + str(node.depth),end = ', ')
    print(node.nodetype,end = ', ')
    print(node.children_num)
    
"
7609978,ALDS1_7_A,"import sys
readline = sys.stdin.readline
writelines = sys.stdout.writelines
N = int(readline())
depth = [0]*N
PR = [-1]*N
G = [None]*N
for i in range(N):
    i, _, *cs, = map(int, readline().split())
    G[i] = cs
    for v in G[i]:
        PR[v] = i
def dfs(v, d):
    depth[v] = d
    for w in G[v]:
        dfs(w, d+1)
dfs(PR.index(-1), 0)
writelines([""node %d: parent = %d, depth = %d, %s, %s\n"" % (i, PR[i], depth[i], ('root' if PR[i] == -1 else 'leaf' if len(G[i]) == 0 else 'internal node'), G[i]) for i in range(N)])

"
3185364,ALDS1_7_A,"import sys
readline = sys.stdin.readline
writelines = sys.stdout.writelines
N = int(readline())
depth = [0]*N
PR = [-1]*N
G = [None]*N
for i in range(N):
    i, _, *cs, = map(int, readline().split())
    G[i] = cs
    for v in G[i]:
        PR[v] = i
def dfs(v, d):
    depth[v] = d
    for w in G[v]:
        dfs(w, d+1)
dfs(PR.index(-1), 0)
writelines([""node %d: parent = %d, depth = %d, %s, %s\n"" % (i, PR[i], depth[i], ('root' if PR[i] == -1 else 'leaf' if len(G[i]) == 0 else 'internal node'), G[i]) for i in range(N)])

"
4550091,ALDS1_7_A,"import sys

readline = sys.stdin.readline
writelines = sys.stdout.writelines  
N = int(readline())

depth = [0]*N
PR = [-1]*N
G = [None]*N

for i in range(N):
    i, _, *cs, = map(int, readline().split())
    G[i] = cs
    for v in G[i]:
        PR[v] = i

def dfs(v, d):
    depth[v] = d
    for w in G[v]:
        dfs(w, d+1)

dfs(PR.index(-1), 0)
writelines([""node %d: parent = %d, depth = %d, %s, %s\n"" % (i, PR[i], depth[i], ('root' if PR[i] == -1 else 'leaf' if len(G[i]) == 0 else 'internal node'), G[i]) for i in range(N)])


"
5653058,ALDS1_7_A,"import sys
readline = sys.stdin.readline
writelines = sys.stdout.writelines
N = int(readline())
depth = [0]*N
PR = [-1]*N
G = [None]*N
for i in range(N):
    i, _, *cs, = map(int, readline().split())
    G[i] = cs
    for v in G[i]:
        PR[v] = i
def dfs(v, d):
    depth[v] = d
    for w in G[v]:
        dfs(w, d+1)
dfs(PR.index(-1), 0)
writelines([""node %d: parent = %d, depth = %d, %s, %s\n"" % (i, PR[i], depth[i], ('root' if PR[i] == -1 else 'leaf' if len(G[i]) == 0 else 'internal node'), G[i]) for i in range(N)])


"
2696927,ALDS1_7_A,"import sys
readline = sys.stdin.readline
class Tree:
    __slots__ = ['id', 'p', 'depth', 'type', 'c']
    def __init__(self, id):
        self.id = id
        self.p = -1
        self.depth = -1
        self.type = ""leaf""
        self.c = []
    def __str__(self):
        return f""node {self.id}: parent = {self.p}, depth = {self.depth}, {self.type}, {self.c}""
n = int(input())
li = tuple(Tree(i) for i in range(n))
for _ in range(n):
    id, k, *c = map(int, readline().split())
    if k != 0:
        li[id].type = ""internal node""
        li[id].c = c
        for j in c:
            li[j].p = id
root = 0
while li[root].p != -1:
    root = li[root].p
li[root].type = ""root""
li[root].depth = 0
def depth_check(id, d):
    d += 1
    for i in li[id].c:
        li[i].depth = d
        if li[i].type != ""leaf"":
            depth_check(i, d)
depth_check(root, 0)
print(""\n"".join(map(str, li)))

"
4640914,ALDS1_7_A,"import sys

N = int(sys.stdin.readline().rstrip())  # 節点数

parents = [None] * N
depth = [None] * N
type_ = [None] * N
children = [None] * N

CHs = [None] * N


# ## DFS ## #


def dfs(u, d, r=-1):

    # u を訪れたときの処理
    # parents[u] = r
    depth[u] = d
    c = []
    tmp = ""leaf""

    for v in CHs[u]:
        if v == r:
            continue  # 親は無視
        tmp = ""internal node""
        dfs(v, d + 1, u)  # 子の探索
        c.append(v)

    # u を離れる前の処理
    if r == -1:
        tmp = ""root""
    type_[u] = tmp
    children[u] = c


def main():
    for i in range(N):
        id, k, *ch = map(int, sys.stdin.readline().rstrip().split())
        for p in ch:
            parents[p] = id
        CHs[id] = ch

    # 根を見つける
    u = 0
    while True:
        if parents[u] is None:
            root = u
            parents[u] = -1
            break
        u = parents[u]

    dfs(root, 0)

    for i in range(N):
        print(f""node {i}: parent = {parents[i]}, depth = {depth[i]}, {type_[i]}, {children[i]}"")


main()

"
6042807,ALDS1_7_A,"import sys

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines


def main():
    N = int(readline())

    L = [[] for _ in range(N)]
    parent = [None] * N
    flag = [True] * N

    for _ in range(N):
        tmpL = list(map(int, readline().split()))
        i = tmpL[0]

        for j in range(tmpL[1]):
            L[i].append(tmpL[2 + j])
            parent[tmpL[2 + j]] = i
            flag[tmpL[2 + j]] = False
    
    root = flag.index(True)
    parent[root] = -1

    depth = [0] * N
    que = [root]

    for q in que:
        for i in L[q]:
            depth[i] = depth[q] + 1
            que.append(i)
    
    for i in range(N):
        type = ('root' if i == root else 'leaf' if L[i] == [] else 'internal node')
        text = f'node {i}: parent = {parent[i]}, depth = {depth[i]}, {type}, {L[i]}'
        print(text)


if __name__ == '__main__':
    main()
"
2479371,ALDS1_7_A,"import sys

I = 0
K = 1
C = 2
P = 3
D = 4

def setd(A, id, d):
    n = A[id]
#    print(""depth d:{} n:{} {}"".format(d,id,n))
    n[D] = d
    if n[K] > 0:
        for c in n[C]:
            setd(A, c, d + 1)

def setp(A, id, pid):
    n = A[id]
#    print(""parent n:{} {}"".format(id,n))
    if pid > -1:
        n[P] = pid
    if n[K] > 0:
        for c in n[C]:
            setp(A, c, n[I])

def getroot(A, id):
    if A[id][P] > -1:
        return getroot(A,A[id][P])
    return A[id][I]

def main():

    """""" ????????? """"""
    num = int(input().strip())
    istr = sys.stdin.read()
    nlist = list(istr.splitlines())
    
    nodes = [[i,0,None,-1,0] for i in range(num)]

    for nstr in nlist:
        i = list(map(int,nstr.split()))
        id = i[0]
        n = nodes[id]
#        print(""set n:{} {}"".format(id,n))
        if i[K] != 0:
            n[K] = i[K]
            n[C] = i[2:]
            setp(nodes, i[0], -1)

    r = getroot(nodes, 0)
    setd(nodes,r, 0)

    for id in range(num):
        n = nodes[id]
#        print(""print n:{} {}"".format(id,n))
        type = ""leaf""
        children = """"
        if n[K] > 0:
            type = ""internal node""
            children = "", "".join(map(str,n[C]))
        if n[P] == -1:
            type = ""root""
        print(""node {0}: parent = {1}, depth = {2}, {3}, [{4}]"".format(n[I], n[P], n[D], type, children))

if __name__ == '__main__':
    main()
"
5954280,ALDS1_7_A,"from sys import stdin

def main():
    n = int(stdin.readline().rstrip())
    
    root_tree = [{""parent"": -1, ""children"": []} for _ in range(n)]
    
    for _ in range(n):
        t_id, c_num, *c = map(int, stdin.readline().rstrip().split())
        root_tree[t_id][""children""] = c
        
        for node in c:
            root_tree[node][""parent""] = t_id
    
    for idx, node in enumerate(root_tree):
        depth = 0
        parent = node[""parent""]
        
        while parent != -1:
            depth += 1
            parent = root_tree[parent][""parent""]
        
        node_type = ""None""
        if depth == 0:
            node_type = ""root""
        elif len(node[""children""]) == 0:
            node_type = ""leaf""
        else:
            node_type = ""internal node""
            
        print(f'node {idx}: parent = {node[""parent""]}, depth = {depth}, {node_type}, {node[""children""]}')

main()
"
4500370,ALDS1_7_A,"from sys import stdin
input = stdin.readline

def depthcheck(idx, depth):
    global depthlist, childlist
    depthlist[idx]['depth'] = depth + 1
    if childlist[idx] != []:
        for child in childlist[idx]:
            depthcheck(child, depth+1)
    else:
        depthlist[idx]['type'] = 'leaf'

n = int(input())
childlist = [[]]*n
parentlist = [-1]*n
depthlist = [{'depth':0, 'type':'internal node'} for _ in range(n)]
for i in range(n):
    idx, c, *childs = map(int, input().split())
    childlist[idx] = list(childs)
    for childidx in childs:
        parentlist[childidx] = idx

for idx in range(n):
    if parentlist[idx] == -1:
        depthlist[idx]['type'] = 'root'
        for child in childlist[idx]:
            depthcheck(child, 0)
        break
for i in range(n):
    print('node %s: parent = %d, depth = %d, %s, %s'%(i, parentlist[i], depthlist[i]['depth'], depthlist[i]['type'], childlist[i]))
"
3856726,ALDS1_7_A,"import sys

n = int(input())

""""""子情報を入れる'c'、親情報を入れる'p'、深さを記録する'd'の、3つの辞書を作る""""""
c, p, d = {}, {}, {}

""""""根のid, depthを引数とすることで、全てのnodeの深さを'd'に記録する関数""""""
def checkdepth(id, depth):
    d[id] = depth
    for child in c[id]:
        checkdepth(child, depth+1)

for i in sys.stdin:
    i = i.split()
    """"""i[0]=id, i[1]=k, i[2:]=children""""""
    c[i[0]] = i[2:]
    for j in i[2:]:
        p[j] = i[0]

""""""親の集合から子の集合を差し引いて残ったものは根（root）になる""""""
root = (set(c) - set(p)).pop()
p[root] = '-1'
checkdepth(root, 0)

for i in range(n):
    i = str(i)
    if p[i] == '-1':
        nodetype = 'root'
    else:
        if c[i]:
            nodetype = 'internal node'
        else:
            nodetype = 'leaf'
    children = ', '.join(c[i])
    print('node {}: parent = {}, depth = {}, {}, [{}]'.format(i, p[i], d[i], nodetype, children))
"
5112094,ALDS1_7_A,"import math
import sys

n = int(input())
depth = [0]*n
parent = [-1]*n
G = [None]*n
for i in range(n):
    i, _, *cs, = map(int, sys.stdin.readline().split())
    G[i] = cs
    for v in G[i]:
        parent[v] = i

def dfs(v, d):
    depth[v] = d
    for w in G[v]:
        dfs(w, d+1)

dfs(parent.index(-1), 0)
# sys.stdout.writelines([""node %d: parent = %d, depth = %d, %s, %s\n"" % (i, parent[i], depth[i], ('root' if parent[i] == -1 else 'leaf' if len(G[i]) == 0 else 'internal node'), G[i]) for i in range(n)])
for i in range(n):
    # type = """"
    if parent[i] == -1:
        type = 'root'
    elif len(G[i]) != 0:
        type = 'internal node'
    else:
        type = 'leaf'
    print(f""node {i}: parent = {parent[i]}, depth = {depth[i]}, {type}, {G[i]}"")
"
4552815,ALDS1_7_A,"import sys, collections
input = lambda: sys.stdin.readline().rstrip() 
sys.setrecursionlimit(10**7)
INF = 10**10
def I(): return int(input())
def F(): return float(input())
def SS(): return input()
def LI(): return [int(x) for x in input().split()]
def LI_(): return [int(x)-1 for x in input().split()]
def LF(): return [float(x) for x in input().split()]
def LSS(): return input().split()

def resolve():
    n = I()
    children = [[] for _ in range(n)]
    for _ in range(n):
        ikc = LI()
        id = ikc[0]
        # k = ikc[1]
        c = ikc[2:]
        children[id] = c

    parent = [-1]*n
    for i, e in enumerate(children):
        for j in e:
            parent[j] = i

    depth = [-1]*n
    root = parent.index(-1)
    depth[root] = 0
    que = collections.deque()
    que.append(root)
    while que:
        c = que.popleft()
        for i in children[c]:
            if depth[i]==-1:
                que.append(i)
                depth[i] = depth[c] + 1

    node_type = ['']*n
    for i in range(n):
        if parent[i]==-1:
            node_type[i] = 'root'
        elif not children[i]:
            node_type[i] = 'leaf'
        else:
            node_type[i] = 'internal node'

    for i in range(n):
        print('node {0}: parent = {1}, depth = {2}, {3}, {4}'.format(i, parent[i], depth[i], node_type[i], children[i]))

if __name__ == '__main__':
    resolve()

"
4683130,ALDS1_7_A,"import sys
from collections import defaultdict

input = sys.stdin.readline


def main():
    n = int(input().strip())
    tree = defaultdict(list)
    parent = [-1] * n

    for i in range(n):
        line = [int(j) for j in input().strip().split()]
        tree[line[0]] += line[2:]
        for j in line[2:]:
            parent[j] = line[0] 

    depth = [9999] * n
    _root = parent.index(-1)
    depth[_root] = 0

    def fill_depth(tree, n, d):
        depth[n] = d
        links = tree[n]
        for l in links:
            fill_depth(tree, l, d + 1)
    
    fill_depth(tree,_root,0)
    
    def get_attr(tree, n, root):
        if n == root:
            return ""root""
        elif len(tree[n]) > 0:
            return ""internal node""
        else:
            return ""leaf""
    
    for i in range(n):
        print(""node {}: parent = {}, depth = {}, {},"".format(i,parent[i],depth[i],get_attr(tree,i,_root)),tree[i])

if __name__ == ""__main__"":
    main()
"
5111576,ALDS1_7_A,"def main() :
    n = int(input())
    commandArray = [input() for _ in range(n)]

    nodeArray = [Node() for _ in range(n)]

    for command in commandArray :
        splitCommand = list(map(int, command.split()))
        newId = splitCommand[0]

        if splitCommand[1] != 0 :
            newChildren = list(splitCommand[2:])
            nodeArray[newId].children = newChildren

            for child in newChildren :
                nodeArray[child].parent = newId
    
    for node in nodeArray :
        if node.parent == -1 :
            node.type = ""root""
        elif node.children :
            node.type = ""internal node""
        else :
            node.type = ""leaf""

    rootNode = next(filter(lambda n : n.parent == -1, nodeArray), None)

    depth = 0 

    setDepth(nodeArray, rootNode, depth)

    for i in range(n) :
        print(f""node {i}: parent = {nodeArray[i].parent}, depth = {nodeArray[i].depth}, {nodeArray[i].type}, {nodeArray[i].children}"")


def setDepth(nodeArray, targetNode, depth) :
    targetNode.depth = depth
    if targetNode.children :
        for child in targetNode.children :
            setDepth(nodeArray, nodeArray[child], depth + 1)
    else :
        return

class Node :
    parent = -1
    depth = int()
    type = str()
    children = list()

main()
"
5908706,ALDS1_7_A,"import sys
readline = sys.stdin.buffer.readline
def map_readline(): return map(int, readline().split())
def list_readline(): return list(map_readline())

# 出力:node_idx, parent, depth, type, children


def remove_set(candidates_set, remove_iterator):
    for idx in remove_iterator:
        if idx in candidates_set:
            candidates_set.remove(idx)
    return candidates_set


# DFS(再帰とは限らないよ, while, stackでも書けるし)
def dfs(node_idx, node_dict, depth, parent_idx):
    node_dict[node_idx][""parent""] = parent_idx
    node_dict[node_idx][""depth""] = depth
    depth += 1
    for c in node_dict[node_idx][""children""]:
        node_dict = dfs(c, node_dict, depth, node_idx)
    return node_dict


def fill_in_from_root(node_dict):
    for root_idx in root_candidates:
        node_dict[root_idx][""type""] = ""root""
        node_dict = dfs(root_idx, node_dict, 0, -1)
    return node_dict


def print_node_dict():
    for i in range(node_num):
        info = node_dict[i]
        print(
                (
                    f""node {i}: parent = {info['parent']}, ""
                    f""depth = {info['depth']}, ""
                    f""{info['type']}, "" 
                    f""{str(info['children'])}""
                )
            )



if __name__ == ""__main__"":
    node_num = int(readline())
    node_dict = {}
    root_candidates = set(range(node_num))
    for i in range(node_num):
        node_info = list_readline()
        children = node_info[2:]
        root_candidates = remove_set(root_candidates, children)
        if len(children) == 0:
            node_type = ""leaf""
        else:
            node_type = ""internal node"" # rootの可能性もあるので,上書きされることもある
        node_dict[node_info[0]] = {""parent"": None, ""depth"": None, ""type"": node_type,
                                   ""children"": children}
    node_dict = fill_in_from_root(node_dict)
    # print(""node_dict"", node_dict)  # debug
    print_node_dict()

"
6235770,ALDS1_7_A,"import sys
import math
import bisect
from heapq import heapify, heappop, heappush
from collections import deque, defaultdict, Counter
from functools import lru_cache
from itertools import accumulate, combinations, permutations

sys.setrecursionlimit(1000000)
MOD = 10 ** 9 + 7
MOD99 = 998244353

input = lambda: sys.stdin.readline().strip()
NI = lambda: int(input())
NMI = lambda: map(int, input().split())
NLI = lambda: list(NMI())
SI = lambda: input()
SMI = lambda: input().split()
SLI = lambda: list(SMI())


def main():
    N = NI()

    class Node:
        def __init__(self):
            self.par = -1
            self.children = []

        def __repr__(self):
            return f""par={self.par} children={self.children}""

    class Tree:
        def __init__(self, n):
            self.n = n
            self.V = [Node() for _ in range(n)]

        def add(self, u, v):
            self.V[u].children.append(v)
            self.V[v].par = u

        def roots(self):
            return [i for i, node in enumerate(self.V) if node.par == -1]


    tree = Tree(N)

    for i in range(N):
        u, k, *C = NMI()
        for v in C:
            tree.add(u, v)

    root = tree.roots()[0]
    D = [-1] * N
    D[root] = 0

    def rec(now):
        node = tree.V[now]
        for goto in node.children:
            D[goto] = D[now] + 1
            rec(goto)

    rec(root)

    for i, node in enumerate(tree.V):
        status = ""internal node""
        if i == root:
            status = ""root""
        elif not node.children:
            status = ""leaf""

        print(f""node {i}: parent = {node.par}, depth = {D[i]}, {status}, {node.children}"")


if __name__ == ""__main__"":
    main()

"
4894962,ALDS1_7_A,"import sys
readline = sys.stdin.readline
writelines = sys.stdout.writelines

n = int(readline())
depth = [0]*n; pr = [-1]*n; g = [None]*n
for i in range(n):
    i, _, *cs = map(int,input().split())
    g[i] = cs
    for v in g[i]:
        pr[v] = i

def dfs(v, d):
    depth[v] = d
    for w in g[v]:
        dfs(w, d+1)
dfs(pr.index(-1), 0)
writelines([""node %d: parent = %d, depth = %d, %s, %s\n"" \
    % (i, pr[i], depth[i], ('root' if pr[i] == -1 \
    else 'leaf' if len(g[i]) == 0 else 'internal node'), \
    g[i]) for i in range(n)])
"
5452034,ALDS1_7_A,"from sys import stdin


class Node():
    def __init__(self,pa=-1,chs=None):
        self.pa=pa
        self.chs=chs

n=int(input())
tree={id:Node() for id in range(n)}
for _ in range(n):
    id,_,*chs=map(int,stdin.readline().split())
    tree[id].chs=chs
    for ch in chs:
        tree[ch].pa=id

def set_depths(id,depth):
    tree[id].depth=depth
    for ch in tree[id].chs:
        set_depths(ch,depth+1)

for id in tree:
    if tree[id].pa==-1:
        set_depths(id,0)
        break

for id,node in tree.items():
    kind= ""root"" if node.pa == -1 else ""internal node"" if node.chs else ""leaf""
    print(f""node {id}: parent = {node.pa}, depth = {node.depth}, {kind}, {node.chs}"")
"
4002455,ALDS1_7_A,"import sys

sys.setrecursionlimit(10 ** 6)
int1 = lambda x: int(x) - 1
p2D = lambda x: print(*x, sep=""\n"")

def main():
    n=int(input())
    par=[-1]*n
    dep=[-1]*n
    typ=[""internal node""]*n
    chi=[[] for _ in range(n)]
    for _ in range(n):
        u,deg,*child=map(int,input().split())
        if deg==0:typ[u]=""leaf""
        chi[u]=child
        for cu in child:
            par[cu]=u
    root=par.index(-1)
    typ[root]=""root""
    d=0
    now=[root]
    while now:
        nxt=[]
        for u in now:
            dep[u]=d
            nxt+=chi[u]
        now=nxt
        d+=1
    #print(par)
    #print(dep)
    #print(typ)
    #print(chi)
    for u in range(n):
        print(""node {}: parent = {}, depth = {}, {}, {}"".format(u,par[u],dep[u],typ[u],chi[u]))

main()

"
4702593,ALDS1_7_A,"import sys, os, math, bisect, itertools, collections, heapq, queue, copy, array

# from scipy.sparse.csgraph import csgraph_from_dense, floyd_warshall
# from decimal import Decimal
# from collections import defaultdict, deque

sys.setrecursionlimit(10000000)

ii = lambda: int(sys.stdin.buffer.readline().rstrip())
il = lambda: list(map(int, sys.stdin.buffer.readline().split()))
fl = lambda: list(map(float, sys.stdin.buffer.readline().split()))
iln = lambda n: [int(sys.stdin.buffer.readline().rstrip()) for _ in range(n)]

iss = lambda: sys.stdin.buffer.readline().decode().rstrip()
sl = lambda: list(map(str, sys.stdin.buffer.readline().decode().split()))
isn = lambda n: [sys.stdin.buffer.readline().decode().rstrip() for _ in range(n)]

lcm = lambda x, y: (x * y) // math.gcd(x, y)

MOD = 10 ** 9 + 7
MAX = float('inf')


def get_depth(parent, node):
    depth = 0
    n = node
    while True:
        if parent[n] == -1: break
        n = parent[n]
        depth += 1

    return depth


def main():
    if os.getenv(""LOCAL""):
        sys.stdin = open(""input.txt"", ""r"")

    N = ii()
    parent = [-1] * N
    children = collections.defaultdict(list)

    for n in range(N):
        id, k, *C = il()
        for c in C:
            children[id].append(c)
            parent[c] = id

    for node in range(N):
        depth = get_depth(parent, node)
        type = ''
        if parent[node] == -1:
            type = 'root'
        elif len(children[node]) > 0:
            type = 'internal node'
        else:
            type = 'leaf'

        print('node {0}: parent = {1}, depth = {2}, {3}, {4}'.format(node, parent[node], depth, type, children[node]))


if __name__ == '__main__':
    main()

"
4799136,ALDS1_7_A,"import bisect, collections, copy, heapq, itertools, math, string
import sys
def I(): return int(sys.stdin.readline().rstrip())
def MI(): return map(int, sys.stdin.readline().rstrip().split())
def LI(): return list(map(int, sys.stdin.readline().rstrip().split()))
def S(): return sys.stdin.readline().rstrip()
def LS(): return list(sys.stdin.readline().rstrip().split())

from collections import  defaultdict
def main():
    N = I()
    num_list = [0] * N
    D = defaultdict()
    for i in range(N):
        X = LI()
        id, k, c_list = X[0], X[1], X[2:]
        D[id] = (k, c_list)
        for x in c_list:
            num_list[x] = 1
    id_root = num_list.index(0)

    dep = 0
    id = id_root
    pare = -1
    ans_list = []
    lis = D[id_root][1]

    def Tree(A, D, id, pare, dep, lis):
        if dep == 0:
            type = 'root'
        elif D[id][0] == 0:
            type = 'leaf'
        else:
            type = 'internal node'
        A.append([id, pare, dep, type, lis])
        dep += 1
        pare = id
        for l in lis:
            id = l
            lis = D[id][1]
            Tree(A, D, id, pare, dep, lis)

    Tree(ans_list, D, id, pare, dep, lis)
    ans_list.sort(key=lambda tup: tup[0])
    for a in ans_list:
        ans = 'node {0}: parent = {1}, depth = {2}, {3}, {4}'
        print(ans.format(a[0], a[1], a[2], a[3], a[4]))


if __name__ == ""__main__"":
    main()

"
6816425,ALDS1_7_A,"import sys


class Node():
    def __init__(self):
        self.parent = -1
        self.children = []
        self.depth = -1

    def type(self):
        if self.parent == -1:
            return 'root'
        elif self.children == []:
            return 'leaf'
        else:
            return 'internal node'


def set_depth(node_id, count):
    nodes[node_id].depth = count

    for child in nodes[node_id].children:
        set_depth(child, count+1)


input = sys.stdin.readline
n = int(input())
nodes = [Node() for _ in range(n)]

for _ in range(n):
    id, _, *cs, = map(int, input().split())
    nodes[id].children = cs
    for child in cs:
        nodes[child].parent = id

root_id = None
for i in range(n):
    if nodes[i].parent == -1:
        root_id = i

set_depth(root_id, 0)

for (i, item) in enumerate(nodes):
    print(
        f'node {i}: parent = {item.parent}, depth = {item.depth}, {item.type()}, {item.children}')
"
5952041,ALDS1_7_A,"class Node:
    def __init__(self, num, parent, children):
        self.id = num
        self.parent = -1
        self.depth = 0
        self.type = None
        self.children = children
        
    def show_info(self):
        print(f'node {self.id}: parent = {self.parent}, depth = {self.depth}, {self.type}, {self.children}')
        
        
def set_node(i_s):
    i_l = list(map(int, i_s.split()))
    num = i_l[0]
    children = i_l[2:]
    node = Node(num, -1, children)
    T[num] = node
    for n in children:
        T[-1] -= n
        
        
def set_pdt(n_i, parent, depth):
    node = T[n_i]
    node.parent = parent
    node.depth = depth
    if node.children:
        node.type = 'internal node'
        for n in node.children:
            set_pdt(n, n_i, depth + 1)
    else:
        node.type = 'leaf'

import sys

n = int(sys.stdin.readline())

T = [None] * n
T.append(int(n * (n-1)/2))


for i in sys.stdin.readlines():
    set_node(i)
    
set_pdt(T[-1], -1, 0)
T[T[-1]].type = 'root'

for n in T[:-1]:
    n.show_info()
"
3866407,ALDS1_7_A,"import sys
input = sys.stdin.readline
from collections import deque

n = int(input())
P = [-1]*n
C = [[] for i in range(n)]
D = [[] for i in range(n)]
T = [[] for i in range(n)]

for i in range(n):
  s = [int(i) for i in input().split()]
  id = s[0]
  k = s[1]
  if k >= 1:
    c = s[2:]
    C[id] = c
    for j in range(k):
      P[c[j]] = id
  else:
    T[id] = ""leaf""

for i in range(n):
  if P[i] == -1:
    root = i
    T[i] = ""root""
  elif T[i] == []:
    T[i] = ""internal node""

H = deque()
H.append(root)
D[root] = 0

while H:
  x = H.popleft()
  for nx in C[x]:
    H.append(nx)
    D[nx] = D[x] + 1

for i in range(n):
  print(""node {}: parent = {}, depth = {}, {}, {}"".format(i,P[i],D[i],T[i],C[i]))
"
4505585,ALDS1_7_A,"from collections import deque


def main():
    n = int(input())
    trees = [None for _ in range(n)]
    for i in range(n):
        tree = list(map(int, input().split()))
        trees[tree[0]] = tree[2:]

    # 根を探す
    candidates = set()
    have_parents = set()
    children = []
    for i in range(len(trees)):
        if len(trees[i]):
            candidates.add(i)
            children.extend(trees[i])
    children = set(children)
    have_parents = {c for c in candidates if c in children}

    if n == 1:
        root_node = 0
    else:
        root_node = list(candidates - have_parents)[0]

    depth = []
    q = deque()
    seen = [0]*n
    depth = [0]*n
    parents = [0]*n

    q.append(root_node)
    seen[root_node] = 1
    parents[root_node] = -1

    while len(q):
        v = q.pop()
        d = depth[v] + 1
        for t in trees[v]:
            if seen[t]:
                continue
            seen[t] += 1
            parents[t] = v
            q.append(t)
            depth[t] = d

    for i in range(n):
        if not depth[i]:
            print(
                ""node {}: parent = {}, depth = {}, root, {}""
                .format(i, parents[i], depth[i], trees[i]))
        elif depth and len(trees[i]):
            print(
                ""node {}: parent = {}, depth = {}, internal node, {}""
                .format(i, parents[i], depth[i], trees[i]))
        else:
            print(
                ""node {}: parent = {}, depth = {}, leaf, {}""
                .format(i, parents[i], depth[i], trees[i]))


if __name__ == '__main__':
    main()
"
5058808,ALDS1_7_A,"def main():

    n = int(input())
    pa = [-1] * n
    ch = [-1] * n
    
    for _ in range(n):
        id, _, *chi = [*map(int, input().split())]
        ch[id] = chi
        for chii in chi:
            pa[chii] = id
    
    for node in range(n):
        dep = -1
        ind = node
        while ind != -1:
            dep += 1
            ind = pa[ind]

        if pa[node] == -1:
            tp = ""root""
        elif ch[node] == []:
            tp = ""leaf""
        else:
            tp = ""internal node""

        print(""node {0}: parent = {1}, depth = {2}, {3}, {4}"".format(node, pa[node], dep, tp, ch[node]))


main()
"
2161815,ALDS1_7_A,"import sys

nil = -1

def set_depth(v, depth):
    tree[v][2] = depth

    for child in tree[v][1]:
        set_depth(child, depth + 1)

n = int(input())

tree = [[nil, [], 0, 'leaf'] for i in range(n)]

for i in range(n):
    line = [int(i) for i in sys.stdin.readline().split()]
    t_id = line[0]
    children = line[2:]

    tree[t_id][1] = children

    if children:
        tree[t_id][3] = 'internal node'

    for child in children:
        tree[child][0] = t_id

for t_id in range(n):
    if tree[t_id][0] == nil:
        tree[t_id][3] = 'root'
        r = t_id
        break

# print(tree)

set_depth(r, 0)

for t_id in range(n):
    parent = tree[t_id][0]
    depth = tree[t_id][2]
    children = tree[t_id][1]
    type_t = tree[t_id][3]

    print('node {}: parent = {}, depth = {}, {}, {}'.format(
            t_id, parent, depth, type_t, children))
"
2487518,ALDS1_7_A,"import sys

NIL = -1

def set_depth(v, depth):
    tree[v][2] = depth
    
    for child in tree[v][1]:
        set_depth(child, depth + 1)

N = int(input())
tree = [[NIL, [], 0, 'leaf'] for _ in range(N)]

for _ in range(N):
    line = [int(i) for i in sys.stdin.readline().split()]
    t_id = line[0]
    children = line[2:]
    tree[t_id][1] = children
    
    if children:
        tree[t_id][3] = 'internal node'
    
    for child in children:
        tree[child][0] = t_id
        
for t_id in range(N):
    if tree[t_id][0] == NIL:
        tree[t_id][3] = 'root'
        r = t_id
        break

set_depth(r, 0)

for t_id in range(N):
    parent = tree[t_id][0]
    depth = tree[t_id][2]
    children = tree[t_id][1]
    type_t = tree[t_id][3]
    
    print('node {}: parent = {}, depth = {}, {}, {}'.format(t_id, parent, depth, type_t, children))
"
6032045,ALDS1_7_A,"from sys import stdin

input = stdin.readline
n = int(input())
tree = [None] * n


def set_parent_node(i, parent, depth):
    node = tree[i]
    node[1], node[2] = parent, depth
    for child in node[0]:
        set_parent_node(child, i, depth + 1)


def root_or_node(d, c):
    return 'root' if not d else 'internal node' if c else 'leaf'


root = set(range(n))
while n:
    leaf = list(map(int, input().split()))
    c = leaf[2:]
    tree[leaf[0]] = [c, None, None]
    root -= set(c)
    n -= 1
set_parent_node(root.pop(), -1, 0)

for i, node in enumerate(tree):
    c, p, depth = node
    print(f'node {i}: parent = {p}, depth = {depth}, {root_or_node(depth, c)}, {"""".join(str(c))}')
"
6570324,ALDS1_7_A,"from collections import deque


n = int(input())

parent = [-1]*n
child = [[] for _ in range(n)]
for _ in range(n):
    i, k, *c = map(int,input().split())
    if k > 0:
        for j in c:
            parent[j] = i
        child[i] = c

depth = [0]*n
types = [0]*n

q = deque()
for i in range(n):
    if parent[i] == -1:
        q.append([i,0])
        types[i] = ""root""
        break

while q:
    i, dep_i = q.popleft()
    if child[i]:
        for j in child[i]:
            depth[j] = dep_i + 1
            types[j] = ""internal node""
            q.append([j, dep_i + 1])
    else:
        if types[i] != ""root"":
            types[i] = ""leaf""

for i in range(n):
    print(f""node {i}: parent = {parent[i]}, depth = {depth[i]}, {types[i]}, {child[i]}"")
"
3881428,ALDS1_7_A,"import sys
input = sys.stdin.readline

class Node:
    def __init__(self):
        self.parent = -1
        self.typ = ""leaf""

def dfs(G, v, d=0):
    G[v].depth = d
    for child in G[v].childlen:
        dfs(G, child, d+1)

def main():
    N = int(input())
    G = [Node() for _ in range(N)]
    for _ in range(N):
        idx, k, *childlen = map(int, input().split())
        G[idx].childlen = childlen
        if k:
            G[idx].typ = ""internal node""
        for child in childlen:
            G[child].parent = idx
    root = [i for i, x in enumerate(G) if x.parent == -1][0]
    G[root].typ = 'root'
    dfs(G, root)
    for i, x in enumerate(G):
        print('node {}: parent = {}, depth = {}, {}, [{}]'.format(i, x.parent, x.depth, x.typ, ', '.join(list(map(str, x.childlen)))))

if __name__ == '__main__': main()
"
5013547,ALDS1_7_A,"import sys
input = sys.stdin.readline

N = int(input())
G = [{} for _ in range(N)]
lst = []
for n in range(N):
    lst.append(list(map(int, input().split())))
lst.sort()
for n in range(N):
    G[n]['node'] = lst[n][0]
    G[n]['child'] = lst[n][2:]

for n in range(N):
    for m in G[n]['child']:
        G[m]['parent'] = n

for n in range(N):
    if not 'parent' in G[n]:
        G[n]['parent'] = -1
        G[n]['depth'] = 0
        G[n]['type'] = 'root'
        

for n in range(N):
    x = G[n]['parent']
    if x == -1:
        continue
    count = 0
    while True:
        if x == -1:
            G[n]['depth'] = count
            if G[n]['child'] == []:
                G[n]['type'] = 'leaf'
            else:
                G[n]['type'] = 'internal node'
            break
        x = G[x]['parent']
        count += 1

for x in G:
    print(f""node {x['node']}: parent = {x['parent']}, depth = {x['depth']}, {x['type']}, {x['child']}"")
"
5293155,ALDS1_7_A,"n = int(input())

node_parent = [-1]*n
node_children = [[]]*n
node_depth = [0]*n
for i in range(n):
    inputs = [int(n) for n in input().split()]
    id = inputs[0]
    # The children are all the values entered after the id and k
    children = inputs[2:]
    node_children[id] = children
    for child in children:
        node_parent[child] = id
        # The depth for a child node should always be 1 more than that of the parent node
        node_depth[child] = node_depth[id] + 1
        if node_children[child] != []:
            for child in node_children[child]:
                node_depth[child] += 1

for i in range(n):
    node_type = None

    if node_parent[i] == -1:
        node_type = ""root""
    elif node_children[i] == []:
        node_type = ""leaf""
    elif node_children[i] != []:
        node_type = ""internal node""

    print(""node %d: parent = %d, depth = %d, %s, %s"" % (i, node_parent[i], node_depth[i], node_type,str(node_children[i])) )
"
5425812,ALDS1_7_A,"from sys import stdin

input = stdin.readline


class Node:
    def __init__(self):
        self.id = None
        self.parent = -1
        self.depth = 0
        self.type = None
        self.children = []

def cal_depth(node_id, d = 0):
    Tree[node_id].depth = d
    for child in Tree[node_id].children:
        cal_depth(child, d+1)



N = int(input())
Tree = [Node() for _ in range(N)]


# make_tree
for _ in range(N):
    tree_info = list(map(int, input().split()))
    node_id = tree_info[0]
    Tree[node_id].id = node_id
    k = tree_info[1] # 節点の次元数(子の数)


    if (k > 0):
        Tree[node_id].type = ""internal node""
        Tree[node_id].children = tree_info[2:]

    else:
        Tree[node_id].type = ""leaf""

    for child in Tree[node_id].children:
        Tree[child].parent = node_id


# search_root
for t in Tree:
    if (t.parent == -1):
        root_id = t.id
        Tree[root_id].type = ""root""
        cal_depth(root_id)
        break



# asnser_output
for node in Tree:
    print(""node {}: parent = {}, depth = {}, {}, {}"".format(node.id, node.parent, node.depth, node.type, node.children))





"
8321293,ALDS1_7_B,"class Node:
  def __init__(self, chs, pa=-1):
    self.chs = chs
    self.pa = pa

n = int(input())
tree = {id:Node(chs=[-1,-1]) for id in range(-1, n)}
for _ in range(n):
  id, *chs = map(int, input().split())
  tree[id].chs = chs
  for ch in chs:
    tree[ch].pa = id

def set_d_and_h(id, d):
  tree[id].d = d
  h = 0
  for ch in tree[id].chs:
    if ch != -1:
      h = max(h, set_d_and_h(ch, d+1) + 1)
  tree[id].h = h
  return h

for id in tree:
  if tree[id].pa == -1:
    set_d_and_h(id, 0)
    break

for id, node in tree.items():
  if id != -1:
    sib = tree[node.pa].chs[1] if tree[node.pa].chs[0] == id else tree[node.pa].chs[0]
    deg = 2 - node.chs.count(-1)  
    kind = ""root"" if node.pa == -1 else ""internal node"" if deg else ""leaf""
    print(f""node {id}: parent = {node.pa}, sibling = {sib}, degree = {deg}, depth = {node.d}, height = {node.h}, {kind}"")

"
8351193,ALDS1_7_B,"def main():
    n = int(input())
    # 親→子グラフと子→親グラフを作成しつつ, 各頂点の兄弟を求める.
    pc = [[] for i in range(n)]
    cp = [-1 for i in range(n)]
    sb = [-1 for i in range(n)]
    for i in range(n):
        j, l, r = map(int, input().split())
        pc[j] = [l, r]
        if l != -1 and r != -1:
            sb[l], sb[r] = r, l
        if l != -1:
            cp[l] = j
        if r != -1:
            cp[r] = j
    # 浅さ優先・トップダウンで各頂点の深さを求める.
    parents = []
    for i in range(n):
        if cp[i] == -1:
            parents.append(i)
            break
    dp = [0 for i in range(n)]
    while 0 < len(parents):
        tmp = []
        for p in parents:
            for i in range(2):
                if pc[p][i] != -1:
                    dp[pc[p][i]] = dp[p] + 1
                    tmp.append(pc[p][i])
        parents = tmp
    # 浅さ優先・ボトムアップで各頂点の高さを求める.
    childs = [i for i in range(n) if pc[i][0] == -1 and pc[i][1] == -1]
    ht = [0 for i in range(n)]
    while 0 < len(childs):
        tmp = []
        for c in childs:
            if cp[c] != -1:
                ht[cp[c]] = ht[c] + 1
                if cp[c] not in tmp:
                    tmp.append(cp[c])
        childs = tmp
    # 各頂点の種類を求める関数.
    def type(i):
        if cp[i] == -1:
            return ""root""
        if pc[i][0] == -1 and pc[i][1] == -1:
            return ""leaf""
        return ""internal node""
    # 出力.
    for i in range(n):
        print(
            ""node {}: parent = {}, sibling = {}, degree = {}, depth = {}, height = {}, {}""
            .format(i, cp[i], sb[i], 2 - pc[i].count(-1), dp[i], ht[i], type(i))
            )


if __name__ == ""__main__"":
    main()
"
8424825,ALDS1_7_B,"class Node:
  def __init__(self, chs, pa=-1):
    self.chs = chs
    self.pa = pa

n = int(input())
tree = {id:Node(chs=[-1,-1]) for id in range(-1, n)}
for _ in range(n):
  id, *chs = map(int, input().split())
  tree[id].chs = chs
  for ch in chs:
    tree[ch].pa = id

def set_d_and_h(id, d):
  tree[id].d = d
  h = 0
  for ch in tree[id].chs:
    if ch != -1:
      h = max(h, set_d_and_h(ch, d+1) + 1)
  tree[id].h = h
  return h

for id in tree:
  if tree[id].pa == -1:
    set_d_and_h(id, 0)
    break

for id, node in tree.items():
  if id != -1:
    sib = tree[node.pa].chs[1] if tree[node.pa].chs[0] == id else tree[node.pa].chs[0]
    deg = 2 - node.chs.count(-1)  
    kind = ""root"" if node.pa == -1 else ""internal node"" if deg else ""leaf""
    print(f""node {id}: parent = {node.pa}, sibling = {sib}, degree = {deg}, depth = {node.d}, height = {node.h}, {kind}"")

"
8430798,ALDS1_7_B,"r = set(range(int(input())))
a = {}
n = 0

for _ in list(r):
    i, *c = [int(t) for t in input().split()]
    a[i] = [i, -1, -1, (c[0] > -1) + (c[1] > -1), 0, 0, c]
    r.difference_update(set(c))
q = [a[r.pop()]]

while n < len(q):
    i, _, _, l, d, _, c = q[n]
    for x, y in [c, c[::-1]]:
        if x > -1:
            x = a[x]
            x[1], x[2], x[4] = i, y, d + 1
            q.append(x)
    if l: n += 1
    else: q.pop(n)

while q:
    i, *_, c = q.pop()
    a[i][5] = max(a[x][5] + 1 if x > -1 else 0 for x in c)

for i, p, s, l, d, h, _ in sorted(a.values()):
    b = 'root' if p == -1 else 'internal node' if l else 'leaf'
    print(f'node {i}: parent = {p}, sibling = {s}, degree = {l}, depth = {d}, height = {h}, {b}')
"
8525487,ALDS1_7_B,"class Node:
    def __init__(self):
        self.parent = -1
        self.left = -1
        self.right = -1

def setDepth(nodes, u, depth, depths):
    if u == -1:
        return
    depths[u] = depth
    setDepth(nodes, nodes[u].left, depth + 1, depths)
    setDepth(nodes, nodes[u].right, depth + 1, depths)

def setHeight(nodes, u):
    if u == -1:
        return -1
    left_height = setHeight(nodes, nodes[u].left)
    right_height = setHeight(nodes, nodes[u].right)
    return max(left_height, right_height) + 1

def getType(node):
    if node.parent == -1:
        return ""root""
    if node.left == -1 and node.right == -1:
        return ""leaf""
    return ""internal node""

def getSibling(nodes, u):
    if nodes[u].parent == -1:
        return -1
    parent = nodes[nodes[u].parent]
    if parent.left != u and parent.left != -1:
        return parent.left
    if parent.right != u and parent.right != -1:
        return parent.right
    return -1

def main():
    n = int(input())
    nodes = [Node() for _ in range(n)]
    depths = [0] * n

    for _ in range(n):
        id, left, right = map(int, input().split())
        nodes[id].left = left
        nodes[id].right = right
        if left != -1:
            nodes[left].parent = id
        if right != -1:
            nodes[right].parent = id

    root = next(i for i, node in enumerate(nodes) if node.parent == -1)
    setDepth(nodes, root, 0, depths)

    for i in range(n):
        print(f""node {i}: parent = {nodes[i].parent}, sibling = {getSibling(nodes, i)}, degree = {int(nodes[i].left != -1) + int(nodes[i].right != -1)}, depth = {depths[i]}, height = {setHeight(nodes, i)}, {getType(nodes[i])}"")

if __name__ == ""__main__"":
    main()

"
8542958,ALDS1_7_B,"class Node:
    """"""
    ノードを表すクラス
    """"""
    def __init__(self) -> None:
        """"""
        ノードの初期化
        """"""
        self.parent: int = -1  # 親ノードのインデックス
        self.degree: int = 0  # 子の数
        self.sibling: int = -1 # 兄弟ノードのインデックス


def calculate_depth(node_id: int, depth: int = 0) -> None:
    """"""
    ノードの深さを計算する関数
    """"""
    Tree[node_id].depth = depth
    if Tree[node_id].left != -1:
        calculate_depth(Tree[node_id].left, depth+1)
    if Tree[node_id].right != -1:
        calculate_depth(Tree[node_id].right, depth+1)


def calculate_height(node_id: int) -> int:
    """"""
    ノードの高さを計算する関数
    """"""
    left_height = 0
    right_height = 0
    if Tree[node_id].left != -1:
        left_height = calculate_height(Tree[node_id].left) + 1
    if Tree[node_id].right != -1:
        right_height = calculate_height(Tree[node_id].right) + 1
    Tree[node_id].height: int = max(left_height, right_height)
    return Tree[node_id].height

debug_mode: bool = False  # デバッグモード
if debug_mode:
    N: int = 1
else:
    N: int = int(input())

Tree: list[Node] = [Node() for _ in range(N)]  # ツリーのリスト

for _ in range(N):
    if debug_mode:
        tree_info: list[int] = [0, 3, 1]
    else:
        tree_info: list[int] = list(map(int, input().split()))
    node_id: int = tree_info[0]
    left: int = tree_info[1]
    right: int = tree_info[2]
    Tree[node_id].left = left
    Tree[node_id].right = right
    # 子から見た親をセット
    if Tree[node_id].left != -1:
        Tree[left].parent = node_id
    if Tree[node_id].right != -1:
        Tree[right].parent = node_id
    
    # ノードのタイプをセット
    if left == -1 and right == -1:
        Tree[node_id].type = ""leaf""
    elif left == -1 or right == -1:
        Tree[node_id].degree = 1
        Tree[node_id].type = ""internal node""
    else:
        Tree[right].sibling = left
        Tree[left].sibling = right
        Tree[node_id].degree = 2
        Tree[node_id].type = ""internal node""

root_id: int = [i for i, t in enumerate(Tree) if t.parent == -1][0]  # ルートノードのインデックス
Tree[root_id].type = ""root""
calculate_depth(root_id)  # ルートからの深さを計算
calculate_height(root_id)  # ルートからの高さを計算

for i, t in enumerate(Tree):
    print(f""node {i}: parent = {t.parent}, sibling = {t.sibling}, degree = {t.degree}, depth = {t.depth}, height = {t.height}, {t.type}"")  # 結果の出力

"
8567088,ALDS1_7_B,"class Node:
    def __init__(self) -> None:
        self.id: int = None
        self.parent: Node = None
        self.left: Node = None
        self.right: Node = None

    def _set_height(self) -> int:
        h1 = h2 = 0
        if self.right is not None:
            h1 = self.right._set_height() + 1
        if self.left is not None:
            h2 = self.left._set_height() + 1
        self.height = max(h1, h2)
        return self.height

    def _set_depth(self, depth: int) -> None:
        self.depth = depth
        if self.right is not None:
            self.right._set_depth(depth + 1)
        if self.left is not None:
            self.left._set_depth(depth + 1)

    def get_degree(self) -> int:
        deg = 0
        if self.left is not None:
            deg = deg + 1
        if self.right is not None:
            deg = deg + 1
        return deg


n = int(input())
node_list = [Node() for _ in range(n)]

for _ in range(n):
    id, left, right = map(int, input().split())
    node_list[id].id = id
    if left != -1:
        node_list[id].left = node_list[left]
        node_list[left].parent = node_list[id]
    if right != -1:
        node_list[id].right = node_list[right]
        node_list[right].parent = node_list[id]

for i in range(n):
    if node_list[i].parent is None:
        node_list[i]._set_depth(0)
        node_list[i]._set_height()

for i in range(n):
    node = node_list[i]

    parent = -1 if node.parent is None else node.parent.id

    if node.parent is None:
        sibling = -1
    elif node.parent.left is not None and node.parent.left == node:
        sibling = -1 if node.parent.right is None else node.parent.right.id
    elif node.parent.right is not None and node.parent.right == node:
        sibling = -1 if node.parent.left is None else node.parent.left.id
    else:
        sibling = -1

    if node.parent is None:
        node_type = ""root""
    elif node.left is None and node.right is None:
        node_type = ""leaf""
    else:
        node_type = ""internal node""
    print(
        f""node {node.id}: "",
        f""parent = {parent}, "",
        f""sibling = {sibling}, "",
        f""degree = {node.get_degree()}, "",
        f""depth = {node.depth}, "",
        f""height = {node.height}, "",
        f""{node_type}"",
    )

"
8709565,ALDS1_7_B,"import sys
input = sys.stdin.readline

from collections import defaultdict

NIL = -1

n = int(input())

# pythonは構造体を用意するのに手間取るので、辞書型を使う
T = defaultdict(lambda: {'left':NIL, 'right':NIL, 'parent':NIL})
D = {}
H = {}

for _ in range(n):
    u, left, right = map(int, input().split())
    T[u]['left'] = left
    T[u]['right'] = right
    if left != NIL:
        T[left]['parent'] = u
    if right != NIL:
        T[right]['parent'] = u

def set_depth(u, d):
    if u == NIL:
        return
    D[u] = d
    set_depth(T[u]['left'], d+1)
    set_depth(T[u]['right'], d+1)

def set_height(u):
    h1 = 0
    h2 = 0
    if T[u]['left'] != NIL:
        h1 = set_height(T[u]['left'])+1
    if T[u]['right'] != NIL:
        h2 = set_height(T[u]['right'])+1
    height = max(h1, h2)
    H[u] = height
    return height

for u, value in T.items():
    if value['parent'] == NIL:
        root = u
        break

set_depth(root, 0)
set_height(root)

def get_sibling(u):
    if T[u]['parent'] == NIL:
        return NIL
    if T[T[u]['parent']]['left'] != u:
        return T[T[u]['parent']]['left']
    if T[T[u]['parent']]['right'] != u:
        return T[T[u]['parent']]['right']
    return NIL

for u in range(n):
    value = T[u]
    parent = value['parent']
    sibling = get_sibling(u)
    deg = 0
    if T[u]['left'] != NIL:
        deg += 1
    if T[u]['right'] != NIL:
        deg += 1
    if value['parent'] == NIL:
        type = 'root'
    elif value['left'] == NIL and value['right'] == NIL:
        type = 'leaf'
    else:
        type = 'internal node'
    depth = D[u]
    height = H[u]
    print('node ' + str(u) + ': ', end = '')
    print('parent = ' + str(parent) + ', ', end = '')
    print('sibling = ' + str(sibling) + ', ', end = '')
    print('degree = ' + str(deg) + ', ', end='')
    print('depth = ' + str(depth) + ', ', end='')
    print('height = ' + str(height) + ', ', end = '')
    print(type)
"
8719621,ALDS1_7_B,"n = int(input())

tree_dict = {}
root_node = set([i for i in range(n)])

for i in range(n):
    tmp = list(map(int, input().split(' ')))
    idx, children = tmp[0], tmp[1:]
    tree_dict[idx] = children
    root_node = root_node.difference(set(children))

root_idx = list(root_node)[0]
root_degree = 2
if tree_dict[root_idx].count(-1) == 2: root_degree = 0
if tree_dict[root_idx].count(-1) == 1: root_degree = 1

point = [[root_idx, -1, -1, root_degree, 0, 0]] #idx, parent, sibling, degree, depth, heigth
ans = {}

while point:
    idx, parent, sibling, degree, depth, height = point.pop()

    if parent == -1:
        ans[idx] = [parent , sibling, degree, depth, height, 'root']   
    elif tree_dict[idx][0] == -1 and tree_dict[idx][1] == -1:
        height = 0
        ans[idx] = [parent, sibling, 0, depth, height, 'leaf']
        parent_idx = parent
        while parent_idx != -1:
            height += 1
            if ans[parent_idx][4] < height:
                ans[parent_idx][4] = height
            parent_idx = ans[parent_idx][0]
    else:
        ans[idx] = [parent, sibling, degree, depth, height, 'internal node']

    for child_idx in tree_dict[idx]:
        if child_idx != -1:
            i = 0 
            if tree_dict[idx].index(child_idx) == 0: i = 1
            point.append([child_idx, idx, tree_dict[idx][i], 2 - tree_dict[child_idx].count(-1), depth + 1, height - 1]) #idx, parent, sibling, degree, depth, heigth

for i in range(n):
    print(f'node {str(i)}: parent = {str(ans[i][0])}, sibling = {str(ans[i][1])}, degree = {str(ans[i][2])}, depth = {str(ans[i][3])}, height = {str(ans[i][4])}, {ans[i][5]}')
"
8738631,ALDS1_7_B,"import sys

N = int(input())

L = [None]*N
R = [None]*N

P = [-1]*N
S = [-1]*N
DG = [0]*N
D = [0]*N
H = [0]*N

for i in range(N):
    i,l,r = map(int, input().split())
    L[i] = l
    R[i] = r
    if l != -1:
        P[l] = i
        DG[i] += 1
    if r != -1:
        P[r] = i
        DG[i] += 1
    if l != -1 and r != -1:
        S[l] = r; S[r] = l
        
def dfs(v,d):
    D[v] = d
    H[v] = h = max((dfs(L[v], d+1) if L[v] != -1 else 0), (dfs(R[v], d+1) if R[v] != -1 else 0))
    return h+1
    
dfs(P.index(-1), 0)

sys.stdout.writelines([""node %d: parent = %d, sibling = %d, degree = %d, depth = %d, height = %d, %s\n"" % (i, P[i], S[i], DG[i], D[i], H[i], 'root' if P[i] == -1 else 'leaf' if DG[i] == 0 else 'internal node') for i in range(N)])
"
8759985,ALDS1_7_B,"# from icecream import ic

n = int(input())

treeDict = {}
for i in range(n):
    id, left, right = map(int,input().split())
    treeDict[id] = [left, right]
# ic(treeDict)

def rootis(d,n):
    idsum = 0
    for i in range(n):
        for j in treeDict[i]:
            if j != -1: idsum += j
    return (n-1)*n//2 - idsum

typename = {}
for i in range(n):
    if treeDict[i] == [-1, -1]:
        typename[i] = ""leaf""
    else:
        typename[i] = ""internal node""

root = rootis(treeDict,n)
typename[root] = ""root""
# ic(typename)

parent = {i:-1 for i in range(n)}
for i in range(n):
    for j in treeDict[i]:
        if j != -1: parent[j] = i
# ic(parent)

depth = {i:0 for i in range(n)}
def parse(T,x):
    for i in T:
        if i != -1:
            depth[i] = x
            parse(treeDict[i],x+1)
parse(treeDict[root],1)
# ic(depth)

sibling = {i:-1 for i in range(n)}
for i in range(n):
    sibling[treeDict[i][0]], sibling[treeDict[i][1]] = treeDict[i][1], treeDict[i][0]
sibling.pop(-1)

degree = {i:0 for i in range(n)}
for i in range(n):
    degs = 0
    for j in treeDict[i]:
        if j != -1:
            degs += 1
    degree[i] = degs
# ic(degree)
    
height = {i:0 for i in range(n)}
def parse2(T,x):
    for i in T:
        if i != -1:
            if x > height[i]:
                height[i] = x
            parse2(treeDict[i],x-1)

            if parent[i] != -1 and height[parent[i]] < height[i] + 1:
                height[parent[i]] = height[i] + 1

parse2(treeDict[root],0)
# ic(height.values())

for i in range(n):
    print(f""node {i}: parent = {parent[i]}, sibling = {sibling[i]}, degree = {degree[i]}, depth = {depth[i]}, height = {height[i]}, {typename[i]}"")
"
8770582,ALDS1_7_B,"def Depth(index):
    if tree[index][1] == -1 and tree[index][2] == -1:
         return 
    for i in range(1,len(tree[index])):
         if tree[index][i] == -1:
             continue
         depth[tree[index][i]] = depth[index] + 1
         Depth(tree[index][i])

def Height(height_list):
    for start in height_list:
       number = start
       while True:
           if parent[number] == -1:
               break
           box = height[number] + 1
           if box > height[parent[number]]:
               height[parent[number]] = box
           number = parent[number]
    return
n = int(input())
intput_data = []
tree  = []
parent = [-1 for i in range(n)]
sibling = [-1 for i in range(n)]
depth = [0 for i in range(n)]
status = [""leaf"" for i in range(n)]
degree = [0 for i in range(n)]
height = [0 for i in range(n)]
for i in range(n):
    input_data = list(map(int,input().split()))
    degree[input_data[0]] = 2 - input_data.count(-1)
    if degree[input_data[0]] != 0:

        if input_data[1] != -1:
            sibling[input_data[1]]  = input_data[2]
        if input_data[2] != -1:
            sibling[input_data[2]]  = input_data[1]

        status[input_data[0]] = ""internal node""

        for number in input_data[1:]:
          parent[number] =  input_data[0]         
    tree.append(input_data)

tree = sorted(tree,key=lambda x:x[0])
root_index = parent.index(-1)
status[root_index] = ""root""
Depth(root_index)
height_index = [n for n,v in enumerate(status) if v == ""leaf""]
Height(height_index)
for i in range(n):
     print(""node {0}: parent = {1}, sibling = {2}, degree = {3}, depth = {4}, height = {5}, {6}"".format(i,parent[i],sibling[i],degree[i],depth[i],height[i],status[i]))



"
8785957,ALDS1_7_B,"class Node:
  def __init__(self, parent = -1, childlen = -1):
    self.parent = parent  # 親
    self.childlen = childlen    # 子
    
n = int(input())  # 節点の個数

# 木のノードの集合を表すtreeを作成・初期化する。
# idは節点の番号
# [左の子のid参照, 右の子のid参照] の組のリストを1つのノードとして，辞書型に追加。
# この時点では互いのノードがつながっていない状態。
# idが-1のノードは番兵。子がなければここにつながれる。
tree = {id:Node(childlen=[-1, -1]) for id in range(-1, n)}


for i in range(n):
  id, *childlen = map(int, input().split(' '))
  tree[id].childlen = childlen  # 辞書に存在するキーがidのノードのメンバchildlenを，取得したものに更新する。親->子がつながる。
  for j in childlen:
    tree[j].parent = id   # 子->親をつなげる。
    

def depth_hight(id, d):
  tree[id].d = d
  h = 0   # 高さ
  for i in tree[id].childlen:
    if i != -1:
      h = max(h, depth_hight(i, d + 1) + 1)
  tree[id].h = h
  return h

# 親を見つけて，そこから再帰的に深さと高さを計算する。
for i in tree:
  if tree[i].parent == -1:
    depth_hight(i, 0)
    break

for id, node in tree.items():
  if id != -1:  # 番兵以外のノードを出力
    sibling = tree[node.parent].childlen[1] if tree[node.parent].childlen[0] == id else tree[node.parent].childlen[0]
    degree = 2 - node.childlen.count(-1)  # 2分木なので最大この数は2。そこから子を持っていなければ引く。
    type = ""root"" if node.parent == -1 else ""internal node"" if degree else ""leaf"" # 一旦根以外をinternalとし，子が0個ならleafに置きかえる。
    print(f""node {id}: parent = {node.parent}, sibling = {sibling}, degree = {degree}, depth = {node.d}, height = {node.h}, {type}"")
"
8808272,ALDS1_7_B,"# aizu_ALDS1_7_B_BinaryTrees.py  

class Node:
    def __init__(self):
        self.id = id
        self.parent = -1
        self.type ='internal node'
        self.degree = 0
        self.depth = 0
        self.height = 0


n = int(input())
binary_tree = [ Node() for i in range(n)]

for i in range(n):
    id,left,right = map(int,input().split())
    x = binary_tree[id]
    x.id = id
    x.left = left
    x.right = right

for x in binary_tree:
    l = x.left
    r = x.right
    if l != -1: binary_tree[l].parent = x.id
    if r != -1: binary_tree[r].parent = x.id    
    if l == -1 and r == -1: x.type = 'leaf'

root_id = [i for i in range(n) if binary_tree[i].parent==-1][0]
binary_tree[root_id].type = 'root'

for x in binary_tree:
    if x.parent == -1: x.sibling = -1;continue
    l = binary_tree[x.parent].left
    r = binary_tree[x.parent].right
    if l == x.id: x.sibling = r
    if r == x.id: x.sibling = l

for x in binary_tree:
    if x.left != -1:x.degree += 1
    if x.right != -1:x.degree += 1    

def calc_depth(id,depth):
    l =binary_tree[id].left
    r =binary_tree[id].right
    if l != -1: 
        binary_tree[l].depth = depth+1
        calc_depth(l,depth+1)
    if r != -1: 
        binary_tree[r].depth = depth+1
        calc_depth(r,depth+1)

def calc_height(id):
    left_h ,right_h = 0,0
    l = binary_tree[id].left
    if l != -1: left_h = calc_height(l)+1
    r = binary_tree[id].right
    if r != -1: right_h = calc_height(r)+1
    t = max(left_h,right_h)
    binary_tree[id].height = t
    return t
    
calc_depth(root_id,0)
calc_height(root_id)
 

for i in range(n):
    x = binary_tree[i]
    ans = 'node '+ str(x.id)+': parent = '+str(x.parent)+', sibling = '+ str(x.sibling) + \
        ', degree = '+str(x.degree) + ', depth = '+str(x.depth) \
            +', height = '+str(x.height) + ', '+ x.type
    print(ans)
"
8812300,ALDS1_7_B,"#参考 : Pythonで木構造を実装してみた ~二分木と根付き木~ https://tech-shelf.hatenablog.com/entry/algorithm/tree
class node:
    def __init__(self):
        self.left = -2
        self.right = -2
        self.parent = -1
        self.degree = 0
        self.sibling = -1
        self.height = 0
        self.type = None
        
def cal_depth(node_id, d = 0):
    Tree[node_id].depth = d
    if Tree[node_id].left != -1:
        cal_depth(Tree[node_id].left, d+1)
    if Tree[node_id].right != -1:
        cal_depth(Tree[node_id].right, d+1)
        
def cal_height(node_id):
    left_h = 0
    right_h = 0
    if Tree[node_id].left != -1:
        left_h = cal_height(Tree[node_id].left) + 1
    if Tree[node_id].right != -1:
        right_h = cal_height(Tree[node_id].right) + 1
    Tree[node_id].height = max(left_h, right_h)
    return max(left_h, right_h)
    
N = int(input())
Tree = [node() for _ in range(N)]

#make_tree
for _ in range(N):
    #id, left, right
    tree_info = list(map(int, input().split()))
    node_id = tree_info[0]
    left = tree_info[1]
    right = tree_info[2]
    #自身の子をセット
    Tree[node_id].left = left
    Tree[node_id].right = right
    #子から見た親をセット
    if left != -1:
        Tree[left].parent = node_id
    if right != -1:
        Tree[right].parent = node_id
    #ノードのタイプをセット
    if left == -1 and right == -1:
        Tree[node_id].type = ""leaf""
    elif left == -1 or right == -1:
        Tree[node_id].degree = 1
        Tree[node_id].type = ""internal node""
    else:
        #兄弟をセット
        Tree[left].sibling = right
        Tree[right].sibling = left
        Tree[node_id].degree = 2
        Tree[node_id].type = ""internal node""

#search_root
root_id = [i for i,t in enumerate(Tree) if t.parent == -1][0]
Tree[root_id].type = ""root""
cal_depth(root_id)
cal_height(root_id)

#answer_output
for i, t in enumerate(Tree):
    print(""node {}: parent = {}, sibling = {}, degree = {}, depth = {}, height = {}, {}"".format(i, t.parent, t.sibling, t.degree, t.depth, t.height, t.type))
    
"
8855636,ALDS1_7_B,"class Node:
    def __init__(self, parent=-1, left=-1, right=-1):
        self.parent = parent
        self.left = left
        self.right = right

def set_depth(u, p):
    D[u] = p
    if T[u].left != -1:
        set_depth(T[u].left, p + 1)
    if T[u].right != -1:
        set_depth(T[u].right, p + 1)

def set_height(u):
    h1 = h2 = 0
    if T[u].right != -1:
        h1 = set_height(T[u].right) + 1
    if T[u].left != -1:
        h2 = set_height(T[u].left) + 1
    H[u] = max(h1, h2)
    return H[u]

def get_sibling(u):
    if T[u].parent == -1:
        return -1
    if T[T[u].parent].left != u and T[T[u].parent].left != -1:
        return T[T[u].parent].left
    if T[T[u].parent].right != u and T[T[u].parent].right != -1:
        return T[T[u].parent].right
    return -1

n = int(input())
T = [Node() for _ in range(n)]
D = [0]*n
H = [0]*n
root = 0

for _ in range(n):
    v, l, r = map(int, input().split())
    T[v].left = l
    T[v].right = r
    if l != -1:
        T[l].parent = v
    if r != -1:
        T[r].parent = v

for i in range(n):
    if T[i].parent == -1:
        root = i

set_depth(root, 0)
set_height(root)

for i in range(n):
    deg = 0
    if T[i].left != -1:
        deg += 1
    if T[i].right != -1:
        deg += 1
    print(f""node {i}: parent = {T[i].parent}, sibling = {get_sibling(i)}, degree = {deg}, depth = {D[i]}, height = {H[i]}, "", end="""")
    if T[i].parent == -1:
        print(""root"")
    elif T[i].left == -1 and T[i].right == -1:
        print(""leaf"")
    else:
        print(""internal node"")

"
8893116,ALDS1_7_B,"n=int(input())
pt=[-1]*n
sibling=[-1]*n
deg=[0]*n
info=[0]*n
depth=[0]*n
height=[0]*n
tree=[0]*n
for i in range(n):
    degcnt=0
    s=list(map(int,input().split()))
    tree[s[0]]=s[1:]
    for j in s[1:]:    #親の処理
        if j!=-1:
            pt[j]=s[0]
            degcnt+=1
    deg[s[0]]=degcnt          #degの処理
    if s[1]!=-1:            #兄弟の処理
        sibling[s[1]]=s[2]
    if s[2]!=-1:
        sibling[s[2]]=s[1]
for i in range(n):      #typeの処理
    if pt[i]==-1:
        info[i]='root'
    elif deg[i]==0:
        info[i]='leaf'
    else:
        info[i]='internal node'

def dep(i,d):
    depth[i]=d
    for j in tree[i]:
        if j!=-1:
            dep(j,d+1)
dep(pt.index(-1),0)
def high(i):
    if deg[i]==0:
        return 0
    return 1+max(high(tree[i][0]),high(tree[i][1]))
for i in range(n):
    height[i]=high(i)
for i in range(n):
    print('node %d: parent = %d, sibling = %d, degree = %d, depth = %d, height = %d, %s'%(i,pt[i],sibling[i],deg[i],depth[i],height[i],info[i]))
    
"
8928049,ALDS1_7_B,"import sys
sys.setrecursionlimit(1000000)
n = int(input())

class TreeNode:
    def __init__(self):
        self.left = -1
        self.right = -1
        self.p = -1
        self.depth = -1
        self.height = -1
        self.sibling = -1
        self.degree = 0
        self.category = """"

Nodes = [TreeNode() for _ in range(n)]
for _ in range(n):
    id,left,right = map(int,input().split())
    Nodes[id].left = left
    Nodes[id].right = right
    if left != -1:
        Nodes[left].p = id
        Nodes[left].sibling = right
        Nodes[id].degree += 1
    if right != -1:
        Nodes[right].p = id
        Nodes[right].sibling = left
        Nodes[id].degree += 1

root = 0
for id in range(n):
    if Nodes[id].p == -1:
        root = id
        break

def calDepth(id,depth):
    if id == -1:
        return
    Nodes[id].depth = depth
    calDepth(Nodes[id].left,depth+1)
    calDepth(Nodes[id].right,depth+1)

def calHeight(id):
    if id == -1:
        return -1
    Nodes[id].height = max(calHeight(Nodes[id].left), calHeight(Nodes[id].right)) + 1
    return Nodes[id].height

calDepth(root,0)
calHeight(root)
for i in range(n):
    if Nodes[i].p == -1:
        Nodes[i].category = ""root""
    elif Nodes[i].degree == 0:
        Nodes[i].category = ""leaf""
    else:
        Nodes[i].category = ""internal node""
    print(""node ""+str(i)+"": parent = ""+str(Nodes[i].p)+"", sibling = ""+str(Nodes[i].sibling)+"", degree = ""+str(Nodes[i].degree)+"", depth = ""+str(Nodes[i].depth)+"", height = ""+str(Nodes[i].height)+"", ""+Nodes[i].category)


    

"
8942755,ALDS1_7_B,"from collections import deque
nodes_dict = dict() # key:node, value:parent, children, sibling, degree, depth, height, type

n = int(input())
all_children = set()
for _ in range(n):
    node, left, right = map(int, input().split())
    deg = 0
    if left != -1:
        deg += 1
    if right != -1:
        deg += 1

    if node not in nodes_dict:
        nodes_dict[node] = [None, [left, right], None, deg, None, None, None]
    else:
        nodes_dict[node][1] = [left, right]
        nodes_dict[node][3] = deg

    if left != -1:
        if left not in nodes_dict:
            nodes_dict[left] = [node, [None, None], right, 0, None, None, None]
        else:
            nodes_dict[left][0] = node
            nodes_dict[left][2] = right
    if right != -1:
        if right not in nodes_dict:
            nodes_dict[right] = [node, [None, None], left, 0, None, None, None]   
        else:
            nodes_dict[right][0] = node
            nodes_dict[right][2] = left

    all_children |= set([left, right])

root = -1
for node in nodes_dict.keys():
    if node not in all_children:
        root = node
        nodes_dict[root][0] = -1
        nodes_dict[root][2] = -1
        nodes_dict[root][6] = ""root""

routes = []
def search(node:int, depth:int):
    if node == -1:
        return
    routes.append(node)
    nodes_dict[node][4] = depth

    if nodes_dict[node][3] == 0: # leaf
        nodes_dict[node][5] = 0
        if nodes_dict[node][6] != ""root"":
            nodes_dict[node][6] = ""leaf""
    else: # internal
        if nodes_dict[node][6] != ""root"":
            nodes_dict[node][6] = ""internal node""

        left, right = nodes_dict[node][1]
        search(left, depth+1)
        search(right, depth+1)
    return

search(root, 0)

routes.reverse()
# print(routes)
for node in routes[:-1]:
    parent = nodes_dict[node][0]
    height = nodes_dict[node][5]
    # print(parent, height)
    try:
        nodes_dict[parent][5] = max(height+1, nodes_dict[parent][5])
    except:
        nodes_dict[parent][5] = height+1

# print(nodes_dict)
sorted_lists = sorted(nodes_dict.items())
# print(sorted_lists)
for lis in sorted_lists:
    print(f""node {lis[0]}: parent = {lis[1][0]}, sibling = {lis[1][2]}, degree = {lis[1][3]}, depth = {lis[1][4]}, height = {lis[1][5]}, {lis[1][6]}"")
"
8998465,ALDS1_7_B,"class Node:
    def __init__(self, u):
        self.u=u
        self.left=-1
        self.right=-1
        self.parent=-1
        self.sibling=-1
        self.degree=0
        self.depth=0
        self.height=0
    def __str__(self):
        return f""node {self.u}: parent = {self.parent}, sibling = {self.sibling}, degree = {self.degree}, depth = {self.depth}, height = {self.height}, {self.type()}""
    def type(self):
        if self.parent==-1:
            return(""root"")
        elif self.degree==0:
            return(""leaf"")
        else:
            return(""internal node"")

def adddepth(nodes, u):
    if (nodes[u].left==-1) and (nodes[u].right==-1):
        return
    if nodes[u].left!=-1:
        nodes[nodes[u].left].depth=nodes[u].depth+1
        adddepth(nodes, nodes[u].left)
    if nodes[u].right!=-1:
        nodes[nodes[u].right].depth=nodes[u].depth+1
        adddepth(nodes, nodes[u].right)
def addheight(nodes, u):
    if nodes[u].parent==-1:
        return
    if nodes[nodes[u].parent].height<nodes[u].height+1:
        nodes[nodes[u].parent].height=nodes[u].height+1
    addheight(nodes, nodes[u].parent)

n=int(input())
nodes=[Node(i) for i in range(n)]
nodes=sorted(nodes, key=lambda x:x.u)
for _ in range(n):
    u, left, right=map(int, input().split())
    nodes[u].left=left
    nodes[u].right=right
    if left!=-1:
        nodes[left].parent=u
        nodes[left].sibling=right
        nodes[u].degree+=1
    if right!=-1:
        nodes[right].parent=u
        nodes[right].sibling=left
        nodes[u].degree+=1
    adddepth(nodes, u)
for i in range(n):
    addheight(nodes, nodes[i].u)
for n in nodes:
    print(n)
"
9069198,ALDS1_7_B,"class Node:
    def __init__(self, id: int) -> None:
        self.id: int = id
        self.parent: int = -1
        self.sibling: int = -1
        self.degree: int = 0
        self.depth: int = 0
        self.height :int = 0
        self.type: str = ""root""
        self.left :int = -1
        self.right: int = -1

class BinaryTree:
    def __init__(self, id) -> None:
        self.id = id
        self.left = self.right = None
        if nodes[id].left > -1: self.left = BinaryTree(nodes[id].left)
        if nodes[id].right > -1: self.right = BinaryTree(nodes[id].right)
    
    def culcDepth(self, depth: int) -> None:
        nodes[self.id].depth = depth
        if not self.left is None: self.left.culcDepth(depth + 1)
        if not self.right is None: self.right.culcDepth(depth + 1)
    
    def culcHeight(self, height:int) -> int:
        l = r = 0
        if not self.left is None: l = self.left.culcHeight(height + 1)
        if not self.right is None: r = self.right.culcHeight(height + 1)
        nodes[self.id].height = max(l, r)
        return max(l+1, r+1)
             
n = int(input()) # nodeの数
nodes = [Node(i) for i in range(n)]
for _ in range(n):
    id, left, right = map(int, input().split())
    if left > -1:
        nodes[id].left = left
        nodes[id].degree += 1
        nodes[left].parent = id
        nodes[left].type = ""internal node""
        nodes[left].sibling = right
    if right > -1:
        nodes[id].right = right
        nodes[id].degree += 1 
        nodes[right].parent = id
        nodes[right].type = ""internal node""
        nodes[right].sibling = left       
        
for nd in nodes:
    if nd.type != ""root"": 
        if nd.left == -1 and nd.right == -1:
            nd.type = ""leaf""
        continue
    global tree 
    tree = BinaryTree(nd.id)
    tree.culcDepth(0)
    tree.culcHeight(0)

for nd in nodes:
    print(f""node {nd.id}: parent = {nd.parent}, sibling = {nd.sibling}, degree = {nd.degree}, depth = {nd.depth}, height = {nd.height}, {nd.type}"")          

"
9110053,ALDS1_7_B,"# time out

class Node():
    def __init__(self, id):
        self.id = id
        self.parent = None
        self.left_child = None
        self.right_child = None
        self.sibling = None
        self.degree = None
        self.type = None
        self.depth = None
        self.height = None

    def printNode(self):
        print(f'node {self.id}: ', end='')
        print(f'parent = {self.parent}, ', end='')
        print(f'sibling = {self.sibling}, ', end='')
        print(f'degree = {self.degree}, ', end='')
        print(f'depth = {self.depth}, ', end='')
        print(f'height = {self.height}, ', end='')
        print(f'{self.type}')


def getDepth(node: Node, depth):
    node.depth = depth
    if node.left_child != -1:
        getDepth(nodes[node.left_child], depth+1)
    if node.right_child != -1:
        getDepth(nodes[node.right_child], depth+1)


def getHeight(node: Node):
    if node.left_child == -1 and node.right_child == -1:
        node.height = 0
    else:
        node.height = max(
            (getHeight(nodes[node.left_child]) + 1),
            (getHeight(nodes[node.right_child]) + 1)
        )
    return node.height


n = int(input())
nodes = [Node(i) for i in range(n)]

LEAVES = []
for _ in range(n):
    node_info = list(map(int, input().split()))
    cur_node_id = node_info[0]
    left_child = node_info[1]
    right_child = node_info[2]

    nodes[cur_node_id].left_child = left_child
    nodes[cur_node_id].right_child = right_child
    nodes[cur_node_id].degree = 2 - [left_child, right_child].count(-1)

    if left_child != -1:
        nodes[left_child].sibling = right_child
        nodes[left_child].parent = cur_node_id
    if right_child != -1:
        nodes[right_child].sibling = left_child
        nodes[right_child].parent = cur_node_id

    if left_child == -1 and right_child == -1:
        LEAVES.append(cur_node_id)
        nodes[cur_node_id].type = 'leaf'


for node in nodes:
    if node.parent == None:
        node.parent = -1
        node.type = 'root'
        node.sibling = -1
        ROOT = node.id
    elif node.type != 'leaf':
        node.type = 'internal node'

getDepth(nodes[ROOT], 0)
getHeight(nodes[ROOT])

for node in nodes:
    node.printNode()

"
1657103,ALDS1_7_B,"n = int(input())
tree = [None] * n
root = set(range(n))


def set_pd(i, parent, sibling, depth):
    if i == -1:
        return -1
    node = tree[i]
    l, r = node[0], node[1]
    node[2], node[3], node[5] = parent, sibling, depth
    node[4] = (l != -1) + (r != -1)
    height = node[6] = max(set_pd(l, i, r, depth + 1), set_pd(r, i, l, depth + 1)) + 1
    return height


while n:
    i, l, r = list(map(int, input().split()))
    tree[i] = [l, r] + [None] * 5  # parent, sibling, degree, depth, height
    root -= {l, r}
    n -= 1

set_pd(root.pop(), -1, -1, 0)

for i, node in enumerate(tree):
    l, r, p, s, deg, dep, h = node
    print('node {}: parent = {}, sibling = {}, degree = {}, depth = {}, height = {}, {}'.format(
        i, p, s, deg, dep, h, 'root' if not dep else 'internal node' if deg else 'leaf'
    ))
"
1661734,ALDS1_7_B,"#coding:utf-8
#1_7_B
class Node():
    def __init__(self, node_id, left, right):
        self.node_id    =   node_id
        self.parent     =   -1
        self.sibling    =   -1
        self.left       =   left
        self.right      =   right
        self.degree     =   0
        self.depth      =   0
        self.height     =   0
        self.typ        =   ""leaf""

    def set_attr(self, node_id, parent, sibling, depth):
        if node_id == -1:
            return -1
        self.parent     =   parent
        self.sibling    =   sibling
        self.depth      =   depth
        self.degree     =   (self.left != -1) + (self.right != -1)
        if self.degree:
            self.typ    =   ""internal node""
        if self.parent == -1:
            self.typ    =   ""root""
        self.height     =   max(tree[self.left].set_attr(self.left, self.node_id, self.right, self.depth + 1), tree[self.right].set_attr(self.right, self.node_id, self.left, self.depth + 1)) + 1
        return self.height

n = int(input())
tree = [None for i in range(n)]
root = set(range(n))

for i in range(n):
    node_id, left, right = map(int, input().split())
    tree[node_id] = Node(node_id, left, right)
    root -= set([left, right])

root_id = root.pop()
tree[root_id].set_attr(root_id, -1, -1, 0)

for node in tree:
    print(""node {}: parent = {}, sibling = {}, degree = {}, depth = {}, height = {}, {}"".format(node.node_id, node.parent, node.sibling, node.degree, node.depth, node.height, node.typ))
"
1676314,ALDS1_7_B,"""""""Binary Trees.""""""

class Node:
    def __init__(self, num, leftChild, rightChild):
        self.id = num
        self.parent = -1
        self.sibling = -1
        self.degree = 0
        self.depth = 0
        self.height = 0
        self.type = 'leaf'
        self.leftChild = leftChild
        self.rightChild = rightChild
        
    def show_info(self):
        print('node {}:'.format(self.id), 'parent = {},'.format(self.parent),
              'sibling = {},'.format(self.sibling),
              'degree = {},'.format(self.degree),
              'depth = {},'.format(self.depth),
              'height = {},'.format(self.height),
              '{}'.format(self.type))


def set_attributes(n_i, parent, sibling, depth):
    if n_i == -1:
        return -1
    node = T[n_i]
    lc = node.leftChild
    rc = node.rightChild
    node.parent = parent
    node.sibling = sibling
    node.depth = depth
    node.degree = (node.leftChild != -1) + (node.rightChild != -1)
    if lc != -1 or rc != -1:
        node.type = 'internal node'
    node.height = max(set_attributes(lc, n_i, rc, depth + 1),
                      set_attributes(rc, n_i, lc, depth + 1)) + 1
    return node.height



import sys

n = int(sys.stdin.readline())

T = [None] * n

rt_n = int(n * (n - 1) / 2)

for x in sys.stdin.readlines():
    num, leftChild, rightChild = list(map(int, x.split()))
    node = Node(num, leftChild, rightChild)
    T[num] = node
    rt_n -= (max(0, leftChild) + max(0, rightChild))

set_attributes(rt_n, -1, -1, 0)

T[rt_n].type = 'root'

for n in T:
    n.show_info()
"
2010623,ALDS1_7_B,"def print_node(i, node):
    parent = -1 if node[1] == None else node[1]
    degree = len([x for x in node[0] if x != -1])
    sibling = -1 if node[2] == None else node[2]
    depth = node[3]
    height = node[4]
    t = 'root' if parent == -1 else 'leaf' if height == 0 else 'internal node'
    ans = ""node {}: parent = {}, sibling = {}, degree = {}, depth = {}, height = {}, {}"".format(i, parent, sibling, degree, depth, height, t)
    print(ans)

n = int(input())

root = set([x for x in range(n)])
T = [None] * n
for x in range(n):
    i, l, r = list(map(int, input().split()))

    # children, parent, sibling, depth, height
    T[i] = [[l, r], None, None, None, None]
    root -= set([l, r])

def set_info(i, depth):
    node = T[i]
    node[3] = depth
    l = None
    r = None
    if node[0][0] != -1:
        l = T[node[0][0]]
        l[1] = i
        set_info(node[0][0], depth + 1)
    if node[0][1] != -1:
        r = T[node[0][1]]
        r[1] = i
        set_info(node[0][1], depth + 1)
    if l != None and r != None:
        l[2] = node[0][1]
        r[2] = node[0][0]

    node[4] = height(i)

def height(i):
    node = T[i]
    l = node[0][0]
    r = node[0][1]
    lh = None
    rh = None
    h = None
    if l != -1:
        lh = height(l)
    if r != -1:
        rh = height(r)
    if lh != None and rh != None:
        h = max(lh, rh)
    elif lh != None:
        h = lh
    elif rh != None:
        h = rh
    if h == None:
        return 0
    else:
        return 1 + h


r = root.pop()
T[r][1] = -1
set_info(r, 0)

for i, n in enumerate(T):
    print_node(i, n)
"
2044196,ALDS1_7_B,"# -*- coding: utf-8 -*-

class Node(object):
    def __init__(self, N):
        self.parent = [-1 for i in range(N)]
        self.left = [-1 for i in range(N)]
        self.right = [-1 for i in range(N)]
        self.depth = [-1 for i in range(N)]
        self.sibling = [-1 for i in range(N)]
        self.height = [0 for i in range(N)]
        self.degree = [0 for i in range(N)]

    def set_depth(self, u):
        d, U = 0, u
        while T.parent[u] is not -1:
            u = T.parent[u]
            d += 1
        self.depth[U] = d

    def set_height(self, u):
        h1 = h2 = 0
        if self.left[u] is not -1:
            h1 = self.set_height(self.left[u]) + 1
        if self.right[u] is not -1:
            h2 = self.set_height(self.right[u]) + 1
        
        self.height[u] = max(h1, h2)
        return max(h1, h2)
            

N = int(input())

# create node
T = Node(N)

# set data
for j in range(N):
    A = [int(i) for i in input().split()]

    # left???right????±????
    T.left[A[0]] = A[1]
    T.right[A[0]] = A[2]
    
    # parent???degree????±????
    for u in A[1:]:
        if u is not -1:
            T.parent[u] = A[0]
            T.degree[A[0]] += 1
            
    # sibling????±????
    if (A[1] is not -1) and (A[2] is not -1):
        T.sibling[A[1]], T.sibling[A[2]] = A[2], A[1]

# set depth
for i in range(N):
    T.set_depth(i)

# set height
T.set_height(T.parent.index(-1))

# ??????
for i in range(N):
    # ?????????????¨?????????????
    if T.parent[i] is -1:
        node = ""root""
    elif T.left[i] is -1 and T.right[i] is -1:
        node = ""leaf""
    else:
        node = ""internal node""

    print(""node {0}: parent = {1}, sibling = {2}, degree = {3}, depth = {4}, height = {5}, {6}"".format(i, T.parent[i], T.sibling[i], T.degree[i], T.depth[i], T.height[i], node))
"
2072580,ALDS1_7_B,"#http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_7_B&lang=jp
def cal_depth(binary_tree, target_index, depth, parent, sibling):
    if target_index == -1:
        return 0
    binary_tree[target_index][""depth""] = depth
    binary_tree[target_index][""parent""] = parent
    binary_tree[target_index][""sibling""] = sibling
    height_left = cal_depth(binary_tree, binary_tree[target_index][""left""], depth + 1, target_index, binary_tree[target_index][""right""])
    height_right = cal_depth(binary_tree, binary_tree[target_index][""right""], depth + 1, target_index, binary_tree[target_index][""left""])
    height = max(height_left, height_right)
    binary_tree[target_index][""height""] = height
    return height + 1

def solve(node_data, node_num):
    binary_tree = [{""left"":-1, ""right"":-1, ""depth"":0, ""parent"":-1, ""sibling"":-1, ""height"":0, ""degree"":0} for a in range(node_num)]
    root_index = sum([i for i in range(node_num)])
    for node in node_data:
        binary_tree[node[0]][""left""] =  node[1]
        binary_tree[node[0]][""right""] =  node[2]

        if not node[1] == -1:
            root_index -= node[1]
            binary_tree[node[0]][""degree""] += 1
        if not node[2] == -1:
            root_index -= node[2]
            binary_tree[node[0]][""degree""] += 1
            
    cal_depth(binary_tree, root_index, 0, -1,-1)
    return binary_tree

def main():
    node_num = int(input())
    node_data = [[int(a) for a in input().split()] for i in range(node_num)]
    binary_tree = solve(node_data, node_num)

    for i, node in enumerate(binary_tree):
        node_type = ""root""
        if node[""left""] == -1 and node[""right""] == -1 and not node[""parent""] == -1:
            node_type = ""leaf""
        elif not node[""parent""] == -1:
            node_type = ""internal node""
        print(""node {}: parent = {}, sibling = {}, degree = {}, depth = {}, height = {}, {}"".format(i, node[""parent""], node[""sibling""], node[""degree""], node[""depth""], node[""height""], node_type))
if __name__ == ""__main__"":
    main()
    
"
2107320,ALDS1_7_B,"class Node(object):
    def __init__(self, parent, left, right):
        self.parent = parent
        self.left = left
        self.right = right
        self.height = None

    def get_type(self):
        if self.parent == -1:
            return 'root'
        elif self.left == -1 and self.right == -1:
            return 'leaf'
        else:
            return 'internal node'

    def get_depth(self):
        if self.parent == -1:
            return 0
        else:
            depth = 1
            t = Nodes[self.parent]
            while t.parent != -1:
                t = Nodes[t.parent]
                depth += 1
            return depth

    def get_height(self):
        h_left = 0
        h_right = 0
        if self.left != -1:
            h_left = Nodes[self.left].get_height() + 1
        if self.right != -1:
            h_right = Nodes[self.right].get_height() + 1
        self.height = max(h_left, h_right)
        return self.height

    def get_degree(self):
        degree = 0
        if self.left != -1:
            degree += 1
        if self.right != -1:
            degree += 1
        return degree

    def get_sigling(self):
        if self.parent == -1:
            return -1
        p = Nodes[self.parent]
        if Nodes[p.left] != self and  Nodes[p.left] != -1:
            return p.left
        if Nodes[p.right] != self and  Nodes[p.right] != -1:
            return p.right


def process_node_data(data):
    global Nodes
    num_of_elem = len(data)
    if num_of_elem != 3:
        raise ValueError
    else:
        my_id, left, right = data
        Nodes[my_id].left = left
        if left != -1:
            Nodes[left].parent = my_id
        Nodes[my_id].right = right
        if right != -1:
            Nodes[right].parent = my_id



MAX_NODES = 25
Nodes = [Node(-1, None, None) for _ in range(MAX_NODES)]  # ????´???? [Node(None, None, None)] * MAX_NODES ????????¨????????????????????????????????§??¨???

if __name__ == '__main__':
    # ??????????????\???
    num_of_nodes = int(input())
    node_data = []
    for i in range(num_of_nodes):
        t = [int(x) for x in input().split(' ')]
        node_data.append(t)

    # ???????????????
    for d in node_data:
        process_node_data(d)

    # ???????????????
    for i in range(num_of_nodes):
        p = Nodes[i]
        print('node {0}: parent = {1}, sibling = {2}, degree = {3}, depth = {4}, height = {5}, {6}'.format(
            i, p.parent, p.get_sigling(), p.get_degree(), p.get_depth(), p.get_height(), p.get_type()
        ))
"
2161967,ALDS1_7_B,"import sys

nil = -1

class Node:
    def __init__(self):
        self.parent = nil
        self.sibling = nil
        self.degree = 0
        self.left = nil
        self.right = nil
        self.depth = nil
        self.height = nil
        self.ntype = 'leaf'

def set_depth(v, depth):
    bitree[v].depth = depth

    if bitree[v].left != nil:
        set_depth(bitree[v].left, depth + 1)

    if bitree[v].right != nil:
        set_depth(bitree[v].right, depth + 1)

def set_height(v, height):
    while v != -1:
        if height > bitree[v].height:
            bitree[v].height = height
            v = bitree[v].parent
            height += 1
        else:
            break

n = int(input())
bitree = [Node() for i in range(n)]
leaves = set()

for i in range(n):
    line = [int(j) for j in input().split()]
    t_id = line[0]
    bitree[t_id].left = line[1]
    bitree[t_id].right = line[2]
    bitree[t_id].degree = (line[1] != nil) + (line[2] != nil)

    if bitree[t_id].degree > 0:
        bitree[t_id].ntype = 'internal node'

        if bitree[t_id].left != nil:
            bitree[bitree[t_id].left].parent = t_id

        if bitree[t_id].right != nil:
            bitree[bitree[t_id].right].parent = t_id

        if bitree[t_id].degree == 2:
            bitree[bitree[t_id].left].sibling = bitree[t_id].right
            bitree[bitree[t_id].right].sibling = bitree[t_id].left
    else:
        leaves.add(t_id)

for t_id in range(n):
    if bitree[t_id].parent == nil:
        bitree[t_id].ntype = 'root'
        r = t_id
        break

set_depth(r, 0)

for leaf in leaves:
    set_height(leaf, 0)

for t_id in range(n):

    print('node {}: parent = {}, sibling = {}, degree = {}, depth = {}, height = {}, {}'.format(
            t_id, bitree[t_id].parent, bitree[t_id].sibling, bitree[t_id].degree,
            bitree[t_id].depth, bitree[t_id].height, bitree[t_id].ntype))
"
2299157,ALDS1_7_B,"NIL = -1


class Node:
    right = NIL
    left = NIL
    parent = NIL


def setHeight(u):
    global T, H
    hr = 0
    hl = 0
    if T[u].right != NIL:
        hr = setHeight(T[u].right) + 1
    if T[u].left != NIL:
        hl = setHeight(T[u].left) + 1
    h = max(hr, hl)
    H[u] = h
    return h


def setDepth(u, d):
    global T, D
    D[u] = d
    if T[u].right != NIL:
        setDepth(T[u].right, d + 1)
    if T[u].left != NIL:
        setDepth(T[u].left, d + 1)


def getSibling(u):
    global T
    if T[u].parent == NIL:
        return NIL
    if T[T[u].parent].left != u and T[T[u].parent].left != NIL:
        return T[T[u].parent].left
    if T[T[u].parent].right != u and T[T[u].parent].right != NIL:
        return T[T[u].parent].right
    return NIL


def getDegree(u):
    global T
    deg = 0
    if T[u].left != NIL: deg += 1
    if T[u].right != NIL: deg += 1
    return deg


def show_info(u):
    global T, D, H
    label = """"
    if T[u].parent == NIL:
        label = 'root'
    elif T[u].left == NIL and T[u].right == NIL:
        label = 'leaf'
    else:
        label = 'internal node'
    print(""node {0}: parent = {1}, sibling = {2}, degree = {3}, depth = {4}, height = {5}, {6}"".format(u, T[u].parent,
                                                                                                       getSibling(u),
                                                                                                       getDegree(u),
                                                                                                       D[u],
                                                                                                       H[u], label))


if __name__ == ""__main__"":
    # ????????¨??????
    n = int(input())
    T, D, H = [], [], []
    root_num = NIL
    for i in range(n):
        T.append(Node())
        D.append(NIL)
        H.append(0)
    for i in range(n):
        id, r, l = map(int, input().split())
        T[id].right = r
        T[id].left = l
    for i in range(n):
        if T[i].right != NIL:
            T[T[i].right].parent = i
        if T[i].left != NIL:
            T[T[i].left].parent = i
    for i in range(n):
        if T[i].parent == NIL:
            root_num = i

    setHeight(root_num)
    setDepth(root_num, 0)
    for i in range(n):
        show_info(i)
"
2349054,ALDS1_7_B,"class Node:
    def __init__(self, num, left,  right):
        self.id = num
        self.left = left
        self.right = right
        self.parent = -1
        self.brother = -1
        if self.left== -1 and self.right==-1:
        	self.child = 0
        elif self.left != -1 and self.right!=-1:
        	self.child = 2
        else:
        	self.child = 1
        self.depth = 0
        self.height = 0
        self.type = None

    def show_info(self):
        print('node {0}: parent = {1}, sibling = {2}, degree = {3}, depth = {4}, height = {5}, {6}'.format(self.id, self.parent, self.brother, self.child, self.depth, self.height, self.type))

def SetNode(I_Line):
	L = list(map(int, I_Line.split()))
	num = L[0]
	left = L[1]
	right = L[2]
	node = Node(num, left, right)
	T[num] = node
	if left != -1:
		T[-1] -= left
	if right != -1:
		T[-1] -= right

def setPBD(i,p,b,d): #??????????????????
    node = T[i]
    node.parent = p
    node.brother = b
    node.depth = d
    if node.parent == -1:
        node.type = ""root""
    elif node.child == 0:
        node.type = ""leaf""
    else:
        node.type = ""internal node""
    if node.left != -1:
        setPBD(node.left, i, node.right, node.depth + 1)
    if node.right != -1:
        setPBD(node.right, i, node.left, node.depth + 1)

def setH(i): #??????????????????
    node = T[i]
    if node.left == -1:
        leftheight = 0
    else:
        leftheight = setH(node.left) + 1
    if node.right == -1:
        rightheight = 0
    else:
        rightheight = setH(node.right) + 1
    node.height = max(leftheight, rightheight)
    return node.height

n = int(input())
T = [None] * n
T.append(int(n * (n-1)/2))
for i in range(n):
    x = input()
    SetNode(x)

root = T[-1]
setPBD(root, -1, -1, 0)
setH(root)
T.pop()
for i in T:
    i.show_info()
"
2406472,ALDS1_7_B,"# coding=utf-8
 
class Node:
    def __init__(self, ID, left, right):
        ### information for output ###
        self.id = ID
        self.parent = -1
        self.sibling = -1
        self.degree = -1
        self.depth = 0
        self.height = 0
        self.type = None
 
        ### other information ###
        self.left_child = left
        self.right_child = right
 
def calc_depth(i):
    global node_list
 
    if node_list[i].depth != 0:
        return node_list[i].depth
 
    depth = 0
    if node_list[i].parent != -1:
        depth = calc_depth(node_list[i].parent) + 1
 
    node_list[i].depth = depth
    return depth
 
 
def calc_height(i):
    global node_list
 
    if node_list[i].height != 0:
        return node_list[i].height
 
    h1 = h2 = 0
    if node_list[i].right_child != -1:
        h1 = calc_height(node_list[i].right_child) + 1
    if node_list[i].left_child != -1:
        h2 = calc_height(node_list[i].left_child) + 1
 
    height = max(h1, h2)
    node_list[i].height = height
    return height
 
n = int(input())
data = [tuple(map(int, input().split())) for x in range(n)]
node_list = []
 
for data_row in data:
    ID, left, right = data_row
    node = Node(ID, left, right)
    node_list.append(node)
 
node_list.sort(key = lambda node: node.id)
 
for i, node in enumerate(node_list):
    left = node.left_child
    right = node.right_child
    degree = 0
 
    ### child information ###
    if left != -1:
        degree += 1
        node_list[left].parent = i
        node_list[left].sibling = right
 
    if right != -1:
        degree += 1
        node_list[right].parent = i
        node_list[right].sibling = left
 
    ### self information ###
    node.degree = degree
 
for i in range(n):
    calc_depth(i)
    calc_height(i)
 
    node = node_list[i]
 
    if node.depth == 0:
        node.type = 'root'
    elif node.height == 0:
        node.type = 'leaf'
    else:
        node.type = 'internal node'
 
    print(""node {}: parent = {}, sibling = {}, degree = {}, depth = {}, height = {}, {}"".format(node.id, node.parent, node.sibling, node.degree, node.depth, node.height, node.type))
"
2473428,ALDS1_7_B,"class Node():

    def __init__(self, node_id, left, right):
        self.node_id = node_id
        self.parent = -1
        self.sibling = -1
        self.left = left
        self.right = right
        self.degree = 0
        self.depth = 0
        self.height = 0
        self.type = ""leaf""

    def set_attr(self, node_id, parent, sibling, depth):
        if node_id == -1:
            return -1
        self.parent = parent
        self.sibling = sibling
        self.depth = depth
        self.degree = (self.left != -1) + (self.right != -1)
        if self.degree:
            self.type = ""internal node""
        if self.parent == -1:
            self.type = ""root""
        self.height = max(tree[self.left].set_attr(self.left, self.node_id, self.right, self.depth + 1),
                          tree[self.right].set_attr(self.right, self.node_id, self.left, self.depth + 1)) +1
        return self.height

n = int(input())
tree = [0] * n
root = set(range(n))

for i in range(n):
    node_id, left, right = map(int, input().split())
    tree[node_id] = Node(node_id, left, right)
    root -= set([left, right])

root_id = root.pop()
tree[root_id].set_attr(root_id, -1, -1, 0)

for node in tree:
    print(""node {}: parent = {}, sibling = {}, degree = {}, depth = {}, height = {}, {}"".format(
        node.node_id, node.parent, node.sibling, node.degree, node.depth, node.height, node.type))
"
2479557,ALDS1_7_B,"#!/usr/bin/env python
# -*- coding: utf-8 -*-
""""""
???????????¨
??????????????????????????¨ T ???????????? u ???????????????
??\???????????±???????????????????????°????????????????????????????????????

u ???????????????
u ?????????????????????
u ?????±???
u ?????????????¨??????????????????¨?????????????????????
u ??????????????????
????????§???????????????????????¨??? n ????????????????????????
???????????? 0 ?????? n???1 ???????????????????????????????????????????????¨????????????

??\???
??\??????????????????????????????????????° n ????????????????????????
?¶???? n ?????????????????????????????±????¬??????¢?????§??????????????????????????????

id k c1 c2 ... ck

id ?????????????????????k ????¬???°?????¨????????????c1 c2 ...ck ???
 1 ??????????????????????????????... kk ?????????????????????????????????????????????

??????
?¬??????¢?????§??????????????±??????????????????????????????
??????????????±???????????????????°????????????????????????????????????????

node id: parent = p , depth = d, type, [c1...ck]

p ?????????????????????????????????????????????????????????????????´?????? -1 ??¨????????????
d ??????????????±?????????????????????

type??????????????¨??????????????????????????????????????? root???internal node???leaf ?????????????????????????????§??????
?????????????????????????????¨??????????????¶?????????????????´?????? root ??¨????????????

c1...ck ????????????????????§??????
????????¨??¨???????????\?????????????????????????????????????????????
?????????????????????????????¨???????????????????????????????????????????????¢???????¢?????????????????????????

""""""
import sys

I = 0
L = 1
R = 2
P = 3
B = 4
D = 5
H = 6

def setd(A, id, d):
    n = A[id]
#    print(""depth d:{} n:{} {}"".format(d,id,n))
    n[D] = d
    ld = 0
    rd = 0
    if n[L] > -1:
       ld = setd(A, n[L], d + 1) + 1
    if n[R] > -1:
       rd = setd(A, n[R], d + 1) + 1
    if ld > rd:
        n[H] = ld
    else:
        n[H] = rd
    return n[H]

def getroot(A, id):
    if A[id][P] > -1:
        return getroot(A,A[id][P])
    return A[id][I]

def main():

    """""" ????????? """"""
    num = int(input().strip())
    istr = sys.stdin.read()
    nlist = list(istr.splitlines())
    
    nodes = [[i, -1, -1, -1, -1, 0, 0] for i in range(num)]

    for nstr in nlist:
        i = list(map(int,nstr.split()))
        n = nodes[i[I]]
        n[I] = i[I]
        if i[L] > -1:
            n[L] = i[L]
            nodes[n[L]][P] = i[I]
            nodes[n[L]][B] = i[R]
        if i[R] > -1:
            n[R] = i[R]
            nodes[n[R]][P] = i[I]
            nodes[n[R]][B] = i[L]
#        print(""set n:{} {} {}"".format(n[I],n,i))

    r = getroot(nodes, 0)
    setd(nodes,r, 0)

    for id in range(num):
        n = nodes[id]
#        print(""print n:{} {}"".format(id,n))
        type = ""leaf""
        children = """"
        cnum = 0

        if n[L] > -1:
            type = ""internal node""
            cnum += 1

        if n[R] > -1:
            type = ""internal node""
            cnum += 1

        if n[P] == -1:
            type = ""root""

        print(""node {}: parent = {}, sibling = {}, degree = {}, depth = {}, height = {}, {}"".format(n[I], n[P], n[B], cnum, n[D], n[H], type))

if __name__ == '__main__':
    main()
"
2487558,ALDS1_7_B,"N = int(input())
tree = [None] * N
root = set(range(N))

def set_pd(i, parent, sibling, depth):
    if i == -1:
        return -1
    node = tree[i]
    l, r = node[0], node[1]
    
    node[2], node[3], node[5] = parent, sibling, depth
    node[4] = (l != -1) + (r != -1)
    height = node[6] = max(set_pd(l, i, r, depth + 1), set_pd(r, i, l, depth + 1)) + 1
    return height

while N:
    i, l, r = list(map(int, input().split()))
    tree[i] = [l,r] + [None] * 5 # parent, sibling, degree, depth, height
    root -= {l, r}
    N -= 1

set_pd(root.pop(), -1, -1, 0)

for i, node in enumerate(tree):
    l, r, p, s, deg, dep, h = node
    print('node {}: parent = {}, sibling = {}, degree = {}, depth = {}, height = {}, {}'.format(
        i, p, s, deg, dep, h, 'root' if not dep else 'internal node' if deg else 'leaf'
    ))
"
2498131,ALDS1_7_B,"def binarytrees():
    def set_depth(node_id):
        if tree[node_id]['parent'] == -1:
            return 0
        else:
            return set_depth(tree[node_id]['parent']) + 1

    def set_height(node_id):
        if not tree[node_id]['degree']:
            return 0
        else:
            return max(set_height(tree[node_id]['children'][0]),
                set_height(tree[node_id]['children'][1])) + 1

    n = int(input())

    tree = [{'parent': -1, 'sibling': -1, 'degree': 0, 'depth': 0, 'height': 0,
             'node_type': 'leaf', 'children': []} for i in range(n)]

    for i in range(n):
        line = list(map(int, input().split()))
        node_id = line[0]
        child1 = line[1]
        child2 = line[2]

        for child in [child1, child2]:
            if child != -1:
                tree[node_id]['children'] = line[1:]
                tree[child]['parent'] = node_id
                tree[node_id]['degree'] += 1

        if (child1 != -1) and (child2 != -1):
            tree[child1]['sibling'] = child2
            tree[child2]['sibling'] = child1

        if tree[node_id]['degree']:
            tree[node_id]['node_type'] = 'internal node'

    for node_id in range(n):
        tree[node_id]['depth'] = set_depth(node_id)
        tree[node_id]['height'] = set_height(node_id)

        if tree[node_id]['parent'] == -1:
            tree[node_id]['node_type'] = 'root'

    for node_id in range(n):
        parent = tree[node_id]['parent']
        sibling = tree[node_id]['sibling']
        degree = tree[node_id]['degree']
        depth = tree[node_id]['depth']
        height = tree[node_id]['height']
        node_type = tree[node_id]['node_type']

        print('node {}: parent = {}, sibling = {}, degree = {}, depth = {}, height = {}, {}'
            .format(node_id, parent, sibling, degree, depth, height, node_type))

if __name__ == '__main__':
    binarytrees()
"
2589154,ALDS1_7_B,"class Node():
    def __init__(self, node_id, left, right):
        self.node_id    =   node_id
        self.parent     =   -1
        self.sibling    =   -1
        self.left       =   left
        self.right      =   right
        self.degree     =   0
        self.depth      =   0
        self.height     =   0
        self.typ        =   ""leaf""

    def set_prop(self, node_id, parent, sibling, depth):
        if node_id == -1:
            return -1
        self.parent     =   parent
        self.sibling    =   sibling
        self.depth      =   depth
        self.degree     =   (self.left != -1) + (self.right != -1)
        if self.degree:
            self.typ    =   ""internal node""
        if self.parent == -1:
            self.typ    =   ""root""
        self.height     =   max(tree[self.left].set_prop(self.left, self.node_id, self.right, self.depth + 1), 
                                tree[self.right].set_prop(self.right, self.node_id, self.left, self.depth + 1)) + 1
        return self.height

n = int(input())
tree = [None for i in range(n)]
root = set(range(n))

for i in range(n):
    node_id, left, right = map(int, input().split())
    tree[node_id] = Node(node_id, left, right)
    root -= set([left, right])
r = root.pop()
tree[r].set_prop(r, -1, -1, 0)

for i in range(n):
    a = tree[i]
    print(""node "", a.node_id, "": parent = "", a.parent, "", sibling = "", a.sibling,
          "", degree = "", a.degree, "", depth = "", a.depth, "", height = "", a.height, "", "", a.typ, sep="""")
"
2632037,ALDS1_7_B,"# -*- coding:utf-8 -*-
import sys


def bin_tree(lst, n):
    """"""
        tree[0]: node
        tree[1]: parent
        tree[2]: sibling
        tree[3]: degree
        tree[4]: depth
        tree[5]: height
    """"""
    info = [[-1, -1, -1, -1, -1, -1] for n in range(0, n)]
    degree = 0
    for node, left, right in lst:
        if left >= 0:
            info[left][1] = node
            info[left][2] = right
            degree += 1

        if right >= 0:
            info[right][1] = node
            info[right][2] = left
            degree += 1

        info[node][0] = node
        info[node][3] = degree

        degree = 0

    root = -1
    for node in info:
        root = node[0]
        if node[1] == -1:
            break

    get_depth(lst, root, info)
    get_height(lst, root, info)
    print_info(info)


def get_height(tree, root, info):
    def _get_height(node, depth):
        if node == -1:
            return 0

        left_height = _get_height(tree[node][1], depth + 1)
        right_height = _get_height(tree[node][2], depth + 1)

        if left_height > right_height:
            info[node][5] = left_height
        else:
            info[node][5] = right_height

        return info[node][5] + 1

    _get_height(root, 0)


def get_depth(tree, root, info):
    def _get_depth(node, depth):
        if node == -1:
            return

        info[node][4] = depth
        _get_depth(tree[node][1], depth + 1)
        _get_depth(tree[node][2], depth + 1)

    _get_depth(root, 0)


def print_info(info):
    for node, parent, sibling, degree, depth, height in info:
        if parent == -1:
            _type = ""root""
        elif degree != 0:
            _type = ""internal node""
        else:
            _type = ""leaf""

        print(""node {0}: parent = {1}, sibling = {2}, degree = {3}, depth = {4}, height = {5}, {6}"".format(node, parent, sibling, degree, depth, height, _type))


if __name__ == ""__main__"":
    n = int(input())
    lst = [[int(n) for n in val.split()] for val in sys.stdin.readlines()]
    lst.sort(key=lambda x: x[0])
    bin_tree(lst, n)
"
2691844,ALDS1_7_B,"# -*- coding: utf-8 -*-

class Node():
    def __init__(self, parent=-1, left=-1, right=-1, depth=0, height=0, sibling=-1, degree=0):
        self.parent = parent
        self.left = left
        self.right = right
        self.depth = depth
        self.height = height
        self.sibling = sibling
        self.degree = degree

if __name__ == '__main__':

    n = int(input())
    T = [Node() for i in range(n)]

    for _ in range(n):
        i, left, right = [int(s) for s in input().split("" "")]
        has_left = (left != -1)
        has_right = (right != -1)
        if has_left:
            T[i].left = left
            T[left].parent = i
            T[i].degree += 1
        if has_right:
            T[i].right = right
            T[right].parent = i
            T[i].degree += 1
        if has_left and has_right:
            T[left].sibling = right
            T[right].sibling = left

    def setDepth(u, p):
        T[u].depth = p
        if T[u].right != -1:
            setDepth(T[u].right, p + 1)
        if T[u].left != -1:
            setDepth(T[u].left, p + 1)

    def setHeight(u):
        h1 = 0
        h2 = 0
        if T[u].right != -1:
            h1 = setHeight(T[u].right) + 1
        if T[u].left != -1:
            h2 = setHeight(T[u].left) + 1
        T[u].height = max(h1, h2)
        return T[u].height

    for i, n in enumerate(T):
        if n.parent == -1:
            root = i
        
    setDepth(root, 0)
    setHeight(root)

    for i, node in enumerate(T):
        if node.parent == -1:
            n_type = ""root""
        elif node.left != -1 or node.right != -1:
            n_type = ""internal node""
        else:
            n_type = ""leaf""

        print(""node {}: parent = {}, sibling = {}, degree = {}, depth = {}, height = {}, {}"".format(
            i, node.parent, node.sibling, node.degree, node.depth, node.height, n_type))
    
"
2698025,ALDS1_7_B,"import sys
readline = sys.stdin.readline
class Tree:
    __slots__ = ['id', 'p', 'sibling', 'degree', 'depth', 'height', 'type', 'c']
    def __init__(self, id):
        self.id = id
        self.p = -1
        self.sibling = -1
        self.degree = 0
        self.depth = 0
        self.height = 0
        self.type = ""leaf""
        self.c = []
    def __str__(self):
        return f""node {self.id}: parent = {self.p}, sibling = {self.sibling}, degree = {self.degree}, depth = {self.depth}, height = {self.height}, {self.type}""
n = int(input())
tree = tuple(Tree(i) for i in range(n))
for _ in range(n):
    id, *c = map(int, readline().replace(""-1"", """").split())
    if c != []:
        tree[id].type = ""internal node""
        tree[id].c = c
        for j in c:
            tree[j].p = id
        len_c = len(c)
        tree[id].degree = len_c
        if len_c == 2:
            tree[c[0]].sibling = c[1]
            tree[c[1]].sibling = c[0]
root = 0
while tree[root].p != -1:
    root = tree[root].p
tree[root].type = ""root""
def depth_height_check(id, d):
    d += 1
    height = 0
    for i in tree[id].c:
        tree[i].depth = d
        if tree[i].type != ""leaf"":
            tree[i].height = depth_height_check(i, d)
            height = max(height, tree[i].height)
    return height + 1
tree[root].height = depth_height_check(root, 0) if n > 1 else 0
print(""\n"".join(map(str, tree)))

"
2715829,ALDS1_7_B,"N=int(input())
t=[0]*N
r=set(range(N))
for _ in[0]*N:
 x,y,z=map(int,input().split())
 t[x]=[y,z]+[0]*5
 r-={y,z}
def f(i,p,s,d):
 if i<0:return-1
 l,r=t[i][:2]
 t[i][2:]=[p,s,(l!=-1)+(r!=-1),d,max(f(l,i,r,d+1),f(r,i,l,d+1))+1]
 return t[i][-1]
f(r.pop(),-1,-1,0)
for i in range(N):
 print('node {}: parent = {}, sibling = {}, degree = {}, depth = {}, height = {}, {}'.format(i,*t[i][2:],'root'if not t[i][5]else'internal node'if t[i][4]else'leaf'))
"
2743508,ALDS1_7_B,"class Tree:
    nodes = []
    def __init__(self):
        self.root = None
    def insert(self, nodenum, leftnum, rightnum):
        if leftnum != -1:
            self.nodes[nodenum].left = self.nodes[leftnum]
            self.nodes[leftnum].type_ = ""internal node""
            self.nodes[leftnum].parent = self.nodes[nodenum]
            self.nodes[nodenum].degree += 1
        else:
            self.nodes[nodenum].left = -1
        if rightnum != -1:
            self.nodes[nodenum].right = self.nodes[rightnum]
            self.nodes[rightnum].type_ = ""internal node""
            self.nodes[rightnum].parent = self.nodes[nodenum]
            self.nodes[nodenum].degree += 1
        else:
            self.nodes[nodenum].right = -1
        if leftnum != -1 and rightnum != -1:
            self.nodes[leftnum].sibling = rightnum
            self.nodes[rightnum].sibling = leftnum
    def depth(self, node):
        if node.left != -1:
            node.left.depth += node.depth + 1
            self.depth(node.left)
        if node.right != -1:
            node.right.depth += node.depth + 1
            self.depth(node.right)
    def height(self, node):
        if node.left == -1 and node.right == -1:
            node.type_ = ""leaf""
            return 0
        elif node.left == -1:
            x = self.height(node.right)
            node.height = x + 1
            return x + 1
        elif node.right == -1:
            x = self.height(node.left)
            node.height = x + 1
            return x + 1
        else:
            x = max(self.height(node.left), self.height(node.right)) + 1
            node.height = x
            return x
class Node:
    def __init__(self, label, left = -1, right = -1):
        self.label = label
        self.type_ = ""root""
        self.parent = -1
        self.sibling = -1
        self.depth = 0
        self.height = 0
        self.degree = 0
        self.left = left
        self.right = right

tree = Tree()
n = int(input())
for i in range(n):
    tree.nodes.append(Node(i))
for i in range(n):
    num, left, right = map(int, input().split())
    tree.insert(num, left, right)
for i in tree.nodes:
    if i.parent == -1:
        tree.depth(i)
        tree.height(i)
if n == 1:
    tree.nodes[0].type_ = ""root""
for i in tree.nodes:
    print(""node {0:}: parent = "".format(i.label), end = """")
    if i.parent == -1:
        print(i.parent, end = """")
    else:
        print(i.parent.label, end = """")
    print("", sibling = {0:}, degree = {1:}, depth = {2:}, height = {3:}, {4:}"".format(i.sibling, i.degree, i.depth, i.height, i.type_))
"
2876675,ALDS1_7_B,"# -*- coding: utf-8 -*-
""""""
Created on Sat May 19 19:34:44 2018
ALDS1_7_B
@author: maezawa
""""""

n = int(input())

parent = [-1 for _ in range(n)]
left = [-1 for _ in range(n)]
right = [-1 for _ in range(n)]
height = [None for _ in range(n)]
depth = [None for _ in range(n)]

def set_parent():
    global parent
    for i in range(n):
        if left[i] != -1:
            parent[left[i]] = i
        if right[i] != -1:
            parent[right[i]] = i

    
def set_depth(i, p):
    global depth
    if depth[i] != None:
        return
    depth[i] = p
    if right[i] != None:
        set_depth(right[i], p)
    if left[i] != None:
        set_depth(left[i], p+1)
       
def get_depth(i):
    global depth
    if depth[i] != None:
        return depth[i]
    d = 0
    u = i
    while parent[u] != -1:
        u = parent[u]
        d += 1
    depth[i] = d
    return d

def set_height(u):
    global height
    h1 = 0
    h2 = 0
    if right[u] != -1:
        h1 = set_height(right[u])+1
    if left[u] != -1:
        h2 = set_height(left[u])+1
    height[u] = max(h1, h2)
    return height[u]    

def get_sib(i):
    if right[parent[i]] == i:
        return left[parent[i]]
    else:
        return right[parent[i]]
    
def get_deg(i):
    deg = 0
    if right[i] != -1:
        deg += 1
    if left[i] != -1:
        deg += 1
    return deg    

def get_height(i):
    return height[i]
    
for i in range(n):
    line = list(map(int, input().split()))
    left[line[0]] = line[1]
    right[line[0]] = line[2]

set_parent()

for i in range(n):
    set_height(i)
    
for i in range(n):
    out_str = 'node {}: parent = {}, sibling = {}, degree = {}, depth = {}, height = {}, '.format(i,parent[i],get_sib(i), get_deg(i), get_depth(i), get_height(i))
    if parent[i] == -1:
        out_str += 'root'
    elif right[i] == -1 and left[i] == -1:
        out_str += 'leaf'
    else:
        out_str += 'internal node'
    print(out_str)
        
        

"
2892475,ALDS1_7_B,"class Node:
    def __init__(self, parent=-1, left=-1, right=-1):
        self.parent = parent
        self.left = left
        self.right = right


n = int(input())
binary_tree = [Node() for i in range(n)]
h, d = [0 for j in range(n)], [0 for k in range(n)]


def set_height(u):
    h1 = h2 = 0
    if binary_tree[u].right != -1:
        h1 = set_height(binary_tree[u].right) + 1
    if binary_tree[u].left != -1:
        h2 = set_height(binary_tree[u].left) + 1

    h[u] = max(h1, h2)
    return h[u]


def set_depth(u, dep):
    d[u] = dep
    if binary_tree[u].right != -1:
        set_depth(binary_tree[u].right, dep+1)
    if binary_tree[u].left != -1:
        set_depth(binary_tree[u].left, dep+1)

    return d[u]


def set_sibling(u):
    if binary_tree[binary_tree[u].parent].left != u:
        return binary_tree[binary_tree[u].parent].left
    else:
        return binary_tree[binary_tree[u].parent].right


def set_degree(u):
    cnt = 0
    if binary_tree[u].left != -1:
        cnt += 1
    if binary_tree[u].right != -1:
        cnt += 1
    return cnt


def set_type(u):
    if binary_tree[u].parent == -1:
        return ""root""
    elif binary_tree[u].left == -1 and binary_tree[u].right == -1:
        return ""leaf""
    else:
        return ""internal node""


def main():
    for i in range(n):
        idx, left, right = map(int, input().split())
        binary_tree[idx].left = left
        binary_tree[idx].right = right
        if left != -1:
            binary_tree[left].parent = idx
        if right != -1:
            binary_tree[right].parent = idx

    # 根の探索
    root_idx = 0
    for i in range(n):
        if binary_tree[i].parent == -1:
            root_idx = i
            break

    # 各ノードの高さを求める
    set_height(root_idx)

    # 各ノードの深さを求める
    set_depth(root_idx, 0)

    for i in range(n):
        print(""node {}: parent = {}, sibling = {}, degree = {}, depth = {}, ""
              ""height = {}, {}"".format(i, binary_tree[i].parent,
                set_sibling(i), set_degree(i), d[i], h[i], set_type(i)))


if __name__ == '__main__':
    main()

"
2902021,ALDS1_7_B,"n = int(input())
root = set(range(n))
binary_tree = [0 for i in range(n)]
#out = [0 for i in range(n)]
for i in range(n):
    l = list(map(int, input().split()))
    binary_tree[l[0]] = l
    s = set(l[1:3])
    root -= s

def binary(id, parent, depth, sibling, height):
    output = {}
    hline = []
    hline.append(height)
    output['node'] = id
    output['parent'] = parent
    output['sibling'] = sibling
    output['depth'] = depth
    left = binary_tree[id][1]
    right = binary_tree[id][2]
    degree = 0
    if(parent == -1):
        output['type'] = 'root'
    elif(left == -1 and right == -1):
        output['type'] = 'leaf'
    else:
        output['type'] = 'internal node'
    if(left != -1):
        degree += 1
        hline.append(binary(left, id, depth+1, right, height))
    if(right != -1):
        degree += 1
        hline.append(binary(right, id, depth+1, left, height))
    max_height = max(hline)
    output['degree'] = degree
    output['height'] = max_height
    binary_tree[id] = output
    return max_height + 1

binary(list(root)[0], -1, 0, -1, 0)
for line in binary_tree:
    print('node {}: parent = {}, sibling = {}, degree = {}, depth = {}, height = {}, {}'.format(line['node'], line['parent'], line['sibling'], line['degree'], line['depth'], line['height'], line['type']))

"
2903505,ALDS1_7_B,"class Tree:
    def __init__(self, ary):
        self.nodes = [
            Node(node, self) for node in sorted(ary, key=lambda x: x[0])
        ]
        [node.set() for node in self.nodes]
        for node in self.nodes:
            if node.parent == -1:
                node.set_depth(0)
                node.set_height()
                break

    def output(self):
        [node.output() for node in self.nodes]


class Node:
    def __init__(self, node, tree):
        self.tree = tree
        self.no = node[0]
        self.left = node[1]
        self.right = node[2]
        self.parent = -1
        self.sibling = -1
        self.degree = 0

    def set(self):
        if self.left > -1:
            self.tree.nodes[self.left].parent = self.no
            if self.right > -1:
                self.tree.nodes[self.right].sibling = self.left
            self.degree += 1

        if self.right > -1:
            self.tree.nodes[self.right].parent = self.no
            if self.left > -1:
                self.tree.nodes[self.left].sibling = self.right
            self.degree += 1

    def set_depth(self, d):
        self.depth = d
        if self.left > -1:
            self.tree.nodes[self.left].set_depth(d + 1)
        if self.right > -1:
            self.tree.nodes[self.right].set_depth(d + 1)

    def set_height(self):
        if self.degree == 0:
            self.height = 0
        else:
            self.tree.nodes[self.right].set_height()
            self.tree.nodes[self.left].set_height()
            self.height = 1 + max(self.tree.nodes[self.right].height,
                                  self.tree.nodes[self.left].height)

    def output(self):
        if self.parent == -1:
            kind = 'root'
        elif self.degree == 0:
            kind = 'leaf'
        else:
            kind = 'internal node'

        print(
            'node {}: parent = {}, sibling = {}, degree = {}, depth = {}, height = {}, {}'.
            format(self.no, self.parent, self.sibling, self.degree, self.depth,
                   self.height, kind))


if __name__ == '__main__':
    # import sys
    n = int(input())
    ary = [[int(_) for _ in input().split()] for i in range(n)]
    tree = Tree(ary)
    tree.output()

"
2910362,ALDS1_7_B,"class NullNode():
    def __init__(self):
        self.id = -1

class Node():
    def __init__(self, id):
        self.id = id
        self.parent = NullNode()
        self.left = NullNode()
        self.right = NullNode()
        self.sibling = NullNode()

    def __str__(self):
        return '{} {} {} {} {}'.format(self.id, self.parent.id, self.left.id, self.right.id, self.sibling.id)

    def getHeight(self, right_height=0, left_height=0):
        if self.left.id != -1:
            left_height += 1
            left_height = self.left.getHeight(left_height, left_height)
        if self.right.id != -1:
            right_height += 1
            right_height = self.right.getHeight(right_height, right_height)
        return max(left_height, right_height)

    def getDepth(self, depth=0):
        if self.parent.id != -1:
            depth += 1
            depth = self.parent.getDepth(depth)
        return depth

    def getDegree(self):
        degree = 0
        if self.left.id != -1:
            degree += 1
        if self.right.id != -1:
            degree += 1
        return degree

    def getType(self):
        if self.parent.id == -1:
            return 'root'
        elif self.left.id == -1 and self.right.id == -1:
            return 'leaf'
        else:
            return 'internal node'

n = int(input())
node_list = [Node(id) for id in range(n)]
for i in range(n):
    [id, left, right] = [int(j) for j in input().split()]
    i_node = node_list[id]
    if left != -1:
        i_node.left = node_list[left]
        node_list[left].parent = node_list[id]
        if right != -1:
            node_list[left].sibling = node_list[right]
    if right != -1:
        i_node.right = node_list[right]
        node_list[right].parent = node_list[id]
        if left != -1:
            node_list[right].sibling = node_list[left]

for id in range(n):
    i_node = node_list[id]
    parent = i_node.parent.id
    sibling = i_node.sibling.id
    degree = i_node.getDegree()
    depth = i_node.getDepth()
    height = i_node.getHeight()
    type = i_node.getType()
    print('node {0}: parent = {1}, sibling = {2}, degree = {3}, depth = {4}, height = {5}, {6}'.format(id, parent, sibling, degree, depth, height, type))

"
2915608,ALDS1_7_B,"#coding:utf-8

n = int(input())
T = [list(map(int, input().split())) for i in range(n)]
A = [False for i in range(n)]

class binaryTree:
    def __init__(self, node, x=-1):
        self.node = node
        self.p = x
    
    def partialTree(self,tree,left, right):
        node = tree.node
        if left != -1:
            if A[left]:
                A[left].p = tree
                tree.l = A[left]
            else:
                tree.l = binaryTree(left, node)
                A[left] = tree.l
                tree.l.p = tree
        else:
            tree.l = binaryTree(left, node)
            tree.l.node = -1
            
        if right != -1:
            if A[right]:
                A[right].p = tree
                tree.r = A[right]
            else:
                tree.r = binaryTree(right, node)
                A[right] = tree.r
                tree.r.p = tree
        else:
            tree.r = binaryTree(right, node)
            tree.r.node = -1
            
def searchParent():
    p_tree = A[0]
    while p_tree.p != -1:
        p_tree = p_tree.p
    return p_tree

     
def setHeight(tree):
    h1 = h2 = 0
    if tree.l.node != -1:
        h1 = setHeight(tree.l) + 1
    if tree.r.node != -1:
        h2 = setHeight(tree.r) + 1
    if tree.l.node == -1 and tree.r.node == -1:
        tree.hei = 0
        return 0
    tree.hei = max(h1,h2)
    return max(h1, h2)

def setDepth(tree,depth):
    tree.dep = depth
    depth += 1
    if tree.l.node != -1:
        setDepth(tree.l,depth)

    if tree.r.node != -1:
        setDepth(tree.r,depth)

def getSibling(tree):
    if tree.p == -1:
        return -1
    if tree.p.l.node != -1 and tree.p.l.node != tree.node:
        return tree.p.l.node
    if tree.p.r.node != -1 and tree.p.r.node != tree.node:
        return tree.p.r.node
    return -1

        
def makeTree():
    for i in range(n):
        t = T[i]
        node = t[0]
        left = t[1]
        right = t[2]
        if A[node]:
            tree = A[node]
        else:
            tree = binaryTree(node)
            A[node] = tree
        binaryTree.partialTree(binaryTree, tree,left,right)

makeTree()
p_tree = searchParent()
setHeight(p_tree)
depth = 0
setDepth(p_tree,depth)


for i in range(n):
    tree = A[i]
    tree.sib = getSibling(tree)
    deg = 0
    if tree.r.node != -1:
        deg += 1

    if tree.l.node != -1:
        deg += 1

    if tree.p == -1:
        kind = ""root""
    else:
        if deg == 0:
            kind = ""leaf""
        else:
            kind = ""internal node""

    ID = i
    if tree.p == -1:
        parent = -1
    else:
        parent = tree.p.node
    sibling = tree.sib
    degree = deg
    depth = tree.dep
    height = tree.hei

    print(""node {}: parent = {}, sibling = {}, degree = {}, depth = {}, height = {}, {}""\
          .format(ID, parent, sibling, degree, depth, height, kind))
"
2924818,ALDS1_7_B,"def search(ps, id):
    if ps[id] == -1:
        return 0
    else:
        return 1 + search(ps, ps[id])


def search_h(tree, id):
    if tree[id][0] == -1:
        left = -1
    else:
        left = search_h(tree, tree[id][0])

    if tree[id][1] == -1:
        right = -1
    else:
        right = search_h(tree, tree[id][1])

    return 1 + max(left, right)


n = int(input())
tree = [[] for _ in range(n)]
ps = [-1 for _ in range(n)]
ss = [-1 for _ in range(n)]
for _ in range(n):
    s = input().split()
    id = int(s[0])
    left = int(s[1])
    right = int(s[2])
    tree[id] = [left, right]
    if left >= 0:
        ps[left] = id
        ss[left] = right
    if right >= 0:
        ps[right] = id
        ss[right] = left

for id in range(n):
    p = ps[id]
    s = ss[id]
    deg = int(tree[id][0] >= 0) + int(tree[id][1] >= 0)
    d = search(ps, id)
    h = search_h(tree, id)
    if p == -1:
        type = ""root""
    elif tree[id][0] == -1 and tree[id][1] == -1:
        type = ""leaf""
    else:
        type = ""internal node""

    print(""node "" + str(id) + "": parent = "" + str(p) + "", sibling = "" + str(s) + "", degree = "" + str(
        deg) + "", depth = "" + str(d) + "", height = "" + str(h) + "", "" + type)
"
3022847,ALDS1_7_B,"n = int(input())
tree = [0] * n
root = set(range(n))
def type(i, parent, sibling, depth):
    if i == -1:
        return -1
    node = tree[i]
    l, r = node[0], node[1]
    node[2], node[3], node[5] = parent, sibling, depth
    node[4] = (l != -1) + (r != -1)
    h = node[6] = max(type(l, i, r, depth + 1), type(r, i, l, depth + 1)) + 1
    return h
 
while n:
    i, l, r = list(map(int, input().split()))
    tree[i] = [l, r] + [0] * 5
    root -= {l, r}
    n -= 1
type(root.pop(), -1, -1, 0)
for i, node in enumerate(tree):
    l, r, p, s, deg, dep, h = node
    print('node {}: parent = {}, sibling = {}, degree = {}, depth = {}, height = {}, {}'.format(i, p, s, deg, dep, h, 'root' if not dep else 'internal node' if deg else 'leaf'))
"
3031408,ALDS1_7_B,"N = int(input())

binary_tree = [{""parent"": -1, ""sibling"": -1} for _ in range(N)]
for _ in range(N):
    node_input = input()
    id, left, right = map(int, node_input.split())

    binary_tree[id][""left""] = left
    binary_tree[id][""right""] = right

    degree = 0
    if left != -1:
        degree += 1
        binary_tree[left][""parent""] = id
        binary_tree[left][""sibling""] = right
    if right != -1:
        degree += 1
        binary_tree[right][""parent""] = id
        binary_tree[right][""sibling""] = left
    binary_tree[id][""degree""] = degree


def measure_depth_and_height(id, depth):
    H[id] = max(H[id], depth)

    parent_id = binary_tree[id][""parent""]
    if parent_id == -1:
        return depth

    return measure_depth_and_height(parent_id, depth+1)

D = [0 for i in range(N)]
H = [0 for i in range(N)]
for id in range(N):
    depth = measure_depth_and_height(id, 0)
    D[id] = depth


def get_type(node):
    if node[""parent""] == -1:
        return ""root""
    if node[""degree""] == 0:
        return ""leaf""
    return ""internal node""

for id in range(N):
    node = binary_tree[id]
    parent_id = node[""parent""]
    sibling_id = node[""sibling""]
    degree = node[""degree""]
    node_type = get_type(node)
    print(""node {}: parent = {}, sibling = {}, degree = {}, depth = {}, height = {}, {}"".format(id, parent_id, sibling_id, degree, D[id], H[id], node_type))
"
3034128,ALDS1_7_B,"class Node:
	def __init__(self, id):
		self.id = id
		self.parent_id = -1
		self.left = -1
		self.right = -1
		self.sibling = -1
		self.depth = -1
		self.height = -1
	def get_type(self):
		if self.parent_id == -1:
			return 'root'
		elif self.left == -1 and self.right == -1:
			return 'leaf'
		return 'internal node'
	def get_degree(self):
		ret = 0
		if self.left != -1: ret += 1
		if self.right != -1: ret += 1
		return ret
	def __str__(self):
		strNode = 'node ' + str(self.id) + ': '
		strNode += 'parent = ' + str(self.parent_id) + ', '
		strNode += 'sibling = ' + str(self.sibling) + ', '
		strNode += 'degree = ' + str(self.get_degree()) + ', '
		strNode += 'depth = ' + str(self.depth) + ', '
		strNode += 'height = ' + str(self.height) + ', '
		strNode += self.get_type()
		return strNode

def calc_depth(nodes):
	stack = []
	for i in range(len(nodes)):
		if nodes[i].parent_id == -1:
			nodes[i].depth = 0
			stack.append(nodes[i].id)
			break
	while len(stack) != 0:
		node = nodes[stack.pop()]
		if node.left != -1:
			nodes[node.left].depth = node.depth + 1
			stack.append(node.left)
		if node.right != -1:
			nodes[node.right].depth = node.depth + 1
			stack.append(node.right)

def calc_height(nodes):
	stack = []
	for i in range(len(nodes)):
		if nodes[i].left == -1 and nodes[i].right == -1:
			nodes[i].height = 0
			stack.append(nodes[i].id)
	while len(stack) != 0:
		node = nodes[stack.pop()]
		if node.parent_id != -1:
			parent = nodes[node.parent_id]
			parent.height = max(parent.height, node.height + 1)
			stack.append(node.parent_id)

n = int(input())
nodes = [Node(i) for i in range(n)]
for i in range(n):
	id, left, right = map(int, input().split())
	nodes[id].left = left
	nodes[id].right = right
	if left != -1:
		nodes[left].parent_id = id
		nodes[left].sibling = right
	if right != -1:
		nodes[right].parent_id = id
		nodes[right].sibling = left

calc_depth(nodes)
calc_height(nodes)

for i in range(n):
	print(nodes[i])

"
3070478,ALDS1_7_B,"NIL = -1

class Node:
    def __init__(self, parent=NIL, left=NIL, right=NIL):
        self.parent = parent
        self.left = left
        self.right = right


def setDepth(tree, depthList, u, depth):
    if u == NIL:
        return
    depthList[u] = depth
    setDepth(tree, depthList, tree[u].left, depth + 1)
    setDepth(tree, depthList, tree[u].right, depth + 1)


def setHeight(tree, heightList, u):
    h1 = 0
    h2 = 0
    if tree[u].left != NIL:
        h1 = setHeight(tree, heightList, tree[u].left) + 1
    if tree[u].right != NIL:
        h2 = setHeight(tree, heightList, tree[u].right) + 1
    heightList[u] = max(h1, h2)
    return heightList[u]


def getSibling(tree, u):
    if tree[u].parent == NIL:
        return NIL
    if tree[tree[u].parent].left not in (u, NIL):
        return tree[tree[u].parent].left
    if tree[tree[u].parent].right not in (u, NIL):
        return tree[tree[u].parent].right
    return NIL


def printNode(tree, depthList, heightList, u):
    result = 'node %d: ' % u
    result += 'parent = %d, ' % tree[u].parent
    result += 'sibling = %d, ' % getSibling(tree, u)
    deg = 0
    if tree[u].left != NIL:
        deg += 1
    if tree[u].right != NIL:
        deg += 1
    result += 'degree = %d, ' % deg
    result += 'depth = %d, ' % depthList[u]
    result += 'height = %d, ' % heightList[u]

    if tree[u].parent == NIL:
        result += 'root'
    elif tree[u].left == NIL and tree[u].right == NIL:
        result += 'leaf'
    else:
        result += 'internal node'
    print(result)


n = int(input())
tree = [Node() for i in range(n)]

for i in range(n):
    value, left, right = [int(v) for v in input().split()]
    tree[value].left = left
    tree[value].right = right
    if left != NIL:
        tree[left].parent = value
    if right != NIL:
        tree[right].parent = value

root = 0
for i in range(n):
    if tree[i].parent == NIL:
        root = i
        break

depthList = [-1] * n
heightList = [-1] * n
setDepth(tree, depthList, root, 0)
setHeight(tree, heightList, root)
for i in range(n):
    printNode(tree, depthList, heightList, i)
"
3107850,ALDS1_7_B,"from sys import stdin

class Node(object):
    def __init__(self, parent=None, left=None, right=None,
                 name=None, sibling=None, degree=None):
        self.parent = parent
        self.left = left
        self.right = right
        self.name = name
        self.sibling = sibling
        self.degree = degree

def print_nodes(nodes, n):
    def get_depth(nodes, u):
        p = nodes[u].parent
        nonlocal d
        if p != None and p != -1:
            get_depth(nodes, p)
            d += 1
        return d

    def get_height(nodes, u):
        h1 = 0
        h2 = 0
        r = nodes[u].right
        l = nodes[u].left
        if r != -1:
            h1 = get_height(nodes, r) + 1
        if l != -1:
            h2 = get_height(nodes, l) + 1
        return max(h1, h2)

    for i in range(n):
        d = 0
        if nodes[i].parent == None:
            nodes[i].parent = -1
            nodes[i].sibling = -1
            nodes[i].name = ""root""
        print(""node {0}: parent = {1}, sibling = {2}, degree = {3}, depth = {4}, height = {5}, {6}"".format(
               i, nodes[i].parent, nodes[i].sibling, nodes[i].degree, get_depth(nodes, i),
               get_height(nodes, i), nodes[i].name))

def read_binary_tree(nodes, n):
    for _ in range(n):
        i = [int(i) for i in stdin.readline().strip().split()]
        nodes[i[0]].left = i[1]
        nodes[i[0]].right = i[2]
        nodes[i[0]].degree = 0
        if i[1] != -1:
            nodes[i[0]].name = ""internal node""
            nodes[i[1]].parent = i[0]
            nodes[i[1]].sibling = i[2]
            nodes[i[0]].degree += 1
        if i[2] != -1:
            nodes[i[0]].name = ""internal node""
            nodes[i[2]].parent = i[0]
            nodes[i[2]].sibling = i[1]
            nodes[i[0]].degree += 1
        if i[1] == -1 and i[2] == -1:
            nodes[i[0]].name = ""leaf""

n = int(input())
nodes = [Node() for _ in range(n)]
read_binary_tree(nodes, n)
print_nodes(nodes, n)
"
3118762,ALDS1_7_B,"from sys import stdin

class Node():
    NIL = -1

    def __init__(self, p=NIL, l=NIL, r=NIL, d=-1, h=-1):
        self.p = p
        self.l = l
        self.r = r
        self.d = d
        self.h = h

    def __repr__(self):
        return ""Node({}, {}, {}, {})"".format(self.p, self.l, self.r, self.d)

def root_of(T):
    return [u.p for u in T].index(Node.NIL)

def sibling_of(T, id):
    p = T[T[id].p]
    return p.r if p.l == id else p.l

def degree_of(T, id):
    l = 0 if T[id].l == Node.NIL else 1
    r = 0 if T[id].r == Node.NIL else 1
    return l + r

def calc_depth(T):

    def rec(id, depth):
        nonlocal T

        T[id].d = depth
        if T[id].l != Node.NIL:
            rec(T[id].l, depth + 1)
        if T[id].r != Node.NIL:
            rec(T[id].r, depth + 1)

    rec(root_of(T), 0)

def calc_height(T):

    def rec(id):
        nonlocal T

        l = 0 if T[id].l == Node.NIL else rec(T[id].l) + 1
        r = 0 if T[id].r == Node.NIL else rec(T[id].r) + 1
        T[id].h = max(l, r)
        return T[id].h

    rec(root_of(T))

def type_of(T, id):
    if T[id].p == Node.NIL:
        return ""root""
    elif T[id].l == Node.NIL and T[id].r == Node.NIL:
        return ""leaf""
    else:
        return ""internal node""

def read_nodes(T):
    for line in stdin:
        id, l, r = [int(x) for x in line.split()]
        T[id].l = l
        if l != Node.NIL:
            T[l].p = id
        T[id].r = r
        if r != Node.NIL:
            T[r].p = id

def print_nodes(T):
    for id in range(len(T)):
        print(""node {}: "".format(id), end="""")
        print(""parent = {}, "".format(T[id].p), end="""")
        print(""sibling = {}, "".format(sibling_of(T, id)), end="""")
        print(""degree = {}, "".format(degree_of(T, id)), end="""")
        print(""depth = {}, "".format(T[id].d), end="""")
        print(""height = {}, "".format(T[id].h), end="""")
        print(type_of(T, id))

def main():
    n = int(stdin.readline())
    T = [Node() for _ in range(n)]

    read_nodes(T)
    calc_depth(T)
    calc_height(T)
    print_nodes(T)

main()

"
3119778,ALDS1_7_B,"class Tree():
    def __init__(self):
        self.nodes = {}
        self.nodes[-1] = None

    def add_node(self, id):
        if id not in self.nodes:
            self.nodes[id] = Node(id)

    def add_child(self, parent_id, left_id, right_id):
        self.add_node(parent_id)
        self.add_node(left_id)
        self.add_node(right_id)
        self.nodes[parent_id].add_child(self.nodes[left_id],
                                        self.nodes[right_id])


class Node():
    def __init__(self, id):
        self.id = id
        self.parent = self.left = self.right = None
        self.depth = self.height = 0

    def add_child(self, left, right):
        self.left = left
        self.right = right

        self.update_height()

        for child in self.children():
            child.parent = self
            child.update_depth()

    def update_height(self):
        if self.degree():
            self.height = max([child.height + 1 for child in self.children()])
            if self.parent:
                self.parent.update_height()

    def update_depth(self):
        self.depth = self.parent.depth + 1
        for child in self.children():
            child.update_depth()

    def nodetype(self):
        if self.parent:
            if self.degree():
                return 'internal node'
            else:
                return 'leaf'
        else:
            return 'root'

    def degree(self):
        return len(self.children())

    def children(self):
        return [child for child in [self.left, self.right] if child]

    def sibling(self):
        if self.parent and self.parent.degree() == 2:
            if self.parent.left == self:
                return self.parent.right.id
            else:
                return self.parent.left.id
        else:
            return -1

    def __str__(self):
        return 'node {}: parent = {}, sibling = {}, degree = {}, depth = {}, height = {}, {}'.format(
            self.id,
            self.parent.id if self.parent else - 1,
            self.sibling(),
            self.degree(),
            self.depth,
            self.height,
            self.nodetype())


tree = Tree()

n = int(input())
for i in range(n):
    id, left, right = map(int, input().split())
    tree.add_child(id, left, right)

for id in sorted(tree.nodes):
    if id != -1:
        print(tree.nodes[id])
"
3128513,ALDS1_7_B,"class Node():
    def __init__(self):
        self.parent = None
        self.left = None
        self.right = None
        self.depth = None
        self.height = None
        self.type = None

n = int(input())

# preparing the tree
tree = []
for _ in range(n):
    tree.append(Node())
for _ in range(n):
    id, left, right = map(int, input().split())
    if left > -1:
        tree[id].left = left
        tree[left].parent = id
    if right > -1:
        tree[id].right = right
        tree[right].parent = id
        
        
def get_type(id):
    if tree[id].parent is None:
        return 'root'
    elif (tree[id].left is None) and (tree[id].right is None):
        return 'leaf'
    else:
        return 'internal node'

# recursively set the depth of each node    
def set_depth(id, d):
    tree[id].depth = d
    if tree[id].left is not None:
        set_depth(tree[id].left, d+1)
    if tree[id].right is not None:
        set_depth(tree[id].right, d+1)

# recursively set the height of each node
def set_height(id):
    if id is None:
        pass
    elif tree[id].type == 'leaf':
        tree[id].height = 0
    else:
        left_id = tree[id].left
        right_id = tree[id].right
        set_height(left_id)
        set_height(right_id)
        
        
        tree[id].height = max(
                0 if left_id is None else tree[left_id].height + 1,  
                0 if right_id is None else tree[right_id].height + 1 
            )
         

def get_num_child(id):
    return (tree[id].left is not None)  + (tree[id].right is not None)

def get_sibling(id):
    if tree[id].type == 'root':
        out = None
    else:
        parent_node = tree[tree[id].parent]
        out = (parent_node.right if (parent_node.left == id) else parent_node.left)
    return (-1 if out is None else out)

# ==========

for id in range(n):
    tree[id].type = get_type(id)
    if tree[id].type == 'root':
        root_id = id
set_depth(root_id, 0)
set_height(root_id)

for id in range(n):
    print(f""node {id}: parent = {-1 if tree[id].parent is None else tree[id].parent}, sibling = {get_sibling(id)}, degree = {get_num_child(id)}, depth = {tree[id].depth}, height = {tree[id].height}, {tree[id].type}"")

"
3138223,ALDS1_7_B,"n = int(input())
par_kid = {}
not0 = []
for i in range(n):
    a = list(map(int, input().split()))
    if (a[1] != -1 or a[2] != -1):
        par_kid[a[0]] = a[1:]
        not0 += a[1:]
for i in range(n):
    if (i not in not0):
        first_node = i
        break
par_dep = {first_node:(-1,0)}
def pd(f):
    if (len(par_kid) == 0):
        return 0
    A = par_kid[f]
    c = 0
    for a in A:
        if (a == -1):
            c += 1
            continue
        par_dep[a] = (f, par_dep[f][1]+1)
        if (a not in par_kid.keys()):
            c += 1
            continue
        pd(a)
    if (c == len(A)):
        return 0
s = pd(first_node)
height = {}
for i in range(n):
    if (i not in par_kid.keys()):
        k = i
        height[k] = 0
        while True:
            par = par_dep[k][0]
            if (par in height.keys()):
                height[par] = max(height[par], height[k] + 1)
            else:
                height[par] = height[k] + 1
            if (par == -1):
                break
            k = par
for i in range(n):
    if (n == 1):
        print('node 0: parent = -1, sibling = -1, degree = 0, depth = 0, height = 0, root')
    elif (i == first_node):
        if (-1 in par_kid[i]):
            print('node {}: parent = -1, sibling = -1, degree = 1, depth = 0, height = {}, root'.format(i,height[i]))
        else:
            print('node {}: parent = -1, sibling = -1, degree = 2, depth = 0, height = {}, root'.format(i,height[i]))
    elif(i in par_kid.keys()):
        par = par_dep[i][0]
        dep = par_dep[i][1]
        h = height[i]
        A = par_kid[par]
        for a in A:
            if (a != i):
                sib = a
        if (-1 in par_kid[i]):
            print('node {}: parent = {}, sibling = {}, degree = 1, depth = {}, height = {}, internal node'.format(i,par,sib,dep,h))
        else:    
            print('node {}: parent = {}, sibling = {}, degree = 2, depth = {}, height = {}, internal node'.format(i,par,sib,dep,h))
    else:
        par = par_dep[i][0]
        dep = par_dep[i][1]
        h = height[i]
        A = par_kid[par]
        for a in A:
            if (a != i):
                sib = a
        print('node {}: parent = {}, sibling = {}, degree = 0, depth = {}, height = {}, leaf'.format(i,par,sib,dep,h))
        
"
3152526,ALDS1_7_B,"NIL = -1
class Node:
  def __init__(self):
    self.parent = NIL
    self.left = NIL
    self.right = NIL
    self.type = NIL
    self.depth = NIL
    self.sibling = NIL
    self.degree = NIL
    self.height = NIL

def setHeight(u):
  h1 = h2 = 0
  if T[u].right != NIL:
    h1 = setHeight(T[u].right) + 1
  if T[u].left != NIL:
    h2 = setHeight(T[u].left) + 1
  if h1 == h2 == NIL:
    return NIL
  else:
    return max(h1, h2)

def getDepth(u):
  d = 0
  while T[u].parent != NIL:
    u = T[u].parent
    d += 1
  return d

def getSibling(u):
  if T[u].parent == NIL:
    return NIL
  if T[T[u].parent].left != u and T[T[u].parent].left != NIL:
    return T[T[u].parent].left
  if T[T[u].parent].right != u and T[T[u].parent].right != NIL:
    return T[T[u].parent].right
  return NIL

def getDegree(u):
  deg = 0
  if T[u].left != NIL:
    deg += 1
  if T[u].right != NIL:
    deg += 1
  return deg

n = int(input())
T = [0]*n
for i in range(n):
  T[i] = Node()
for i in range(n):
  id, l, r = map(int,input().split())
  T[id].left = l
  T[id].right = r

for i in range(n):
  if T[i].left != NIL:
    T[T[i].left].parent = i
  if T[i].right != NIL:
    T[T[i].right].parent = i

for i in range(n):
  if T[i].parent == NIL:
    T[i].type = 'root'
  elif T[i].parent != NIL and (T[i].left != NIL or T[i].right != NIL):
    T[i].type = 'internal node'
  else:
    T[i].type = 'leaf'

for i in range(n):
  T[i].depth = getDepth(i)
  T[i].sibling = getSibling(i)
  T[i].degree = getDegree(i)
  T[i].height = setHeight(i)

for i in range(n):
  print('node ',i,': parent = ',T[i].parent,', sibling = ',T[i].sibling,', degree = ',T[i].degree,', depth = ',T[i].depth,', height = ',T[i].height,', ',T[i].type,sep = '')

















"
3176404,ALDS1_7_B,"
class Node():
    ""node of the tree structure""
    def __init__(self, parent = -1, left = -1, right = -1):
        self.parent = parent
        self.left = left
        self.right = right

def setHeight(u):
    h1 = 0
    h2 = 0
    if node_list[u].right != -1:
        h1 = setHeight(node_list[u].right) + 1
    if node_list[u].left != -1:
        h2 = setHeight(node_list[u].left) + 1
    return max(h1,h2)

def getSibling(u):
    if node_list[u].parent == -1:
        return -1
    if node_list[node_list[u].parent].left != -1 and node_list[node_list[u].parent].left != u:
        return node_list[node_list[u].parent].left
    if node_list[node_list[u].parent].right != -1 and node_list[node_list[u].parent].right != u:
        return node_list[node_list[u].parent].right
    return -1

def getDegree(u):
    count = 0
    if node_list[u].left != -1:
        count += 1
    if node_list[u].right != -1:
        count += 1
    return count

def getDepth(u):
    count = 0
    while node_list[u].parent != -1:
        count += 1
        u = node_list[u].parent
    return count

def getType(u):
    if node_list[u].parent == -1:
        return ""root""
    if node_list[u].left == -1 and node_list[u].right == -1:
        return ""leaf""
    return ""internal node""

n = int(input())
node_list = []
for i in range(n):
    node = Node()
    node_list.append(node)

for i in range(n):
    a,b,c = map(int, input().split())
    node_list[a].left = b
    node_list[a].right = c
    if b != -1:
        node_list[b].parent = a
    if c != -1:
        node_list[c].parent = a
height_list = [-1]*n

for i in range(n):
    print(""node"", str(i)+"":"", ""parent ="", str(node_list[i].parent) + "","", ""sibling ="", str(getSibling(i)) + "","", ""degree ="", str(getDegree(i)) + "","", ""depth ="", str(getDepth(i)) + "","", ""height ="", str(setHeight(i)) + "","", getType(i))

"
3185385,ALDS1_7_B,"import sys
readline = sys.stdin.readline
writelines = sys.stdout.writelines
N = int(readline())
L = [None]*N; R = [None]*N
S = [-1]*N
P = [-1]*N
D = [-1]*N
DG = [0]*N
H = [-1]*N
for i in range(N):
    i, l, r = map(int, readline().split())
    L[i] = l; R[i] = r
    if l != -1:
        P[l] = i
        DG[i] += 1
    if r != -1:
        P[r] = i
        DG[i] += 1
    if l != -1 != r:
        S[l] = r; S[r] = l
def dfs(v, d):
    D[v] = d
    H[v] = h = max((dfs(L[v], d+1) if L[v] != -1 else 0), (dfs(R[v], d+1) if R[v] != -1 else 0))
    return h+1
dfs(P.index(-1), 0)
writelines([""node %d: parent = %d, sibling = %d, degree = %d, depth = %d, height = %d, %s\n"" % (i, P[i], S[i], DG[i], D[i], H[i], 'root' if P[i] == -1 else 'leaf' if DG[i] == 0 else 'internal node') for i in range(N)])

"
8240789,ALDS1_7_C,"class Node:
  def __init__(self, no, parent, child):
    self.no    = no
    self.parent = parent
    self.child = child

# 二分木を行きがけ順でなぞる
def preorder(trees, i):
  if i<0:
    return
  print(f"" {i}"", end="""")
  preorder(trees, trees[i].child[0]) # left
  preorder(trees, trees[i].child[1]) # right

# 二分木を通りがけ順でなぞる
def inorder(trees, i):
  if i < 0:
    return
  inorder(trees, trees[i].child[0]) # left
  print(f"" {i}"", end="""")
  inorder(trees, trees[i].child[1]) # right

# 二分木を帰りがけ順でなぞる
def postorder(trees, i):
  if i < 0:
    return
  postorder(trees, trees[i].child[0]) # left
  postorder(trees, trees[i].child[1]) # right
  print(f"" {i}"", end="""")

N = int(input())
trees = [ Node(i, -1, [-1, -1]) for i in range(N) ]
for _ in range(N):
    no, *child = list(map(int, input().split()))
    trees[no].child = child
    # mark parent
    for ch in child:
        if ch>=0:
            trees[ch].parent = no

root  = 0
for i in range(N):
  if trees[i].parent == -1:
    root = i

print(""Preorder"")
preorder(trees, root)
print()
print(""Inorder"")
inorder(trees, root)
print()
print(""Postorder"")
postorder(trees, root)
print()
"
8271635,ALDS1_7_C,"class Node:
  def __init__(self, left, right):
    self.left  = left
    self.right = right


# Input
num_nodes = int(input())
nodes = {}
for i in range(num_nodes):
  ident, left, right = map(int, input().split())
  nodes[ident] = Node(left, right)

# Find root ident
nodes_which_has_not_parents = set(nodes.keys())
for node in nodes.values():
  nodes_which_has_not_parents -= {node.left, node.right}
assert len(nodes_which_has_not_parents) == 1
root_ident = nodes_which_has_not_parents.pop()

def walk_tree(ident, fns):
  def walk(ident):
    if ident == -1:
      return
    for f in fns:
      f(walk, ident)
  walk(ident)

# Compute and print
print('Preorder')
walk_tree(root_ident, [
  lambda walk, ident: print(' ' + str(ident), end=''),
  lambda walk, ident: walk(nodes[ident].left),
  lambda walk, ident: walk(nodes[ident].right),
  ])
print()
print('Inorder')
walk_tree(root_ident, [
    lambda walk, ident: walk(nodes[ident].left),
  lambda walk, ident: print(' ' + str(ident), end=''),
  lambda walk, ident: walk(nodes[ident].right),
  ])
print()
print('Postorder')
walk_tree(root_ident, [
  lambda walk, ident: walk(nodes[ident].left),
  lambda walk, ident: walk(nodes[ident].right),
  lambda walk, ident: print(' ' + str(ident), end=''),
  ])
print()
"
8326946,ALDS1_7_C,"class Node:
  def __init__(self, chs, pa=-1):
    self.chs = chs
    self.pa = pa

n = int(input())
tree = {id:Node(chs=[-1,-1]) for id in range(-1, n)}
for _ in range(n):
  id, *chs = map(int, input().split())
  tree[id].chs = chs
  for ch in chs:
    tree[ch].pa = id

def walk(id, order):
  walked = """"
  if id != -1:
    if order == ""Pre"":
      walked += f"" {id}""
    walked += walk(tree[id].chs[0], order)
    if order == ""In"":
      walked += f"" {id}""
    walked += walk(tree[id].chs[1], order)
    if order == ""Post"":
      walked += f"" {id}""
  return walked

for id in tree:
  if tree[id].pa == -1:
    for order in [""Pre"", ""In"", ""Post""]:
      print(order + ""order\n"" + walk(id, order))      
    break

"
8369439,ALDS1_7_C,"def root(tree, tmp_rt):
    for i in range(len(tree)):
        if tmp_rt in tree[i]:
            return root(tree, i)
    return tmp_rt


def dfs_pre_order(tree, p):
    if 0 <= p:
        print("" {}"".format(p), end="""")
        for c in tree[p]:
            dfs_pre_order(tree, c)


def dfs_in_order(tree, p):
    if 0 <= p:
        l, r = tree[p]
        dfs_in_order(tree, l)
        print("" {}"".format(p), end="""")
        dfs_in_order(tree, r)        


def dfs_post_order(tree, p):
    if 0 <= p:
        for c in tree[p]:
            dfs_post_order(tree, c)
        print("" {}"".format(p), end="""")


def main():
    n = int(input())
    tree = [[] for i in range(n)]
    for i in range(n):
        i, l, r = map(int, input().split())
        tree[i] = [l, r]
    rt = root(tree, 0)
    print(""Preorder"")
    dfs_pre_order(tree, rt)
    print()
    print(""Inorder"")
    dfs_in_order(tree, rt)
    print()
    print(""Postorder"")
    dfs_post_order(tree, rt)
    print()


if __name__ == ""__main__"":
    main()

"
8425129,ALDS1_7_C,"import sys
readline = sys.stdin.readline
write= sys.stdout.write
N = int(readline())
L = [None]*N; R = [None]*N; P = [-1]*(N+1)
for i in range(N):
    i, l, r = map(int, readline().split())
    L[i] = l; R[i] = r
    P[l] = i; P[r] = i
s0 = []; s1 = []; s2 = []
def dfs(v):
    v0 = str(v)
    s0.append(v0)
    L[v] != -1 and dfs(L[v])
    s1.append(v0)
    R[v] != -1 and dfs(R[v])
    s2.append(v0)
dfs(P.index(-1))
write(""Preorder\n %s\nInorder\n %s\nPostorder\n %s\n"" % tuple(map("" "".join, [s0, s1, s2])))
"
8431702,ALDS1_7_C,"import collections
def u(x): return [x[0], x[1:]]

n = dict(u([int(i) for i in input().split()]) for _ in range(int(input())))
r = set(n.keys())
r.difference_update(sum(n.values(), []))
q = collections.deque([r.pop()])
r = []
w = [[] for _ in range(3)]

while q or r:
    i = q.popleft() if q else r.pop()
    c = n[i]
    if c:
        j = c.pop(0)
        r.append(i)
        if c:
            if j > -1: q.append(j)
            w[0].append(i)
        else:
            if j > -1: r.append(j)
            w[1].append(i)
    else: w[2].append(i)

for i in range(3):
    print(['Preorder', 'Inorder', 'Postorder'][i])
    print('', *w[i])
"
8525552,ALDS1_7_C,"class BinaryTree:
    class Node:
        def __init__(self, num, left_child, right_child):
            self.id = num
            self.left_child = left_child
            self.right_child = right_child
            
    def __init__(self, n):
        self.nodes = [None] * n
        self.root_id = int(n * (n - 1) / 2)

    def add_node(self, i_s):
        num, left_child, right_child = map(int, i_s.split())
        self.nodes[num] = BinaryTree.Node(num, left_child, right_child)
        if left_child != -1:
            self.root_id -= left_child
        if right_child != -1:
            self.root_id -= right_child

    def preorder_walk(self):
        print('Preorder')
        def _pre_walk(node_id):
            if node_id != -1:
                print(' {0}'.format(node_id), end = '')
                _pre_walk(self.nodes[node_id].left_child)
                _pre_walk(self.nodes[node_id].right_child)
        _pre_walk(self.root_id)
        print('')

    def inorder_walk(self):
        print('Inorder')
        root_node = self.nodes[self.root_id]
        def _in_walk(node_id):
            if node_id != -1:
                _in_walk(self.nodes[node_id].left_child)
                print(' {0}'.format(node_id), end = '')
                _in_walk(self.nodes[node_id].right_child)
        _in_walk(self.root_id)
        print('')

    def postorder_walk(self):
        print('Postorder')
        root_node = self.nodes[self.root_id]
        def _post_walk(node_id):
            if node_id != -1:
                _post_walk(self.nodes[node_id].left_child)
                _post_walk(self.nodes[node_id].right_child)
                print(' {0}'.format(node_id), end = '')
        _post_walk(self.root_id)
        print('')


n = int(input())

BT = BinaryTree(n)

for i in range(n):
    BT.add_node(input())

BT.preorder_walk()
BT.inorder_walk()
BT.postorder_walk()

"
8543144,ALDS1_7_C,"class Node:
    """"""
    ノードを表すクラス
    """"""
    def __init__(self) -> None:
        """"""
        ノードの初期化
        """"""
        self.parent: int = -1  # 親ノードのインデックス
        self.degree: int = 0  # 子の数
        self.sibling: int = -1 # 兄弟ノードのインデックス


def calculate_depth(node_id: int, depth: int = 0) -> None:
    """"""
    ノードの深さを計算する関数
    """"""
    Tree[node_id].depth = depth
    if Tree[node_id].left != -1:
        calculate_depth(Tree[node_id].left, depth+1)
    if Tree[node_id].right != -1:
        calculate_depth(Tree[node_id].right, depth+1)


def calculate_height(node_id: int) -> int:
    """"""
    ノードの高さを計算する関数
    """"""
    left_height = 0
    right_height = 0
    if Tree[node_id].left != -1:
        left_height = calculate_height(Tree[node_id].left) + 1
    if Tree[node_id].right != -1:
        right_height = calculate_height(Tree[node_id].right) + 1
    Tree[node_id].height: int = max(left_height, right_height)
    return Tree[node_id].height

debug_mode: bool = False  # デバッグモード
if debug_mode:
    N: int = 9
else:
    N: int = int(input())

Tree: list[Node] = [Node() for _ in range(N)]  # ツリーのリスト
tmp = [
    [0, 1, 4], 
    [1, 2, 3], 
    [2, -1, -1], 
    [3, -1, -1], 
    [4, 5, 8],
    [5, 6, 7],
    [6, -1, -1],
    [7, -1, -1],
    [8, -1, -1],

]
for i in range(N):
    if debug_mode:
        tree_info: list[int] = tmp[i]
    else:
        tree_info: list[int] = list(map(int, input().split()))
    node_id: int = tree_info[0]
    left: int = tree_info[1]
    right: int = tree_info[2]
    Tree[node_id].left = left
    Tree[node_id].right = right
    # 子から見た親をセット
    if Tree[node_id].left != -1:
        Tree[left].parent = node_id
    if Tree[node_id].right != -1:
        Tree[right].parent = node_id
    
    # ノードのタイプをセット
    if left == -1 and right == -1:
        Tree[node_id].type = ""leaf""
    elif left == -1 or right == -1:
        Tree[node_id].degree = 1
        Tree[node_id].type = ""internal node""
    else:
        Tree[right].sibling = left
        Tree[left].sibling = right
        Tree[node_id].degree = 2
        Tree[node_id].type = ""internal node""

root_id: int = [i for i, t in enumerate(Tree) if t.parent == -1][0]  # ルートノードのインデックス
Tree[root_id].type = ""root""
calculate_depth(root_id)  # ルートからの深さを計算
calculate_height(root_id)  # ルートからの高さを計算

# for i, t in enumerate(Tree):
#     print(f""node {i}: parent = {t.parent}, sibling = {t.sibling}, degree = {t.degree}, depth = {t.depth}, height = {t.height}, {t.type}"")  # 結果の出力
global ans_Pre
global ans_In
global ans_Post
ans_Pre = []
ans_In = []
ans_Post = []
def Preorder(root_id):
    global ans_Pre
    if root_id == -1: # 基底ケース:ノードが存在しない場合、処理を終了
        return
    ans_Pre.append(root_id)
    # print(root_id, end="" "")  # 数値の出力を改行無しで出力
    Preorder(Tree[root_id].left)
    Preorder(Tree[root_id].right)
print(""Preorder"")
Preorder(root_id)
print("" "", end="""")
print(*ans_Pre, sep="" "")

def Inorder(root_id, ans_list = []):
    global ans_In
    # 基底ケース
    if root_id == -1:
        return
    
    Inorder(Tree[root_id].left)
    # print(root_id, end="" "")
    ans_In.append(root_id)
    Inorder(Tree[root_id].right)
print(""Inorder"")
Inorder(root_id)
print("" "", end="""")
print(*ans_In, sep="" "")

def Postorder(root_id, ans_list = []):
    global ans_Post
    if root_id == -1:
        return
    Postorder(Tree[root_id].left)
    Postorder(Tree[root_id].right)
    ans_Post.append(root_id)

print(""Postorder"")
Postorder(root_id)
print("" "", end="""")
print(*ans_Post, sep="" "")
"
8567109,ALDS1_7_C,"class Node:
    def __init__(self) -> None:
        self.id: int = None
        self.parent: Node = None
        self.left: Node = None
        self.right: Node = None


n = int(input())
node_list = [Node() for _ in range(n)]

for _ in range(n):
    id, left, right = map(int, input().split())
    node_list[id].id = id
    if left != -1:
        node_list[id].left = node_list[left]
        node_list[left].parent = node_list[id]
    if right != -1:
        node_list[id].right = node_list[right]
        node_list[right].parent = node_list[id]

root = -1
for i in range(n):
    if node_list[i].parent is None:
        root = i
        break


def preorder(node_list: list, root: int) -> list:
    if node_list[root].left is None:
        left = []
    else:
        left = preorder(node_list, node_list[root].left.id)
    if node_list[root].right is None:
        right = []
    else:
        right = preorder(node_list, node_list[root].right.id)
    return [root] + left + right


def inorder(node_list: list, root: int) -> list:
    if node_list[root].left is None:
        left = []
    else:
        left = inorder(node_list, node_list[root].left.id)
    if node_list[root].right is None:
        right = []
    else:
        right = inorder(node_list, node_list[root].right.id)
    return left + [root] + right


def postorder(node_list: list, root: int) -> list:
    if node_list[root].left is None:
        left = []
    else:
        left = postorder(node_list, node_list[root].left.id)
    if node_list[root].right is None:
        right = []
    else:
        right = postorder(node_list, node_list[root].right.id)
    return left + right + [root]


print(""Preorder"")
print("" "" + "" "".join(map(str, preorder(node_list, root))))
print(""Inorder"")
print("" "" + "" "".join(map(str, inorder(node_list, root))))
print(""Postorder"")
print("" "" + "" "".join(map(str, postorder(node_list, root))))

"
8725535,ALDS1_7_C,"n = int(input())

tree_dict = {}
root_node = set([i for i in range(n)])
for _ in range(n):
    tmp = list(map(int, input().split(' ')))
    idx, left, right = tmp[0], tmp[1], tmp[2]
    tree_dict[idx] = { ""left"" : left, ""right"" : right }
    root_node = root_node - set([left, right])

preoder = []
root_node = list(root_node)[0]
pre_point = [root_node]
while pre_point:
    idx = pre_point.pop()
    preoder.append(idx)
    #右から先入、左から後出しすることで左分岐優先となる
    if tree_dict[idx][""right""] != -1:
        pre_point.append(tree_dict[idx][""right""])
    if tree_dict[idx][""left""] != -1:
        pre_point.append(tree_dict[idx][""left""])
print(""Preorder"")
print(' ' + ' '.join(list(map(str, preoder))))

inorder = []
def searchLeftNode(node, n):
    for _ in range(n):
        if node == root_node and tree_dict[node][""left""] == -1:
            break
        if tree_dict[node][""left""] == -1:
            break
        if tree_dict[node][""left""] != -1:
            node = tree_dict[node][""left""]
    return node

def parentCheck(idx, n, root_node):
    if idx == root_node:
        return -1      
    for i in range(n):
        if idx in tree_dict[i].values():
            return i
        
in_start_node = searchLeftNode(root_node, n)
in_point = [[in_start_node, tree_dict[in_start_node], parentCheck(in_start_node, n, root_node)]]

while in_point:
    idx, children, parent = in_point.pop()
    if parent == -1 and idx in inorder:
        break
    if parent == -1:
        inorder.append(idx)
        if children[""right""] != -1:
            a = searchLeftNode(children[""right""], n)
            in_point.append([a, tree_dict[a], parentCheck(a, n, root_node)])
            continue
        else:
            break
    
    left_node = searchLeftNode(idx, n)
    if left_node != idx and left_node not in inorder:
        in_point.append([left_node, tree_dict[left_node], parentCheck(left_node, n, root_node)])
        continue
    
    if left_node != idx and left_node in inorder:
        in_point.append([left_node, tree_dict[left_node], parentCheck(left_node, n, root_node)])
        
    if left_node != idx and tree_dict[idx][""right""] != -1  and left_node in inorder:
        next_left_node = searchLeftNode(tree_dict[idx][""right""], n)
        in_point.append([next_left_node, tree_dict[next_left_node], parentCheck(next_left_node, n, root_node)])
        
    if left_node == idx and tree_dict[idx][""right""] != -1 and tree_dict[idx][""right""] not in inorder:
        in_point.append([tree_dict[idx][""right""], tree_dict[tree_dict[idx][""right""]], idx])

    if left_node == idx and tree_dict[idx][""left""] == -1 and tree_dict[idx][""right""] == -1:
        parent = parentCheck(left_node, n , root_node)
        in_point.append([parent, tree_dict[parent], parentCheck(parent, n, root_node)])
    
    if idx in inorder:
        parent = parentCheck(idx, n , root_node)
        in_point.append([parent, tree_dict[parent], parentCheck(parent, n, root_node)])
        
    if idx not in inorder:
        inorder.append(idx)

print(""Inorder"")
print(' ' + ' '.join(list(map(str, inorder))))

def searchPostNode(node, n):
    for _ in range(n):
        if tree_dict[node][""left""] == -1 and tree_dict[node][""right""] == -1:
            break
        if tree_dict[node][""left""] != -1:
            node = tree_dict[node][""left""]  
        if tree_dict[node][""left""] == -1 and tree_dict[node][""right""] != -1:
            node = tree_dict[node][""right""]
    return node

post_start_node = searchPostNode(root_node, n)
post_point = [[post_start_node, tree_dict[post_start_node], parentCheck(post_start_node, n, root_node)]]

postorder = []
while post_point:
    idx, children, parent = post_point.pop()
    
    if parent == -1 and tree_dict[idx][""left""] != -1 and tree_dict[idx][""right""] != -1:
        post_node = searchPostNode(tree_dict[idx][""right""], n)
        post_point.append([post_node, tree_dict[post_node], parentCheck(post_node, n, root_node)])
        if post_node in postorder:
            postorder.append(idx)
            break
    elif parent == -1 and (tree_dict[idx][""left""] == -1 or tree_dict[idx][""right""] == -1):
        postorder.append(idx)
        break
    
    post_node = searchPostNode(idx, n)
    if post_node != idx and tree_dict[idx][""right""] != -1 and tree_dict[idx][""right""] not in postorder:
        next_post_node = searchPostNode(tree_dict[idx][""right""], n)
        post_point.append([next_post_node, tree_dict[next_post_node], parentCheck(next_post_node, n, root_node)])
        continue
    
    if post_node != idx and post_node in postorder:
        parent = parentCheck(idx, n, root_node)
        post_point.append([parent, tree_dict[parent], parentCheck(parent, n, root_node)])

    if post_node == idx and tree_dict[idx][""left""] == -1 and tree_dict[idx][""right""] == -1:
        parent = parentCheck(post_node, n, root_node)
        post_point.append([parent, tree_dict[parent], parentCheck(parent, n, root_node)])    
           
    if idx not in postorder:
        postorder.append(idx)

print(""Postorder"")
print(' ' + ' '.join(list(map(str, postorder))))

"
8760035,ALDS1_7_C,"# from icecream import ic

n = int(input())

treeDict = {}
for i in range(n):
    id, left, right = map(int,input().split())
    treeDict[id] = [left, right]
# ic(treeDict)

def rootis(d,n):
    idsum = 0
    for i in range(n):
        for j in treeDict[i]:
            if j != -1: idsum += j
    return (n-1)*n//2 - idsum
root = rootis(treeDict,n)

print(""Preorder"")
def pre(i):
    if i != -1:
        print(f"" {i}"",end="""")
        pre(treeDict[i][0])
        pre(treeDict[i][1])
pre(root)
print()

print(""Inorder"")
def pre(i):
    if i != -1:
        pre(treeDict[i][0])
        print(f"" {i}"",end="""")
        pre(treeDict[i][1])
pre(root)
print()

print(""Postorder"")
def pre(i):
    if i != -1:
        pre(treeDict[i][0])
        pre(treeDict[i][1])
        print(f"" {i}"",end="""")
pre(root)
print()
"
8786047,ALDS1_7_C,"class Node:
  def __init__(self, parent = -1, childlen = -1):
    self.parent = parent  # 親
    self.childlen = childlen    # 子
    
n = int(input())  # 節点の個数

# 木のノードの集合を表すtreeを作成・初期化する。
# idは節点の番号
# [左の子のid参照, 右の子のid参照] の組のリストを1つのノードとして，辞書型に追加。
# この時点では互いのノードがつながっていない状態。
# idが-1のノードは番兵。子がなければここにつながれる。
tree = {id:Node(childlen=[-1, -1]) for id in range(-1, n)}


for i in range(n):
  id, *childlen = map(int, input().split(' '))
  tree[id].childlen = childlen  # 辞書に存在するキーがidのノードのメンバchildlenを，取得したものに更新する。親->子がつながる。
  for j in childlen:
    tree[j].parent = id   # 子->親をつなげる。


def tree_walk(id, how):
  s = """"
  if id != -1:  # 番兵以外
    if how == ""Preorder"":
      s += f"" {id}"" # 先行順ではまずは（部分木の）根節点を出力
      
    s += tree_walk(tree[id].childlen[0], how)
    
    if how == ""Inorder"":
      s += f"" {id}"" # 上の再帰が終わったら根節点を出力
    
    s += tree_walk(tree[id].childlen[1], how)
    
    if how == ""Postorder"":
      s += f"" {id}"" # 上の2つの再帰が終わったら根節点を出力
    
  return s

for i in tree:
  if tree[i].parent == -1:
    print(""Preorder\n"" + tree_walk(i, ""Preorder""))

for i in tree:
  if tree[i].parent == -1:
    print(""Inorder\n"" + tree_walk(i, ""Inorder""))
    
for i in tree:
  if tree[i].parent == -1:
    print(""Postorder\n"" + tree_walk(i, ""Postorder""))  
"
8812378,ALDS1_7_C,"class node:
    def __init__(self):
        self.left = -2
        self.right = -2
        self.parent = -1
        
def preorder(id):
    if id != -1:
        print("" {}"".format(id), end="""")
        preorder(Tree[id].left)
        preorder(Tree[id].right)

def inorder(id):
    if id != -1:
        inorder(Tree[id].left)
        print("" {}"".format(id), end="""")
        inorder(Tree[id].right)
        
def postorder(id):
    if id != -1:
        postorder(Tree[id].left)
        postorder(Tree[id].right)
        print("" {}"".format(id), end="""")

    
N = int(input())
Tree = [node() for _ in range(N)]

#make_tree
for _ in range(N):
    #id, left, right
    tree_info = list(map(int, input().split()))
    node_id = tree_info[0]
    left = tree_info[1]
    right = tree_info[2]
    #自身の子をセット
    Tree[node_id].left = left
    Tree[node_id].right = right
    #子から見た親をセット
    if left != -1:
        Tree[left].parent = node_id
    if right != -1:
        Tree[right].parent = node_id

#search_root
root_id = [i for i,t in enumerate(Tree) if t.parent == -1][0]

#answer_output
print(""Preorder"")
preorder(root_id)
print()

print(""Inorder"")
inorder(root_id)
print()

print(""Postorder"")
postorder(root_id)
print()
"
8822182,ALDS1_7_C,"import sys
input = sys.stdin.readline

from collections import defaultdict

NIL = -1

n = int(input())

T = defaultdict(lambda: {'l':NIL, 'r':NIL, 'p':NIL})

for _ in range(n):
    u, l, r = map(int, input().split())
    T[u]['l'] = l
    T[u]['r'] = r
    if l != NIL:
        T[l]['p'] = u
    if r != NIL:
        T[r]['p'] = u

for u, info in T.items():
    if info['p'] == NIL:
        root = u
        break

def pre_parse(u):
    if u == NIL:
        return
    print(' ' + str(u), end = '')
    pre_parse(T[u]['l'])
    pre_parse(T[u]['r'])

def in_parse(u):
    if u == NIL:
        return
    in_parse(T[u]['l'])
    print(' ' + str(u), end = '')
    in_parse(T[u]['r'])

def post_parse(u):
    if u == NIL:
        return
    post_parse(T[u]['l'])
    post_parse(T[u]['r'])
    print(' ' + str(u), end = '')

print('Preorder')
pre_parse(root)
print('')

print('Inorder')
in_parse(root)
print('')

print('Postorder')
post_parse(root)
print('')
"
8871393,ALDS1_7_C,"class Node():
    def __init__(self):
        self.left = None
        self.right = None
        self.parent = -1
        self.depth = 0
        self.height = 0

def Depth(index,d = 0):
    Tree[index].depth = d
    if Tree[index].left != -1:
        Depth(Tree[index].left,d+1)
    if Tree[index].right != -1:
        Depth(Tree[index].right,d+1)

def Height(index):
    left_height = 0
    right_height = 0

    if Tree[index].left != -1:
        left_height = Height(Tree[index].left) + 1
    if Tree[index].right != -1:
        right_height = Height(Tree[index].right) + 1
    
    Tree[index].height = max(left_height, right_height)

    return max(left_height, right_height)

def Preorder(index):
    global cnt
    if index == -1:
        return
    cnt += 1
    if cnt != n:
        print(index,end="" "")
    else:
        print(index)
    Preorder(Tree[index].left)
    Preorder(Tree[index].right)

def Inorder(index):
    global cnt
    if index == -1:
        return
    Inorder(Tree[index].left)
    cnt += 1
    if cnt != n:
        print(index,end="" "")
    else :
        print(index)
    Inorder(Tree[index].right)

def Postorder(index):
    global cnt
    if index == -1:
        return
    Postorder(Tree[index].left)
    Postorder(Tree[index].right)
    cnt += 1
    if cnt != n:
        print(index,end="" "")
    else :
        print(index)

n = int(input())
Tree = [Node() for i in range(n)]
cnt = 0

for i in range(n):
    index,left,right= map(int,input().split())

    Tree[index].left = left
    Tree[index].right = right

    if left != -1:
        Tree[left].parent = index
    if right != -1:
        Tree[right].parent = index


root_index = [i for i,t in enumerate(Tree) if t.parent == -1][0]

Depth(root_index)
Height(root_index)

print(""Preorder"")
print(end="" "")
Preorder(root_index)
cnt = 0
print(""Inorder"")
print(end="" "")
Inorder(root_index)
print(""Postorder"")
print(end="" "")
cnt = 0
Postorder(root_index)
"
8893354,ALDS1_7_C,"n=int(input())
tree=[0]*n
pt=[-1]*n
preans=[]
inans=[]
postans=[]
for i in range(n):
    id,left,right=map(int,input().split())
    tree[id]=[left,right]
    if left!=-1:
        pt[left]=id
    if right!=-1:
        pt[right]=id
def pre(i):
    preans.append(i)
    if tree[i]==[-1,-1]:
        return
    if tree[i][0]!=-1:
        pre(tree[i][0])
    if tree[i][1]!=-1:
        pre(tree[i][1])
def inorder(i):
    if tree[i]==[-1,-1]:
        inans.append(i)
        return
    if tree[i][0]!=-1:
        inorder(tree[i][0])
    inans.append(i)
    if tree[i][1]!=-1:
        inorder(tree[i][1])
def post(i):
    if tree[i]==[-1,-1]:
        postans.append(i)
        return
    if tree[i][0]!=-1:
        post(tree[i][0])
    if tree[i][1]!=-1:
        post(tree[i][1])
    postans.append(i)
    
pre(pt.index(-1))
inorder(pt.index(-1))
post(pt.index(-1))
print('Preorder')
print(' ',end='')
print(*preans)
print('Inorder')
print(' ',end='')
print(*inans)
print('Postorder')
print(' ',end='')
print(*postans)
"
8942827,ALDS1_7_C,"from collections import deque
import copy
nodes_dict = dict() # key:node, value:parent, children, sibling, degree, depth, height, type

n = int(input())
all_children = set()
for _ in range(n):
    node, left, right = map(int, input().split())
    deg = 0
    if left != -1:
        deg += 1
    if right != -1:
        deg += 1

    if node not in nodes_dict:
        nodes_dict[node] = [None, [left, right], None, deg, None, None, None]
    else:
        nodes_dict[node][1] = [left, right]
        nodes_dict[node][3] = deg

    if left != -1:
        if left not in nodes_dict:
            nodes_dict[left] = [node, [None, None], right, 0, None, None, None]
        else:
            nodes_dict[left][0] = node
            nodes_dict[left][2] = right
    if right != -1:
        if right not in nodes_dict:
            nodes_dict[right] = [node, [None, None], left, 0, None, None, None]   
        else:
            nodes_dict[right][0] = node
            nodes_dict[right][2] = left

    all_children |= set([left, right])

root = -1
for node in nodes_dict.keys():
    if node not in all_children:
        root = node
        nodes_dict[root][0] = -1
        nodes_dict[root][2] = -1
        nodes_dict[root][6] = ""root""

pre_routes = []
def pre_search(node:int):
    if node == -1:
        return
    pre_routes.append(node)

    left, right = nodes_dict[node][1]
    pre_search(left)
    pre_search(right)
    return

nodes_dict_copy = copy.deepcopy(nodes_dict)
nodes_dict_copy2 = copy.deepcopy(nodes_dict)
int_routes = []
stack = deque()
def int_search(node:int):
    if node == -1:
        return
    
    left, right = nodes_dict_copy[node][1]
    if nodes_dict_copy[node][1] == [-1, -1]:
        int_routes.append(node)
    else:
        nodes_dict_copy[node][1] = [-1, -1]
    if right != -1:
        stack.appendleft(right)
    if right != -1 or left != -1:
        stack.appendleft(node)
    if left != -1:
        stack.appendleft(left)
    
    while len(stack) > 0:
        next_node = stack.popleft()
        int_search(next_node)
    
    return

pos_routes = []
stack = deque()
def pos_search(node:int):
    if node == -1:
        return
    
    left, right = nodes_dict_copy2[node][1]
    # print(node,left, right)
    if nodes_dict_copy2[node][1] == [-1, -1]:
        pos_routes.append(node)
    else:
        nodes_dict_copy2[node][1] = [-1, -1]
    if right != -1 or left != -1:
        stack.appendleft(node)
    if right != -1:
        stack.appendleft(right)
    if left != -1:
        stack.appendleft(left)
    
    while len(stack) > 0:
        next_node = stack.popleft()
        pos_search(next_node)
    
    return

pre_search(root)
print(""Preorder"")
print("""", *pre_routes)

int_search(root)
print(""Inorder"")
print("""", *int_routes)

pos_search(root)
print(""Postorder"")
print("""", *pos_routes)

"
9001632,ALDS1_7_C,"class Node:
    def __init__(self, u):
        self.u=u
        self.left=-1
        self.right=-1
        self.parent=-1

def preorder(nodes, u, preorder_ans):
    preorder_ans.append(u)
    if nodes[u].left!=-1:
        preorder(nodes, nodes[u].left, preorder_ans)
    if nodes[u].right!=-1:
        preorder(nodes, nodes[u].right, preorder_ans)
def inorder(nodes, u, inorder_ans):
    if nodes[u].left!=-1:
        inorder(nodes, nodes[u].left, inorder_ans)
    inorder_ans.append(u)
    if nodes[u].right!=-1:
        inorder(nodes, nodes[u].right, inorder_ans)
def postorder(nodes, u, postorder_ans):
    if nodes[u].left!=-1:
        postorder(nodes, nodes[u].left, postorder_ans)
    if nodes[u].right!=-1:
        postorder(nodes, nodes[u].right, postorder_ans)
    postorder_ans.append(u)

n=int(input())
nodes=[Node(i) for i in range(n)]
nodes=sorted(nodes, key=lambda x:x.u)
for _ in range(n):
    u, left, right=map(int, input().split())
    nodes[u].left=left
    nodes[u].right=right
    if left!=-1:
        nodes[left].parent=u
    if right!=-1:
        nodes[right].parent=u
for i in range(n):
    if nodes[i].parent==-1:
        preorder_ans=[]
        preorder(nodes, nodes[i].u, preorder_ans)
        inorder_ans=[]
        inorder(nodes, nodes[i].u, inorder_ans)
        postorder_ans=[]
        postorder(nodes, nodes[i].u, postorder_ans)
        break
print(""Preorder"")
for i in preorder_ans:
    print("" %d""%i,end = """")
print()
print(""Inorder"")
for i in inorder_ans:
    print("" %d""%i,end = """")
print()
print(""Postorder"")
for i in postorder_ans:
    print("" %d""%i,end = """")
print()
"
9072904,ALDS1_7_C,"class Node:
    def __init__(self, id: int) -> None:
        self.id: int = id
        self.parent: int = -1
        self.type: str = ""root""
        self.left :int = -1
        self.right: int = -1

class BinaryTree:
    def __init__(self, id) -> None:
        self.id = id
        self.left = self.right = None
        if nodes[id].left > -1: self.left = BinaryTree(nodes[id].left)
        if nodes[id].right > -1: self.right = BinaryTree(nodes[id].right)
    
    def order(self, mode: str):
        li = {""Preorder"": [0, 1, 2], ""Inorder"": [1, 0, 2], ""Postorder"": [1, 2, 0]}
        
        for i in li[mode]:
            if i == 0: print(f"" {self.id}"", end = """")
            elif i == 1 and nodes[self.id].left > -1: self.left.order(mode)
            elif i == 2 and nodes[self.id].right > -1: self.right.order(mode)            
 
n = int(input()) # nodeの数
nodes = [Node(i) for i in range(n)]
for _ in range(n):
    id, left, right = map(int, input().split())
    if left > -1:
        nodes[id].left = left
        nodes[left].parent = id
        nodes[left].type = ""internal node""
        
    if right > -1:
        nodes[id].right = right
        nodes[right].parent = id
        nodes[right].type = ""internal node""
        
for nd in nodes:
    if nd.type != ""root"": 
        if nd.left == -1 and nd.right == -1:
            nd.type = ""leaf""
        continue
    global tree 
    tree = BinaryTree(nd.id)
    
orders = [""Preorder"", ""Inorder"", ""Postorder""]
for o in orders:
    print(o)
    tree.order(o)
    print()
"
9111254,ALDS1_7_C,"class Node():
    def __init__(self, id):
        self.id = id
        self.parent = -1
        self.left = -1
        self.right = -1


def preParse(node: Node):
    print(f' {node.id}', end='')
    if node.left != -1:
        preParse(T[node.left])
    if node.right != -1:
        preParse(T[node.right])


def inParse(node: Node):
    if node.left != -1:
        inParse(T[node.left])
    print(f' {node.id}', end='')
    if node.right != -1:
        inParse(T[node.right])


def postParse(node: Node):
    if node.left != -1:
        postParse(T[node.left])
    if node.right != -1:
        postParse(T[node.right])
    print(f' {node.id}', end='')


n = int(input())
T: 'list[Node]' = [Node(i) for i in range(n)]
for _ in range(n):
    id, left, right = map(int, input().split())
    T[id].left = left
    T[id].right = right
    T[left].parent = id
    T[right].parent = id

ROOT = -1
for nd in T:
    if nd.parent == -1:
        ROOT = nd.id
        break

print('Preorder')
preParse(T[ROOT])
print('\nInorder')
inParse(T[ROOT])
print('\nPostorder')
postParse(T[ROOT])
print()

"
1680736,ALDS1_7_C,"class BinaryTree:
    class Node:
        def __init__(self, num, left_child, right_child):
            self.id = num
            self.left_child = left_child
            self.right_child = right_child
            
    def __init__(self, n):
        self.nodes = [None] * n
        self.root_id = int(n * (n - 1) / 2)

    def add_node(self, i_s):
        num, left_child, right_child = map(int, i_s.split())
        self.nodes[num] = BinaryTree.Node(num, left_child, right_child)
        if left_child != -1:
            self.root_id -= left_child
        if right_child != -1:
            self.root_id -= right_child

    def preorder_walk(self):
        print('Preorder')
        def _pre_walk(node_id):
            if node_id != -1:
                print(' {0}'.format(node_id), end = '')
                _pre_walk(self.nodes[node_id].left_child)
                _pre_walk(self.nodes[node_id].right_child)
        _pre_walk(self.root_id)
        print('')

    def inorder_walk(self):
        print('Inorder')
        root_node = self.nodes[self.root_id]
        def _in_walk(node_id):
            if node_id != -1:
                _in_walk(self.nodes[node_id].left_child)
                print(' {0}'.format(node_id), end = '')
                _in_walk(self.nodes[node_id].right_child)
        _in_walk(self.root_id)
        print('')

    def postorder_walk(self):
        print('Postorder')
        root_node = self.nodes[self.root_id]
        def _post_walk(node_id):
            if node_id != -1:
                _post_walk(self.nodes[node_id].left_child)
                _post_walk(self.nodes[node_id].right_child)
                print(' {0}'.format(node_id), end = '')
        _post_walk(self.root_id)
        print('')


n = int(input())

BT = BinaryTree(n)

for i in range(n):
    BT.add_node(input())

BT.preorder_walk()
BT.inorder_walk()
BT.postorder_walk()
"
1706309,ALDS1_7_C,"#coding:utf-8
#1_7_C
def preorder(i):
    if i == -1:
        return
    (l, r) = tree[i]
    print("" {}"".format(i), end = """")
    preorder(l)
    preorder(r)

def inorder(i):
    if i == -1:
        return
    (l, r) = tree[i]
    inorder(l)
    print("" {}"".format(i), end = """")
    inorder(r)

def postorder(i):
    if i == -1:
        return
    (l, r) = tree[i]
    postorder(l)
    postorder(r)
    print("" {}"".format(i), end = """")

n = int(input())
tree = [None for i in range(n)]
root = set(range(n))
for i in range(n):
    i, l, r = map(int, input().split())
    tree[i] = (l, r)
    root -= set([l, r])

root_node = root.pop()

print(""Preorder"")
preorder(root_node)
print()

print(""Inorder"")
inorder(root_node)
print()

print(""Postorder"")
postorder(root_node)
print()
"
2011517,ALDS1_7_C,"def preorder(i, A):
    if i == -1:
        return """"
    n = A[i]
    l = n[1]
    ls = preorder(l, A)
    r = n[2]
    rs = preorder(r, A)
    ans = "" {}"".format(i)
    if ls != """":
        ans += ls
    if rs != """":
        ans += rs

    return ans

def inorder(i, A):
    if i == -1:
        return """"
    n = A[i]
    l = n[1]
    ls = inorder(l, A)
    r = n[2]
    rs = inorder(r, A)
    ans = "" {}"".format(i)
    if ls != """":
        ans = ls + ans
    if rs != """":
        ans += rs

    return ans

def postorder(i, A):
    if i == -1:
        return """"
    n = A[i]
    l = n[1]
    ls = postorder(l, A)
    r = n[2]
    rs = postorder(r, A)
    ans = """"
    if ls != """":
        ans = ls
    if rs != """":
        ans += rs
    ans += "" {}"".format(i)

    return ans

n = int(input())
root = set([x for x in range(n)])

T = [None] * n
for x in range(n):
    N = list(map(int, input().split()))
    T[N[0]] = N
    root -= set(N[1:])

r = root.pop()
print(""Preorder"")
print(preorder(r, T[:]))

print(""Inorder"")
print(inorder(r, T[:]))

print(""Postorder"")
print(postorder(r, T[:]))
"
2163110,ALDS1_7_C,"
nil = -1

class Node:
    def __init__(self):
        self.parent = nil
        self.left = nil
        self.right = nil

def pre_tw(node):
    print(' ' + str(node), end = '')

    if tree[node].left != nil:
        pre_tw(tree[node].left)

    if tree[node].right != nil:
        pre_tw(tree[node].right)

def in_tw(node):
    if tree[node].left != nil:
        in_tw(tree[node].left)

    print(' ' + str(node), end = '')

    if tree[node].right != nil:
        in_tw(tree[node].right)

def post_tw(node):
    if tree[node].left != nil:
        post_tw(tree[node].left)

    if tree[node].right != nil:
        post_tw(tree[node].right)

    print(' ' + str(node), end = '')


n = int(input())

tree = [Node() for i in range(n)]

for i in range(n):
    line = [int(j) for j in input().split()]
    id_t = line[0]
    left = line[1]
    right = line[2]

    if left != nil:
        tree[id_t].left = left
        tree[left].parent = id_t
    if right != nil:
        tree[id_t].right = right
        tree[right].parent = id_t

for i in range(n):
    if tree[i].parent == nil:
        root = i
        break

print('Preorder')
pre_tw(root)
print('')

print('Inorder')
in_tw(root)
print('')

print('Postorder')
post_tw(root)
print('')
"
2223247,ALDS1_7_C,"
class Tree:
    def __init__(self,parent,left,right):
        self.parent = parent
        self.left = left
        self.right = right


def preparse(u):
    if u == -1: return
    print("" "", end="""")
    print(u, end="""")
    preparse(trees[u].left)
    preparse(trees[u].right)


def inparse(u):
    if u == -1: return
    #???????????????????§????
    inparse(trees[u].left)
    #??¨???
    print("" "", end="""")
    print(u, end="""")
    #??????????§????
    inparse(trees[u].right)
    

def postparse(u):
    if u == -1: return
    #???????????????????§????
    postparse(trees[u].left)
    #??????????§????
    postparse(trees[u].right)
    #??¨???
    print("" "", end="""")
    print(u, end="""")


N = int(input())
# ?????????
trees = [Tree(-1,-1,-1) for i in range(N)]
for i in range(N):
    l = list(map(int, input().split()))
    no = l[0]
    left = l[1]
    right = l[2]
    trees[no].left = left
    trees[no].right = right
    if left != -1: trees[left].parent = no
    if right != -1: trees[right].parent = no

r = 0
for i in range(N):
    if trees[i].parent == -1:
        r = i

print(""Preorder"")
preparse(r)
print("""")
print(""Inorder"")
inparse(r)
print("""")
print(""Postorder"")
postparse(r)
print("""")
"
2233461,ALDS1_7_C,"import sys

def walk(T, nid, order):
  if nid < 0: return
  pid, lid, rid = T[nid]

  if order == ""pre"":
    sys.stdout.write("" "" + str(nid))
    walk(T, lid, order)
    walk(T, rid, order)
  elif order == ""in"":
    walk(T, lid, order)
    sys.stdout.write("" "" + str(nid))
    walk(T, rid, order)
  else:
    walk(T, lid, order)
    walk(T, rid, order)
    sys.stdout.write("" "" + str(nid))

T = {}
for i in range(int(input())):
  nid, lid, rid = map(int, input().split())
  T[nid] = [-1, lid, rid]

# set parent
for nid in T:
  pid, lid, rid = T[nid]
  if lid >= 0: T[lid][0] = nid
  if rid >= 0: T[rid][0] = nid

# select root
for nid in T:
  if T[nid][0] == -1: root_id = nid

print(""Preorder""),  walk(T, root_id, ""pre""),  print()
print(""Inorder""),   walk(T, root_id, ""in""),   print()
print(""Postorder""), walk(T, root_id, ""post""), print()
"
2246353,ALDS1_7_C,"class Tree:
    def __init__(self, n):
        self.n = n
        self.nodes = [Node(i) for i in range(n)]
        self.root = -1

    def set_tree(self):
        for _ in range(self.n):
            i_str = [int(i) for i in input().split()]
            for i in range(2):
                if i_str[i+1] != -1:
                    if i == 0:
                        self.nodes[i_str[0]].left = i_str[1]
                    else:
                        self.nodes[i_str[0]].right = i_str[2]
                    self.nodes[i_str[i+1]].parent = i_str[0]

    def set_root(self):
        for tn in self.nodes:
            if tn.parent == -1:
                self.root = tn.id
                return tn.id

    def preorder(self, node):
        print(' ' + str(self.nodes[node].id), end='')
        if self.nodes[node].left != -1:
            self.preorder(self.nodes[node].left)
        if self.nodes[node].right != -1:
            self.preorder(self.nodes[node].right)

    def inorder(self, node):
        if self.nodes[node].left != -1:
            self.inorder(self.nodes[node].left)
        print(' ' + str(self.nodes[node].id), end='')
        if self.nodes[node].right != -1:
            self.inorder(self.nodes[node].right)

    def postorder(self, node):
        if self.nodes[node].left != -1:
            self.postorder(self.nodes[node].left)
        if self.nodes[node].right != -1:
            self.postorder(self.nodes[node].right)
        print(' ' + str(self.nodes[node].id), end='')

class Node:
    def __init__(self, id):
        self.id = id
        self.parent = -1
        self.left = -1
        self.right = -1

if __name__ == '__main__':
    tree = Tree(int(input()))
    tree.set_tree()
    root = tree.set_root()
    print(""Preorder"")
    tree.preorder(root)
    print()
    print('Inorder')
    tree.inorder(root)
    print()
    print('Postorder')
    tree.postorder(root)
    print()
"
2349103,ALDS1_7_C,"class Node:
    def __init__(self, num, left,  right):
        self.id = num
        self.left = left
        self.right = right
        self.parent = -1
        self.brother = -1
        if self.left== -1 and self.right==-1:
        	self.child = 0
        elif self.left != -1 and self.right!=-1:
        	self.child = 2
        else:
        	self.child = 1
        self.depth = 0
        self.height = 0
        self.type = None

    def show_info(self):
        print('node {0}: parent = {1}, sibling = {2}, degree = {3}, depth = {4}, height = {5}, {6}'.format(self.id, self.parent, self.brother, self.child, self.depth, self.height, self.type))

def SetNode(I_Line):
	L = list(map(int, I_Line.split()))
	num = L[0]
	left = L[1]
	right = L[2]
	node = Node(num, left, right)
	T[num] = node
	if left != -1:
		T[-1] -= left
	if right != -1:
		T[-1] -= right

def setPBD(i,p,b,d): #??????????????????
    node = T[i]
    node.parent = p
    node.brother = b
    node.depth = d
    if node.parent == -1:
        node.type = ""root""
    elif node.child == 0:
        node.type = ""leaf""
    else:
        node.type = ""internal node""
    if node.left != -1:
        setPBD(node.left, i, node.right, node.depth + 1)
    if node.right != -1:
        setPBD(node.right, i, node.left, node.depth + 1)

def setH(i): #??????????????????
    node = T[i]
    if node.left == -1:
        leftheight = 0
    else:
        leftheight = setH(node.left) + 1
    if node.right == -1:
        rightheight = 0
    else:
        rightheight = setH(node.right) + 1
    node.height = max(leftheight, rightheight)
    return node.height

n = int(input())
T = [None] * n
T.append(int(n * (n-1)/2))
for i in range(n):
    x = input()
    SetNode(x)

root = T[-1]
setPBD(root, -1, -1, 0)
setH(root)
T.pop()

pre = []
def preoder(x): #??????????????????
	if x == -1: return
	else:
            node = T[x]
            pre.append(str(x))
            preoder(node.left)
            preoder(node.right)
print(""Preorder"")
preoder(root)
print("" "" + "" "".join(pre))

ino = []
def inoder(x):
	if x == -1: return
	else:
            node = T[x]
            inoder(node.left)
            ino.append(str(x))
            inoder(node.right)
print(""Inorder"")
inoder(root)
print("" "" + "" "".join(ino))

pos = []
def postoder(x):
	if x == -1: return
	else:
            node = T[x]
            postoder(node.left)
            postoder(node.right)
            pos.append(str(x))
print(""Postorder"")
postoder(root)
print("" "" + "" "".join(pos))
"
2406644,ALDS1_7_C,"# coding=utf-8

class Node:
    def __init__(self, ID, left, right):
        ### output information ###
        self.id = ID
        self.parent = -1 #initialize
        self.sibling = -1 #initialize
        self.degree = -1 #initialize
        self.depth = -1 #initialize
        self.height = -1 #initialize
        self.type = None #initialize

        ### other information ###
        self.left = left
        self.right = right

def calc_depth(i):
    global node_list

    if node_list[i].depth != -1:
        return node_list[i].depth

    depth = 0
    if node_list[i].parent != -1:
        depth = calc_depth(node_list[i].parent) + 1

    node_list[i].depth = depth
    return depth


def calc_height(i):
    global node_list

    if node_list[i].height != -1:
        return node_list[i].height

    h1 = h2 = 0
    if node_list[i].right != -1:
        h1 = calc_height(node_list[i].right) + 1
    if node_list[i].left != -1:
        h2 = calc_height(node_list[i].left) + 1

    height = max(h1, h2)
    node_list[i].height = height
    return height

def pre_order(node):
    global node_list
    global pre_ordered_node_list

    if node == -1:
        return None
    pre_ordered_node_list.append(node)
    pre_order(node_list[node].left)
    pre_order(node_list[node].right)

def in_order(node):
    global node_list
    global in_ordered_node_list

    if node == -1:
        return None
    in_order(node_list[node].left)
    in_ordered_node_list.append(node)
    in_order(node_list[node].right)

def post_order(node):
    global node_list
    global post_ordered_node_list

    if node == -1:
        return None
    post_order(node_list[node].left)
    post_order(node_list[node].right)
    post_ordered_node_list.append(node)

n = int(input())
data = [tuple(map(int, input().split())) for x in range(n)]
node_list = []
root_node = None
pre_ordered_node_list = []
in_ordered_node_list = []
post_ordered_node_list = []

for data_row in data:
    ID, left, right = data_row
    node = Node(ID, left, right)
    node_list.append(node)

node_list.sort(key = lambda node: node.id)

for i, node in enumerate(node_list):
    left = node.left
    right = node.right
    degree = 0

    ### child information ###
    if left != -1:
        degree += 1
        node_list[left].parent = i
        node_list[left].sibling = right

    if right != -1:
        degree += 1
        node_list[right].parent = i
        node_list[right].sibling = left

    ### self information ###
    node.degree = degree

for i in range(n):
    calc_depth(i)
    calc_height(i)

    node = node_list[i]

    if node.depth == 0:
        node.type = 'root'
        root_node = node.id
    elif node.height == 0:
        node.type = 'leaf'
    else:
        node.type = 'internal node'

    #print(""node {}: parent = {}, sibling = {}, degree = {}, depth = {}, height = {}, {}"".format(node.id, node.parent, node.sibling, node.degree, node.depth, node.height, node.type))

### Tree Walk ###
pre_order(root_node)
in_order(root_node)
post_order(root_node)

print(""Preorder"")
print("""", *pre_ordered_node_list)
print(""Inorder"")
print("""", *in_ordered_node_list)
print(""Postorder"")
print("""", *post_ordered_node_list)
"
2474365,ALDS1_7_C,"n = int(input())
tree = [0] * n
root = set(range(n))
for i in range(n):
    node_id, left, right = map(int, input().split())
    tree[node_id] = (left, right)
    root -= {left, right}
root_node = root.pop()


def preorder(i):
    if i == -1:
        return
    (left, right) = tree[i]
    yield i
    yield from preorder(left)
    yield from preorder(right)


def inorder(i):
    if i == -1:
        return
    (left, right) = tree[i]
    yield from inorder(left)
    yield i
    yield from inorder(right)


def postorder(i):
    if i == -1:
        return
    (left, right) = tree[i]
    yield from postorder(left)
    yield from postorder(right)
    yield i

print(""Preorder\n "", end="""")
print(*preorder(root_node))
print(""Inorder\n "", end="""")
print(*inorder(root_node))
print(""Postorder\n "", end="""")
print(*postorder(root_node))
"
2490705,ALDS1_7_C,"N = int(input())
tree = [None for _ in range(N)]
root = set(range(N))

for i in range(N):
    i, l, r = map(int,input().split())
    tree[i] = (l, r)
    root -= {l, r}

root_node = root.pop()

def preorder(i):
    if i == -1:
        return
    (l, r) = tree[i]
    print("" {}"".format(i), end = """")
    preorder(l)
    preorder(r)
    
def inorder(i):
    if i == -1:
        return
    (l, r) = tree[i]
    inorder(l)
    print("" {}"".format(i), end = """")
    inorder(r)
    
def postorder(i):
    if i == -1:
        return
    (l, r) = tree[i]
    postorder(l)
    postorder(r)
    print("" {}"".format(i), end = """")
    
print('Preorder')
preorder(root_node)
print()

print('Inorder')
inorder(root_node)
print()

print('Postorder')
postorder(root_node)
print()
"
2498803,ALDS1_7_C,"class Node:
    def __init__(self, node_id, left_child, right_child):
        self.node_id = node_id
        self.parent = -1
        self.sibling = -1
        self.degree = 0
        self.depth = 0
        self.height = 0
        self.node_type = ''

        self.left_child = left_child
        self.right_child = right_child
        

def binarytrees():
    def input_node_list():
        n = int(input())

        for i in range(n):
            node_id, left_child, right_child = list(map(int, input().split()))

            node = Node(node_id, left_child, right_child)
            node_list.append(node)

        node_list.sort(key = lambda node: node.node_id)

    def calc_parent_sibling_degree():
        if node.left_child != -1:
            node_list[node.left_child].parent = node.node_id
            node_list[node.left_child].sibling = node.right_child
            node.degree += 1

        if node.right_child != -1:
            node_list[node.right_child].parent = node.node_id
            node_list[node.right_child].sibling = node.left_child
            node.degree += 1

    def calc_depth(node_id):
        if  node_list[node_id].parent == -1:
            return 0
        else:
            return calc_depth(node_list[node_id].parent) + 1

    def calc_height(node_id):
        if node_list[node_id].degree == 0:
            return 0
        else:
            left_height = right_height = 0

            if node_list[node_id].left_child != -1:
                left_height = calc_height(node_list[node_id].left_child)
            if node_list[node_id].right_child != -1:
                right_height = calc_height(node_list[node_id].right_child)

            return max(left_height, right_height) + 1

    def calc_node_type():
        if node.depth == 0:
            node.node_type = 'root'
        elif node.height == 0:
            node.node_type = 'leaf'
        else:
            node.node_type = 'internal node'

    def show_node_info():
        print('node {}: parent = {}, sibling = {}, degree = {}, depth = {}, height = {}, {}'
            .format(node.node_id, node.parent, node.sibling,
            node.degree, node.depth, node.height, node.node_type))

    node_list = []
    input_node_list()

    for node in node_list:
        calc_parent_sibling_degree()

    # for node in node_list:
    #     node.depth = calc_depth(node.node_id)
    #     node.height = calc_height(node.node_id)

    #     calc_node_type()

    #     show_node_info()

    return node_list

def treewalk():
    def show_preorder(node_id):
        current_node = node_list[node_id]

        print(' {}'.format(current_node.node_id), end='')

        if current_node.left_child != -1:
            show_preorder(current_node.left_child)
        if current_node.right_child != -1:
            show_preorder(current_node.right_child)

    def show_inorder(node_id):
        current_node = node_list[node_id]

        if current_node.left_child != -1:
            show_inorder(current_node.left_child)

        print(' {}'.format(current_node.node_id), end='')

        if current_node.right_child != -1:
            show_inorder(current_node.right_child)

    def show_postorder(node_id):
        current_node = node_list[node_id]

        if current_node.left_child != -1:
            show_postorder(current_node.left_child)
        if current_node.right_child != -1:
            show_postorder(current_node.right_child)

        print(' {}'.format(current_node.node_id), end='')

    node_list = binarytrees()

    root_id = 0
    for node in node_list:
        if node.parent == -1:
            root_id = node.node_id
    
    print('Preorder')
    show_preorder(root_id)
    print('')

    print('Inorder')
    show_inorder(root_id)
    print('')

    print('Postorder')
    show_postorder(root_id)
    print('')

if __name__ == '__main__':
    treewalk()
"
2589261,ALDS1_7_C,"class Node():
    def __init__(self, node_id, left, right):
        self.node_id    =   node_id
        self.left       =   left
        self.right      =   right

    def pre_order_search(self):
        l = self.left
        r = self.right
        print("""",self.node_id, end="""")
        if l != -1:
            tree[l].pre_order_search()
        if r != -1:
            tree[r].pre_order_search()

    def in_order_search(self):
        l = self.left
        r = self.right
        if l != -1:
            tree[l].in_order_search()
        print("""",self.node_id, end="""")
        if r != -1:
            tree[r].in_order_search()

    def post_order_search(self):
        l = self.left
        r = self.right
        if l != -1:
            tree[l].post_order_search()
        if r != -1:
            tree[r].post_order_search()
        print("""",self.node_id, end="""")

n = int(input())
tree = [None for i in range(n)]
root_set = set(range(n))

for i in range(n):
    node_id, left, right = map(int, input().split())
    tree[node_id] = Node(node_id, left, right)
    root_set -= set([left, right])
root = root_set.pop()

print(""Preorder"")
tree[root].pre_order_search()
print("""")

print(""Inorder"")
tree[root].in_order_search()
print("""")

print(""Postorder"")
tree[root].post_order_search()
print("""")
"
2616036,ALDS1_7_C,"N = int(input())
left  =  [-1 for i in range(N)]
right =  [-1 for i in range(N)]
root = sum(range(N)) - N - 1
 
for i in range(N):
    i, l, r = map(int, input().split())
    left[i] = l
    right[i] = r
    root -= (l + r)
 
def preorder(i):
    if i == -1:
        return
    print(' ', i, sep = '', end = '')
    preorder(left[i])
    preorder(right[i])
     
def inorder(i):
    if i == -1:
        return
    inorder(left[i])
    print(' ', i, sep = '', end = '')
    inorder(right[i])
     
def postorder(i):
    if i == -1:
        return
    postorder(left[i])
    postorder(right[i])
    print(' ', i, sep = '', end = '')
     
print('Preorder')
preorder(root)
print()
 
print('Inorder')
inorder(root)
print()
 
print('Postorder')
postorder(root)
print()
"
2616186,ALDS1_7_C,"n = int(input())
left = [None for i in range(n)]
right = [None for i in range(n)]
root = sum(range(n)) - n - 1

for i in range(n):
    i, l, r = map(int, input().split())
    left[i] = l
    right[i] = r
    root -= (l + r)

def Preorder(i):
    if (i == -1):
        return
    print("" {}"".format(i), end = """")
    Preorder(left[i])
    Preorder(right[i])
      
def Inorder(i):
    if (i == -1):
        return
    Inorder(left[i])
    print("" {}"".format(i), end = """")
    Inorder(right[i])
      
def Postorder(i):
    if (i == -1):
        return
    Postorder(left[i])
    Postorder(right[i])
    print("" {}"".format(i), end = """")

print(""Preorder"")
Preorder(root)
print()
  
print(""Inorder"")
Inorder(root)
print()
  
print(""Postorder"")
Postorder(root)
print()
"
2633593,ALDS1_7_C,"# -*- coding:utf-8 -*-
import sys


def tree_walk(tree, root):
    preorder_walk(tree, root)
    inorder_walk(tree, root)
    postoder_walk(tree, root)


def preorder_walk(tree, root):
    print(""Preorder"")
    result = []

    def preorder_walk_rec(node):
        if node == -1:
            pass
        else:
            result.append(str(node))
            preorder_walk_rec(tree[node][1])
            preorder_walk_rec(tree[node][2])

    preorder_walk_rec(root)
    print("" "" + "" "".join(result))


def inorder_walk(tree, root):
    print(""Inorder"")
    result = []

    def inorder_walk_rec(node):
        if node == -1:
            pass
        else:
            inorder_walk_rec(tree[node][1])
            result.append(str(node))
            inorder_walk_rec(tree[node][2])

    inorder_walk_rec(root)
    print("" "" + "" "".join(result))


def postoder_walk(tree, root):
    print(""Postorder"")
    result = []

    def postoder_work_rec(node):
        if node == -1:
            pass
        else:
            postoder_work_rec(tree[node][1])
            postoder_work_rec(tree[node][2])
            result.append(str(node))

    postoder_work_rec(root)
    print("" "" + "" "".join(result))


def get_tree():
    n = int(input())
    tree = [[-1, -1, -1] for x in range(0, n)]
    for node in sys.stdin.readlines():
        _id, left, right = [int(x) for x in node.split()]
        if left >= 0:
            tree[left][0] = _id
            tree[_id][1] = left
        if right >= 0:
            tree[right][0] = _id
            tree[_id][2] = right
    return tree


def get_root(tree):
    for i, node in enumerate(tree):
        if node[0] == -1:
            return i
    raise ValueError


if __name__ == ""__main__"":
    tree = get_tree()
    tree_walk(tree, get_root(tree))
"
2692854,ALDS1_7_C,"# -*- coding: utf-8 -*-

import sys
sys.setrecursionlimit(100000)

class Node():
    def __init__(self, ID=None, parent=-1, left=-1, right=-1):
        self.id = ID
        self.parent = parent
        self.left = left
        self.right = right

def preParse(u):
    if u == -1:
        return
    print("" "" + str(u), end="""")
    preParse(T[u].left)
    preParse(T[u].right)
    
def inParse(u):
    if u == -1:
        return
    inParse(T[u].left)
    print("" "" + str(u), end="""")
    inParse(T[u].right)
    
def postParse(u):
    if u == -1:
        return
    postParse(T[u].left)
    postParse(T[u].right)
    print("" "" + str(u), end="""")
    
    
if __name__ == '__main__':

    n = int(input())
    T = [Node() for i in range(n)]

    for _ in range(n):
        ID, left, right = list(map(int, input().split("" "")))
        T[ID].id = ID
        T[ID].left = left
        T[ID].right = right
        if left != -1:
            T[left].parent = ID
        if right != -1:
            T[right].parent = ID
    
    for node in T:
        if node.parent==-1:
            r = node.id
    
    print(""Preorder"")
    preParse(r)
    print()
        
    print(""Inorder"")
    inParse(r)
    print()
    
    print(""Postorder"")
    postParse(r)
    print()
    
"
2699059,ALDS1_7_C,"class Tree:
    __slots__ = ['id', 'p', 'left', 'right', ""type""]
    def __init__(self, id):
        self.id = id
        self.p = -1
        self.left = -1
        self.right = -1
        self.type = ""leaf""
    def __str__(self):
        return f""node {self.id}: parent = {self.p}, left = {self.left}, right = {self.right}, type = {self.type}""
n = int(input())
tree = tuple(Tree(i) for i in range(n))
for _ in range(n):
    id, l, r = map(int, input().split())
    if l != -1:
        tree[id].left = l
        tree[l].p = id
    if r != -1:
        tree[id].right = r
        tree[r].p = id
root = 0
while tree[root].p != -1:
    root = tree[root].p
def preorder_tree_walk(id):
    print(f"" {tree[id].id}"", end="""")
    if tree[id].left != -1:
        preorder_tree_walk(tree[id].left)
    if tree[id].right != -1:
        preorder_tree_walk(tree[id].right)
def inorder_tree_walk(id):
    if tree[id].left != -1:
        inorder_tree_walk(tree[id].left)
    print(f"" {tree[id].id}"", end="""")
    if tree[id].right != -1:
        inorder_tree_walk(tree[id].right)
def postorder_tree_walk(id):
    if tree[id].left != -1:
        postorder_tree_walk(tree[id].left)
    if tree[id].right != -1:
        postorder_tree_walk(tree[id].right)
    print(f"" {tree[id].id}"", end="""")
print(""Preorder"")
preorder_tree_walk(root)
print(""\nInorder"")
inorder_tree_walk(root)
print(""\nPostorder"")
postorder_tree_walk(root)
print()

"
2716917,ALDS1_7_C,"def s(x):print('',x,end='')
def p(u):
 if u+1:s(u);p(T[u]);p(T[u+N])
def i(u):
 if u+1:i(T[u]);s(u);i(T[u+N])
def o(u):
 if u+1:o(T[u]);o(T[u+N]);s(u)
N=int(input())
T=[0,0]*N
for _ in[0]*N:
 a,b,c=map(int,input().split())
 T[a],T[a+N]=b,c
r=(set(range(N))-set(T)).pop()
print('Preorder');p(r)
print('\nInorder');i(r)
print('\nPostorder');o(r)
print()
"
2818814,ALDS1_7_C,"class BinaryTree:
    class Node:
        def __init__(self, nid, left, right):
            self.id = nid
            self.left = left
            self.right = right

        def has_left(self):
            return self.left is not None

        def has_right(self):
            return self.right is not None

        def __str__(self):
            return str(self.id)

    @classmethod
    def create(cls, ids):
        nodes = [None] * len(ids)

        def _create(nid):
            if nid in nodes:
                return nodes[nid]
            if nid == -1:
                return None

            lid, rid = ids[nid]
            if lid == -1 and rid == -1:
                right = None
                left = None
            elif lid == -1:
                right = _create(rid)
                left = None
            elif lid == -1:
                right = None
                left = _create(lid)
            else:
                right = _create(rid)
                left = _create(lid)
            nodes[nid] = cls.Node(nid, left, right)
            return nodes[nid]

        def _root(nodeids):
            for nid in range(len(nodeids)):
                if all([lid != nid and rid != nid for lid, rid in nodeids]):
                    return nid

        root = _create(_root(ids))
        return cls(root)

    def __init__(self, root):
        self.root = root

    def preorder(self):
        def _preorder(node):
            yield node
            if node.has_left():
                yield from _preorder(node.left)
            if node.has_right():
                yield from _preorder(node.right)
        yield from _preorder(self.root)

    def inorder(self):
        def _inorder(node):
            if node.has_left():
                yield from _inorder(node.left)
            yield node
            if node.has_right():
                yield from _inorder(node.right)
        yield from _inorder(self.root)

    def postorder(self):
        def _postorder(node):
            if node.has_left():
                yield from _postorder(node.left)
            if node.has_right():
                yield from _postorder(node.right)
            yield node
        yield from _postorder(self.root)


def run():
    n = int(input())

    nodeids = [None] * n
    for i in range(n):
        nid, lid, rid = [int(x) for x in input().split()]
        nodeids[nid] = [lid, rid]

    tree = BinaryTree.create(nodeids)

    print('Preorder')
    for node in tree.preorder():
        print("" {}"".format(node), end="""")
    print()
    print('Inorder')
    for node in tree.inorder():
        print("" {}"".format(node), end="""")
    print()
    print('Postorder')
    for node in tree.postorder():
        print("" {}"".format(node), end="""")
    print()


if __name__ == '__main__':
    run()

"
2833929,ALDS1_7_C,"class Node():
    def __init__(self, parent = -1, left = -1, right = -1):
        self.parent = parent
        self.left = left
        self.right = right

def preorder(ns, i):
    print("" "" + str(i), end ="""")
    if ns[i].left != -1:
        preorder(ns, ns[i].left)
    if ns[i].right != -1:
        preorder(ns, ns[i].right)

def inorder(ns, i):
    if ns[i].left != -1:
        inorder(ns, ns[i].left)
    print("" "" + str(i), end ="""")
    if ns[i].right != -1:
        inorder(ns, ns[i].right)

def postorder(ns, i):
    if ns[i].left != -1:
        postorder(ns, ns[i].left)
    if ns[i].right != -1:
        postorder(ns, ns[i].right)
    print("" "" + str(i), end ="""")
    
    
n = int(input())
ns = [Node() for i in range(n)]
for i in range(n):
    p, l, r = map(int, input().split())
    if l != -1:
        ns[p].left = l
        ns[l].parent = p
    if r != -1:
        ns[p].right = r
        ns[r].parent = p

for i in range(n):
    if ns[i].parent == -1:
        print(""Preorder"")
        preorder(ns, i)
        print()
        print(""Inorder"")
        inorder(ns, i)
        print()
        print(""Postorder"")
        postorder(ns, i)
        print()
"
2876755,ALDS1_7_C,"# -*- coding: utf-8 -*-
""""""
Created on Sat May 19 19:34:44 2018
ALDS1_7_B
@author: maezawa
""""""

n = int(input())

parent = [-1 for _ in range(n)]
left = [-1 for _ in range(n)]
right = [-1 for _ in range(n)]
height = [None for _ in range(n)]
depth = [None for _ in range(n)]

def set_parent():
    global parent
    for i in range(n):
        if left[i] != -1:
            parent[left[i]] = i
        if right[i] != -1:
            parent[right[i]] = i

    
def set_depth(i, p):
    global depth
    if depth[i] != None:
        return
    depth[i] = p
    if right[i] != None:
        set_depth(right[i], p)
    if left[i] != None:
        set_depth(left[i], p+1)
       
def get_depth(i):
    global depth
    if depth[i] != None:
        return depth[i]
    d = 0
    u = i
    while parent[u] != -1:
        u = parent[u]
        d += 1
    depth[i] = d
    return d

def set_height(u):
    global height
    h1 = 0
    h2 = 0
    if right[u] != -1:
        h1 = set_height(right[u])+1
    if left[u] != -1:
        h2 = set_height(left[u])+1
    height[u] = max(h1, h2)
    return height[u]    

def get_sib(i):
    if right[parent[i]] == i:
        return left[parent[i]]
    else:
        return right[parent[i]]
    
def get_deg(i):
    deg = 0
    if right[i] != -1:
        deg += 1
    if left[i] != -1:
        deg += 1
    return deg    

def get_height(i):
    return height[i]

def preparse(i):
    if i == -1:
        return
    print(' {}'.format(i), end='')
    preparse(left[i])
    preparse(right[i])
    
def inparse(i):
    if i == -1:
        return
    inparse(left[i])
    print(' {}'.format(i), end='')
    inparse(right[i])
 
def postparse(i):
    if i == -1:
        return
    postparse(left[i])
    postparse(right[i])
    print(' {}'.format(i), end='')

for i in range(n):
    line = list(map(int, input().split()))
    left[line[0]] = line[1]
    right[line[0]] = line[2]

set_parent()
root = parent.index(-1)
print('Preorder')
preparse(root)
print()
print('Inorder')
inparse(root)
print()
print('Postorder')
postparse(root)
print()        

"
2898696,ALDS1_7_C,"class Node:
    def __init__(self, parent=-1, left=-1, right=-1):
        self.parent = parent
        self.left = left
        self.right = right


n = int(input())
binary_tree = [Node() for i in range(n)]
pre_lst, in_lst, post_lst = [], [], []


def pre_order(u):
    if u == -1:
        return

    pre_lst.append(u)
    pre_order(binary_tree[u].left)
    pre_order(binary_tree[u].right)


def in_order(u):
    if u == -1:
        return

    in_order(binary_tree[u].left)
    in_lst.append(u)
    in_order(binary_tree[u].right)


def post_order(u):
    if u == -1:
        return

    post_order(binary_tree[u].left)
    post_order(binary_tree[u].right)
    post_lst.append(u)


def main():
    for i in range(n):
        idx, left, right = map(int, input().split())
        binary_tree[idx].left = left
        binary_tree[idx].right = right
        if left != -1:
            binary_tree[left].parent = idx
        if right != -1:
            binary_tree[right].parent = idx

    root_idx = 0
    for i in range(n):
        if binary_tree[i].parent == -1:
            root_idx = i
            break

    pre_order(root_idx)
    in_order(root_idx)
    post_order(root_idx)

    print(""Preorder"")
    print("""", "" "".join([str(i) for i in pre_lst]))
    print(""Inorder"")
    print("""", "" "".join([str(i) for i in in_lst]))
    print(""Postorder"")
    print("""", "" "".join([str(i) for i in post_lst]))


if __name__ == '__main__':
    main()

"
2902081,ALDS1_7_C,"n = int(input())
root = set(range(n))
nodes = [0 for i in range(n)]
for i in range(n):
    node = list(map(int, input().split()))
    children = node[1:3]
    root -= set(children)
    nodes[node[0]] = children

def preorder(id):
    if(id == -1):
        return
    order.append(id)
    preorder(nodes[id][0])
    preorder(nodes[id][1])

def inorder(id):
    if(id == -1):
        return
    inorder(nodes[id][0])
    order.append(id)
    inorder(nodes[id][1])

def postorder(id):
    if(id == -1):
        return
    postorder(nodes[id][0])
    postorder(nodes[id][1])
    order.append(id)

order = []
preorder(list(root)[0])
print('Preorder')
print(' ', end='')
print(*order)
order = []
inorder(list(root)[0])
print('Inorder')
print(' ', end='')
print(*order)
order = []
postorder(list(root)[0])
print('Postorder')
print(' ', end='')
print(*order)

"
2904008,ALDS1_7_C,"class Tree:
    def __init__(self, ary):
        self.nodes = [
            Node(node, self) for node in sorted(ary, key=lambda x: x[0])
        ]
        [node.set() for node in self.nodes]
        for node in self.nodes:
            if node.parent == -1:
                self.root = node
                break
        self.root.set_depth(0)
        self.root.set_height()

    def output(self):
        [node.output() for node in self.nodes]

    def preorder(self):
        print('Preorder')
        self.root.preorder()
        print()

    def inorder(self):
        print('Inorder')
        self.root.inorder()
        print()

    def postorder(self):
        print('Postorder')
        self.root.postorder()
        print()


class Node:
    def __init__(self, node, tree):
        self.tree = tree
        self.no = node[0]
        self.left = node[1]
        self.right = node[2]
        self.parent = -1
        self.sibling = -1
        self.degree = 0

    def set(self):
        if self.left > -1:
            self.tree.nodes[self.left].parent = self.no
            if self.right > -1:
                self.tree.nodes[self.right].sibling = self.left
            self.degree += 1

        if self.right > -1:
            self.tree.nodes[self.right].parent = self.no
            if self.left > -1:
                self.tree.nodes[self.left].sibling = self.right
            self.degree += 1

    def set_depth(self, d):
        self.depth = d
        if self.left > -1:
            self.tree.nodes[self.left].set_depth(d + 1)
        if self.right > -1:
            self.tree.nodes[self.right].set_depth(d + 1)

    def set_height(self):
        if self.degree == 0:
            self.height = 0
        else:
            self.tree.nodes[self.right].set_height()
            self.tree.nodes[self.left].set_height()
            self.height = 1 + max(self.tree.nodes[self.right].height,
                                  self.tree.nodes[self.left].height)

    def output(self):
        if self.parent == -1:
            kind = 'root'
        elif self.degree == 0:
            kind = 'leaf'
        else:
            kind = 'internal node'
        print(
            'node {}: parent = {}, sibling = {}, degree = {}, depth = {}, height = {}, {}'.
            format(self.no, self.parent, self.sibling, self.degree, self.depth,
                   self.height, kind))

    def preorder(self):
        print(' {}'.format(self.no), end='')
        if self.left > -1:
            self.tree.nodes[self.left].preorder()
        if self.right > -1:
            self.tree.nodes[self.right].preorder()

    def inorder(self):
        if self.left > -1:
            self.tree.nodes[self.left].inorder()
        print(' {}'.format(self.no), end='')
        if self.right > -1:
            self.tree.nodes[self.right].inorder()

    def postorder(self):
        if self.left > -1:
            self.tree.nodes[self.left].postorder()
        if self.right > -1:
            self.tree.nodes[self.right].postorder()
        print(' {}'.format(self.no), end='')


n = int(input())
ary = [[int(_) for _ in input().split()] for i in range(n)]
tree = Tree(ary)
tree.preorder()
tree.inorder()
tree.postorder()

"
2911471,ALDS1_7_C,"class NullNode():
    def __init__(self):
        self.id = -1

class Node():
    def __init__(self, id):
        self.id = id
        self.parent = NullNode()
        self.left = NullNode()
        self.right = NullNode()

def preorder(node, out_list=[]):
    if node.id != -1:
        out_list.append(str(node.id))
        out_list = preorder(node.left, out_list)
        out_list = preorder(node.right, out_list)
    return out_list

def inorder(node, out_list=[]):
    if node.id != -1:
        out_list = inorder(node.left, out_list)
        out_list.append(str(node.id))
        out_list = inorder(node.right, out_list)
    return out_list

def postorder(node, out_list=[]):
    if node.id != -1:
        out_list = postorder(node.left, out_list)
        out_list = postorder(node.right, out_list)
        out_list.append(str(node.id))
    return out_list

n = int(input())
node_list = [Node(id) for id in range(n)]
for i in range(n):
    [id, left, right] = [int(j) for j in input().split()]
    i_node = node_list[id]
    if left != -1:
        i_node.left = node_list[left]
        node_list[left].parent = node_list[id]
    if right != -1:
        i_node.right = node_list[right]
        node_list[right].parent = node_list[id]

for node in node_list:
    if node.parent.id == -1:
        root = node

print('Preorder')
out_list = preorder(root)
print(' ' + ' '.join(out_list))

print('Inorder')
out_list = inorder(root)
print(' ' + ' '.join(out_list))

print('Postorder')
out_list = postorder(root)
print(' ' + ' '.join(out_list))

"
2924838,ALDS1_7_C,"def preorder(tree, now):
    if now == -1:
        return []
    else:
        left = tree[now][0]
        right = tree[now][1]
        return [now] + preorder(tree, left) + preorder(tree, right)


def inorder(tree, now):
    if now == -1:
        return []
    else:
        left = tree[now][0]
        right = tree[now][1]
        return inorder(tree, left) + [now] + inorder(tree, right)


def postorder(tree, now):
    if now == -1:
        return []
    else:
        left = tree[now][0]
        right = tree[now][1]
        return postorder(tree, left) + postorder(tree, right) + [now]


def print_list_split_whitespace(a):
    print("" "", end="""")
    for x in a[:-1]:
        print(x, end="" "")
    print(a[-1])


n = int(input())
tree = [[] for _ in range(n)]
ps = [-1 for _ in range(n)]
ss = [-1 for _ in range(n)]
for _ in range(n):
    s = input().split()
    id = int(s[0])
    left = int(s[1])
    right = int(s[2])
    tree[id] = [left, right]
    if left >= 0:
        ps[left] = id
        ss[left] = right
    if right >= 0:
        ps[right] = id
        ss[right] = left

root = ps.index(-1)

print(""Preorder"")
pre_list = preorder(tree, root)
print_list_split_whitespace(pre_list)

print(""Inorder"")
in_list = inorder(tree, root)
print_list_split_whitespace(in_list)

print(""Postorder"")
post_list = postorder(tree, root)
print_list_split_whitespace(post_list)
"
2939211,ALDS1_7_C,"n = int(input())
tree = [[-1, -1, True] for i in range(n)]
for i in range(n):
    id, left, right = map(int, input().split())
    if left != -1:
        tree[id][0] = left
        tree[left][2] = False
    if right != -1:
        tree[id][1] = right
        tree[right][2] = False

def preoder(id):
    if id == -1:
        return
    print(' ' + str(id), end='')
    preoder(tree[id][0])
    preoder(tree[id][1])

def inorder(id):
    if id == -1:
        return
    inorder(tree[id][0])
    print(' ' + str(id), end='')
    inorder(tree[id][1])

def postorder(id):
    if id == -1:
        return
    postorder(tree[id][0])
    postorder(tree[id][1])
    print(' ' + str(id), end='')

root = 0
for i, node in enumerate(tree):
    if node[2] == True:
        root = i

print('Preorder')
preoder(root)
print('')
print('Inorder')
inorder(root)
print('')
print('Postorder')
postorder(root)
print('')

"
3031877,ALDS1_7_C,"N = int(input())

class Node():
    def __init__(self, parent=-1, left=-1, right=-1):
        self.parent = parent
        self.left = left
        self.right = right

T = [Node() for _ in range(N)]

for _ in range(N):
    id, left, right = map(int, input().split())

    T[id].left = left
    T[id].right = right

    if left != -1:
        T[left].parent = id
    if right != -1:
        T[right].parent = id


def preorder(id):
    if id == -1:
        return

    preorder_list.append(id)

    preorder(T[id].left)
    preorder(T[id].right)

def inorder(id):
    if id == -1:
        return

    inorder(T[id].left)
    inorder_list.append(id)
    inorder(T[id].right)

def postorder(id):
    if id == -1:
        return

    postorder(T[id].left)
    postorder(T[id].right)
    postorder_list.append(id)

preorder_list = []
inorder_list = []
postorder_list = []
for id in range(N):
    if T[id].parent == -1:
        preorder(id)
        inorder(id)
        postorder(id)
        break


print(""Preorder"")
print("" ""+"" "".join(map(str, preorder_list)))
print(""Inorder"")
print("" ""+"" "".join(map(str, inorder_list)))
print(""Postorder"")
print("" ""+"" "".join(map(str, postorder_list)))
"
3037551,ALDS1_7_C,"class Node:
	def __init__(self):
		self.p = self.l = self.r = -1

def pre_order(nodes, u):
	if u == -1: return
	print(' ' + str(u), end='')
	pre_order(nodes, nodes[u].l)
	pre_order(nodes, nodes[u].r)

def in_order(nodes, u):
	if u == -1: return
	in_order(nodes, nodes[u].l)
	print(' ' + str(u), end='')
	in_order(nodes, nodes[u].r)

def post_order(nodes, u):
	if u == -1: return
	post_order(nodes, nodes[u].l)
	post_order(nodes, nodes[u].r)
	print(' ' + str(u), end='')

n = int(input())
nodes = []
for i in range(n): nodes.append(Node())
for i in range(n):
	id, l, r = map(int, input().split())
	nodes[id].l = l
	nodes[id].r = r
	if l != -1: nodes[l].p = id
	if r != -1: nodes[r].p = id
for i in range(n):
	if nodes[i].p == -1:
		rootId = i
		break
print('Preorder')
pre_order(nodes, rootId)
print()
print('Inorder')
in_order(nodes, rootId)
print()
print('Postorder')
post_order(nodes, rootId)
print()

"
3070484,ALDS1_7_C,"NIL = -1

class Node:
    def __init__(self, parent=NIL, left=NIL, right=NIL):
        self.parent = parent
        self.left = left
        self.right = right


def preParse(tree, u):
    if u == NIL:
        return
    print(' %d' % u, end='')
    preParse(tree, tree[u].left)
    preParse(tree, tree[u].right)


def inParse(tree, u):
    if u == NIL:
        return
    inParse(tree, tree[u].left)
    print(' %d' % u, end='') 
    inParse(tree, tree[u].right)


def postParse(tree, u):
    if u == NIL:
        return
    postParse(tree, tree[u].left)
    postParse(tree, tree[u].right)
    print(' %d' % u, end='') 


n = int(input())
tree = [Node() for i in range(n)]

for i in range(n):
    value, left, right = [int(v) for v in input().split()]
    tree[value].left = left
    tree[value].right = right
    if left != NIL:
        tree[left].parent = value
    if right != NIL:
        tree[right].parent = value

root = 0
for i in range(n):
    if tree[i].parent == NIL:
        root = i
        break

print('Preorder')
preParse(tree, root)
print()
print('Inorder')
inParse(tree, root)
print()
print('Postorder')
postParse(tree, root)
print()
"
3089414,ALDS1_7_C,"class Node:
    def __init__(self, nid):
        self.nid = nid
        self.parent = None
        self.left = None
        self.right = None
    
    def preo(self):
        tmp = """"
        tmp += "" "" + str(self.nid)
        if self.left:
            tmp += self.left.preo()
        if self.right:
            tmp += self.right.preo()
        return tmp
    
    def ino(self):
        tmp = """"
        if self.left:
            tmp += self.left.ino()
        tmp += "" "" + str(self.nid)
        if self.right:
            tmp += self.right.ino()
        return tmp
    
    def posto(self):
        tmp = """"
        if self.left:
            tmp += self.left.posto()
        if self.right:
            tmp += self.right.posto()
        tmp += "" "" + str(self.nid) 
        return tmp
    
n = int(input())
T={}
for i in range(n):
    T[i] = Node(i)
for i in range(n):
    nid, left, right = [int(i) for i in input().split()]
    if left != -1:
        T[nid].left = T[left]
        T[left].parent = T[nid]
    if right != -1:
        T[nid].right = T[right]
        T[right].parent = T[nid]
root = T[0]
while(True):
    if root.parent:
        root = root.parent
    else:
        break
print(""Preorder"")
print(root.preo())
print(""Inorder"")
print(root.ino())
print(""Postorder"")
print(root.posto())
"
3108498,ALDS1_7_C,"from sys import stdin

class Node(object):
    def __init__(self, parent=None, left=None, right=None):
        self.parent = parent
        self.left = left
        self.right = right

def print_nodes(nodes, n):
    A = []
    B = []
    C = []
    def walk_tree(nodes, u):
        if u == -1:
            return
        r = nodes[u].right
        l = nodes[u].left
        A.append(u)
        walk_tree(nodes, l)
        B.append(u)
        walk_tree(nodes, r)
        C.append(u)

    for i in range(n):
        if nodes[i].parent == None:
            walk_tree(nodes, i)
            print(""Preorder"", end=""\n "")
            print(*A, sep="" "")
            print(""Inorder"", end=""\n "")
            print(*B, sep="" "")
            print(""Postorder"", end=""\n "")
            print(*C, sep="" "")

def read_binary_tree(nodes, n):
    for _ in range(n):
        i = [int(i) for i in stdin.readline().strip().split()]
        nodes[i[0]].left = i[1]
        nodes[i[0]].right = i[2]
        if i[1] != -1:
            nodes[i[1]].parent = i[0]
        if i[2] != -1:
            nodes[i[2]].parent = i[0]

n = int(input())
nodes = [Node() for _ in range(n)]
read_binary_tree(nodes, n)
print_nodes(nodes, n)
"
3120134,ALDS1_7_C,"def pre_order(u):
    if u == -1:
        return
    print('', u, end='')
    pre_order(T[u])
    pre_order(T[u + N])

def in_order(u):
    if u == -1:
        return
    in_order(T[u])
    print('', u, end='')
    in_order(T[u + N])

def post_order(u):
    if u == -1:
        return
    post_order(T[u])
    post_order(T[u + N])
    print('', u, end='')

N = int(input())
T = [0, 0] * N
for _ in range(N):
    a, b, c = map(int, input().split())
    T[a], T[a + N] = b, c
root = (set(range(N)) - set(T)).pop()
print('Preorder')
pre_order(root)
print('\nInorder')
in_order(root)
print('\nPostorder')
post_order(root)
print()
"
3128571,ALDS1_7_C,"class Node():
    def __init__(self):
        self.parent = None
        self.left = None
        self.right = None


def preorder(id):
    print(f"" {id}"", end="""")
    if tree[id].left is not None:
        preorder(tree[id].left)
    if tree[id].right is not None:
        preorder(tree[id].right)

def inorder(id):
    if tree[id].left is not None:
        inorder(tree[id].left)
    print(f"" {id}"", end="""")
    if tree[id].right is not None:
        inorder(tree[id].right)


def postorder(id):
    if tree[id].left is not None:
        postorder(tree[id].left)
    if tree[id].right is not None:
        postorder(tree[id].right)
    print(f"" {id}"", end="""")
    
n = int(input())
tree = []
for _ in range(n):
    tree.append(Node())
for _ in range(n):
    id, left, right = map(int, input().split())
    if left != -1:
        tree[id].left = left
        tree[left].parent = id
    if right != -1:
        tree[id].right = right
        tree[right].parent = id
        
for id in range(n):
    if tree[id].parent is None:
        root_id = id
        break
    
print(""Preorder"")
preorder(root_id)
print("""")
print(""Inorder"")
inorder(root_id)
print("""")
print(""Postorder"")
postorder(root_id)
print("""")
"
3140255,ALDS1_7_C,"#이런식으로 코드 짜니까 이문제가 왜 이런걸 물어보는건지 이해가 감... 대단하다
class Node():
    def __init__(self, parent = -1, left = -1, right = -1): ##초기값 설정
        self.parent = parent
        self.left = left
        self.right = right
##초기 Node()class는 parent,left,right모두 -1
n = int(input())
ns = [Node()for i in range(n)] ##ns[0~(n-1)]모두 Node class 인스턴스화
for i in range(n):
    p, l, r = map(int, input().split())
    if (l != -1):
        ns[l].parent = p ##클래스변수 (메소드 아님,()없음)
        ns[p].left = l
    if (r != -1):
        ns[r].parent = p
        ns[p].right = r
        
        
def preorder(ns, i):  ##여기서의 i는 root 
    print("" ""+str(i), end ='')  ##preorder은 루트 쪽부터 print
    if (ns[i].left != -1):  ##left쪽으로 쭉감
        preorder(ns, ns[i].left) ##ns[i].left를 root로써 재귀함수!
    if (ns[i].right != -1):
        preorder(ns, ns[i].right) ##left다했으면 right으로도 똑같이 해줌

def inorder(ns, i):
    if (ns[i].left != -1):
        inorder(ns, ns[i].left)  ##inorder는 일단 재귀함수로 왼쪽 끝까지 감
    print(' ' + str(i), end = '') ##왼쪽 끝가지 간 후 print (더이상 왼쪽으로 갈 수 없을때 print)
    if (ns[i].right != -1):
        inorder(ns, ns[i].right)  ##left로 갈수없을때 실행됨 (오른쪽으로 한번)

def postorder(ns, i):
    if (ns[i].left != -1):
        postorder(ns, ns[i].left)  ##inorder는 일단 재귀함수로 왼쪽 끝까지 감
    if (ns[i].right != -1):
        postorder(ns, ns[i].right)  ##left로 갈수없을때 오른쪽으로 끝까지 감
    print(' ' + str(i), end = '')  ##더이상 갈 수 없을때 print

for i in range(n):
    if (ns[i].parent == -1): ##root를 찾아서 위의 세 함수에 대입하여 print
        print('Preorder')
        preorder(ns, i)
        print()
        print('Inorder')
        inorder(ns, i)
        print()
        print('Postorder')
        postorder(ns, i)
        print()
        break
"
3176462,ALDS1_7_C,"
class Node():
    ""node of the tree structure""
    def __init__(self, parent = -1, left = -1, right = -1):
        self.parent = parent
        self.left = left
        self.right = right
def preParse(u):
    if u == -1:
        return
    list_preParse.append(u)
    preParse(node_list[u].left)
    preParse(node_list[u].right)

def inParse(u):
    if u == -1:
        return
    inParse(node_list[u].left)
    list_inParse.append(u)
    inParse(node_list[u].right)

def postParse(u):
    if u == -1:
        return
    postParse(node_list[u].left)
    postParse(node_list[u].right)
    list_postParse.append(u)

def returnRoot(u):
    while node_list[u].parent != -1:
        u = node_list[u].parent
    return u

list_preParse = []
list_inParse = []
list_postParse = []
n = int(input())
node_list = []
for i in range(n):
    node = Node()
    node_list.append(node)

for i in range(n):
    a,b,c = map(int, input().split())
    node_list[a].left = b
    node_list[a].right = c
    if b != -1:
        node_list[b].parent = a
    if c != -1:
        node_list[c].parent = a

print(""Preorder"")
preParse(returnRoot(0))
for i in range(n):
    list_preParse[i] = str(list_preParse[i])
print("" "" + "" "".join(list_preParse))

print(""Inorder"")
inParse(returnRoot(0))
for i in range(n):
    list_inParse[i] = str(list_inParse[i])
print("" "" + "" "".join(list_inParse))
print(""Postorder"")
postParse(returnRoot(0))
for i in range(n):
    list_postParse[i] = str(list_postParse[i])
print("" "" + "" "".join(list_postParse))

"
3179192,ALDS1_7_C,"class Node():
  def __init__(self, parent = -1, left = -1, right = -1):
    self.parent = parent
    self.left = left
    self.right = right

def preorder(ns,i):
  print(' '+ str(i), end="""")
  if ns[i].left != -1:
    preorder(ns, ns[i].left)
  if ns[i].right != -1:
    preorder(ns, ns[i].right)

def inorder(ns,i):
  if ns[i].left != -1:
    inorder(ns, ns[i].left)
  print(' '+ str(i), end="""")
  if ns[i].right != -1:
    inorder(ns, ns[i].right)

def postorder(ns, i):
  if ns[i].left != -1:
    postorder(ns, ns[i].left)
  if ns[i].right != -1:
    postorder(ns, ns[i].right)
  print(' '+ str(i), end="""")

n = int(input())
ns = [Node() for i in range(n)]
for i in range(n):
  p, l, r = map(int, input().split())
  if l != -1:
    ns[p].left = l
    ns[l].parent = p
  if r != -1:
    ns[p].right = r
    ns[r].parent = p

for i in range(n):
  if ns[i].parent == -1:
    print(""Preorder"")
    preorder(ns, i)
    print()
    print(""Inorder"")
    inorder(ns, i)
    print()
    print(""Postorder"")
    postorder(ns, i)
    print()

"
3185395,ALDS1_7_C,"import sys
readline = sys.stdin.readline
write= sys.stdout.write
N = int(readline())
L = [None]*N; R = [None]*N; P = [-1]*(N+1)
for i in range(N):
    i, l, r = map(int, readline().split())
    L[i] = l; R[i] = r
    P[l] = i; P[r] = i
s0 = []; s1 = []; s2 = []
def dfs(v):
    v0 = str(v)
    s0.append(v0)
    L[v] != -1 and dfs(L[v])
    s1.append(v0)
    R[v] != -1 and dfs(R[v])
    s2.append(v0)
dfs(P.index(-1))
write(""Preorder\n %s\nInorder\n %s\nPostorder\n %s\n"" % tuple(map("" "".join, [s0, s1, s2])))

"
3186741,ALDS1_7_C,"import sys

def walk_preorder(n):
    c = children[n]
    print(' {}'.format(n), end='')
    if c[0]>=0: walk_preorder(c[0])
    if c[1]>=0: walk_preorder(c[1])

def walk_inorder(n):
    c = children[n]
    if c[0]>=0: walk_inorder(c[0])
    print(' {}'.format(n), end='')
    if c[1]>=0: walk_inorder(c[1])

def walk_postorder(n):
    c = children[n]
    if c[0]>=0: walk_postorder(c[0])
    if c[1]>=0: walk_postorder(c[1])
    print(' {}'.format(n), end='')
    

n = int(sys.stdin.readline())
parent = [-1 for _ in range(n)]
children = [[] for _ in range(n)]
for _ in range(n):
    id, left, right = list(map(int, sys.stdin.readline().split()))
    children[id] = [left, right]
    if left>=0:  parent[left] = id
    if right>=0: parent[right] = id

root=parent.index(-1)
order=[]
print('Preorder')
walk_preorder(root)
print()
print('Inorder')
walk_inorder(root)
print()
print('Postorder')
walk_postorder(root)
print()
"
8242951,ALDS1_7_D,"def reconstruct(l, r):
  global preorder, inorder, ans
  if l >= r:
    return 
  root = preorder.pop(0)
  center = inorder.index(root)

  reconstruct(l, center)
  reconstruct(center+1, r)
  ans.append(root)
  
N = int(input())
preorder = list(map(int, input().split()))
inorder = list(map(int, input().split()))
ans = []

reconstruct(0, N)
print(*ans)

"
8315432,ALDS1_7_D,"num_nodes = int(input())
preorder_tree_walk = list(map(int, input().split()))
inorder_tree_walk = list(map(int, input().split()))

def reconst(preorder, inorder):
  node = preorder[0]
  tree = [node]
  left, right = inorder[:inorder.index(node)], inorder[inorder.index(node)+1:]
  preorder_consumed = preorder[1:]
  if left:
    # `node` has a left node.
    new_children, preorder_consumed = reconst(preorder_consumed, left)
    tree.append(new_children)
  if right:
    # `node` has a left node.
    new_children, preorder_consumed = reconst(preorder_consumed, right)
    tree.append(new_children)
  return tree, preorder_consumed

tree, _ = reconst(preorder_tree_walk, inorder_tree_walk)

def make_postorder(tree):
  global postorder
  if not tree:
    return
  node = tree[0]
  if len(tree) >= 2:
    make_postorder(tree[1])
  if len(tree) >= 3:
    make_postorder(tree[2])
  postorder.append(node)

postorder = []
make_postorder(tree)
print(' '.join(map(str, postorder)))
"
8373636,ALDS1_7_D,"def post_order(a, b):
    if not a:
        return []
    rt = a[0]
    rt_idx = b.index(rt)

    a_l = a[1:rt_idx+1]
    a_r = a[rt_idx+1:]

    b_l = b[:rt_idx]
    b_r = b[rt_idx+1:]

    c_l = post_order(a_l, b_l)
    c_r = post_order(a_r, b_r)

    return c_l + c_r + [rt]


def main():
    n = int(input())
    # 先行順巡回
    a = [int(s) for s in input().split()]
    # 中間順巡回
    b = [int(s) for s in input().split()]
    # 後行順巡回
    c = post_order(a, b)
    print(*c)


if __name__ == ""__main__"":
    main()

"
8425205,ALDS1_7_D,"_ = int(input())
pr_walk = [*map(int, input().split())]
in_walk = [*map(int, input().split())]
walked = []

def recon_tree(pr_walk, in_walk):
  if pr_walk:
    root = pr_walk[0]
    i = in_walk.index(root)
    recon_tree(pr_walk[1:i+1], in_walk[:i])
    recon_tree(pr_walk[i+1:], in_walk[i+1:])
    walked.append(root)

recon_tree(pr_walk, in_walk)
print(*walked)

"
8448485,ALDS1_7_D,"input()
a, b = ([int(s) for s in input().split()] for _ in (1, 2))
b = [b]
t = []

while b:
    w = b.pop()
    if w:
        for c in a:
            if c in w:
                i = w.index(c)
                t.append(c)
                a.remove(c)
                break
        b.append(w[:i])
        b.append(w[i + 1:])

print(*t[::-1])
"
8543394,ALDS1_7_D,"debug_mode = False
if debug_mode:
    pre = [0, 1, 2, 3, 4, 5, 6, 7, 8]
    in_ = [2, 1, 3, 0, 6, 5, 7, 4, 8]
else:
    n = int(input())
    pre = list(map(int, input().split()))
    in_ = list(map(int, input().split()))

root_id = pre[0]
idx_root_id = in_.index(root_id)
sub_left_tree = in_[:idx_root_id]
sub_right_tree = in_[idx_root_id+1:]

def Rebuild_Postorder(pre, in_):
    if len(pre) == 0 or len(in_) == 0:
        return []
    root_id = pre[0]
    idx_root_id = in_.index(root_id)
    sub_left_tree = in_[:idx_root_id]
    sub_right_tree = in_[idx_root_id+1:]
    sub_pre_left_tree = pre[1:1 + len(sub_left_tree)]
    sub_pre_right_tree = pre[1 + len(sub_left_tree):]

    left = Rebuild_Postorder(sub_pre_left_tree, sub_left_tree)
    right = Rebuild_Postorder(sub_pre_right_tree, sub_right_tree)
    
    return left + right + [root_id]

Postorder_list = Rebuild_Postorder(pre, in_)
print(*Postorder_list, sep="" "")

    

    


"
8812603,ALDS1_7_D,"#参考 : 木の復元の問題を解いてみた https://programgenjin.hatenablog.com/entry/2019/02/28/070613
N = int(input())
pre_list = list(map(int, input().split()))
in_list = list(map(int, input().split()))
post_list = []
pos = 0

def reconstruction(left, right):
    global pos
    if left >= right:
        return
    
    root = pre_list[pos]
    pos += 1
    
    root_pos = in_list.index(root)
    reconstruction(left, root_pos)
    reconstruction(root_pos+1, right)
    
    post_list.append(root)
    
reconstruction(pos, N)
print(*post_list)
"
8894206,ALDS1_7_D,"n=int(input())
preorder=list(map(int,input().split()))
inorder=list(map(int,input().split()))
ans=[]
def post(a,b):
    if a==[]:
        return
    root=a[0]
    left=b[:b.index(root)]
    right=b[b.index(root)+1:]
    post(a[1:1+len(left)],left)
    post(a[len(left)+1:],right)
    ans.append(root)    

post(preorder,inorder)
print(*ans)
"
9003460,ALDS1_7_D,"n=int(input())
preorder=list(map(int, input().split()))
inorder=list(map(int, input().split()))
def recontruct(preorder, inorder, postorder):
    if len(preorder)==0:
        return
    root=preorder[0]
    center=inorder.index(root)
    recontruct(preorder[1:center+1], inorder[:center], postorder)
    recontruct(preorder[center+1:], inorder[center+1:], postorder)
    postorder.append(str(root))
postorder=[]
recontruct(preorder, inorder, postorder)
print("" "".join(postorder))
"
9084899,ALDS1_7_D,"class Node:
    def __init__(self, id: int) -> None:
        self.id: int = id
        self.left :int = -1
        self.right: int = -1

class BinaryTree:
    def __init__(self, id) -> None:
        self.id = id
        self.left = self.right = None
        if nodes[id].left > -1: self.left = BinaryTree(nodes[id].left)
        if nodes[id].right > -1: self.right = BinaryTree(nodes[id].right)
    
    def order(self, mode: str):
        li = {""Preorder"": [0, 1, 2], ""Inorder"": [1, 0, 2], ""Postorder"": [1, 2, 0]}
        
        for i in li[mode]:
            if i == 0: ans.append(self.id)
            elif i == 1 and nodes[self.id].left > -1: self.left.order(mode)
            elif i == 2 and nodes[self.id].right > -1: self.right.order(mode)            

n = int(input())
preorder = list(map(int, input().split()))  # parent → left → rightの順
inorder = list(map(int, input().split()))  # left → parent → rightの順
nodes = [Node(i) for i in range(n+1)]
i = 0
ans = []
def createTree(temp:list[int]) -> int:
    global i
    temp_i = i
    if preorder[temp_i] in temp:
        index = temp.index(preorder[temp_i])
        left = temp[:index]
        right = temp[index + 1:]
        if len(left) > 0:
            i += 1
            nodes[preorder[temp_i]].left = preorder[i]
            createTree(left)
        if len(right) > 0:
            i += 1
            nodes[preorder[temp_i]].right = preorder[i]
            createTree(right)
        
createTree(inorder)
tree = BinaryTree(preorder[0])
tree.order(""Postorder"")
print("" "".join(map(str, ans)))
"
9111310,ALDS1_7_D,"def reconstruction(l, r):
    if l >= r:
        return

    c = next(preOrder)
    m = inOrder.index(c)

    reconstruction(l, m)
    reconstruction(m+1, r)

    postOrder.append(c)


n = int(input())
preOrder = iter(list(map(int, input().split())))
inOrder = list(map(int, input().split()))

postOrder = []


reconstruction(0, n)
print(' '.join(str(post) for post in postOrder))

"
9145930,ALDS1_7_D,"n = int(input())
preorder = list(map(int, input().split()))
inorder = list(map(int, input().split()))

ans = []
def reconstruct(pre_cur, pre_in):
    if len(pre_cur) == 0:
        return

    root = pre_cur[0]
    mid = pre_in.index(root)
    
    # left
    reconstruct(pre_cur[1:1+mid], pre_in[0:mid])
    
    # right
    reconstruct(pre_cur[1+mid:], pre_in[mid+1:])

    ans.append(root)

reconstruct(preorder, inorder)

print("" "".join(map(str, ans)))
"
1685817,ALDS1_7_D,"postorder_elements = []

def post_from_pre_in(preorder_elements, inorder_elements):
    if preorder_elements:
        root = preorder_elements[0]
        root_index = inorder_elements.index(root)
        preorder_left = preorder_elements[1:root_index+1]
        inorder_left = inorder_elements[:root_index]
        preorder_right = preorder_elements[root_index+1:]
        inorder_right = inorder_elements[root_index+1:]
        post_from_pre_in(preorder_left, inorder_left)
        post_from_pre_in(preorder_right, inorder_right)
        postorder_elements.append(root)



n = int(input())

a = list(map(int, input().split()))
b = list(map(int, input().split()))

post_from_pre_in(a, b)

print(*postorder_elements)
"
2068208,ALDS1_7_D,"#coding:UTF-8

def RoT(A,B,ans):
    if A:
        root=A[0]
        rindex=B.index(root)
        Aleft=A[1:rindex+1]
        Aright=A[rindex+1:]
        Bleft=B[:rindex]
        Bright=B[rindex+1:]
        RoT(Aleft,Bleft,ans)
        RoT(Aright,Bright,ans)
        ans.append(root)
        
        


if __name__==""__main__"":
    n=int(input())
    A=input().split("" "")
    B=input().split("" "")
    ans=[]
    RoT(A,B,ans)
    print("" "".join(ans))
"
2163121,ALDS1_7_D,"
nil = -1

class Node:
    def __init__(self):
        self.parent = nil
        self.left = nil
        self.right = nil

def post_tw(node, ans):
    if tree[node].left != nil:
        post_tw(tree[node].left, ans)

    if tree[node].right != nil:
        post_tw(tree[node].right, ans)

    ans.append(node + 1)

def reconst_tree(node, pretw_itr, subt):
    n_i = subt.index(node)

    left_subt = subt[:n_i]
    right_subt = subt[n_i + 1:]

    if left_subt:
        left = next(pretw_itr)
        tree[node].left = left
        reconst_tree(left, pretw_itr, left_subt)

    if right_subt:
        right = next(pretw_itr)
        tree[node].right = right
        reconst_tree(right, pretw_itr, right_subt)


n = int(input())
tree = [Node() for i in range(n)]

pretw = [int(i) - 1 for i in input().split()]
intw = [int(i) - 1 for i in input().split()]

pretw_itr = iter(pretw)

root = next(pretw_itr)

reconst_tree(root, pretw_itr, intw)

ans = []

post_tw(root, ans)

print(*ans)
"
2245492,ALDS1_7_D,"def get_postorder(PRE, IN):
  if not PRE: return []

  result = []
  root = PRE[0]
  ri = IN.index(PRE[0])
  result.extend(get_postorder(PRE[1:ri+1], IN[:ri]))
  result.extend(get_postorder(PRE[ri+1:],  IN[ri+1:]))
  result.append(root)
  return result


N = int(input())
PRE = list(map(int, input().split()))
IN  = list(map(int, input().split()))
print(*get_postorder(PRE, IN))
"
2335298,ALDS1_7_D,"class Node:
    def __init__(self, num, left, right):
        self.value = num
        self.left = left
        self.right = right

EmptyTree = None

def make_node(num, left, right):
    return Node(num, left, right)

def value(tree):
    return tree.value

def left(tree):
    return tree.left

def right(tree):
    return tree.right

def is_empty(tree):
    return tree == EmptyTree

def make_leaf(num):
    return make_node(num, EmptyTree, EmptyTree)

# ????????¢?´¢??¨??¨??????????????????tree???x?????????????????°????????¨?????????
def add_node(tree, x):
    if is_empty(tree):
        return make_leaf(x)
    elif x < value(tree):
        return make_node(value(tree), add_node(left(tree), x), right(tree))
    else:
        return make_node(value(tree), left(tree), add_node(right(tree), x) )

def make_binary_search_tree(a):
    tree = EmptyTree
    # ????????????????????¶:
    # ????????????i???????????£?????¨????????¨????¬????????????????????????§??????
    # a?????????i???????????§???????´????????????¢?´¢??¨tree????????????????????????
    for num in a:
        tree = add_node(tree, num)
    return tree

def inorder(tree):
    if is_empty(tree):
        return []
    return inorder(left(tree)) + [value(tree)] + inorder(right(tree))

def preorder(tree):
    if is_empty(tree):
        return []
    return [value(tree)] + preorder(left(tree)) + preorder(right(tree))

def postorder(tree):
    if is_empty(tree):
        return []
    return postorder(left(tree)) + postorder(right(tree)) + [value(tree)]

# ?????????????????¨????§??????¨???????????¨?????????????¨???????????????????
def calc(tree):
    if is_empty(right(tree)) or is_empty(left(tree)):
        return value(tree)

    if value(tree) == ""+"":
        return calc(right(tree)) + calc(left(tree))
    elif value(tree) == ""-"":
        return calc(right(tree)) - calc(left(tree))
    elif value(tree) == ""*"":
        return calc(right(tree)) * calc(left(tree))
    elif value(tree) == ""/"":
        return calc(right(tree)) / calc(left(tree))

def recover(preorder, inorder):
    # preorder??????????????????root
    # root???inorder??????????????¢???
    # inorder??????root????¢??????????
    # ?????????????????????Node??????????????£???????????????????????£?????????
    if len(inorder) == 0:
        return EmptyTree
    root_val = preorder[0]
    idx = inorder.index(root_val)
    left = inorder[:idx]
    right = inorder[idx+1:]
    return make_node(root_val, recover(preorder[1:], left),  recover(preorder[1+len(left):],right) )

n = input()
pre = list(map(int, input().split()))
ino = list(map(int, input().split()))
t = recover(pre, ino)
t = map(str, postorder(t))
print(' '.join(t))
"
2349500,ALDS1_7_D,"n = int(input())
pre = list(map(int,input().split()))
ino = list(map(int,input().split()))

post=[]
i = -1
def reconstruction(l, r):
    global i
    if l >= r:
        return
    i += 1
    c = pre[i]
    m = ino.index(c)
    reconstruction(l, m)
    reconstruction(m+1, r)
    post.append(c)
reconstruction(0, n)
print("" "".join(map(str,post)))
"
2406788,ALDS1_7_D,"# coding=utf-8
def reconstruction(left, right):
    global pre_order
    global in_order
    global post_order
    global n

    if left > right:
        return None
    elif left == right:
        root = pre_order.pop(0)
        post_order.append(root)
        return None
    else:
        root = pre_order.pop(0)

    root_pos = in_order.index(root)
    reconstruction(left, root_pos-1)
    reconstruction(root_pos+1, right)
    post_order.append(root)

n = int(input())
pre_order = list(map(int, input().split()))
in_order = list(map(int, input().split()))
post_order = []

reconstruction(0, n-1)
print(*post_order)
"
2425018,ALDS1_7_D,"def reconstruction(l, r):
    global i
    if l >= r:
        return
    c = PRE[i]
    i += 1
    m = IN.index(c)
    reconstruction(l, m)
    reconstruction(m + 1, r)
    POST.append(c)


if __name__ == ""__main__"":
    n = int(input())
    PRE = list(map(int, input().split()))
    IN = list(map(int, input().split()))
    POST = []
    i = 0
    reconstruction(0, n)
    print("" "".join(map(str, POST)))
"
2499153,ALDS1_7_D,"def get_postorder(preorder, inorder):
    if not preorder:
        return []

    root = preorder[0]
    root_index = inorder.index(root)
    result = []

    result.extend(get_postorder(preorder[1:root_index+1], inorder[:root_index]))
    result.extend(get_postorder(preorder[root_index+1:], inorder[root_index+1:]))
    result.append(root)

    return result


if __name__ == '__main__':
    n = int(input())
    preorder = list(map(int, input().split()))
    inorder = list(map(int, input().split()))

    print(*get_postorder(preorder, inorder))
"
2590895,ALDS1_7_D,"def getPostorder(preorder, inorder):
    if not preorder:
        return []
    postorder = []
    root = preorder[0]
    rootIndex = inorder.index(root)

    postorder.extend(getPostorder(preorder[1:rootIndex + 1], inorder[:rootIndex]))
    postorder.extend(getPostorder(preorder[rootIndex + 1:], inorder[rootIndex + 1:]))
    postorder.append(root)

    return postorder 

if __name__ == '__main__':
    n = int(input())
    preorder = list(map(int, input().split()))
    inorder = list(map(int, input().split()))
    print(*getPostorder(preorder, inorder))
"
2626158,ALDS1_7_D,"class Node:
    def __init__(self, x):
        self.x = x
        self.left = None
        self.right = None


def reconstruct(x, y):
    top = x[0]
    root = Node(top)
    # print(""root:"", top)

    mid = y.index(top)
    left = y[:mid]
    right = y[mid+1:]
    if len(left) > 0:
        root.left = reconstruct(x[1:mid+1], left)
    if len(right) > 0:
        root.right = reconstruct(x[mid+1:], right)

    return root


def postorder(L, node):
    if node is None:
        return
    postorder(L, node.left)
    postorder(L, node.right)
    L.append(node.x)


if __name__ == ""__main__"":
    input()
    preorder = input().split()
    inorder = input().split()
    root = reconstruct(preorder, inorder)
    L = []
    postorder(L, root)
    print(' '.join(L))
"
2700093,ALDS1_7_D,"n = int(input())
pretree = list(map(int, input().split()))
inotree = list(map(int, input().split()))
def get_postorder(pre, ino):
    if not pre:
        return []
    root = pre[0]
    root_index = ino.index(root)
    result = []
    result.extend(get_postorder(pre[1:root_index + 1], ino[:root_index]))
    result.extend(get_postorder(pre[root_index + 1:], ino[root_index + 1:]))
    result.append(root)
    return result
print(*get_postorder(pretree, inotree))

"
2702243,ALDS1_7_D,"class Node:

    def __init__(self, n):
        self.id = n
        self.left = None
        self.right = None

class BTree:

    def __init__(self, n):
        self.n = n
        self.nodes = [Node(i) for i in range(n + 1)]

    def make_tree(self, preorder, inorder):
        if preorder:
            root = preorder[0]
            i_root = inorder.index(root)
            inorder_left = inorder[:i_root]
            inorder_right = inorder[i_root + 1:]
            leftn = len(inorder_left)
            preorder_left = preorder[1:leftn + 1]
            preorder_right = preorder[leftn + 1:]

            self.nodes[root].left = self.make_tree(preorder_left, inorder_left)
            self.nodes[root].right = self.make_tree(preorder_right, inorder_right)

            return root

        else:
            return -1

    def disp_postorder(self, root, result):
        node = self.nodes[root]
        if node.left != -1:
            self.disp_postorder(node.left, result)
        if node.right != -1:
            self.disp_postorder(node.right, result)
        result.append(root)
        return result

if __name__ == '__main__':

    n = int(input())
    btree = BTree(n)

    preorder = [int(x) for x in input().split()]
    inorder = [int(x) for x in input().split()]

    btree.make_tree(preorder, inorder)

    result = btree.disp_postorder(preorder[0], [])
    print("" "".join([str(x) for x in result]))
"
2717402,ALDS1_7_D,"j,a=0,[]
def f(l,r):
 if l<r:
  global j,a;c=p[j];j+=1;m=i.index(c)
  f(l,m);f(m+1,r);a+=[c]
n,p,i=int(input()),input().split(),input().split()
f(0,n);print(*a)
"
2744949,ALDS1_7_D,"def reconstruct(pre, in_):
    if not pre:
        return -1
    root = pre[0]
    i = in_.index(root)
    tree[root] = (reconstruct(pre[1 : i+1], in_[:i]), reconstruct(pre[i+1:], in_[i+1:]))
    return root

def postorder(i):
    if i == -1:
        return
    l, r = tree[i]
    for v in postorder(l):
        yield v
    for v in postorder(r):
        yield v
    yield i

n = int(input())
tree = [None for i in range(n+1)]
pre_tree = list(map(int, input().split()))
in_tree = list(map(int, input().split()))
reconstruct(pre_tree, in_tree)
print(*postorder(pre_tree[0]))
"
2822569,ALDS1_7_D,"class BinaryTree:
    class Node:
        def __init__(self, nid, left, right):
            self.id = nid
            self.left = left
            self.right = right

        def has_left(self):
            return self.left is not None

        def has_right(self):
            return self.right is not None

        def __str__(self):
            return str(self.id)

    @classmethod
    def create(cls, ids):
        nodes = {}
        def find(n, li):
            for e1, e2, e3 in li:
                if e1 == n:
                    return (e2, e3)
            raise ValueError()

        def _create(nid):
            if nid in nodes:
                return nodes[nid]
            if nid == -1:
                return None

            lid, rid = find(nid, ids)
            if lid == -1 and rid == -1:
                right = None
                left = None
            elif lid == -1:
                right = _create(rid)
                left = None
            elif lid == -1:
                right = None
                left = _create(lid)
            else:
                right = _create(rid)
                left = _create(lid)
            nodes[nid] = cls.Node(nid, left, right)
            return nodes[nid]

        def _root(nodeids):
            for nid in [n[0] for n in nodeids]:
                if all([lid != nid and rid != nid for _, lid, rid in nodeids]):
                    return nid

        root = _create(_root(ids))
        return cls(root)

    def __init__(self, root):
        self.root = root

    def preorder(self):
        def _preorder(node):
            yield node
            if node.has_left():
                yield from _preorder(node.left)
            if node.has_right():
                yield from _preorder(node.right)
        yield from _preorder(self.root)

    def inorder(self):
        def _inorder(node):
            if node.has_left():
                yield from _inorder(node.left)
            yield node
            if node.has_right():
                yield from _inorder(node.right)
        yield from _inorder(self.root)

    def postorder(self):
        def _postorder(node):
            if node.has_left():
                yield from _postorder(node.left)
            if node.has_right():
                yield from _postorder(node.right)
            yield node
        yield from _postorder(self.root)

def reconstruct(preorder, inorder):
    """"""Reconstruct a binary tree from preorder list
    and inorder list of the tree.

    >>> tree = reconstruct([1, 2, 3, 4, 5], [3, 2, 4, 1, 5])
    >>> print("" "".join([str(node) for node in tree.postorder()]))
    3 4 2 5 1
    """"""
    def _first(li):
        if len(li) > 0:
            return li[0]
        else:
            return -1

    def _reconstruct(_pre, _in):
        assert(len(_pre) == len(_in))
        if len(_pre) == 0:
            return []
        if len(_pre) == 1:
            return [[_pre[0], -1, -1]]
        root, *pre = _pre
        i = _in.index(root)
        in1, in2 = _in[:i], _in[i+1:]
        pre1, pre2 = _pre[1:i+1], _pre[i+1:]
        return ([[root, _first(pre1), _first(pre2)]] +
                _reconstruct(pre1, in1) +
                _reconstruct(pre2, in2))

    return BinaryTree.create(_reconstruct(preorder, inorder))


def run():
    _ = int(input())
    preorder = [int(i) for i in input().split()]
    inorder = [int(i) for i in input().split()]

    tree = reconstruct(preorder, inorder)
    print("" "".join([str(n) for n in tree.postorder()]))


if __name__ == '__main__':
    run()

"
2834012,ALDS1_7_D,"class Node():
    def __init__(self, parent = -1, left = -1, right = -1):
        self.parent = parent
        self.left = left
        self.right = right

def postorder(ns, i, post):
    if ns[i].left != -1:
        postorder(ns, ns[i].left, post)
    if ns[i].right != -1:
        postorder(ns, ns[i].right, post)
    post.append(str(i + 1))

def poio_node(ns, po, io):
    p = po[0]
    i = io.index(p)
    if i != 0:
        ns[p].left = po[1]
        ns[po[1]].parent = p
        poio_node(ns, po[1:i + 1], io[:i])
    if i != len(io) -1:
        ns[p].right = po[i + 1]
        ns[po[1 + i]].parent = p
        poio_node(ns, po[i + 1:], io[i + 1:])

def min1(n):
    return n - 1
    
n = int(input())
po = list(map(int, input().split()))
io = list(map(int, input().split()))
po = list(map(min1, po))
io = list(map(min1, io))
ns = [Node() for i in range(n)]

poio_node(ns, po, io)

post = []
postorder(ns, po[0], post)
print("" "".join(post))
"
2901080,ALDS1_7_D,"n = int(input())
preorder = list(map(int, input().split(' ')))
inorder = list(map(int, input().split(' ')))
postorder = []
pos = 0

def solve():
    global pos
    pos = 0
    reconstruction(0, len(preorder))
    for i in range(n):
        if i: print(' ', end='')
        print(postorder[i], end='')
    print()

def reconstruction(left, right):
    global inorder, preorder, postorder, pos
    if left >= right: return None
    root = preorder[pos]
    pos += 1
    mid = inorder.index(root)
    reconstruction(left, mid)
    reconstruction(1 + mid, right)
    postorder.append(root)

solve()
"
2905497,ALDS1_7_D,"INF = 10**3


def reconstruction(o_ary, p_ary, i_ary, l, r):
    if l >= r:
        return

    ind = INF
    for i in i_ary[l:r]:
        tmp_ind = p_ary.index(i)
        if ind > tmp_ind:
            ind = tmp_ind
    c = p_ary[ind]
    m = i_ary.index(c)

    reconstruction(o_ary, p_ary, i_ary, l, m)
    reconstruction(o_ary, p_ary, i_ary, m + 1, r)
    o_ary.append(c)


n = int(input())
p_ary = [int(_) for _ in input().split()]
i_ary = [int(_) for _ in input().split()]
o_ary = []
reconstruction(o_ary, p_ary, i_ary, 0, n)
print(*o_ary)

"
2924856,ALDS1_7_D,"def reconstruct(pre_list, in_list):
    if len(pre_list) <= 1:
        return pre_list
    now = pre_list[0]
    split_place = in_list.index(now)
    pre_left = pre_list[1:split_place + 1]
    in_left = in_list[0:split_place]
    pre_right = pre_list[split_place + 1:]
    in_right = in_list[split_place + 1:]
    return reconstruct(pre_left, in_left) + reconstruct(pre_right, in_right) + [now]

def print_list_split_whitespace(a):
    for x in a[:-1]:
        print(x, end="" "")
    print(a[-1])


n = int(input())
pre_list = [int(x) for x in input().split()]
in_list = [int(x) for x in input().split()]

post_list = reconstruct(pre_list, in_list)
print_list_split_whitespace(post_list)
"
3048484,ALDS1_7_D,"class Node:
	def __init__(self, v):
		self.v = v
		self.l = self.r = None
		self.p = -1
	def __str__(self):
		return str(self.v)

def find_pos(a, v):
	for i in range(len(a)):
		if a[i] == v:
			return i
	return -1

def add_node(root, cur, ino):
	cur.p = find_pos(ino, cur.v)
	st = []
	st.append(root)
	while len(st) != 0:
		node = st.pop()
		if node.p == -1:
			node.p = find_pos(ino, node.v)
		if cur.p < node.p:
			if node.l == None:
				node.l = cur
				return
			else:
				st.append(node.l)
		else:
			if node.r == None:
				node.r = cur
				return
			else:
				st.append(node.r)		

def post_order(root):
	st = []
	cur = root
	last = None
	ret = ''
	while cur != None or len(st) != 0:
		if cur != None:
			st.append(cur)
			cur = cur.l
		else:
			peek = st[len(st)-1]
			if peek.r != None and peek.r != last:
				cur = peek.r
			else:
				if len(ret) != 0:
					ret += ' '
				ret += str(peek)
				last = st.pop()
	return ret

n = int(input())
preo = list(map(int, input().split()))
ino = list(map(int, input().split()))
root = Node(preo[0])
for i in range(1, n):
	add_node(root, Node(preo[i]), ino)
print(post_order(root))
"
3070528,ALDS1_7_D,"pos = 0

def reconstruction(pre_order, in_order, post_order, left, right):
    if left >= right:
        return
    global pos
    root = pre_order[pos]
    pos += 1
    mid = in_order.index(root)
    reconstruction(pre_order, in_order, post_order, left, mid)
    reconstruction(pre_order, in_order, post_order, mid + 1, right)
    post_order.append(root)


def solve(pre_order, in_order):
    post_order = []
    reconstruction(pre_order, in_order, post_order, 0, len(pre_order))
    print(' '.join([str(v) for v in post_order]))


n = int(input())
pre_order = [int(v) for v in input().split()]
in_order = [int(v) for v in input().split()]

solve(pre_order, in_order)
"
3081334,ALDS1_7_D,"def post(P, I):
    if len(I)==0:
        return """"
    elif len(I)==1:
        return I[0]
    else:
        root = I.index(P[0])
        right = len(P)
        for i in I[root+1:]:
            if P.index(i) < right:
                right = P.index(i)
        return post(P[1:right],I[:root]) + "" "" + post(P[right:], I[root+1:]) + "" "" + I[root]
    
n = int(input())
P = input().split()
I = input().split()
ans = """"
for i in post(P,I).split():
    ans+=i + "" ""
print(ans[:-1])
"
3120256,ALDS1_7_D,"j, a = 0, []
def f(l, r):
    if l < r:
        global j, a
        c = P[j]
        j += 1
        m = I.index(c)
        f(l, m)
        f(m + 1, r)
        a += [c]


N = int(input())
P = input().split()
I = input().split()
f(0, N)
print(*a)
"
3193107,ALDS1_7_D,"

class Node:
    def __init__(self,name):
        self.name=name
        self.left=-1
        self.right=-1
        self.parent=-1



def mk_tree(Tree,p_order,in_order):
    tmp_p_order=[]
    tmp_in_order=[]
    root=p_order[0]#p_orderの先頭要素が、rootになる

    root_ind=0    
    while(in_order[root_ind] != root):
        root_ind+=1#in_orderでのrootのindexを返す 



    if(root_ind!=0):
        Tree[root].left=p_order[1]
        Tree[p_order[1]].parent=root
        tmp_in_order=in_order[0:root_ind]
        tmp_p_order=p_order[1:root_ind+1]
        mk_tree(Tree,tmp_p_order,tmp_in_order)

    if(root_ind!=len(p_order)-1):
        Tree[root].right=p_order[root_ind+1]
        Tree[p_order[root_ind+1]].parent=root
        tmp_in_order=in_order[root_ind+1:]
        tmp_p_order=p_order[root_ind+1:]
        mk_tree(Tree,tmp_p_order,tmp_in_order)
    


def Postorder(Tree,root,order):
    if(Tree[root].left!=-1):
        Postorder(Tree,Tree[root].left,order)
    if(Tree[root].right!=-1):
        Postorder(Tree,Tree[root].right,order)
    order.append(root)
       






n=int(input())
p_order=list(map(int,input().split()))
root=p_order[0]
in_order=list(map(int,input().split()))
Tree=[None]
for i in range(n):
   Tree.append(Node(i+1))

mk_tree(Tree,p_order,in_order)

#for i in range(1,n+1):
 #  print(f""id {i}: left = {Tree[i].left}, right = {Tree[i].right}, parent = {Tree[i].parent}"")



post_order=[]
Postorder(Tree,root,post_order)
print("" "".join(list(map(str,post_order))))
"
3195322,ALDS1_7_D,"import sys

def flatten(data):
    for item in data:
        if hasattr(item, '__iter__'):
            for element in flatten(item):
                yield element
        else:
            yield item

n = int(sys.stdin.readline())
preorder = list(map(int, sys.stdin.readline().split()))
inorder = list(map(int, sys.stdin.readline().split()))

def eq(a, b):
    if type(a)!=type(b):  return False   
    if type(a)==list:     return set(flatten(a))== set(flatten(b)) 
    return a==b   

while len(preorder)>1:
    for i in range(len(preorder)-3,-2,-1):
        seq = preorder[i:i+3]
        for j in range(len(inorder)-3,-2,-1):
            if type(preorder[i+1])==int:
                if eq(preorder[i+1], inorder[j+1]) and eq(preorder[i+2], inorder[j+2]):
                    
                    preorder[i+1:i+3] = [[preorder[i+1], 0, preorder[i+2]]]
                    inorder[j+1:j+3]  = [[0, inorder[j+1], inorder[j+2]]]
                    break
                if eq(preorder[i+1], inorder[j+2]) and eq(preorder[i+2], inorder[j+1]):
                    
                    preorder[i+1:i+3] = [[preorder[i+1], preorder[i+2], 0]]
                    inorder[j+1:j+3]  = [[inorder[j+1], inorder[j+2], 0]]
                    break
            if i>=0 and j>=0 and type(preorder[i])==int and eq(preorder[i], inorder[j+1]) and eq(preorder[i+1], inorder[j]) and  eq(preorder[i+2], inorder[j+2]): 
                preorder[i:i+3]=[seq]
                inorder[j:j+3]=[inorder[j:j+3]]
                break
        else:  continue
        break


postorder=[]
def create_postorder(a):
    if type(a)==list:
        for i in [1, 2, 0]: 
            if type(a[i])==list:  create_postorder(a[i])
            elif a[i]>0:          postorder.append(a[i])
    else:  postorder.append(a)
create_postorder(preorder[0])
print(' '.join(map(str, postorder)))
"
3224542,ALDS1_7_D,"def reconstruct(preorder, inorder, postorder):
    if len(preorder) == 0:
        return
    node_no = preorder[0]
    node_div = inorder.index(node_no)

    reconstruct(preorder[1:node_div+1], inorder[:node_div], postorder)
    reconstruct(preorder[node_div+1:], inorder[node_div+1:], postorder)

    postorder.append(node_no)
    return

def main():
    input()
    preorder = [int(x) for x in input().split()]
    inorder = [int(x) for x in input().split()]

    postorder = []
    reconstruct(preorder, inorder, postorder)
    print("" "".join(map(str, postorder)))

main()
"
3345708,ALDS1_7_D,"
class Node:
    left = -1
    right = -1


def get_root_index(first: int, end: int) -> int:
    """"""inorder[first:end]の根のインデックスを取得する。
    根： inorder[first:end]を左部分木と右部分木に分割するノード
    """"""

    # inorder[first:end]の要素でpreorderの一番手前にあるものが、
    # inorder[first:end]を左部分木と右部分木に分割するノード。
    # そのインデックスを返す。
    for pre in preorder:
        for j in range(first, end):
            if pre == inorder[j]:
                return j


def get_root(first, end) -> int:
    """"""inorder[first:end]の根のノードを返す。
    """"""

    root_ix = get_root_index(first, end)
    if root_ix is not None:
        return inorder[root_ix]
    else:
        return -1


def set_nodes(first: int, end: int):
    root_ix = get_root_index(first, end)
    if first + 1 < root_ix:
        set_nodes(first, root_ix)
    if root_ix + 1 < end - 1:
        set_nodes(root_ix + 1, end)
    nodes[inorder[root_ix]].left = get_root(first, root_ix)
    nodes[inorder[root_ix]].right = get_root(root_ix + 1, end)


def set_postorder(node_id: int) -> None:
    """"""後行順巡回で得られる節の番号を保存する。

    Args:
        node_id (int): [description]
    """"""

    left = nodes[node_id].left
    if left != -1:
        set_postorder(left)

    right = nodes[node_id].right
    if right != -1:
        set_postorder(right)

    postorder.append(node_id)


N = int(input())
nodes = [Node() for i in range(N + 1)]
preorder = [int(i) for i in input().split()]
inorder = [int(i) for i in input().split()]

set_nodes(0, N)

postorder = []
set_postorder(get_root(0, N))
print(' '.join(map(str, postorder)))
"
3371881,ALDS1_7_D,"# -*- coding: utf-8 -*-

import sys
sys.setrecursionlimit(10 ** 9)
def input(): return sys.stdin.readline().strip()
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(): return list(map(int, input().split()))

N = INT()
preo = LIST()
ino = LIST()
posto = []

def rec(l):
    if len(l) == 0:
        return
    # preorderから次の値を取り出す
    x = preo.pop(0)
    for i in range(len(l)):
        if l[i] == x:
            # preorderの値と一致したら、そこから左右に分割
            rec(l[:i])
            rec(l[i+1:])
    posto.append(x)
    return

rec(ino)
print(*posto)

"
3394256,ALDS1_7_D,"from sys import stdin

class Node:
    def __init__(self):
        self.children = [-1, -1]

###

def initNode(t_pre, t_in):
    global nodes
    if len(t_in) == 1:
        nodes[t_in[0]].children = [-1, -1]
        return t_in[0]
    else:
        r = t_in.index(t_pre[0])
        if r == 0: # 左部分木はなし
            rr = initNode(t_pre[1:], t_in[1:])
            nodes[t_in[r]].children = [-1, rr]
        elif r == len(t_in)-1: # 右部分木はなし
            lr = initNode(t_pre[1:r+1], t_in[:r])
            nodes[t_in[r]].children = [lr, -1]
        else:
            lr = initNode(t_pre[1:r+1], t_in[:r])
            rr = initNode(t_pre[r+1:], t_in[r+1:])
            nodes[t_in[r]].children = [lr, rr]

        return t_in[r]

def postorder(i):
    global nodes, res
    if i != -1:
        c = nodes[i].children
        postorder(c[0])
        postorder(c[1])
        res.append(i)

n = int(stdin.readline().rstrip())
t_pre = [int(x) for x in stdin.readline().rstrip().split()]
t_in = [int(x) for x in stdin.readline().rstrip().split()]

nodes = [Node() for _ in range(n+1)]
initNode(t_pre, t_in)

res = []
postorder(t_pre[0])
print(*res)
"
3406446,ALDS1_7_D,"# -*- coding: utf-8 -*-
""""""
Created on Sat Mar  2 15:32:11 2019

@author: Yamazaki Kenichi
""""""

N = int(input())
pre = list(map(int,input().split()))
ino = list(map(int,input().split()))

tree = [[-1,-1,-1] for i in range(N+1)]
def make_tree(pre,ino):
    if len(pre)==0:
        return
    indx = ino.index(pre[0])
    if indx > 0:
        tree[pre[0]][1] = pre[1]
        tree[pre[1]][0] = pre[0]
        make_tree(pre[1:indx+1],ino[:indx])
    if indx != len(ino)-1:
        tree[pre[0]][2] = pre[indx+1]
        tree[pre[indx+1]][0] = pre[0]
        make_tree(pre[indx+1:],ino[indx+1:])
make_tree(pre,ino)

def pos(u,tree):
    res = []
    if tree[u][1] != -1:
        res += pos(tree[u][1],tree)
    if tree[u][2] != -1:
        res += pos(tree[u][2],tree)
    res += [str(u)]
    return res
ans = pos(pre[0],tree)
print(' '.join(ans))

"
3438062,ALDS1_7_D,"n = int(input())
*preorder, = map(int, input().split())
*inorder, = map(int, input().split())


def reconstruction(l, r):
    global preorder
    global inorder

    if l >= r:
        return """"
    a = """"
    c = preorder.pop(0)
    i = inorder.index(c)
    a += reconstruction(l, i)
    a += reconstruction(i+1, r)
    a += f""{c} ""
    return a


print(reconstruction(0, n).strip())

"
3461044,ALDS1_7_D,"def reconstruction(l, r, p):
    if l >= r:
        return
    c = next(pre)
    m = ino.index(c)
    reconstruction(l, m, p)
    reconstruction(m + 1, r, p)
    p += [c]
n = int(input())
pre = iter(list(map(int, input().split())))
ino = list(map(int, input().split()))
postorder = []
reconstruction(0, n, postorder)
print(' '.join(map(str, postorder)))
"
3537330,ALDS1_7_D,"n = int(input())
pre = list(map(int, input().split()))
ino = list(map(int, input().split()))

d = []
root = pre[0]
pre = iter(pre).__next__

def dfs(l, r):
    global d
    if l >= r:
        return
    c = pre()
    m = ino.index(c)
    dfs(l, m)
    dfs(m+1, r)
    d += [c]
    
dfs(0, len(ino))
print(*d)

"
3589313,ALDS1_7_D,"n = int(input())
preorderList = [int(i) for i in input().split()]
inorderList = [int(i) for i in input().split()]

class Node:
    def __init__(self, idn):
        self.id = idn
        self.left = -1
        self.right = -1
T = [Node(i+1) for i in range(n)]

def splitTree(P, I):
    b = I.index(P[0])
    if P[0] != I[0]:
        T[P[0]-1].left = P[1]
    if P[0] != I[-1]:
        T[P[0]-1].right = P[b+1]
    if b > 1:
        splitTree(P[1:b+1], I[:b])
    if b < len(I)-2:
        splitTree(P[b+1:], I[b+1:])

splitTree(preorderList, inorderList)
root = preorderList[0]

postorderList = []
def setPostorderList(p):
    if T[p-1].left != -1:
        setPostorderList(T[p-1].left)
    if T[p-1].right != -1:
        setPostorderList(T[p-1].right)
    postorderList.append(T[p-1].id)

setPostorderList(root)
print(*postorderList)

"
3599558,ALDS1_7_D,"class Tree:
    def __init__(self, *args):
        self.value, self.left, self.right = args

    def postorder(self):
        left = [] if self.left is None else self.left.postorder()
        right = [] if self.right is None else self.right.postorder()
        return left + right + [self.value]


def recover(pre, ino):
    preord = dict(map(lambda t: (t[1], t[0]), enumerate(pre)))

    def make_tree(tree):
        if len(tree) == 0:
            return None
        root_idx, root_value = min(enumerate(tree), key=lambda t: preord[t[1]])
        return Tree(
            root_value,
            make_tree(tree[:root_idx]),
            make_tree(tree[root_idx + 1:])
        )

    return make_tree(ino).postorder()


if __name__ == '__main__':
    _ = input()
    pre = list(map(int, input().split()))
    ino = list(map(int, input().split()))
    print(' '.join([str(t) for t in recover(pre, ino)]))
"
3636320,ALDS1_7_D,"def postorder(pre,inor):
    if len(pre) <= 1:
        return pre
    else:
        root = pre[0]
        i = inor.index(root)
        leftin = inor[:i]
        leftpre = pre[1:i+1]
        rightin = inor[i+1:]
        rightpre = pre[i+1:]
        left = postorder(leftpre,leftin)
        right = postorder(rightpre,rightin)
        return left+right+[root]
n = str(input())
pre = list(map(str,input().split()))
inor = list(map(str,input().split()))
print("" "".join(postorder(pre,inor)))
"
3662655,ALDS1_7_D,"index = 0
answer = []


def postorder_treewalk(left, right):
    if left >= right:
        return

    global index, answer

    node_mid = preorder[index]
    index += 1
    mid = inorder.index(node_mid)

    postorder_treewalk(left, mid)
    postorder_treewalk(mid + 1, right)
    answer += [node_mid]



n = int(input())
preorder = list(map(int, input().split()))
inorder = list(map(int, input().split()))


postorder_treewalk(0, n)
print(*answer)

"
3707214,ALDS1_7_D,"pos = 0
postorder = []
def reconstruction(l, r):
    global pos
    global postorder
    if l >= r:
        return
    # print(pos)
    c = preorder[pos]
    m = inorder.index(c)
    pos += 1
   
    # 左側を復元
    reconstruction(l, m)
    # 右側を復元
    reconstruction(m + 1, r)
    postorder.append(c)

n = int(input())
preorder = list(map(int, input().split()))
inorder = list(map(int, input().split()))

reconstruction(0, n)
print("" "".join(map(str, postorder)))
"
3803979,ALDS1_7_D,"class Node():
    def __init__(self, parent=-1, left=-1, right=-1):
        self.parent = parent
        self.left = left
        self.right = right
def postorder(ns,i, post):
    if ns[i].left != -1:
        postorder(ns,ns[i].left ,post)
    if ns[i].right != -1:
        postorder(ns,ns[i].right ,post)
    post.append(str(i+1))
def poio_node(ns,po,io):
    root = po[0]
    i = io.index(root)
    if i!=0: # root의 왼쪽노드가 존재한다면 왼쪽으로 재귀
        ns[po[0]].left = po[1]
        ns[po[1]].parent = po[0]
        poio_node(ns,po[1:i+1],io[:i]) # po, io 안의 왼쪽 노드들로만 재귀
    if i!=len(io)-1: # root의 오른쪽 노드가 존재한다면 오른쪽으로 재귀
        ns[po[0]].right = po[i+1]
        ns[po[i+1]].parent = po[0]
        poio_node(ns, po[i+1:], io[i+1:]) # po, io 안의 오른쪽 노드들로만 재귀
def min1(n):
    return (n-1)
n = int(input())
po = list(map(int,input().split()))
io = list(map(int,input().split()))
po = list(map(min1,po))   ##0~(n-1)로 변환
io = list(map(min1,io))
ns =  [Node()for i in range(n)]

poio_node(ns, po, io)

post = []
postorder(ns, po[0], post)
print("" "".join(post))
"
8527716,ALDS1_8_A,"import sys

# READ_FROM_FILE = True
READ_FROM_FILE = False


class Node:
    def __init__(self, parent, key):
        self.key = key
        self.parent = parent
        self.left = None
        self.right = None
        return


def insert(root, i_n):
    parent = None
    c_n = root

    while c_n is not None:
        parent = c_n

        if i_n.key < c_n.key:
            c_n = c_n.left
        else:
            c_n = c_n.right

    i_n.parent = parent
    if root is None:
        root = i_n
    elif i_n.key < parent.key:
        parent.left = i_n
    else:
        parent.right = i_n

    return root


def print_in_order(c_n):
    if c_n is None:
        return

    print_in_order(c_n.left)
    print(f' {c_n.key}', end='')
    print_in_order(c_n.right)
    return


def print_pre_order(c_n):
    if c_n is None:
        return

    print(f' {c_n.key}', end='')
    print_pre_order(c_n.left)
    print_pre_order(c_n.right)
    return


def main():
    if READ_FROM_FILE:
        f = open('test0.txt', 'r')
    else:
        f = sys.stdin

    m = int(f.readline())
    root = None

    for _ in range(m):
        op = f.readline().split()

        if len(op) > 1:
            key = int(op[1])
            node = Node(None, key)
            root = insert(root, node)
        else:
            print_in_order(root)
            print()
            print_pre_order(root)
            print()

    if READ_FROM_FILE:
        f.close()
    return


if __name__ == '__main__':
    main()


"
8448844,ALDS1_8_A,"a = []
t = []

for _ in range(int(input())):
    i = input()
    if i[0] == 'i':
        i = int(i.split()[1])
        t.append(i)
        w = a
        while w: w = w[1] if w[0] > i else w[2]
        w += [i, [], []]
    else:
        t.sort()
        print('', *t)
        l = [a]
        while l:
            i = l.pop()
            if i:
                print('', i[0], end='')
                l += i[:0:-1]
        print()
"
8710319,ALDS1_8_A,"import sys
input = sys.stdin.readline

NIL = -1

m = int(input())

root = NIL

def insert(k):
    global root
    y = NIL
    x = root
    z = {'key':k, 'left':NIL, 'right':NIL}
    while x != NIL:
        y = x
        if z['key'] < x['key']:
            x = x['left']
        else:
            x = x['right']
    z['parent'] = y

    if y == NIL:
        root = z
    elif z['key'] < y['key']:
        y['left'] = z
    else:
        y['right'] = z

def inorder(u):
    if u == NIL:
        return
    inorder(u['left'])
    print(' ' + str(u['key']), end='')
    inorder(u['right'])

def preorder(u):
    if u == NIL:
        return
    print(' ' + str(u['key']), end='')
    preorder(u['left'])
    preorder(u['right'])

for _ in range(m):
    command = input()
    if command[:6] == 'insert':
        _, x = command.split()
        x = int(x)
        insert(x)
    else:
        inorder(root)
        print('')
        # pythonのprintは最後に改行記号をつけてくれるので、これで改行できる
        preorder(root)
        print('')
"
9003631,ALDS1_8_A,"class Node:
    def __init__(self, key):
        self.key=key
        self.left=None
        self.right=None
        self.p=None
root=None
def insert(z):
    global root
    y=None
    x=root
    while x is not None:
        y=x
        if z.key < x.key:
            x=x.left
        else:
            x=x.right
    z.p=y
    if y is None:
        root=z
    elif z.key < y.key:
        y.left=z
    else:
        y.right=z

def print_order(num):
    global inorder, preorder
    preorder.append(str(num.key))
    if num.left is not None:
        print_order(num.left)
    inorder.append(str(num.key))
    if num.right is not None:
        print_order(num.right)    

m=int(input())
for _ in range(m):
    order = list(input().split())
    if order[0] == ""insert"":
        insert(Node(int(order[1])))
    else:
        inorder=[]
        preorder=[]
        print_order(root)
        print("" ""+"" "".join(inorder))
        print("" ""+"" "".join(preorder))
"
8385693,ALDS1_8_A,"class Node():
    def __init__(self, key):
        self.key = key
        self.parent = None
        self.left = None
        self.right = None


class Tree():
    def __init__(self):
        self.root = None


    def in_order(self):
        def exe(x):
            if x:
                exe(x.left)
                print("" {}"".format(x.key), end="""")
                exe(x.right)
        exe(self.root)


    def pre_order(self):
        def exe(x):
            if x:
                print("" {}"".format(x.key), end="""")
                exe(x.left)
                exe(x.right)
        exe(self.root)


    def insert(self, key):
        z = Node(key)
        y = None
        x = self.root
        while x:
            y = x
            if z.key < x.key:
                x = x.left
            else:
                x = x.right
            # この時点において, y は x の親.
        z.parent = y
        if not y:
            self.root = z
        elif z.key < y.key:
            y.left = z
        else:
            y.right = z


def main():
    n = int(input())
    T = Tree()
    for i in range(n):
        cmd = input().split()
        if len(cmd) == 1:
            T.in_order()
            print()
            T.pre_order()
            print()
        else:
            T.insert(int(cmd[1]))


if __name__ == ""__main__"":
    main()
"
8338996,ALDS1_8_A,"# Nodeクラスの定義。各ノードはキー、左の子、右の子、親を持つ。
class Node:
    def __init__(self, key):
        self.key = key       # ノードのキー値
        self.right = None    # 右の子ノードへの参照
        self.left = None     # 左の子ノードへの参照
        self.parent = None   # 親ノードへの参照

# 二分探索木のルートノードの初期化
root = None

# キーを持つ新しいノードを二分探索木に挿入する関数
def insert(key):
    global root                     # グローバル変数rootを関数内で使用する宣言
    par_node = None                        # 新しいノードの親ノードを初期化
    cur_node = root                 # 現在のノードとしてルートを開始
    new_node = Node(key)              # 新しいノードの作成

    # 適切な挿入位置（空っぽのノード）を探す
    while cur_node is not None:
        
        # 現在のノードを親として保存
        par_node = cur_node
        
        # 新しいノードのキーが現在のノードのキー未満の場合、左に移動        
        if new_node.key < cur_node.key:  
            cur_node = cur_node.left
        else:  # それ以外の場合、右に移動
            cur_node = cur_node.right

    # 新しいノードは親だけを設定、cur_nodeは何もしない
    new_node.parent = par_node
    
    if par_node is None:  # 木が空の場合、新しいノードをルートとして設定
        root = new_node
    else: # 親ノードの子を設定
        # 新しいノードのキーが親のキー未満の場合、左の子として設定
        if new_node.key < par_node.key:
            par_node.left = new_node
        else:              # それ以外の場合、右の子として設定
            par_node.right = new_node

# 中間順で二分探索木を巡回する関数
def inOrder(node):
    if node is None:
        return
    inOrder(node.left)        # 左の子ノードを再帰
    print(f' {node.key}', end="""")  
    inOrder(node.right)       # 右の子ノードを再帰

# 先行順で二分探索木を巡回する関数
def preOrder(node):
    if node is None:
        return
    print(f' {node.key}', end="""")
    preOrder(node.left)       # 左の子ノードを再帰
    preOrder(node.right)      # 右の子ノードを再帰

# メイン関数
def main():
    n = int(input())

    # 各操作に対して
    for _ in range(n):
        cmd = input().split()
        
        # ""insert""操作の場合
        if cmd[0] == ""insert"":  
            key = int(cmd[1])
            insert(key)
        
        # ""print""操作の場合
        elif cmd[0] == ""print"": 
            inOrder(root)
            print()
            preOrder(root)
            print()

# スクリプトとして実行された場合、メイン関数を呼び出す
if __name__ == ""__main__"":
    main()

"
8802084,ALDS1_8_A,"class Node:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.parent = None

class BinarySearchTree:
    def __init__(self):
        self.root = None

    def insert(self, key):
        node = Node(key)
        if self.root is None:
            self.root = node
        else:
            current = self.root
            while True:
                parent = current
                if node.key < current.key:
                    current = current.left
                    if current is None:
                        parent.left = node
                        node.parent = parent
                        break
                else:
                    current = current.right
                    if current is None:
                        parent.right = node
                        node.parent = parent
                        break

    def inorder(self, node):
        if node is not None:
            self.inorder(node.left)
            print(f' {node.key}', end='')
            self.inorder(node.right)

    def preorder(self, node):
        if node is not None:
            print(f' {node.key}', end='')
            self.preorder(node.left)
            self.preorder(node.right)

tree = BinarySearchTree()
n = int(input())
for i in range(n):
    command = input().split()
    if command[0] == 'insert':
        tree.insert(int(command[1]))
    elif command[0] == 'print':
        tree.inorder(tree.root)
        print()
        tree.preorder(tree.root)
        print()

"
9113152,ALDS1_8_A,"class Node():
    def __init__(self, key):
        self.key = key
        self.parent: Node = None
        self.left: Node = None
        self.right: Node = None


ROOT: Node = None


def preParse(root: Node):
    print(f' {root.key}', end='')
    if root.left != None:
        preParse(root.left)
    if root.right != None:
        preParse(root.right)


def inParse(root: Node):
    if root.left != None:
        inParse(root.left)
    print(f' {root.key}', end='')
    if root.right != None:
        inParse(root.right)


def insertNode(root: Node, key):
    global ROOT
    parent = root
    new_node = Node(key)

    target = root
    while target != None:
        parent = target
        if new_node.key < parent.key:
            target = target.left
        else:
            target = target.right

    new_node.parent = parent

    if parent == None:
        ROOT = new_node
    elif new_node.key < parent.key:
        parent.left = new_node
    else:
        parent.right = new_node


N = int(input())
for _ in range(N):
    command = input().split()
    if len(command) == 2:
        insertNode(ROOT, int(command[1]))
    else:
        inParse(ROOT)
        print()
        preParse(ROOT)
        print()

"
8899430,ALDS1_8_A,"class Node():
    def __init__(self,key):
        self.key=key
        self.left=None
        self.right=None
        self.p=None

root=None
def insert(z):
    global root
    y=None
    x=root
    while x!=None:
        y=x
        if z.key<x.key:
            x=x.left
        else:
            x=x.right
        
    z.p=y
    if y==None:
        root=z
    elif z.key<y.key:
        y.left=z
    else:
        y.right=z

def preord(node):
    global preorder
    preorder.append(node.key)
    if node.left!=None:
        preord(node.left)
    if node.right!=None:
        preord(node.right)

def inord(node):
    global inorder
    if node.left!=None:
        inord(node.left)
    inorder.append(node.key)
    if node.right!=None:
        inord(node.right)


n=int(input())

for i in range(n):
    s=list(input().split())
    if s[0]=='print':
        preorder=[]
        inorder=[]
        inord(root)
        preord(root)
        print(' ',end='')
        print(*inorder)
        print(' ',end='')
        print(*preorder)
    else:
        insert(Node(int(s[1])))
    
"
8824036,ALDS1_8_A,"# aizu_ALDS1_8_A_BinarySearchTreeI.py  

class Node:
    def __init__(self,key):
        self.key = key
        self.parent = None
        self.left = None
        self.right = None

def preorder(id):
    if id == None:return
    que.append(id.key)
    n_id = id.left
    preorder(n_id)
    n_id = id.right
    preorder(n_id)

def inorder(id):
    if id == None:return
    n_id = id.left
    inorder(n_id)  
    que.append(id.key)
    n_id = id.right
    inorder(n_id)  

def insert(zz):
    global root
    z = Node(zz)
    y = None
    x = root
    while x!= None:
        y = x
        if z.key < x.key: x = x.left
        else: x = x.right
    z.parent = y

    if y == None:
        root = z
    elif z.key < y.key: y.left = z
    else: y.right = z

root = None    
m = int(input())
for _ in range(m):
    *ope, = input().split()
    if ope[0] == 'insert': insert(int(ope[1]))
    if ope[0] == 'print':
        que = []; inorder(root) ; print('',*que)
        que = []; preorder(root); print('',*que)
"
9090259,ALDS1_8_A,"class Node:
    def __init__(self, key:int) -> None:
        self.key: int = key
        self.parent: Node = None
        self.left: Node = None
        self.right: Node = None
    def order(self, mode: str):
        li = {
            ""Pre"": [0, 1, 2],  # 先行順巡回 node -> left -> right 
            ""In"": [1, 0, 2],   # 中間順巡回 left -> node -> right
            ""Post"": [1, 2, 0]  # 後方順巡回 right -> left -> right
        }
        for i in li[mode]:
            if i == 0: print(f"" {self.key}"", end = """")
            elif i == 1 and self.left != None : self.left.order(mode)
            elif i == 2 and self.right != None: self.right.order(mode)
        
class BinarySearchTree:
    def __init__(self) -> None:
        self.node: Node = None

def insert(t: BinarySearchTree, z : Node) -> None:
    y: Node = None  # x の親
    x: Node = t.node
    while x != None:
        y = x # 親を設定
        if z.key < x.key:
            x = x.left
        else:
            x = x.right
    z.parent = y
    if y == None:
        t.node = z
    elif z.key < y.key:
        y.left = z
    else:
        y.right = z

def ans(t: BinarySearchTree):
    t.node.order(""In"")  
    print()
    t.node.order(""Pre"")     
    print()
    
n = int(input())
t = BinarySearchTree()
for _ in range(n):
    order = input()
    if order[0] == ""i"": insert(t, Node(int(order[7:])))
    else: ans(t)

"
5488290,ALDS1_8_A,"import sys

class Node:
    __slots__ = ['key', 'left', 'right']
    def __init__(self, key):
        self.key = key
        self.left = self.right = None

root = None

def insert(key):
    global root
    x, y = root, None
    while x: x, y = x.left if key < x.key else x.right, x
    if y is None: root = Node(key)
    elif key < y.key: y.left = Node(key)
    else: y.right = Node(key)

def inorder(node):
    return inorder(node.left) + f' {node.key}' + inorder(node.right) if node else ''
def preorder(node):
    return f' {node.key}' + preorder(node.left) + preorder(node.right) if node else ''

input()
for e in sys.stdin:
    if e[0] == 'i': insert(int(e[7:]))
    else: print(inorder(root)); print(preorder(root))

"
4119203,ALDS1_8_A,"import sys

class Node:
    __slots__ = ['key', 'left', 'right']
    def __init__(self, key):
        self.key = key
        self.left = self.right = None

root = None

def insert(key):
    global root
    x, y = root, None
    while x: x, y = x.left if key < x.key else x.right, x
    if y is None: root = Node(key)
    elif key < y.key: y.left = Node(key)
    else: y.right = Node(key)

def inorder(node):
    return inorder(node.left) + f' {node.key}' + inorder(node.right) if node else ''
def preorder(node):
    return f' {node.key}' + preorder(node.left) + preorder(node.right) if node else ''

input()
for e in sys.stdin:
    if e[0] == 'i': insert(int(e[7:]))
    else: print(inorder(root)); print(preorder(root))
"
4254065,ALDS1_8_A,"import sys

class Node:
    __slots__ = ['key', 'left', 'right']
    def __init__(self, key):
        self.key = key
        self.left = self.right = None

root = None

def insert(key):
    global root
    x, y = root, None
    while x: x, y = x.left if key < x.key else x.right, x
    if y is None: root = Node(key)
    elif key < y.key: y.left = Node(key)
    else: y.right = Node(key)

def inorder(node):
    return inorder(node.left) + f' {node.key}' + inorder(node.right) if node else ''
def preorder(node):
    return f' {node.key}' + preorder(node.left) + preorder(node.right) if node else ''

input()
for e in sys.stdin:
    if e[0] == 'i': insert(int(e[7:]))
    else: print(inorder(root)); print(preorder(root))

"
4305542,ALDS1_8_A,"import sys

class Node:
    __slots__ = ['key', 'left', 'right']
    def __init__(self, key):
        self.key = key
        self.left = self.right = None

root = None

def insert(key):
    global root
    x, y = root, None
    while x: x, y = x.left if key < x.key else x.right, x
    if y is None: root = Node(key)
    elif key < y.key: y.left = Node(key)
    else: y.right = Node(key)

def inorder(node):
    return inorder(node.left) + f' {node.key}' + inorder(node.right) if node else ''
def preorder(node):
    return f' {node.key}' + preorder(node.left) + preorder(node.right) if node else ''

input()
for e in sys.stdin:
    if e[0] == 'i': insert(int(e[7:]))
    else: print(inorder(root)); print(preorder(root))
"
4483533,ALDS1_8_A,"import sys

class Node():
    #key = ตัว z เอง และตัวด้านซ้ายด้านขวา
    __slots__ = ['key', 'left', 'right']
    def __init__(self, key):
        self.key = key
        self.left, self.right = None, None
        
    def __str__(self):
        return self.key

root = None
#z คือรับเลขเข้ามาว่าจะ insert ค่าไหน
def insert(z):
    global root
    x, y = root, None
    #ทำการ update ค่า y ว่าตัวไหนเป็น root ต่อไป โดยมาเทียบกับ root ว่าจะลงซ้ายหรือขวา
    while x:
        y = x
        if z < x.key:
            x = x.left
        else:
            x = x.right
    
    if y == None:
       #ทำการ update ค่า y ให้ อีกที ว่าอะไรเป็น left เป็น right 
        root = Node(z)
    elif z < y.key:
        y.left = Node(z)
    else:
        y.right = Node(z)
        
#root->left->right        
def preorder(x):
    return f"" {x.key}"" + preorder(x.left) + preorder(x.right) if x else """"
#left-root-right
def inorder(x):
    return inorder(x.left) + f"" {x.key}"" + inorder(x.right) if x else """"
        
input()
#รับค่าทีละบรรทัด
node = {}
for s in sys.stdin:
    if s[0] == ""p"":
        #ถ้าเป็น p ก็ print ถ้าไม่เป็น p ดู ตน. 7 คือ ตัวเลข
        pass
        print(inorder(root))
        print(preorder(root))
    else:
        insert(int(s[7:]))

"
4090161,ALDS1_8_A,"import sys

class Node:
    __slots__ = ['key', 'left', 'right']
    def __init__(self, key):
        self.key = key
        self.left = self.right = None

root = None

def insert(key):
    global root
    x, y = root, None
    while x: x, y = x.left if key < x.key else x.right, x
    if y is None: root = Node(key)
    elif key < y.key: y.left = Node(key)
    else: y.right = Node(key)

def inorder(node):
    return inorder(node.left) + f' {node.key}' + inorder(node.right) if node else ''
def preorder(node):
    return f' {node.key}' + preorder(node.left) + preorder(node.right) if node else ''

input()
for e in sys.stdin:
    if e[0] == 'i': insert(int(e[7:]))
    else: print(inorder(root)); print(preorder(root))

"
3120635,ALDS1_8_A,"import sys
class Node:
    __slots__ = ['key', 'left', 'right']
    def __init__(self, key):
        self.key = key
        self.left = self.right = None

root = None

def insert(key):
    global root
    y = None  # xの親
    x = root
    while x:
        y = x
        x = x.left if key < x.key else x.right
    if y is None:  # Tが空の場合
        root = Node(key)
    elif key < y.key:
        y.left = Node(key)
    else:
        y.right = Node(key)

def in_order(node):
    if node is None:
        return ''
    return in_order(node.left) + f' {node.key}' + in_order(node.right)
def pre_order(node):
    if node is None:
        return ''
    return f' {node.key}' + pre_order(node.left) + pre_order(node.right)
input()
for e in sys.stdin:
    if e[0] == 'i':
        insert(int(e[7:]))
    else:
        print(in_order(root))
        print(pre_order(root))
"
4470599,ALDS1_8_A,"import sys
class Node:
    __slots__ = ['key', 'left', 'right']
    def __init__(self, key):
        self.key = key
        self.left = self.right = None

root = None

def insert(key):
    global root
    x, y = root, None
    while x:
        y = x
        if key < x.key:
            x = x.left
        else:
            x = x.right

    if y is None:
        root = Node(key)
    elif key < y.key:
        y.left = Node(key)
    else:
        y.right = Node(key)

def inorder(node):
    return inorder(node.left) + f' {node.key}' + inorder(node.right) if node else ''
def preorder(node):
    return f' {node.key}' + preorder(node.left) + preorder(node.right) if node else ''

n = int(input())
for e in sys.stdin:
    if e[0] == 'i':
        insert(int(e[7:]))
    else:
        print(inorder(root))
        print(preorder(root))
"
4906468,ALDS1_8_A,"import sys

class Node:
    # slotsで使用する属性を指定することで処理が早くなるらしい
    __slots__ = [""key"", ""left"", ""right""]
    def __init__(self, key):
        self.key = key
        self.left = self.right = None

root = None

def insert(key):
    global root
    x, y = root, None
    while x:
        # 連続で書いてあるため見えづらいが、xはx.left if key < x.key else x.rightの条件式の結果を代入
        # はxを代入している
        x,y = x.left if key < x.key else x.right, x
    if y is None: root = Node(key)
    elif key < y.key: y.left = Node(key)
    else: y.right = Node(key)

def inorder(node):
    # 左,根,右の順で表示する
    return inorder(node.left) + f' {node.key}' + inorder(node.right) if node else ''
def preorder(node):
    # 根,左,右の順で表示する
    return f' {node.key}' + preorder(node.left) + preorder(node.right) if node else ''

input()
for e in sys.stdin:
    if e[0] == ""i"": insert(int(e[7:]))
    else: print(inorder(root)); print(preorder(root))
"
5329380,ALDS1_8_A,"import sys

class Node:
    __slots__ = ['key', 'left', 'right']
    def __init__(self, key):
        self.key = key
        self.left = self.right = None

root = None

def insert(key):
    global root
    x, y = root, None
    while x: x, y = x.left if key < x.key else x.right, x
    if y is None: root = Node(key)
    elif key < y.key: y.left = Node(key)
    else: y.right = Node(key)

def inorder(node):
    return inorder(node.left) + f' {node.key}' + inorder(node.right) if node else ''
def preorder(node):
    return f' {node.key}' + preorder(node.left) + preorder(node.right) if node else ''

input()
for e in sys.stdin:
    if e[0] == 'i': insert(int(e[7:]))
    else: print(inorder(root)); print(preorder(root))
"
2721898,ALDS1_8_A,"import sys

class Node:
    __slots__ = ['key', 'left', 'right']
    def __init__(self, key):
        self.key = key
        self.left = self.right = None

root = None

def insert(key):
    global root
    x, y = root, None
    while x: x, y = x.left if key < x.key else x.right, x
    if y is None: root = Node(key)
    elif key < y.key: y.left = Node(key)
    else: y.right = Node(key)

def inorder(node):
    return inorder(node.left) + f' {node.key}' + inorder(node.right) if node else ''
def preorder(node):
    return f' {node.key}' + preorder(node.left) + preorder(node.right) if node else ''

input()
for e in sys.stdin:
    if e[0] == 'i': insert(int(e[7:]))
    else: print(inorder(root)); print(preorder(root))
"
4052044,ALDS1_8_A,"import sys


class Node:
    __slots__ = ['key', 'left', 'right']

    def __init__(self, key):
        self.key = key
        self.left = self.right = None


root = None


def insert(key):
    global root
    x, y = root, None
    while x:
        y = x
        if key < x.key:
            x= x.left
        else:
            x = x.right

    if y is None:
        root = Node(key)
    elif key < y.key:
        y.left = Node(key)
    else:
        y.right = Node(key)


def inorder(node):
    return inorder(node.left) + f' {node.key}' + inorder(node.right) if node else ''


def preorder(node):
    return f' {node.key}' + preorder(node.left) + preorder(node.right) if node else ''


input()
for e in sys.stdin:
    if e[0] == 'i':
        insert(int(e[7:]))
    else:
        print(inorder(root)); print(preorder(root))
"
2835173,ALDS1_8_A,"import sys

class Node():
    __slots__ = ['key', 'left', 'right']
    def __init__(self, key):
        self.key = key
        self.left, self.right = None, None
        
    def __str__(self):
        return self.key

root = None
def insert(z):
    global root
    x, y = root, None
    while x:
        y = x
        if z < x.key:
            x = x.left
        else:
            x = x.right
    
    if y == None:
        root = Node(z)
    elif z < y.key:
        y.left = Node(z)
    else:
        y.right = Node(z)
        
def preorder(x):
    return f"" {x.key}"" + preorder(x.left) + preorder(x.right) if x else """"

def inorder(x):
    return inorder(x.left) + f"" {x.key}"" + inorder(x.right) if x else """"
        
input()
node = {}
for s in sys.stdin:
    if s[0] == ""p"":
        pass
        print(inorder(root))
        print(preorder(root))
    else:
        insert(int(s[7:]))
"
4481276,ALDS1_8_A,"import sys

class Node():
    __slots__ = ['key', 'left', 'right']
    def __init__(self, key):
        self.key = key
        self.left, self.right = None, None
        
    def __str__(self):
        return self.key

root = None
def insert(z):
    global root
    x, y = root, None
    while x:
        y = x
        if z < x.key:
            x = x.left
        else:
            x = x.right
    
    if y == None:
        root = Node(z)
    elif z < y.key:
        y.left = Node(z)
    else:
        y.right = Node(z)
        
def preorder(x):
    return f"" {x.key}"" + preorder(x.left) + preorder(x.right) if x else """"

def inorder(x):
    return inorder(x.left) + f"" {x.key}"" + inorder(x.right) if x else """"
        
input()
node = {}
for s in sys.stdin:
    if s[0] == ""p"":
        pass
        print(inorder(root))
        print(preorder(root))
    else:
        insert(int(s[7:]))
"
4623696,ALDS1_8_A,"import sys
# def input():
#     return sys.stdin.readline()[:-1]

# n = int(input())
# A = [input().split() for i in range(n)]

class Node():
    __slots__ = ['key', 'left', 'right']
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None


def insert(key):
    global root
    x = root # x is current node
    y = None  #  parent of x 
    while x:
        y = x # set parent
        if key < x.key:
            x = x.left # move to left child
        else:
            x = x.right #move to right child
    
    if root is None:
        root = Node(key)
    elif key < y.key: # set z as left child of y
        y.left = Node(key)
    else: 
        y.right = Node(key) # set z as right child of y
        

def inorder(inorder_list, node):
    if node.left is not None:
        inorder(inorder_list, node.left)
    inorder_list.append(str(node.key))
    if node.right is not None:
        inorder(inorder_list, node.right)
    return inorder_list
        
def preorder(preorder_list, node):
    preorder_list.append(str(node.key))
    if node.left is not None:
        preorder(preorder_list, node.left)
    if node.right is not None:
        preorder(preorder_list, node.right)
    return preorder_list
        
root = None

input()
for o in sys.stdin:
    if o[0]=='i':
        insert(int(o[7:]))
    else:
        x = root
        inorder_list = inorder([], x)
        print(' '+' '.join(inorder_list))
        preorder_list = preorder([], x)
        print(' '+' '.join(preorder_list))
"
8281352,ALDS1_8_A,"class Node:
    def __init__(self, key: int, left = None, right = None, parent = None):
        self.key = key
        self.left = left
        self.right = right
        self.parent = parent
    def __str__(self):
        return self.key

class BinarySearchTree:
    def __init__(self, root = None):
        self.root = root
    
    def insert(self, z: Node) -> None:
        x = self.root # Tの根
        y = None # xの親
        # 木を探索
        while x != None:
            y = x # 親を設定
            if z.key < x.key:
                x = x.left
            else:
                x = x.right
        z.parent = y

        if y == None:
            self.root = z
        elif z.key < y.key:
            y.left = z
        else:
            y.right = z
    
    def inorder(self, left: Node, root: Node, right: Node) -> list:
        if left != None and right != None:
            left = self.inorder(left.left, left, left.right)
            right = self.inorder(right.left, right, right.right)
            return left + [root] + right
        elif left != None and right == None:
            left = self.inorder(left.left, left, left.right)
            return left + [root]
        elif left == None and right != None:
            right = self.inorder(right.left, right, right.right)
            return [root] + right
        else:
            return [root]
    
    def print_inorder(self) -> list:
        inorder_list = self.inorder(self.root.left, self.root, self.root.right)
        ans = []
        for node in inorder_list:
            ans.append(node.key)
        return ans
    
    def preorder(self, left: Node, root: Node, right: Node) -> list:
        if left != None and right != None:
            left = self.preorder(left.left, left, left.right)
            right = self.preorder(right.left, right, right.right)
            return [root] + left + right
        elif left != None and right == None:
            left = self.preorder(left.left, left, left.right)
            return [root] + left
        elif left == None and right != None:
            right = self.preorder(right.left, right, right.right)
            return [root] + right
        else:
            return [root]
        
    def print_preorder(self) -> list:
        preorder_list = self.preorder(self.root.left, self.root, self.root.right)
        ans = []
        for node in preorder_list:
            ans.append(node.key)
        return ans
    
    def postorder(self, left: Node, root: Node, right: Node) -> list:
        if left != None and right != None:
            left = self.postorder(left.left, left, left.right)
            right = self.postorder(right.left, right, right.right)
            return left + right + [root]
        elif left != None and right == None:
            left = self.postorder(left.left, left, left.right)
            return left + [root]
        elif left == None and right != None:
            right = self.postorder(right.left, right, right.right)
            return right + [root]
        else:
            return [root]
        
    def print_postorder(self) -> list:
        postorder_list = self.postorder(self.root.left, self.root, self.root.right)
        ans = []
        for node in postorder_list:
            ans.append(node.key)
        return ans


if __name__==""__main__"":
    BST = BinarySearchTree()
    n = int(input())
    for i in range(n):
        mei, *key = input().split()
        if mei == ""insert"":
            key = int(key[0])
            BST.insert(Node(key))
        elif mei == ""print"":
            print("""", *BST.print_inorder())
            print("""", *BST.print_preorder())
"
5426568,ALDS1_8_A,"import sys

class Node:
    __slots__ = ['key', 'left', 'right']
    def __init__(self, key):
        self.key = key
        self.left = self.right = None

root = None

def insert(key):
    global root
    x, y = root, None
    while x: x, y = x.left if key < x.key else x.right, x
    if y is None: root = Node(key)
    elif key < y.key: y.left = Node(key)
    else: y.right = Node(key)

def inorder(node):
    return inorder(node.left) + f' {node.key}' + inorder(node.right) if node else ''
def preorder(node):
    return f' {node.key}' + preorder(node.left) + preorder(node.right) if node else ''

input()
for e in sys.stdin:
    if e[0] == 'i': insert(int(e[7:]))
    else: print(inorder(root)); print(preorder(root))
"
8934239,ALDS1_8_A,"class Node:
    def __init__(self, data: int) -> None:
        self.data = data
        self.left = None
        self.right = None

class BinarySearchTree:
    def __init__(self, number_list: list = []) -> None:
        """"""初期化""""""
        self.root = None
        for num in number_list:
            self.insert(num)

    def insert(self, data) -> None:
        """"""挿入""""""
        n = self.root
        if n == None:
            self.root = Node(data)
            return
        else:
            while 1:
                entry = n.data
                if data < entry:
                    if n.left is None:
                        n.left = Node(data)
                        return
                    n = n.left
                elif data > entry:
                    if n.right is None:
                        n.right = Node(data)
                        return
                    n = n.right
                else:
                    n.data = data
                    return

    def search(self, search: int) -> bool:
        """"""探索(存在するか)""""""
        searcher = self._search_bool(search)
        if searcher is None:
            raise Exception
        return searcher

    def preorder(self, root: int = None) -> list:
        """"""先行順探索""""""
        res = []
        def _preorder(node: int) -> None:
            if node is None:
                return
            res.append(node.data)
            _preorder(node.left)
            _preorder(node.right)

        if root is None:
            root = self.root
        _preorder(root)
        return res

    def inorder(self, root: int = None) -> list:
        """"""中間順探索""""""
        res = []
        def _inorder(node: int) -> None:
            if node is None:
                return
            _inorder(node.left)
            res.append(node.data)
            _inorder(node.right)

        if root is None:
            root = self.root
        _inorder(root)
        return res

    def postorder(self, root: int = None) -> list:
        """"""後行順探索""""""
        res = []
        def _postorder(node: int) -> None:
            if node is None:
                return
            _postorder(node.left)
            _postorder(node.right)
            res.append(node.data)

        if root is None:
            root = self.root
        _postorder(root)
        return res

    def _search_bool(self, search) -> bool:
        n = self.root
        if n is None:
            raise Exception
        lst = [n]
        while lst:
            node = lst.pop()
            if node.data == search:
                return True
            if node.right is not None:
                lst.append(node.right)
            if node.left is not None:
                lst.append(node.left)
        return False

m = int(input())
t = BinarySearchTree()
for _ in range(m):
    s = input().split()
    if s[0] == ""insert"":
        k = int(s[1])
        t.insert(data=k)
    elif s[0] == ""print"":
        print("""", *t.inorder())
        print("""", *t.preorder())

"
6813964,ALDS1_8_A,"import sys
root = None
class Node:
    __slots__ = ['key', 'left', 'right']

    def __init__(self, key):
        self.key = key
        self.left = self.right = None
def insert(key):
    global root
    x, y = root, None
    while x: x, y = x.left if key < x.key else x.right, x
    if y is None:
        root = Node(key)
    elif key < y.key:
        y.left = Node(key)
    else:
        y.right = Node(key)

def preorder(node):
    return f' {node.key}' + preorder(node.left) + preorder(node.right) if node else ''
def inorder(node):
    return inorder(node.left) + f' {node.key}' + inorder(node.right) if node else ''


sys.stdin.readline()
for line in sys.stdin:
    line = line.split()
    if line[0] == ""insert"":
        insert(int(line[1]))
    else:
        print(inorder(root))
        print(preorder(root))



"
6814136,ALDS1_8_A,"import sys
root = None
class Node:
    __slots__ = ['key', 'left', 'right']

    def __init__(self, key):
        self.key = key
        self.left = self.right = None
def insert(key):
    global root
    x, y = root, None
    while x: x, y = x.left if key < x.key else x.right, x
    if y is None:
        root = Node(key)
    elif key < y.key:
        y.left = Node(key)
    else:
        y.right = Node(key)


def inorder(node):
    return inorder(node.left) + f' {node.key}' + inorder(node.right) if node else ''

def preorder(node):
    return f' {node.key}' + preorder(node.left) + preorder(node.right) if node else ''
sys.stdin.readline()
for line in sys.stdin:
    line = line.split()
    if line[0] == ""insert"":
        insert(int(line[1]))
    else:
        print(inorder(root))
        print(preorder(root))

"
6062770,ALDS1_8_A,"import sys


class Node:
    __slots__ = ['key', 'left', 'right']

    def __init__(self, key):
        self.key = key
        self.left = self.right = None


root = None


def insert(key):
    global root
    x, y = root, None
    while x: x, y = x.left if key < x.key else x.right, x
    if y is None:
        root = Node(key)
    elif key < y.key:
        y.left = Node(key)
    else:
        y.right = Node(key)


def inorder(node):
    return inorder(node.left) + f' {node.key}' + inorder(node.right) if node else ''


def preorder(node):
    return f' {node.key}' + preorder(node.left) + preorder(node.right) if node else ''


sys.stdin.readline()
for line in sys.stdin:
    line = line.split()
    if line[0] == ""insert"":
        insert(int(line[1]))
    else:
        print(inorder(root))
        print(preorder(root))
"
8341096,ALDS1_8_A,"class Node:
  def __init__(self, key):
    self.key = key

    self.left  = None
    self.right = None


def insert(new_node_key):
  global tree

  new_node = Node(new_node_key)

  if tree is None:
    # Make `new_node` as root of `tree`.
    tree = new_node
    return
  
  # Find branch to insert `new_node`.
  branch = tree
  while True:
    if new_node.key < branch.key:
      if branch.left is None:
        break
      # Move to left.
      branch = branch.left
    else:
      if branch.right is None:
        break
      # Move to right.
      branch = branch.right
  
  if new_node.key < branch.key:
    # Insert `new_node` as left of `branch`.
    branch.left = new_node
  else:
    # Insert `new_node` as right of `branch`.
    branch.right = new_node

def walk_tree(tree, fns):
  def walk(tree):
    if tree is None:
      return
    for f in fns:
      f(walk, tree)
  walk(tree)

def print_tree():
  # Print as inorder.
  walk_tree(tree, [
    lambda walk, node: walk(node.left),
    lambda walk, node: print(' ' + str(node.key), end=''),
    lambda walk, node: walk(node.right),
    ])
  print()

  # Print as preorder.
  walk_tree(tree, [
    lambda walk, node: print(' ' + str(node.key), end=''),
    lambda walk, node: walk(node.left),
    lambda walk, node: walk(node.right),
    ])
  print()


# Init tree.
tree = None

# Run.
num_insts = int(input())

for _ in range(num_insts):
  toks = input().split()
  if toks[0] == 'insert':
    insert(int(toks[1]))
  elif toks[0] == 'print':
    print_tree()
  else:
    raise ValueError(f'Invalid inst: {toks[0]}')
"
4508423,ALDS1_8_A,"from collections import deque
import sys
readline = sys.stdin.readline
write = sys.stdout.write

class Node:
    __slots__ = ['key', 'left', 'right']
    def __init__(self, key):
        self.key = key
        self.left = self.right = None


root = None

def insert(key):
    global root
    x = root #Tの根
    y = None #親を設定
    # while x: x, y = x.left if key < x.key else x.right, x
    while x is not None:
        y = x
        if key < x.key:
            x = x.left #左の子へ移動
        else:
            x = x.right  #右の子へ移動

    if y is None: #Tが空の場合
        root = Node(key)
    elif key < y.key:
        y.left = Node(key) #keyをyの左の子にする
    else:
        y.right = Node(key) #keyをyの右の子にする

def inorder(node):
    return   inorder(node.left) + "" ""+ str(node.key) + inorder(node.right) if node else ''
def preorder(node):
    return   "" "" + str(node.key) + preorder(node.left) + preorder(node.right) if node else ''
input()
for e in sys.stdin:
    if e[0] == ""i"":
        insert(int(e[7:]))
    else:
        print(inorder(root))
        print(preorder(root))

"
8571290,ALDS1_8_A,"from functools import total_ordering


@total_ordering
class Node:
    def __init__(self, key: int) -> None:
        self.key: int = key
        self.parent: Node = None
        self.left: Node = None
        self.right: Node = None

    def __eq__(self, __value: object) -> bool:
        if not isinstance(__value, Node):
            return NotImplemented
        return self.key == __value.key

    def __lt__(self, __value: object) -> bool:
        if not isinstance(__value, Node):
            return NotImplemented
        return self.key < __value.key


class BinarySearchTree:
    def __init__(self) -> None:
        self.root: Node = None

    def insert(self, z: Node) -> None:
        y: Node = None
        x: Node = self.root
        while x is not None:
            y = x
            if z < x:
                x = x.left
            else:
                x = x.right
        z.parent = y

        if y is None:  # the root is empty
            self.root = z
        elif z < y:
            y.left = z
        else:
            y.right = z

    def _preorder(self, root: Node) -> list:
        if root.left is None:
            left = []
        else:
            left = self._preorder(root.left)

        if root.right is None:
            right = []
        else:
            right = self._preorder(root.right)

        return [root.key] + left + right

    def print_preorder(self) -> None:
        print("" "" + "" "".join(map(str, self._preorder(self.root))))

    def _inorder(self, root: Node) -> list:
        if root.left is None:
            left = []
        else:
            left = self._inorder(root.left)

        if root.right is None:
            right = []
        else:
            right = self._inorder(root.right)

        return left + [root.key] + right

    def print_inorder(self) -> None:
        print("" "" + "" "".join(map(str, self._inorder(self.root))))


n = int(input())
binary_search_tree = BinarySearchTree()

for _ in range(n):
    command = input().split()
    if command[0] == ""insert"":
        node = Node(int(command[1]))
        binary_search_tree.insert(node)
    elif command[0] == ""print"":
        binary_search_tree.print_inorder()
        binary_search_tree.print_preorder()

"
7611782,ALDS1_8_A,"from collections import deque
import sys
readline = sys.stdin.readline
write = sys.stdout.write

root = None
def insert(z):
    global root
    y = None
    x = root
    while x is not None:
        y = x
        if z[2] < x[2]:
            x = x[0]
        else:
            x = x[1]
    z[3] = y

    if y is None:
        root = z
    elif z[2] < y[2]:
        y[0] = z
    else:
        y[1] = z

def debug():
    s0 = [""""]
    s1 = [""""]

    def dfs(nd):
        v = str(nd[2])
        s0.append(v)
        if nd[0] is not None:
            dfs(nd[0])
        s1.append(v)
        if nd[1] is not None:
            dfs(nd[1])
    dfs(root)
    return "" "".join(s1), "" "".join(s0)


M = int(readline())
ans = []
for m in range(M):
    cmd, *V, = readline().split()
    if cmd == ""print"":
        ans.extend(debug())
    else:
        insert([None, None, int(V[0]), None])
write(""\n"".join(ans))
write(""\n"")

"
4095177,ALDS1_8_A,"from collections import deque
import sys
readline = sys.stdin.readline
write = sys.stdout.write

root = None
def insert(z):
    global root
    y = None
    x = root
    while x is not None:
        y = x
        if z[2] < x[2]:
            x = x[0]
        else:
            x = x[1]
    z[3] = y

    if y is None:
        root = z
    elif z[2] < y[2]:
        y[0] = z
    else:
        y[1] = z

def debug():
    s0 = [""""]
    s1 = [""""]

    def dfs(nd):
        v = str(nd[2])
        s0.append(v)
        if nd[0] is not None:
            dfs(nd[0])
        s1.append(v)
        if nd[1] is not None:
            dfs(nd[1])
    dfs(root)
    return "" "".join(s1), "" "".join(s0)


M = int(readline())
ans = []
for m in range(M):
    cmd, *V, = readline().split()
    if cmd == ""print"":
        ans.extend(debug())
    else:
        insert([None, None, int(V[0]), None])
write(""\n"".join(ans))
write(""\n"")


"
6955785,ALDS1_8_A,"from collections import deque
import sys
readline = sys.stdin.readline
write = sys.stdout.write

root = None
def insert(z):
    global root
    y = None
    x = root
    while x is not None:
        y = x
        if z[2] < x[2]:
            x = x[0]
        else:
            x = x[1]
    z[3] = y

    if y is None:
        root = z
    elif z[2] < y[2]:
        y[0] = z
    else:
        y[1] = z

def debug():
    s0 = [""""]
    s1 = [""""]

    def dfs(nd):
        v = str(nd[2])
        s0.append(v)
        if nd[0] is not None:
            dfs(nd[0])
        s1.append(v)
        if nd[1] is not None:
            dfs(nd[1])
    dfs(root)
    return "" "".join(s1), "" "".join(s0)


M = int(readline())
ans = []
for m in range(M):
    cmd, *V, = readline().split()
    if cmd == ""print"":
        ans.extend(debug())
    else:
        insert([None, None, int(V[0]), None])
write(""\n"".join(ans))
write(""\n"")
"
3986025,ALDS1_8_A,"from collections import deque
import sys
readline = sys.stdin.readline
write = sys.stdout.write

root = None
def insert(z):
    global root
    y = None
    x = root
    while x is not None:
        y = x
        if z[2] < x[2]:
            x = x[0]
        else:
            x = x[1]
    z[3] = y

    if y is None:
        root = z
    elif z[2] < y[2]:
        y[0] = z
    else:
        y[1] = z

def debug():
    s0 = [""""]
    s1 = [""""]

    def dfs(nd):
        v = str(nd[2])
        s0.append(v)
        if nd[0] is not None:
            dfs(nd[0])
        s1.append(v)
        if nd[1] is not None:
            dfs(nd[1])
    dfs(root)
    return "" "".join(s1), "" "".join(s0)


M = int(readline())
ans = []
for m in range(M):
    cmd, *V, = readline().split()
    if cmd == ""print"":
        ans.extend(debug())
    else:
        insert([None, None, int(V[0]), None])
write(""\n"".join(ans))
write(""\n"")


"
7610118,ALDS1_8_A,"from collections import deque
import sys
readline = sys.stdin.readline
write = sys.stdout.write

root = None
def insert(z):
    global root
    y = None
    x = root
    while x is not None:
        y = x
        if z[2] < x[2]:
            x = x[0]
        else:
            x = x[1]
    z[3] = y

    if y is None:
        root = z
    elif z[2] < y[2]:
        y[0] = z
    else:
        y[1] = z

def debug():
    s0 = [""""]
    s1 = [""""]

    def dfs(nd):
        v = str(nd[2])
        s0.append(v)
        if nd[0] is not None:
            dfs(nd[0])
        s1.append(v)
        if nd[1] is not None:
            dfs(nd[1])
    dfs(root)
    return "" "".join(s1), "" "".join(s0)


M = int(readline())
ans = []
for m in range(M):
    cmd, *V, = readline().split()
    if cmd == ""print"":
        ans.extend(debug())
    else:
        insert([None, None, int(V[0]), None])
write(""\n"".join(ans))
write(""\n"")


"
3185533,ALDS1_8_A,"from collections import deque
import sys
readline = sys.stdin.readline
write = sys.stdout.write

root = None
def insert(z):
    global root
    y = None
    x = root
    while x is not None:
        y = x
        if z[2] < x[2]:
            x = x[0]
        else:
            x = x[1]
    z[3] = y

    if y is None:
        root = z
    elif z[2] < y[2]:
        y[0] = z
    else:
        y[1] = z

def debug():
    s0 = [""""]
    s1 = [""""]

    def dfs(nd):
        v = str(nd[2])
        s0.append(v)
        if nd[0] is not None:
            dfs(nd[0])
        s1.append(v)
        if nd[1] is not None:
            dfs(nd[1])
    dfs(root)
    return "" "".join(s1), "" "".join(s0)


M = int(readline())
ans = []
for m in range(M):
    cmd, *V, = readline().split()
    if cmd == ""print"":
        ans.extend(debug())
    else:
        insert([None, None, int(V[0]), None])
write(""\n"".join(ans))
write(""\n"")

"
5329834,ALDS1_8_A,"import sys

class Node(object):
    __slots__ = ['value', 'parent', 'left', 'right']
    
    def __init__(self, value: int, parent: 'Node' = None):
        self.value = value
        self.parent = parent
        self.left: Node = None
        self.right: Node = None

    def walk(self, x, walk_type):
        if walk_type == 0:
            x.append(self.value)
        if self.left:
            self.left.walk(x, walk_type)
        if walk_type == 1:
            x.append(self.value)
        if self.right:
            self.right.walk(x, walk_type)
        if walk_type == 2:
            x.append(self.value)
        return x

class BinarySearchTree(object):
    __slots__ = ['root'] 
    
    def __init__(self):
        self.root: Node = None

    def insert(self, y: int):
        if self.root is None:
            self.root = Node(y)
            return
        parent, current = None, self.root

        while current:
            parent = current
            if y < current.value:
                current = current.left
            else:
                current = current.right

        if y < parent.value:
            parent.left = Node(y, parent)
        else:
            parent.right = Node(y, parent)

def debug():
    tree_ = BinarySearchTree()
    input()
    for z in (z.split() for z in sys.stdin):
        if z[0] == ""insert"":
            tree_.insert(int(z[1]))
        else:
            print('', *tree_.root.walk([], 1))
            print('', *tree_.root.walk([], 0))

if __name__ == ""__main__"":
    debug()

"
4812418,ALDS1_8_A,"import bisect, collections, copy, heapq, itertools, math, string
import sys
def I(): return int(sys.stdin.readline().rstrip())
def MI(): return map(int, sys.stdin.readline().rstrip().split())
def LI(): return list(map(int, sys.stdin.readline().rstrip().split()))
def S(): return sys.stdin.readline().rstrip()
def LS(): return list(sys.stdin.readline().rstrip().split())

from collections import  defaultdict
def main():
    M = I()
    D = defaultdict()
    root = None
    def insert(D, z, id_root):
        y = None
        x = id_root
        while x != None:
            y = x
            if z < x:
                x = D[x][0]
            else:
                x = D[x][1]

        if y is None:
            id_root = z
        elif z < y:
            D[y][0] = z
        else:
            D[y][1] = z
        return id_root

    def PreorderTreeWalk(D, B, id):
        B.append(id)
        left = D[id][0]
        right = D[id][1]
        if left != None:
            PreorderTreeWalk(D, B, left)
        if right != None:
            PreorderTreeWalk(D, B, right)

    def InorderTreeWalk(D,  B, id):
        left = D[id][0]
        right = D[id][1]
        if left != None:
            InorderTreeWalk(D, B, left)
        B.append(id)
        if right != None:
            InorderTreeWalk(D, B, right)

    for i in range(M):
        ord = S()
        if ord[0] == 'i':
            z = int(ord[7:])
            D[z] = [None, None]
            root = insert(D, z, root)
        else:
            Ans_pre = []
            Ans_in = []
            InorderTreeWalk(D, Ans_in, root)
            PreorderTreeWalk(D, Ans_pre, root)
            print(' ' + ' '.join(map(str, Ans_in)))
            print(' ' + ' '.join(map(str, Ans_pre)))

if __name__ == ""__main__"":
    main()

"
3571880,ALDS1_8_A,"import sys


class Node(object):
    __slots__ = ['value', 'parent', 'left', 'right']
    
    def __init__(self, value: int, parent: 'Node' = None):
        self.value = value
        self.parent = parent
        self.left: Node = None
        self.right: Node = None

    def walk(self, a, walk_type):
        if walk_type == 0:
            a.append(self.value)
        if self.left:
            self.left.walk(a, walk_type)
        if walk_type == 1:
            a.append(self.value)
        if self.right:
            self.right.walk(a, walk_type)
        if walk_type == 2:
            a.append(self.value)
        return a


class BinarySearchTree(object):
    __slots__ = ['root']
    
    def __init__(self):
        self.root: Node = None

    def insert(self, x: int):
        if self.root is None:
            self.root = Node(x)
            return
        parent, current = None, self.root

        while current:
            parent = current
            if x < current.value:
                current = current.left
            else:
                current = current.right

        if x < parent.value:
            parent.left = Node(x, parent)
        else:
            parent.right = Node(x, parent)


def solve():
    tree = BinarySearchTree()
    input()
    for l in (l.split() for l in sys.stdin):
        if l[0] == ""insert"":
            tree.insert(int(l[1]))
        else:
            print('', *tree.root.walk([], 1))
            print('', *tree.root.walk([], 0))


if __name__ == ""__main__"":
    solve()
"
8786597,ALDS1_8_A,"# from icecream import ic

n = int(input())

opeList = []
for i in range(n):
    operation = list(map(str,input().split()))
    if len(operation) == 2:
        operation[1] = int(operation[1])
    opeList.append(operation)
# ic(opeList)

root = opeList[0][1]
# ic(root)

#THESE ARE FAILED ATTEMPTS

# def insert(T, z):
#     y = None # x の親
#     x = opeList[0][1]
#     ic(x)
#     while x != None:
#         y = x # 親を設定
#         if z.key < x.key:
#             x = x.left # 左の子へ移動
#         else:
#             x = x.right # 右の子へ移動
#     z.p = y
#     if y == None: # T が空の場合
#        root = z
#     elif z.key < y.key:
#        y.left = z # z を y の左の子にする
#     else: 
#        y.right = z # z を y の右の子にする

# def insert(T:dict,z):
    # ic(z,T)
    # if len(T) == 0:
        # T[""root""] = z
        # T[z] = [None, None, None] # left, parent, right
    # 
    # else:
        # T[z] = [None, None, None] # left, parent, right
        # y = None
        # x = T[""root""]
        # while T[x][0] != None or T[x][2] != None:
            # y = T[x][1]
            # if z < x:
                # x = T[x][0]
            # elif z > x:
                # x = T[x][2]
        # else:
            # if z < x:
                # T[x][0] = z
            # elif z > x:
                # T[x][2] = z
            # T[z][1] = x

left, parent, right = 0, 1, 2

def parse(T:dict,z,p):
    if z < p:
        if T[p][left] == None:
            T[p][left] = z
            T[z][parent] = p
        else:
            parse(T,z,T[p][left])
    elif z > p:
        if T[p][right] == None:
            T[p][right] = z
            T[z][parent] = p
        else:
            parse(T,z,T[p][right])

def insert(T:dict,z):
    if len(T) == 0:
        T[""root""] = z
        T[z] = [None, None, None] # left, parent, right
    
    else:
        T[z] = [None, None, None] # left, parent, right
        parse(T,z,T[""root""])
    # ic(z,T)
        

def pretw(i):
    if i != None:
        print(f"" {i}"",end="""")
        pretw(treeDict[i][left])
        pretw(treeDict[i][right])

def intw(i):
    if i != None:
        intw(treeDict[i][left])
        print(f"" {i}"",end="""")
        intw(treeDict[i][right])

# treeDict -> {key:[left, parent, right], key:[...], key:[...], ...}
treeDict = {}
for i in opeList:
    if len(i) == 2:
        if i[0] == ""insert"":
            # ic(i[1], treeDict)
            insert(treeDict, i[1])
    else:
        if i[0] == ""print"":
            intw(root)
            print()
            pretw(root)
            print()
"
4174236,ALDS1_8_A,"import sys
input = sys.stdin.readline
print = sys.stdout.write

class Node:
    __slots__ = [""data"", ""left"", ""right""]
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

class BinarySearchTree:
    __slots__ = [""root""]
    def __init__(self):
        self.root = None
    
    def insert(self, data):
        parent = self.root
        if parent is None:
            self.root = Node(data)
            return
        while parent:
            parent_old = parent
            parent = parent.left if data < parent.data else parent.right
        if data < parent_old.data:
            parent_old.left = Node(data)
        else:
            parent_old.right = Node(data)


def print_preorder(node):
    print("" {}"".format(node.data))
    if node.left:
        print_preorder(node.left)
    if node.right:
        print_preorder(node.right)

def print_inorder(node):
    if node.left:
        print_inorder(node.left)
    print("" {}"".format(node.data))
    if node.right:
        print_inorder(node.right)

if __name__ == ""__main__"":
    n = int(input())
    binary_search_tree = BinarySearchTree()
    for _ in range(n):
        operation, *num = input().split()
        if num:
            binary_search_tree.insert(int(num[0]))
        elif binary_search_tree.root is not None:
            print_inorder(binary_search_tree.root)
            print(""\n"")
            print_preorder(binary_search_tree.root)
            print(""\n"")
"
2636708,ALDS1_8_A,"# -*- coding:utf-8 -*-
import sys


class Node(object):
    __slots__ = [""value"", ""left"", ""right""]

    def __init__(self, value, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right


class BinTree(object):
    def __init__(self):
        self._tree = None

    def insert(self, value):
        parent = None
        current = self._tree

        while current is not None:
            parent = current
            if value < current.value:
                current = current.left
            else:
                current = current.right

        if parent is None:
            self._tree = Node(value)
        elif value < parent.value:
            parent.left = Node(value)
        else:
            parent.right = Node(value)

    def preoder_walk(self):
        def preoder(node):
            result = []
            if node is None:
                pass
            else:
                result.append(node.value)
                result.extend(preoder(node.left))
                result.extend(preoder(node.right))
            return result

        return preoder(self._tree)

    def inorder_walk(self):
        def inorder(node):
            result = []
            if node is None:
                pass
            else:
                result.extend(inorder(node.left))
                result.append(node.value)
                result.extend(inorder(node.right))
            return result

        return inorder(self._tree)


def print_tree(tree):
    print("" "" + "" "".join([str(val) for val in tree.inorder_walk()]))
    print("" "" + "" "".join([str(val) for val in tree.preoder_walk()]))


def insert_main(commands):
    tree = BinTree()
    for com in commands:
        if com[0] == ""insert"":
            tree.insert(int(com[1]))
        elif com[0] == ""print"":
            print_tree(tree)
        else:
            raise ValueError


if __name__ == ""__main__"":
    n = int(input())
    commands = [com.split() for com in sys.stdin.readlines()]
    insert_main(commands)
"
8812924,ALDS1_8_A,"#参考 : ALDS1_8_C 二分木の実装 https://zenn.dev/usma11dia0/articles/solve-alds-1-8-c
class node:
    def __init__(self, key) -> None:
        self.key = key
        self.left = None
        self.right = None
        
class BinarySearchTree:
    def __init__(self) -> None:
        self.root = None
    
    def insert(self, key) -> None:
        if self.root is None:
            self.root = node(key)
            return
        def _insert(Node, key) -> node:
            #現在ノードの有無確認
            if Node is None:
                return node(key)
            #大小比較
            if key < Node.key:
                Node.left = _insert(Node.left, key)
            else:
                Node.right = _insert(Node.right, key)
            return Node
        _insert(self.root, key)
        
    def print(self) -> str:
        def inorder(node) -> None:
            if node is not None:
                inorder(node.left)
                output.append(str(node.key))
                inorder(node.right)
        def preorder(node) -> None:
            if node is not None:
                output.append(str(node.key))
                preorder(node.left)
                preorder(node.right)
                
                
        output = []
        inorder(self.root)
        inorder_output = "" "".join(output)
        output = []
        preorder(self.root)
        preorder_output = "" "".join(output)
        
        return "" "" + inorder_output + ""\n"" + "" "" + preorder_output
        
m = int(input())
T = BinarySearchTree()
output = []

for _ in range(m):
    command = list(map(str, input().split()))
    if command[0] == ""insert"":
        T.insert(int(command[1]))
    elif command[0] == ""print"":
        output.append(T.print())

print(""\n"".join(output))                
"
8803063,ALDS1_8_A,"# 2分探索木


class Node:
  """"""2分探索木のノード""""""
  def __init__(self, key, value, left = None, right = None):
    """"""コンストラクタ""""""
    self.key = key      # キー
    # self.value = value  # 値
    self.left = left    # 左ポインタ（左の子への参照）
    self.right = right  # 右ポインタ（右の子への参照）
    

class BinarySeachTree:
  """"""2分探索木を実現するクラス""""""
  def __init__(self):
    self.root = None   # 根への参照
  
  def search(self, key):
    """"""キーkeyを持つノードを探索""""""
    p = self.root
    while True:
      if p is None:
        return None
      if key == p.key:
        return p.value
      elif key < p.key:
        p = p.left
      else:
        p = p.right
        
  def add(self, key) -> bool:
    """"""キーがkeyで値がvalueのノードを挿入""""""
    def add_node(node, key) -> None:
      """"""nodeを根とする部分木にキーがkeyで値がvalueのノードを挿入""""""
      if key == node.key:
        return False  # keyは2分探索木上に既に存在
      elif key < node.key:
        if node.left is None:
          node.left = Node(key, None, None)
        else:
          add_node(node.left, key)
      else:
        if node.right is None:
          node.right = Node(key, None, None)
        else:
          add_node(node.right, key)
      return True
    if self.root is None:
      self.root = Node(key, None, None)
    else:
      return add_node(self.root, key)
       
        
  def dump(self) -> None:
    """"""ダンプする""""""
    def print_subtree_in(node):
      """"""nodeを根とする部分木のノードをキーの昇順（中間順）に表示""""""
      if node is not None:
        print_subtree_in(node.left)
        print(f' {node.key}', end='')
        print_subtree_in(node.right)
    
    def print_subtree_pre(node):
      """"""nodeを根とする部分木のノードを先行順で表示""""""
      if node is not None:
        print(f' {node.key}', end='')
        print_subtree_pre(node.left)
        print_subtree_pre(node.right)
        
    print_subtree_in(self.root)
    print()
    print_subtree_pre(self.root)
    print()
  
  
  
tree = BinarySeachTree()         # ２分探索木を生成  

m = int(input())

for i in range(m):
  s = input().split(' ')
  if s[0] == ""insert"":
    x = int(s[1])
    tree.add(x)
  elif s[0] == ""print"":
    tree.dump()
"
5416897,ALDS1_8_A,"import sys

sys.setrecursionlimit(10 ** 7)


def insert(t, v):
    if t[0] is None:
        t[0] = v
        return
    y = None
    x = t
    while x is not None:
        y = x
        x = x[1] if v < x[0] else x[2]
    if v < y[0]:
        y[1] = [v, None, None]
    else:
        y[2] = [v, None, None]


def inorder_walk(t, res):
    res.append(t[0])
    if t[1] is not None:
        inorder_walk(t[1], res)
    if t[2] is not None:
        inorder_walk(t[2], res)


def preorder_walk(t, res):
    if t[1] is not None:
        preorder_walk(t[1], res)
    res.append(t[0])
    if t[2] is not None:
        preorder_walk(t[2], res)


bst = [None, None, None]
N = int(input())
for _ in range(N):
    q = input().split()
    if q[0] == ""insert"":
        insert(bst, int(q[1]))
    else:
        res = []
        preorder_walk(bst, res)
        print("""", *res)
        res = []
        inorder_walk(bst, res)
        print("""", *res)

"
4026002,ALDS1_8_A,"class BinarySearchTree:
    def __init__(self):
        self.lcs = {}
        self.rcs = {}
        self.root = None

    def insert(self, key):
        if self.root is None:
            self.root = key
            self.lcs[key] = None
            self.rcs[key] = None
            return
        parent = self.root
        while True:
            if key < parent:
                if self.lcs[parent] is None:
                    self.lcs[parent] = key
                    self.lcs[key] = None
                    self.rcs[key] = None
                    break
                else:
                    parent = self.lcs[parent]
            else:
                if self.rcs[parent] is None:
                    self.rcs[parent] = key
                    self.lcs[key] = None
                    self.rcs[key] = None
                    break
                else:
                    parent = self.rcs[parent]

    def _print(self, cur):
        self.preorder.append(cur)
        if self.lcs[cur]:
            self._print(self.lcs[cur])
        self.inorder.append(cur)
        if self.rcs[cur]:
            self._print(self.rcs[cur])

    def print(self):
        self.preorder = []
        self.inorder = []
        self._print(self.root)
        print(' ' + ' '.join(map(str, self.inorder)))
        print(' ' + ' '.join(map(str, self.preorder)))


T = BinarySearchTree()
N = int(input())
for _ in range(N):
    s = input().split()
    if s[0] == 'insert':
        T.insert(int(s[1]))
    else:
        T.print()

"
5060299,ALDS1_8_A,"def main():

    bt_root = -1
    bt_num = 0
    bt_pa = []
    bt_chl = []
    bt_chr = []
    bt_contents = []

    n = int(input())
    for _ in range(n):
        query = input()

        if ""insert"" in query:
            _, x = query.split()
            x = int(x)

            bt_contents.append(x)
            ind = bt_root
            ind_p = ind
            while ind != -1:
                ind_p = ind
                if x < bt_contents[ind]:
                    ind = bt_chl[ind]
                else:
                    ind = bt_chr[ind]
            bt_pa.append(ind_p)
            if ind_p == -1:
                bt_root = bt_num
            elif x < bt_contents[ind_p]:
                bt_chl[ind_p] = bt_num
            else:
                bt_chr[ind_p] = bt_num

            bt_chl.append(-1)
            bt_chr.append(-1)
            bt_num += 1

        elif ""print"" in query:

            for config in [""Inorder"", ""Preorder""]:

                btp_vlist = []
                ind = bt_root
                btp_marked = [False] * bt_num

                while True:
                    
                    if bt_chl[ind] != -1 and not btp_marked[bt_chl[ind]]:
                        if config == ""Preorder"":
                            btp_vlist.append(bt_contents[ind])
                            btp_marked[ind] = True        
                        ind = bt_chl[ind]

                    elif bt_chr[ind] != -1 and not btp_marked[bt_chr[ind]]:
                        if bt_chl[ind] == -1 and config == ""Preorder"":
                            btp_vlist.append(bt_contents[ind])
                            btp_marked[ind] = True
                        if config == ""Inorder"":
                            btp_vlist.append(bt_contents[ind])
                            btp_marked[ind] = True
                        ind = bt_chr[ind]

                    else:
                        if btp_marked[ind] == False:
                            btp_vlist.append(bt_contents[ind])
                            btp_marked[ind] = True
                        ind = bt_pa[ind]
                    
                    if ind == -1:
                        break

                
                print("""", *btp_vlist)


main()
"
6236793,ALDS1_8_A,"import sys
import math
import bisect
from heapq import heapify, heappop, heappush
from collections import deque, defaultdict, Counter
from functools import lru_cache
from itertools import accumulate, combinations, permutations

sys.setrecursionlimit(1000000)
MOD = 10 ** 9 + 7
MOD99 = 998244353

input = lambda: sys.stdin.readline().strip()
NI = lambda: int(input())
NMI = lambda: map(int, input().split())
NLI = lambda: list(NMI())
SI = lambda: input()
SMI = lambda: input().split()
SLI = lambda: list(SMI())


class Node:
    __slots__ = [""left"", ""right"", ""par""]
    def __init__(self, left=None, right=None, par=None):
        self.left = left
        self.right = right
        self.par = par


class BinarySearchTree:
    def __init__(self):
        self.V = {}
        self.root = None

    def insert(self, key):
        # 初期化
        self.V[key] = Node()

        # 最初のノードならrootにして終了
        if self.root is None:
            self.root = key
            return

        # 木を潜る
        now = self.root
        par = None
        while now:
            par = now
            if key <= now:
                now = self.V[now].left
            else:
                now = self.V[now].right

        # keyのノードの親を定める
        self.V[key].par = par
        # parのノードのどちらの子かを定める
        if key <= par:
            self.V[par].left = key
        else:
            self.V[par].right = key

    def preorder(self):
        res = self._preorder_rec(self.root)
        return res

    def _preorder_rec(self, now):
        v = self.V[now]
        res = [now]
        res += [] if v.left is None else self._preorder_rec(v.left)
        res += [] if v.right is None else self._preorder_rec(v.right)
        return res

    def inorder(self):
        res = self._inorder_rec(self.root)
        return res

    def _inorder_rec(self, now):
        v = self.V[now]
        res = [] if v.left is None else self._inorder_rec(v.left)
        res += [now]
        res += [] if v.right is None else self._inorder_rec(v.right)
        return res


def main():
    M = NI()
    T = BinarySearchTree()
    for _ in range(M):
        query = SI()
        if query == ""print"":
            ino = T.inorder()
            preo = T.preorder()
            print("" "", end="""")
            print(*ino)
            print("" "", end="""")
            print(*preo)
        else:
            _, k = query.split()
            k = int(k)
            T.insert(k)


if __name__ == ""__main__"":
    main()

"
5561430,ALDS1_8_A,"class Node(object):
    __slots__ = [""value"", ""parent"", ""left"", ""right""]

    def __init__(self, value: int, parent: 'Node' = None) -> None:
        self.value = value
        self.parent = parent
        self.left: Node = None
        self.right: Node = None

    def inPerse(self, a: list) -> list:
        if self.left:
            self.left.inPerse(a)
        a.append(self.value)
        if self.right:
            self.right.inPerse(a)
        return a

    def prePerse(self, a: list) -> list:
        a.append(self.value)
        if self.left:
            self.left.prePerse(a)
        if self.right:
            self.right.prePerse(a)
        return a


class BinarySearchTree(object):
    __slots__ = [""root""]

    def __init__(self) -> None:
        self.root: Node = None

    def insert(self, target: int):
        if self.root is None:
            self.root = Node(target)
            return
        parent, current = None, self.root

        while current:
            parent = current
            if target < current.value:
                current = current.left
            else:
                current = current.right

        if target < parent.value:
            parent.left = Node(target, parent)
        else:
            parent.right = Node(target, parent)


if __name__ == ""__main__"":
    tree = BinarySearchTree()
    for i in range(int(input())):
        order = input()
        if order == ""print"":
            inp = tree.root.inPerse([])
            print("""", *inp)
            prp = tree.root.prePerse([])
            print("""", *prp)
        else:
            _, target = order.split()
            target = int(target)
            tree.insert(target)

"
8551731,ALDS1_8_A,"class TreeNode:
    def __init__(self, value: int) -> None:
        """"""ノードを初期化します。
        
        Args:
            value (int): ノードの値
        
        Returns:
            None
        """"""
        self.value: int = value
        self.left: int = None
        self.right: int = None

class BinarySearchTree:
    def __init__(self) -> None:
        """"""二分探索木を初期化します。
        
        Args:
            None
        
        Returns:
            None
        """"""
        self.root: int = None

    def insert(self, value):
        """"""値を挿入します。
        
        Args:
            value: 挿入する値
        
        Returns:
            None
        """"""
        if self.root is None:
            self.root = TreeNode(value)
        else:
            self._insert_recursive(self.root, value)

    def _insert_recursive(self, node, value):
        """"""再帰的に値を挿入します。
        
        Args:
            node: 現在のノード
            value: 挿入する値
        
        Returns:
            None
        """"""
        if value < node.value:
            if node.left is None:
                node.left = TreeNode(value)
            else:
                self._insert_recursive(node.left, value)
        else:
            if node.right is None:
                node.right = TreeNode(value)
            else:
                self._insert_recursive(node.right, value)

    def Preorder(self):
        result = []
        self._Preorder_recursive(self.root, result)
        return result
            
    def _Preorder_recursive(self, node, result):
        if node is None:
            return
        result.append(node.value)
        self._Preorder_recursive(node.left, result)
        self._Preorder_recursive(node.right, result)

    def Inorder(self):
        result = []
        self._Inorder_recursive(self.root, result)
        return result
    
    def _Inorder_recursive(self, node, result):
        if node is None:
            return
        else:
            self._Inorder_recursive(node.left, result)
            result.append(node.value)
            self._Inorder_recursive(node.right, result)

debug_mode = False
if debug_mode:
    n = 8
    method_list = [
        [""insert"", 30],
        [""insert"", 88],
        [""insert"", 12],
        [""insert"", 1],
        [""insert"", 20],
        [""insert"", 17],
        [""insert"", 25],
        [""print""],
    ]
else:
    n = int(input())
    method_list = [input().split() for _ in range(n)]
    

BST = BinarySearchTree()
for method in method_list:
    if method[0] == ""insert"":
        BST.insert(int(method[1]))
    elif method[0] == ""print"":
        In_result = BST.Inorder()
        print("" "", end="""")
        print(*In_result)
        Pre_result = BST.Preorder()
        print("" "", end="""")
        print(*Pre_result)

"
4300354,ALDS1_8_A,"# Binary Search Tree 1

import sys
sys.setrecursionlimit(10**6)


class Node():
    __slots__ = ['key', 'parent', 'left', 'right']
    def __init__(self, key=None, parent=None, left=None, right=None):
        self.key = key
        self.parent = parent
        self.left = left
        self.right = right

    def __repr__(self):
        k = str(self.key)
        p = str(self.parent.key) if self.parent else 'None'
        l = str(self.left.key) if self.left else 'None'
        r = str(self.right.key) if self.right else 'None'
        s = ""<Node %s: parent=%s, left=%s, right=%s>"" % (k, p, l, r)
        return s


class BinaryTree():
    def __init__(self, n=0):
        self.T = [Node() for _ in range(n)]
        self.root = None

    def preorder(self):
        self.preorder_key = []
        self.preorder_rec(self.root)
        print('', *(self.preorder_key))

    def preorder_rec(self, node):
        if node == None:
            return
        self.preorder_key.append(node.key)
        self.preorder_rec(node.left)
        self.preorder_rec(node.right)

    def inorder(self):
        self.inorder_key = []
        self.inorder_rec(self.root)
        print('', *(self.inorder_key))

    def inorder_rec(self, node):
        if node == None:
            return
        self.inorder_rec(node.left)
        self.inorder_key.append(node.key)
        self.inorder_rec(node.right)

    def insert(self, key):
        node = Node(key)

        y = None
        x = self.root

        while x != None:
            y = x
            if key < x.key:
                x = x.left
            else:
                x = x.right

        node.parent = y
        if y == None:
            self.root = node
        elif key < y.key:
            y.left = node
        else:
            y.right = node


N = int(input())
S = [input() for _ in range(N)]
tree = BinaryTree()

for s in S:
    if 'print' in s:
        tree.inorder()
        tree.preorder()
    else:
        _, key = s.split()
        tree.insert(int(key))

"
7492854,ALDS1_8_A,"# 8_B.py

class BinarySearchTree():
    class Node():
        def __init__(self, val, parent, left=None, right=None):
            self.parent = parent
            self.val = val
            self.left = left
            self.right = right

    def __init__(self):
        self.root = None

    def insert(self, val):
        parent = None
        node = self.root

        while node is not None:
            parent = node
            if val < node.val:
                node = node.left
            else:
                node = node.right
        
        node = BinarySearchTree.Node(val, parent)
        if parent is None:
            self.root = node
        elif val < parent.val:
            parent.left = node
        else:
            parent.right = node

    def to_string(self, order):
        def rec(node):
            nonlocal s

            if order == ""pre"":
                s += f"" {node.val}""
            if node.left is not None:
                rec(node.left)
            if order == ""in"":
                s += f"" {node.val}""
            if node.right is not None:
                rec(node.right)
            if order == ""post"":
                s += f"" {node.val}""

        s = """"
        rec(self.root)
        return s

    def walk(self, order):
        def rec(node):
            if order == ""pre"":
                yield node.val
            if node.left is not None:
                yield from rec(node.left)
            if order == ""in"":
                yield node.val
            if node.right is not None:
                yield from rec(node.right)
            if order == ""post"":
                yield node.val

        yield from rec(self.root)

    def find(self, val):
        def rec(node):
            if node is None:
                return False
            if node.val == val:
                return True
            return rec(node.left) or rec(node.right)

        return rec(self.root) 

    def to_string(self, order):
        def rec(node):
            nonlocal s

            if order == ""pre"":
                s += f"" {node.val}""
            if node.left is not None:
                rec(node.left)
            if order == ""in"":
                s += f"" {node.val}""
            if node.right is not None:
                rec(node.right)
            if order == ""post"":
                s += f"" {node.val}""

        s = """"
        rec(self.root)
        return s
    
from sys import stdin

T = BinarySearchTree()
n = int(stdin.readline())

for command in [e.split() for e in stdin.readlines()]:
    if command[0] == ""insert"":
        T.insert(int(command[1]))
    elif command[0] == ""print"":
        print(T.to_string(""in""))
        print(T.to_string(""pre""))
    elif command[0] == ""find"":
        print(""yes"" if T.find(int(command[1])) else ""no"")
"
3883269,ALDS1_8_A,"import sys
input = sys.stdin.readline

class Node:
    __slots__ = ['value', 'parent', 'left', 'right']
    def __init__(self, value: int, parent: 'Node' = None):
        self.value = value
        self.parent = parent
        self.left: Node = None
        self.right: Node = None
    def inParse(self):
        if self.value == None:
            return
        if self.left != None:
            self.left.inParse()
        print(' {}'.format(self.value), end='')
        if self.right != None:
            self.right.inParse()
    def preParse(self):
        if self.value == None:
            return
        print(' {}'.format(self.value), end='')
        if self.left != None:
            self.left.preParse()
        if self.right != None:
            self.right.preParse()

class BinarySearchTree:
    __slots__ = ['root']
    def __init__(self):
        self.root: Node = None
    def insert(self, x: int):
        if self.root == None:
            self.root = Node(x)
            return
        parent, current = None, self.root
        while current:
            parent = current
            if x < current.value:
                current = current.left
            else:
                current = current.right
        if x < parent.value:
            parent.left = Node(x, parent)
        else:
            parent.right = Node(x, parent)

def main():
    tree = BinarySearchTree()
    n = int(input())
    for _ in range(n):
        inp = input()
        if inp[0] == 'i':
            com, num = inp.split()
            tree.insert(int(num))
        else:
            tree.root.inParse()
            print()
            tree.root.preParse()
            print()

if __name__=='__main__': main()
"
6831415,ALDS1_8_A,"# T:辞書{値：[左の子、右の子]}
def insert(T, z):
    global root
    y = -1
    x = root
    
    while x != None:
        y = x
        if z < x:
            x = T[x][0]
        else:
            x = T[x][1]
    
    T[z] = [None, None]
    
    if y == -1:
        root = z
    
    elif z < y:
        T[y][0] = z
    
    else:
        T[y][1] = z
        

def walk_tree(now):
    global pre_order, in_order
    if now == None:
        return
    
    pre_order.append(now)
    
    x, y = T[now]
    
    if x != None:
        walk_tree(x)
    
    in_order.append(now)
    
    if y != None:
        walk_tree(y)
    

n = int(input())
T = dict()
root = None

for _ in range(n):
    com, *arg = input().split()
    if com == ""insert"":
        insert(T, int(arg[0]))
    
    else:
        in_order = []
        pre_order = []
        
        walk_tree(root)
        
        print("""", *in_order)
        print("""", *pre_order)

"
7443209,ALDS1_8_A,"class Node:
    __slots__ = (""parent"", ""left"", ""right"", ""key"")

    def __init__(self, key):
        self.key = key
        self.parent = None
        self.left = None
        self.right = None


ROOT = Node(2_000_000_010)


def insert(key):
    global ROOT

    node = Node(key)
    parent = ROOT
    cur = ROOT.left

    while cur:
        parent = cur
        if key < parent.key:
            cur = parent.left
        else:
            cur = parent.right

    node.parent = parent
    if key < parent.key:
        parent.left = node
    else:
        parent.right = node


def display():
    global ROOT

    inorder = []
    bcl = [ROOT]
    while bcl:
        node = bcl.pop()
        if node is None:
            continue

        if isinstance(node, int):
            inorder.append(node)
        else:
            bcl.append(node.right)
            bcl.append(node.key)
            bcl.append(node.left)

    print("" "" + "" "".join(map(str, inorder[:-1])))

    preorder = []
    bcl = [ROOT]
    while bcl:
        node = bcl.pop()
        if node is None:
            continue

        preorder.append(node.key)
        bcl.append(node.right)
        bcl.append(node.left)

    print("" "" + "" "".join(map(str, preorder[1:])))


if __name__ == ""__main__"":
    n = int(input())

    for _ in range(n):
        line = input()

        if line == ""print"":
            display()
        elif line.startswith(""insert""):
            key = int(line.split()[1])
            insert(key)
        elif line.startswith(""delete""):
            key = int(line.split()[1])
            delete(key)
        else:
            key = int(line.split()[1])
            find(key)

"
6691562,ALDS1_8_A,"N=int(input())
T={}
root=-1

def insert(T,z):
    global root
    T[z]={""left"":-1,""right"":-1,""parent"":-1}
    y=-1
    x=root
    while not x==-1:
        y=x
        if z<x:
            x=T[x][""left""]
        else:
            x=T[x][""right""]
    T[z][""parent""]=y
    
    if y==-1:
        root=z
    elif z<y:
        T[y][""left""]=z
    else:
        T[y][""right""]=z
        
def Preorder(parent,ans,nodes):
    if not parent==-1: 
        ans.append(parent)
    else:
        return 0
    Preorder(nodes[parent][""left""],ans,nodes)
    Preorder(nodes[parent][""right""],ans,nodes)
        
def Inorder(parent,ans,nodes):
    if parent==-1:
        return 0
    Inorder(nodes[parent][""left""],ans,nodes)
    ans.append(parent)
    Inorder(nodes[parent][""right""],ans,nodes)

for i in range(N):
    s=input().split()
    if s[0]==""insert"":
        insert(T,int(s[1]))
        
    else:
        ans=[]
        Inorder(root,ans,T)
        print("" "",end="""")
        print(*ans)
        ans=[]
        Preorder(root,ans,T)
        print("" "",end="""")
        print(*ans)
"
5439287,ALDS1_8_A,"import sys


class Node():
    def __init__(self, key):
        self.parent = None
        self.left = None
        self.right = None
        self.key = key


root = None


def insert(key):
    global root
    z = Node(key)
    y = Node(-1)
    x = root
    while x:
        y = x
        if z.key < x.key:
            x = x.left
        else:
            x = x.right
    z.parent = y

    if y.key == -1:
        root = z
    elif z.key < y.key:
        y.left = z
    else:
        y.right = z


def inorder(node):
    return inorder(node.left) + f' {node.key}' + inorder(node.right) if node else ''


def preorder(node):
    return f' {node.key}' + preorder(node.left) + preorder(node.right) if node else ''


input()
for e in sys.stdin:
    if e[0] == 'i':
        insert(int(e[7:]))
    else:
        print(inorder(root))
        print(preorder(root))

"
4740814,ALDS1_8_A,"import sys
class Node:
    def __init__(self, data):
        self.data = data
        self.left = self.right = None

rt = None


def inorder(node):
    return inorder(node.left) + f' {node.data}' + inorder(node.right) if node else ''
def preorder(node):
    return f' {node.data}' + preorder(node.left) + preorder(node.right) if node else ''



def insert(data):
    global rt
    x, y = rt, None
    while x: x, y = x.left if data < x.data else x.right, x
    if y is None: rt = Node(data)
    elif data < y.data: y.left = Node(data)
    else: y.right = Node(data)

n = int(input())
for e in sys.stdin:
    if e[0] == 'i': insert(int(e[7:]))
    else: print(inorder(rt)); print(preorder(rt))

"
6822516,ALDS1_8_A,"import sys


class Node(object):
    __slots__ = ['key', 'parent', 'left', 'right']

    def __init__(self, key):
        self.key = key
        self.parent = None
        self.left = None
        self.right = None


def preoder(node):
    print(f' {str(node.key)}', end='')

    if node.left != None:
        preoder(node.left)
    if node.right != None:
        preoder(node.right)


def inorder(node):
    if node == None:
        return

    inorder(node.left)
    print(f' {str(node.key)}', end='')
    inorder(node.right)


def insert(z_key):
    global root_node
    x = root_node
    y = None
    z = Node(z_key)

    while x != None:
        y = x
        if z.key < x.key:
            x = x.left
        else:
            x = x.right
    z.parent = y

    if y == None:
        root_node = z
    elif z.key < y.key:
        y.left = z
    else:
        y.right = z


def main():
    global root_node

    input = sys.stdin.readline
    n = int(input())
    root_node = None

    for _ in range(n):
        line = input().split()
        if line[0] == 'insert':
            insert(int(line[1]))
        else:
            inorder(root_node)
            print('')
            preoder(root_node)
            print('')


root_node = None
main()
"
4946600,ALDS1_8_A,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-

def inorder(nodes, index, answer):
    if nodes[index]['left'] != -1:
        inorder(nodes, nodes[index]['left'], answer)
    answer.append(nodes[index]['key'])
    if nodes[index]['right'] != -1:
        inorder(nodes, nodes[index]['right'], answer)

def preorder(nodes, index, answer):
    answer.append(nodes[index]['key'])
    if nodes[index]['left'] != -1:
        preorder(nodes, nodes[index]['left'], answer)
    if nodes[index]['right'] != -1:
        preorder(nodes, nodes[index]['right'], answer)


def insert(nodes, z):
    if not nodes:
        nodes.append(z)
    else:
        y = -1
        x = 0
        while x != -1:
            y = x
            if z['key'] < nodes[x]['key']:
                x = nodes[x]['left']
            else:
                x = nodes[x]['right']

        if z['key'] < nodes[y]['key']:
            nodes[y]['left'] = z['index']
            nodes.append(z)
        else:
            nodes[y]['right'] = z['index']
            nodes.append(z)

def print_order(nodes, root):
    if root != -1:
        tmp = []
        inorder(nodes, root, tmp)
        print('',' '.join(map(str, tmp)))
        tmp_ = []
        preorder(nodes, root, tmp_)
        print('',' '.join(map(str, tmp_)))

if __name__ == ""__main__"":
    N = int(input())
    nodes = []
    commands = []
    for i in range(N):
        commands.append(input())
    root_index = 0
    for i, command in enumerate(commands):
        if command[0] == 'i':
            z = {
                'key':int(command[7:]),
                'left': -1,
                'right': -1,
                'index': len(nodes)
            }
            insert(nodes, z)
        elif command[0] == 'p':
            print_order(nodes, root_index)


"
4912510,ALDS1_8_A,"import sys
class Node:
    parent = -1
    left = -1
    right = -1

    def __init__(self, key):
        self.key = key

    def __repr__(self):
        return ""key:{},parent:{},left:{},right:{}"".format(self.key, self.parent, self.left, self.right)

root_node_no = -1

def insert(nodes :dict, in_node :Node):
    global root_node_no

    cur_node_no = root_node_no
    parent_node_no = -1
    while cur_node_no != -1:
        parent_node_no = cur_node_no
        if in_node.key < cur_node_no:
            cur_node_no = nodes[cur_node_no].left
        else:
            cur_node_no = nodes[cur_node_no].right

    in_node.parent = parent_node_no

    if root_node_no == -1:
        root_node_no = in_node.key
    elif in_node.key < parent_node_no:
        nodes[parent_node_no].left = in_node.key
    else:
        nodes[parent_node_no].right = in_node.key

    nodes[in_node.key] = in_node

def inorder_tree_walk(nodes, node_no ,inorder):
    if node_no == -1:
        return
    inorder_tree_walk(nodes, nodes[node_no].left, inorder)
    inorder.append(node_no)
    inorder_tree_walk(nodes, nodes[node_no].right, inorder)

def preorder_tree_walk(nodes, node_no, preorder):
    if node_no == -1:
        return
    preorder.append(node_no)
    preorder_tree_walk(nodes, nodes[node_no].left, preorder)
    preorder_tree_walk(nodes, nodes[node_no].right, preorder)
    pass

def main():
    num_com = int(input())
    commands = sys.stdin.readlines()
    nodes = {}
    for i in range(num_com):
        if commands[i][0] == 'i':
            insert(nodes, Node(int(commands[i][7:])))
        elif commands[i][0] == 'p':
            # inorder
            inorder = []
            inorder_tree_walk(nodes, root_node_no, inorder)
            print("" "" + "" "".join(map(str, inorder)))
            # preorder
            preorder = []
            preorder_tree_walk(nodes, root_node_no, preorder)
            print("" "" + "" "".join(map(str, preorder)))


main()
"
8710341,ALDS1_8_B,"import sys
input = sys.stdin.readline

NIL = -1

m = int(input())

root = NIL

def insert(k):
    global root
    y = NIL
    x = root
    z = {'key':k, 'left':NIL, 'right':NIL}
    while x != NIL:
        y = x
        if z['key'] < x['key']:
            x = x['left']
        else:
            x = x['right']
    z['parent'] = y

    if y == NIL:
        root = z
    elif z['key'] < y['key']:
        y['left'] = z
    else:
        y['right'] = z

def find(u, k):
    while u != NIL and k != u['key']:
        if k < u['key']:
            u = u['left']
        else:
            u = u['right']
    return u

def inorder(u):
    if u == NIL:
        return
    inorder(u['left'])
    print(' ' + str(u['key']), end='')
    inorder(u['right'])

def preorder(u):
    if u == NIL:
        return
    print(' ' + str(u['key']), end='')
    preorder(u['left'])
    preorder(u['right'])

for _ in range(m):
    command = input()
    if command[0] == 'f':
        _, x = command.split()
        x = int(x)
        t = find(root, x)
        if t != NIL:
            print('yes')
        else:
            print('no')
    elif command[:6] == 'insert':
        _, x = command.split()
        x = int(x)
        insert(x)
    else:
        inorder(root)
        print('')
        # pythonのprintは最後に改行記号をつけてくれるので、これで改行できる
        preorder(root)
        print('')
"
8448880,ALDS1_8_B,"a = []
t = []

for _ in range(int(input())):
    i = input()
    w = a
    if i[0] == 'i':
        i = int(i.split()[1])
        t.append(i)
        while w: w = w[1] if w[0] > i else w[2]
        w += [i, [], []]
    elif i[0] == 'f':
        i = int(i.split()[1])
        while w:
            if w[0] == i:
                print('yes')
                break
            w = w[1] if w[0] > i else w[2]
        else: print('no')
    else:
        t.sort()
        print('', *t)
        l = [a]
        while l:
            i = l.pop()
            if i:
                print('', i[0], end='')
                l += i[:0:-1]
        print()
"
8386739,ALDS1_8_B,"class Node():
    def __init__(self, key):
        self.key = key
        self.parent = None
        self.left = None
        self.right = None


class Tree():
    def __init__(self):
        self.root = None


    def find(self, q):
        x = self.root
        while x:
            if q == x.key:
                return True
            elif q < x.key:
                x = x.left
            else:
                x = x.right
        return False


    def insert(self, key):
        z = Node(key)
        y = None
        x = self.root
        while x:
            y = x
            if z.key < x.key:
                x = x.left
            else:
                x = x.right
            # この時点において, y は x の親.
        # この時点において, y は z の親.
        z.parent = y
        if not y:
            self.root = z
        elif z.key < y.key:
            y.left = z
        else:
            y.right = z


    def in_order(self):
        def exe(x):
            if x:
                exe(x.left)
                print("" {}"".format(x.key), end="""")
                exe(x.right)
        exe(self.root)


    def pre_order(self):
        def exe(x):
            if x:
                print("" {}"".format(x.key), end="""")
                exe(x.left)
                exe(x.right)
        exe(self.root)


def main():
    n = int(input())
    T = Tree()
    for i in range(n):
        cmd = input().split()
        if cmd[0] == ""find"":
            if T.find(int(cmd[1])):
                print(""yes"")
            else:
                print(""no"")
        elif cmd[0] == ""insert"":
            T.insert(int(cmd[1]))
        else:
            T.in_order()
            print()
            T.pre_order()
            print()


if __name__ == ""__main__"":
    main()
"
9005858,ALDS1_8_B,"class Node:
    def __init__(self, key):
        self.key=key
        self.left=None
        self.right=None
        self.p=None
root=None
def insert(z):
    global root
    y=None
    x=root
    while x is not None:
        y=x
        if z.key < x.key:
            x=x.left
        else:
            x=x.right
    z.p=y
    if y is None:
        root=z
    elif z.key < y.key:
        y.left=z
    else:
        y.right=z

def find(z):
    global root
    x=root
    while x is not None:
        if z.key == x.key:
            print(""yes"")
            break
        if z.key < x.key:
            x=x.left
        else:
            x=x.right
    else:
        print(""no"")

def print_order(num):
    global inorder, preorder
    preorder.append(str(num.key))
    if num.left is not None:
        print_order(num.left)
    inorder.append(str(num.key))
    if num.right is not None:
        print_order(num.right)    

m=int(input())
for _ in range(m):
    order = list(input().split())
    if order[0] == ""insert"":
        insert(Node(int(order[1])))
    elif order[0] == ""find"":
        find(Node(int(order[1])))
    else:
        inorder=[]
        preorder=[]
        print_order(root)
        print("" ""+"" "".join(inorder))
        print("" ""+"" "".join(preorder))
"
8932751,ALDS1_8_B,"class TreeNode:
    def __init__(self,key):
        self.key = key
        self.left = None
        self.right = None
        self.parent = None

root = None
def insert(z):
    global root
    x = root
    y = None
    while x:
        y = x
        if z.key < x.key:
            x = x.left
        else:
            x = x.right
    
    if not y:
        root = z
        return
    z.parent = y
    if z.key < y.key:
        y.left = z
    else:
        y.right = z

def find(z):
    x = root
    while x:
        if x.key == z:
            return x
        if x.key < z:
            x = x.right
        else:
            x = x.left
    return None

def inorder(root,A):
    if root is None:
        return
    inorder(root.left,A)
    A.append(root.key)
    inorder(root.right,A)
    return A

def preorder(root,A):
    if root is None:
        return
    A.append(root.key)
    preorder(root.left,A)
    preorder(root.right,A)
    return A

n = int(input())
for i in range(n):
    a = input().split()
    if a[0] == ""insert"":
        insert(TreeNode(int(a[1])))
    elif a[0] == ""print"":
        print("" "",end ="""")
        print(*inorder(root,[]))
        print("" "",end ="""")
        print(*preorder(root,[]))
    elif a[0] == ""find"":
        if find(int(a[1])):
            print(""yes"")
        else:
            print('no')
"
8802725,ALDS1_8_B,"class Node:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.parent = None

class BinarySearchTree:
    def __init__(self):
        self.root = None

    def insert(self, key):
        node = Node(key)
        if self.root is None:
            self.root = node
        else:
            current = self.root
            while True:
                parent = current
                if node.key < current.key:
                    current = current.left
                    if current is None:
                        parent.left = node
                        node.parent = parent
                        break
                else:
                    current = current.right
                    if current is None:
                        parent.right = node
                        node.parent = parent
                        break

    def find(self, key):
        current = self.root
        while current is not None:
            if current.key == key:
                return True
            elif current.key < key:
                current = current.right
            else:
                current = current.left
        return False

    def inorder(self, node):
        if node is not None:
            self.inorder(node.left)
            print(f' {node.key}', end='')
            self.inorder(node.right)

    def preorder(self, node):
        if node is not None:
            print(f' {node.key}', end='')
            self.preorder(node.left)
            self.preorder(node.right)

tree = BinarySearchTree()
n = int(input())
for i in range(n):
    command = input().split()
    if command[0] == 'insert':
        tree.insert(int(command[1]))
    elif command[0] == 'find':
        if tree.find(int(command[1])):
            print('yes')
        else:
            print('no')
    elif command[0] == 'print':
        tree.inorder(tree.root)
        print()
        tree.preorder(tree.root)
        print()

"
8899519,ALDS1_8_B,"class Node():
    def __init__(self,key):
        self.key=key
        self.left=None
        self.right=None
        self.p=None

root=None
def insert(z):
    global root
    y=None
    x=root
    while x!=None:
        y=x
        if z.key<x.key:
            x=x.left
        else:
            x=x.right
        
    z.p=y
    if y==None:
        root=z
    elif z.key<y.key:
        y.left=z
    else:
        y.right=z

def dfs(node):
    global preorder,inorder
    preorder.append(node.key)
    if node.left!=None:
        dfs(node.left)
    inorder.append(node.key)
    if node.right!=None:
        dfs(node.right)

def find(target, curr_node):
    if curr_node is None:
        print(""no"")
        return
    if curr_node.key == target:
        print(""yes"")
        return
    if target < curr_node.key:
        find(target, curr_node.left)
    else:
        find(target, curr_node.right)
        
n=int(input())

for i in range(n):
    s=list(input().split())
    if s[0]=='print':
        preorder=[]
        inorder=[]
        dfs(root)
        print(' ',end='')
        print(*inorder)
        print(' ',end='')
        print(*preorder)
    elif s[0]=='find':
        find(int(s[1]),root)
        
    else:
        insert(Node(int(s[1])))
"
8414786,ALDS1_8_B,"COMMAND_ID = 0
VALUE_ID = 1

class Node:
    def __init__(self, key, left, right):
        self.key = key
        self.left = left
        self.right = right

class BinaryTree:
    def __init__(self, root):
        self.root = root

    # 値の挿入
    def insert_node(self, z):
        y = None
        x = self.root
        while x:
            y = x
            if z.key < x.key:
                x = x.left
            else:
                x = x.right
        
        if not(y):
            self.root = z
        elif z.key < y.key:
            y.left = z
        else:
            y.right = z

    # 値の検索
    def find_node(self, node, k):
        # 終端条件
        if node == None:
            return False
        if node.key == k:
            return True
        # 再帰
        if node.key > k:
            return self.find_node(node.left, k)
        if node.key < k:
            return self.find_node(node.right, k)


    # 行きがけ順で出力
    def print_preorder(self, node):
        print(f' {node.key}', end='')
        # 再帰
        if node.left:
            self.print_preorder(node.left)
        if node.right:
            self.print_preorder(node.right)
    
    # 通りがけ順で出力
    def print_inorder(self, node):
        # 再帰
        if node.left:
            self.print_inorder(node.left)   
        print(f' {node.key}', end='')
        if node.right:
            self.print_inorder(node.right)


def main():
    m = int(input())

    tree = BinaryTree(None)
    for _ in range(m):
        cmd = input().split()
        if cmd[COMMAND_ID] == 'print':
            tree.print_inorder(tree.root)
            print()
            tree.print_preorder(tree.root)
            print()
        if cmd[COMMAND_ID] == 'insert':
            value = int(cmd[VALUE_ID])
            node = Node(value, None, None)
            tree.insert_node(node)
        if cmd[COMMAND_ID] == 'find':
            k = int(cmd[VALUE_ID])
            is_find = tree.find_node(tree.root, k)
            if is_find:
                print('yes')
            if not is_find:
                print('no')


if __name__ == '__main__':
    main()
"
8824148,ALDS1_8_B,"# aizu_ALDS1_8_B_BinarySearchTreeII.py  

class Node:
    def __init__(self,key):
        self.key = key
        self.parent = None
        self.left = None
        self.right = None
def preorder(id):
    if id == None:return
    que.append(id.key)
    n_id = id.left
    preorder(n_id)
    n_id = id.right
    preorder(n_id)
def inorder(id):
    if id == None:return
    n_id = id.left
    inorder(n_id)  
    que.append(id.key)
    n_id = id.right
    inorder(n_id)  
def insert(zz):
    global root
    z = Node(zz)
    y = None
    x = root
    while x!= None:
        y = x
        if z.key < x.key: x = x.left
        else: x = x.right
    z.parent = y
    if y == None: root = z
    elif z.key < y.key: y.left = z
    else: y.right = z
def find(zz):
    x = root
    while x != None:
        if zz == x.key: print('yes');return
        elif zz < x.key: x = x.left
        else: x = x.right
    print('no');return

root = None    
m = int(input())
for _ in range(m):
    *ope, = input().split()
    if ope[0] == 'insert': insert(int(ope[1]))
    if ope[0] == 'print':
        que = []; inorder(root) ; print('',*que)
        que = []; preorder(root); print('',*que)
    if ope[0] == 'find': find(int(ope[1]))
"
8934461,ALDS1_8_B,"import sys
sys.setrecursionlimit(10**6)

class Node:
    def __init__(self, data: int) -> None:
        self.data = data
        self.left = None
        self.right = None

class BinarySearchTree:
    def __init__(self, number_list: list = []) -> None:
        """"""初期化""""""
        self.root = None
        for num in number_list:
            self.insert(num)

    def insert(self, data) -> None:
        """"""挿入""""""
        n = self.root
        if n == None:
            self.root = Node(data)
            return
        else:
            while 1:
                entry = n.data
                if data < entry:
                    if n.left is None:
                        n.left = Node(data)
                        return
                    n = n.left
                elif data > entry:
                    if n.right is None:
                        n.right = Node(data)
                        return
                    n = n.right
                else:
                    n.data = data
                    return

    def search(self, search: int) -> bool:
        """"""探索(存在するか)""""""
        searcher = self._search_bool(search)
        if searcher is None:
            raise Exception
        return searcher

    def preorder(self, root: int = None) -> list:
        """"""先行順探索""""""
        res = []
        def _preorder(node: int) -> None:
            if node is None:
                return
            res.append(node.data)
            _preorder(node.left)
            _preorder(node.right)

        if root is None:
            root = self.root
        _preorder(root)
        return res

    def inorder(self, root: int = None) -> list:
        """"""中間順探索""""""
        res = []
        def _inorder(node: int) -> None:
            if node is None:
                return
            _inorder(node.left)
            res.append(node.data)
            _inorder(node.right)

        if root is None:
            root = self.root
        _inorder(root)
        return res

    def postorder(self, root: int = None) -> list:
        """"""後行順探索""""""
        res = []
        def _postorder(node: int) -> None:
            if node is None:
                return
            _postorder(node.left)
            _postorder(node.right)
            res.append(node.data)

        if root is None:
            root = self.root
        _postorder(root)
        return res

    def _search_bool(self, search) -> bool:
        n = self.root
        if n is None:
            raise Exception
        while n:
            if n.data == search:
                return True
            if search < n.data:
                n = n.left
            else:
                n = n.right
        return False

m = int(input())
t = BinarySearchTree()
for _ in range(m):
    s = input().split()
    if s[0] == ""insert"":
        k = int(s[1])
        t.insert(data=k)
    elif s[0] == ""print"":
        print("""", *t.inorder())
        print("""", *t.preorder())
    elif s[0] == ""find"":
        k = int(s[1])
        res = t.search(k)
        print(""yes"" if res else ""no"")

"
9090291,ALDS1_8_B,"class Node:
    def __init__(self, key:int) -> None:
        self.key: int = key
        self.parent: Node = None
        self.left: Node = None
        self.right: Node = None
    def order(self, mode: str):
        li = {
            ""Pre"": [0, 1, 2],  # 先行順巡回 node -> left -> right 
            ""In"": [1, 0, 2],   # 中間順巡回 left -> node -> right
            ""Post"": [1, 2, 0]  # 後方順巡回 right -> left -> right
        }
        for i in li[mode]:
            if i == 0: print(f"" {self.key}"", end = """")
            elif i == 1 and self.left != None : self.left.order(mode)
            elif i == 2 and self.right != None: self.right.order(mode)
        
class BinarySearchTree:
    def __init__(self) -> None:
        self.node: Node = None

def insert(t: BinarySearchTree, z : Node) -> None:
    y: Node = None  # x の親
    x: Node = t.node
    while x != None:
        y = x # 親を設定
        if z.key < x.key:
            x = x.left
        else:
            x = x.right
    z.parent = y
    if y == None:
        t.node = z
    elif z.key < y.key:
        y.left = z
    else:
        y.right = z

def ans(t: BinarySearchTree):
    t.node.order(""In"")  
    print()
    t.node.order(""Pre"")
    print() 
        
def find(t: BinarySearchTree, k: Node):
    x: Node = t.node
    while x != None:
        if x.key == k.key:
            print(""yes"")
            return
        if x.key < k.key: x = x.right
        else: x = x.left
    print(""no"")
    
n = int(input())
t = BinarySearchTree()
for _ in range(n):
    order = input()
    if order[0] == ""i"": insert(t, Node(int(order[7:])))
    elif order[0] == ""f"": find(t, Node(int(order[5:])))
    else: ans(t)

"
8281380,ALDS1_8_B,"class Node:
    def __init__(self, key: int, left = None, right = None, parent = None):
        self.key = key
        self.left = left
        self.right = right
        self.parent = parent
    def __str__(self):
        return self.key

class BinarySearchTree:
    def __init__(self, root = None):
        self.root = root
    
    def insert(self, z: Node) -> None:
        x = self.root # Tの根
        y = None # xの親
        # 木を探索
        while x != None:
            y = x # 親を設定
            if z.key < x.key:
                x = x.left
            else:
                x = x.right
        z.parent = y

        if y == None:
            self.root = z
        elif z.key < y.key:
            y.left = z
        else:
            y.right = z
    
    def find(self, k: int) -> Node:
        node = self.root
        while node != None and node.key != k:
            if node.key < k:
                node = node.right
            else:
                node = node.left
        return node

    def inorder(self, left: Node, root: Node, right: Node) -> list:
        if left != None and right != None:
            left = self.inorder(left.left, left, left.right)
            right = self.inorder(right.left, right, right.right)
            return left + [root] + right
        elif left != None and right == None:
            left = self.inorder(left.left, left, left.right)
            return left + [root]
        elif left == None and right != None:
            right = self.inorder(right.left, right, right.right)
            return [root] + right
        else:
            return [root]
    
    def print_inorder(self) -> list:
        inorder_list = self.inorder(self.root.left, self.root, self.root.right)
        ans = []
        for node in inorder_list:
            ans.append(node.key)
        return ans
    
    def preorder(self, left: Node, root: Node, right: Node) -> list:
        if left != None and right != None:
            left = self.preorder(left.left, left, left.right)
            right = self.preorder(right.left, right, right.right)
            return [root] + left + right
        elif left != None and right == None:
            left = self.preorder(left.left, left, left.right)
            return [root] + left
        elif left == None and right != None:
            right = self.preorder(right.left, right, right.right)
            return [root] + right
        else:
            return [root]
        
    def print_preorder(self) -> list:
        preorder_list = self.preorder(self.root.left, self.root, self.root.right)
        ans = []
        for node in preorder_list:
            ans.append(node.key)
        return ans
    
    def postorder(self, left: Node, root: Node, right: Node) -> list:
        if left != None and right != None:
            left = self.postorder(left.left, left, left.right)
            right = self.postorder(right.left, right, right.right)
            return left + right + [root]
        elif left != None and right == None:
            left = self.postorder(left.left, left, left.right)
            return left + [root]
        elif left == None and right != None:
            right = self.postorder(right.left, right, right.right)
            return right + [root]
        else:
            return [root]
        
    def print_postorder(self) -> list:
        postorder_list = self.postorder(self.root.left, self.root, self.root.right)
        ans = []
        for node in postorder_list:
            ans.append(node.key)
        return ans


if __name__==""__main__"":
    BST = BinarySearchTree()
    n = int(input())
    for i in range(n):
        mei, *key = input().split()
        if key != []:
            key = int(key[0])
        if mei == ""insert"":
            BST.insert(Node(key))
        elif mei == ""print"":
            print("""", *BST.print_inorder())
            print("""", *BST.print_preorder())
        elif mei == ""find"":
            ans = BST.find(key)
            if ans == None:
                print(""no"")
            else:
                print(""yes"")
"
8367409,ALDS1_8_B,"class Node:
  def __init__(self, key):
    self.key = key

    self.left  = None
    self.right = None


def find(key):
  global tree

  branch = tree
  while True:
    if key == branch.key:
      print('yes')
      return
    elif key < branch.key:
      if branch.left is None:
        break
      # Move to left.
      branch = branch.left
    else:
      if branch.right is None:
        break
      # Move to right.
      branch = branch.right
  print('no')

def insert(new_node_key):
  global tree

  new_node = Node(new_node_key)

  if tree is None:
    # Make `new_node` as root of `tree`.
    tree = new_node
    return

  # Find branch to insert `new_node`.
  branch = tree
  while True:
    if new_node.key < branch.key:
      if branch.left is None:
        break
      # Move to left.
      branch = branch.left
    else:
      if branch.right is None:
        break
      # Move to right.
      branch = branch.right

  if new_node.key < branch.key:
    # Insert `new_node` as left of `branch`.
    branch.left = new_node
  else:
    # Insert `new_node` as right of `branch`.
    branch.right = new_node

def walk_tree(tree, fns):
  def walk(tree):
    if tree is None:
      return
    for f in fns:
      f(walk, tree)
  walk(tree)

def print_tree():
  # Print as inorder.
  walk_tree(tree, [
    lambda walk, node: walk(node.left),
    lambda walk, node: print(' ' + str(node.key), end=''),
    lambda walk, node: walk(node.right),
    ])
  print()

  # Print as preorder.
  walk_tree(tree, [
    lambda walk, node: print(' ' + str(node.key), end=''),
    lambda walk, node: walk(node.left),
    lambda walk, node: walk(node.right),
    ])
  print()


# Init tree.
tree = None

# Run.
num_insts = int(input())

for _ in range(num_insts):
  toks = input().split()
  if toks[0] == 'find':
    find(int(toks[1]))
  elif toks[0] == 'insert':
    insert(int(toks[1]))
  elif toks[0] == 'print':
    print_tree()
  else:
    raise ValueError(f'Invalid inst: {toks[0]}')
"
8527788,ALDS1_8_B,"class Node:
  def __init__(self, key, left=None, right=None):
    self.key = key
    self.left = left
    self.right = right

def insert(key):
  global root
  if root:
    ch = root
    while ch:
      pa, ch = ch, ch.left if key < ch.key else ch.right
    if key < pa.key:
      pa.left = Node(key)
    else:
      pa.right = Node(key)
  else:
    root = Node(key)

def find(key):
  node = root
  while node and node.key != key:
    node = node.left if key < node.key else node.right
  print(""yes"" if node else ""no"")

def delete(key):
  global root
  pa, node = None, root
  while node.key != key:
    pa, node = node, node.left if key < node.key else node.right
  if node.left and node.right:
    pa, to_del = node, node.right
    while to_del.left:
      pa, to_del = to_del, to_del.left
    node.key = to_del.key
  else:
    to_del = node
  ch = to_del.left or to_del.right
  if not pa:
    root = ch
  elif pa.left == to_del:
    pa.left = ch
  else:
    pa.right = ch

def walk(node, order):
  walked = """"
  if node:
    if order == ""Pre"":
      walked += f"" {node.key}""
    walked += walk(node.left, order)
    if order == ""In"":
      walked += f"" {node.key}""
    walked += walk(node.right, order)
  return walked

def show():
  for order in [""In"", ""Pre""]:
    print(walk(root, order))

root = None
cmds = {""print"":show, ""insert"":insert, ""find"":find, ""delete"":delete}
for _ in range(int(input())):
  cmd_name, *key = input().split()
  cmds[cmd_name](*map(int, key))

"
2835186,ALDS1_8_B,"import sys

class Node():
    __slots__ = ['key', 'left', 'right']
    def __init__(self, key):
        self.key = key
        self.left, self.right = None, None

def insert(z):
    global root
    x, y = root, None
    while x:
        y = x
        if z < x.key:
            x = x.left
        else:
            x = x.right
    
    if y == None:
        root = Node(z)
    elif z < y.key:
        y.left = Node(z)
    else:
        y.right = Node(z)
        
def find(z):
    global root
    x, y = root, None
    while x:
        y = x
        if z < x.key:
            x = x.left
        elif z > x.key:
            x = x.right
        else:
            print(""yes"")
            return
    print(""no"")
        
def preorder(x):
    return f"" {x.key}"" + preorder(x.left) + preorder(x.right) if x else """"

def inorder(x):
    return inorder(x.left) + f"" {x.key}"" + inorder(x.right) if x else """"
        
input()
root = None
for s in sys.stdin:
    if s[0] == ""p"":
        print(inorder(root))
        print(preorder(root))
    elif s[0] == ""f"":
        find(int(s[5:]))
    else:
        insert(int(s[7:]))
"
4470631,ALDS1_8_B,"import sys
class Node:
    __slots__ = ['key', 'left', 'right']
    def __init__(self, key):
        self.key = key
        self.left = self.right = None

root = None

def insert(key):
    global root
    x, y = root, None
    while x:
        y = x
        if key < x.key:
            x = x.left
        else:
            x = x.right

    if y is None:
        root = Node(key)
    elif key < y.key:
        y.left = Node(key)
    else:
        y.right = Node(key)

def find(key):
    global root
    x = root
    while x:
        if key < x.key:
            x = x.left
        elif key == x.key:
            return ""yes""
        else:
            x = x.right
    return ""no""
            
def inorder(node):
    return inorder(node.left) + f' {node.key}' + inorder(node.right) if node else ''
def preorder(node):
    return f' {node.key}' + preorder(node.left) + preorder(node.right) if node else ''

n = int(input())
for e in sys.stdin:
    if e[0] == 'i':
        insert(int(e[7:]))
    elif e[0] == ""f"":
        print(find(int(e[5:])))
    else:
        print(inorder(root))
        print(preorder(root))
"
4483534,ALDS1_8_B,"import sys

class Node():
    __slots__ = ['key', 'left', 'right']
    def __init__(self, key):
        self.key = key
        self.left, self.right = None, None

def insert(z):
    global root
    x, y = root, None
    while x:
        y = x
        if z < x.key:
            x = x.left
        else:
            x = x.right
    
    if y == None:
        root = Node(z)
    elif z < y.key:
        y.left = Node(z)
    else:
        y.right = Node(z)
        
def find(z):
    global root
    x, y = root, None
    while x:
        y = x
        if z < x.key:
            x = x.left
        elif z > x.key:
            x = x.right
        else:
            print(""yes"")
            return
    print(""no"")
        
def preorder(x):
    return f"" {x.key}"" + preorder(x.left) + preorder(x.right) if x else """"

def inorder(x):
    return inorder(x.left) + f"" {x.key}"" + inorder(x.right) if x else """"
        
input()
root = None
for s in sys.stdin:
    if s[0] == ""p"":
        print(inorder(root))
        print(preorder(root))
    elif s[0] == ""f"":
        find(int(s[5:]))
    else:
        insert(int(s[7:]))

"
4481446,ALDS1_8_B,"import sys

class Node():
    __slots__ = ['key', 'left', 'right']
    def __init__(self, key):
        self.key = key
        self.left, self.right = None, None

def insert(z):
    global root
    x, y = root, None
    while x:
        y = x
        if z < x.key:
            x = x.left
        else:
            x = x.right
    
    if y == None:
        root = Node(z)
    elif z < y.key:
        y.left = Node(z)
    else:
        y.right = Node(z)
        
def find(z):
    global root
    x, y = root, None
    while x:
        y = x
        if z < x.key:
            x = x.left
        elif z > x.key:
            x = x.right
        else:
            print(""yes"")
            return
    print(""no"")
        
def preorder(x):
    return f"" {x.key}"" + preorder(x.left) + preorder(x.right) if x else """"

def inorder(x):
    return inorder(x.left) + f"" {x.key}"" + inorder(x.right) if x else """"
        
input()
root = None
for s in sys.stdin:
    if s[0] == ""p"":
        print(inorder(root))
        print(preorder(root))
    elif s[0] == ""f"":
        find(int(s[5:]))
    else:
        insert(int(s[7:]))
"
8571301,ALDS1_8_B,"from functools import total_ordering


@total_ordering
class Node:
    def __init__(self, key: int) -> None:
        self.key: int = key
        self.parent: Node = None
        self.left: Node = None
        self.right: Node = None

    def __eq__(self, __value: object) -> bool:
        if not isinstance(__value, Node):
            return NotImplemented
        return self.key == __value.key

    def __lt__(self, __value: object) -> bool:
        if not isinstance(__value, Node):
            return NotImplemented
        return self.key < __value.key


class BinarySearchTree:
    def __init__(self) -> None:
        self.root: Node = None

    def insert(self, z: Node) -> None:
        y: Node = None
        x: Node = self.root
        while x is not None:
            y = x
            if z < x:
                x = x.left
            else:
                x = x.right
        z.parent = y

        if y is None:  # the root is empty
            self.root = z
        elif z < y:
            y.left = z
        else:
            y.right = z

    def _preorder(self, root: Node) -> list:
        if root.left is None:
            left = []
        else:
            left = self._preorder(root.left)

        if root.right is None:
            right = []
        else:
            right = self._preorder(root.right)

        return [root.key] + left + right

    def print_preorder(self) -> None:
        print("" "" + "" "".join(map(str, self._preorder(self.root))))

    def _inorder(self, root: Node) -> list:
        if root.left is None:
            left = []
        else:
            left = self._inorder(root.left)

        if root.right is None:
            right = []
        else:
            right = self._inorder(root.right)

        return left + [root.key] + right

    def print_inorder(self) -> None:
        print("" "" + "" "".join(map(str, self._inorder(self.root))))

    def find(self, key: int) -> bool:
        x = self.root
        while x is not None:
            if x.key == key:
                return True
            elif x.key < key:
                x = x.right
            else:
                x = x.left
        return False


n = int(input())
binary_search_tree = BinarySearchTree()

for _ in range(n):
    command = input().split()
    if command[0] == ""insert"":
        node = Node(int(command[1]))
        binary_search_tree.insert(node)
    elif command[0] == ""print"":
        binary_search_tree.print_inorder()
        binary_search_tree.print_preorder()
    elif command[0] == ""find"":
        if binary_search_tree.find(int(command[1])):
            print(""yes"")
        else:
            print(""no"")

"
4305639,ALDS1_8_B,"import sys

class Node:
    __slots__ = [""key"",""left"",""right""]
    def __init__(self,key):
        self.key = key
        self.left = self.right = None

root = None

def insert(key):
    global root
    x,y = root,None
    while x:
        y = x
        x = x.left if key < x.key else x.right
    if y is None:root = Node(key)
    elif key < y.key:y.left = Node(key)
    else:y.right = Node(key)

def find(target):
    result = root
    while result and target != result.key:
        result = result.left if target < result.key else result.right
    return result is None

def inorder(node):
    return inorder(node.left) + f' {node.key}' + inorder(node.right) if node else """"

def preorder(node):
    return f' {node.key}' + preorder(node.left) + preorder(node.right) if node else """"

input()
for e in sys.stdin:
    if e[0] == ""i"":insert(int(e[7:]))
    elif e[0] ==""f"":print([""yes"",""no""][find(int(e[5:]))])
    else:print(inorder(root));print(preorder(root))

"
7617536,ALDS1_8_B,"import sys

class Node:
    __slots__ = ['key', 'left', 'right']
    def __init__(self, key):
        self.key = key
        self.left = self.right = None

root = None

def insert(key):
    global root
    x, y = root, None
    while x: x, y = x.left if key < x.key else x.right, x
    if y is None: root = Node(key)
    elif key < y.key: y.left = Node(key)
    else: y.right = Node(key)

def find(target):
    result = root
    while result and target != result.key:
        result = result.left if target < result.key else result.right
    return result is None

def inorder(node):
    return inorder(node.left) + f' {node.key}' + inorder(node.right) if node else ''
def preorder(node):
    return f' {node.key}' + preorder(node.left) + preorder(node.right) if node else ''

input()
for e in sys.stdin:
    if e[0] == 'i': insert(int(e[7:]))
    elif e[0] == 'f': print(['yes','no'][find(int(e[5:]))])
    else: print(inorder(root)); print(preorder(root))

"
5329391,ALDS1_8_B,"import sys

class Node:
    __slots__ = ['key', 'left', 'right']
    def __init__(self, key):
        self.key = key
        self.left = self.right = None

root = None

def insert(key):
    global root
    x, y = root, None
    while x: x, y = x.left if key < x.key else x.right, x
    if y is None: root = Node(key)
    elif key < y.key: y.left = Node(key)
    else: y.right = Node(key)

def find(target):
    result = root
    while result and target != result.key:
        result = result.left if target < result.key else result.right
    return result is None

def inorder(node):
    return inorder(node.left) + f' {node.key}' + inorder(node.right) if node else ''
def preorder(node):
    return f' {node.key}' + preorder(node.left) + preorder(node.right) if node else ''

input()
for e in sys.stdin:
    if e[0] == 'i': insert(int(e[7:]))
    elif e[0] == 'f': print(['yes','no'][find(int(e[5:]))])
    else: print(inorder(root)); print(preorder(root))
"
2721893,ALDS1_8_B,"import sys

class Node:
    __slots__ = ['key', 'left', 'right']
    def __init__(self, key):
        self.key = key
        self.left = self.right = None

root = None

def insert(key):
    global root
    x, y = root, None
    while x: x, y = x.left if key < x.key else x.right, x
    if y is None: root = Node(key)
    elif key < y.key: y.left = Node(key)
    else: y.right = Node(key)

def find(target):
    result = root
    while result and target != result.key:
        result = result.left if target < result.key else result.right
    return result is None

def inorder(node):
    return inorder(node.left) + f' {node.key}' + inorder(node.right) if node else ''
def preorder(node):
    return f' {node.key}' + preorder(node.left) + preorder(node.right) if node else ''

input()
for e in sys.stdin:
    if e[0] == 'i': insert(int(e[7:]))
    elif e[0] == 'f': print(['yes','no'][find(int(e[5:]))])
    else: print(inorder(root)); print(preorder(root))
"
4624242,ALDS1_8_B,"import sys
# def input():
#     return sys.stdin.readline()[:-1]

# n = int(input())
# A = [input().split() for i in range(n)]

class Node():
    __slots__ = ['key', 'left', 'right']
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None


def insert(key):
    global root
    x = root # x is current node
    y = None  #  parent of x 
    while x:
        y = x # set parent
        if key < x.key:
            x = x.left # move to left child
        else:
            x = x.right #move to right child
    
    if root is None:
        root = Node(key)
    elif key < y.key: # set z as left child of y
        y.left = Node(key)
    else: 
        y.right = Node(key) # set z as right child of y
        
        
def find(key):
    x = root
    while x:
        if key==x.key:
            print('yes')
            return
        elif key < x.key:
            x = x.left
        else:
            x = x.right
    print('no')
    

def inorder(inorder_list, node):
    if node.left is not None:
        inorder(inorder_list, node.left)
    inorder_list.append(str(node.key))
    if node.right is not None:
        inorder(inorder_list, node.right)
    return inorder_list
        
def preorder(preorder_list, node):
    preorder_list.append(str(node.key))
    if node.left is not None:
        preorder(preorder_list, node.left)
    if node.right is not None:
        preorder(preorder_list, node.right)
    return preorder_list
        
root = None

input()
for o in sys.stdin:
    if o[0]=='i':
        insert(int(o[7:]))
    elif o[0]=='f':
        find(int(o[5:]))
    else:
        x = root
        inorder_list = inorder([], x)
        print(' '+' '.join(inorder_list))
        preorder_list = preorder([], x)
        print(' '+' '.join(preorder_list))
"
3995828,ALDS1_8_B,"import sys

class Node:
    __slots__ = ['key', 'left', 'right']
    def __init__(self, key):
        self.key = key
        self.left = self.right = None

root = None

def insert(key):
    global root
    x, y = root, None
    while x: x, y = x.left if key < x.key else x.right, x
    if y is None: root = Node(key)
    elif key < y.key: y.left = Node(key)
    else: y.right = Node(key)

def find(target):
    result = root
    while result and target != result.key:
        result = result.left if target < result.key else result.right
    return result is None

def inorder(node):
    return inorder(node.left) + f' {node.key}' + inorder(node.right) if node else ''
def preorder(node):
    return f' {node.key}' + preorder(node.left) + preorder(node.right) if node else ''

input()
for e in sys.stdin:
    if e[0] == 'i': insert(int(e[7:]))
    elif e[0] == 'f': print(['yes','no'][find(int(e[5:]))])
    else: print(inorder(root)); print(preorder(root))
"
4254125,ALDS1_8_B,"import sys

class Node:
    __slots__ = ['key', 'left', 'right']
    def __init__(self, key):
        self.key = key
        self.left = self.right = None

root = None

def insert(key):
    global root
    x, y = root, None
    while x: x, y = x.left if key < x.key else x.right, x
    if y is None: root = Node(key)
    elif key < y.key: y.left = Node(key)
    else: y.right = Node(key)

def find(target):
    result = root
    while result and target != result.key:
        result = result.left if target < result.key else result.right
    return result is None

def inorder(node):
    return inorder(node.left) + f' {node.key}' + inorder(node.right) if node else ''
def preorder(node):
    return f' {node.key}' + preorder(node.left) + preorder(node.right) if node else ''

input()
for e in sys.stdin:
    if e[0] == 'i': insert(int(e[7:]))
    elif e[0] == 'f': print(['yes','no'][find(int(e[5:]))])
    else: print(inorder(root)); print(preorder(root))

"
5426581,ALDS1_8_B,"import sys

class Node:
    __slots__ = ['key', 'left', 'right']
    def __init__(self, key):
        self.key = key
        self.left = self.right = None

root = None

def insert(key):
    global root
    x, y = root, None
    while x: x, y = x.left if key < x.key else x.right, x
    if y is None: root = Node(key)
    elif key < y.key: y.left = Node(key)
    else: y.right = Node(key)

def find(target):
    result = root
    while result and target != result.key:
        result = result.left if target < result.key else result.right
    return result is None

def inorder(node):
    return inorder(node.left) + f' {node.key}' + inorder(node.right) if node else ''
def preorder(node):
    return f' {node.key}' + preorder(node.left) + preorder(node.right) if node else ''

input()
for e in sys.stdin:
    if e[0] == 'i': insert(int(e[7:]))
    elif e[0] == 'f': print(['yes','no'][find(int(e[5:]))])
    else: print(inorder(root)); print(preorder(root))
"
3120641,ALDS1_8_B,"import sys
class Node:
    __slots__ = ['key', 'left', 'right']
    def __init__(self, key):
        self.key = key
        self.left = self.right = None

root = None

def find(target):
    result = root
    while result and target != result.key:
        result = result.left if target < result.key else result.right
    if result is None:
        return False
    else:
        return True

def insert(key):
    global root
    y = None  # xの親
    x = root
    while x:
        y = x
        x = x.left if key < x.key else x.right
    if y is None:  # Tが空の場合
        root = Node(key)
    elif key < y.key:
        y.left = Node(key)
    else:
        y.right = Node(key)

def in_order(node):
    if node is None:
        return ''
    return in_order(node.left) + f' {node.key}' + in_order(node.right)
def pre_order(node):
    if node is None:
        return ''
    return f' {node.key}' + pre_order(node.left) + pre_order(node.right)
input()
for e in sys.stdin:
    if e[0] == 'i':
        insert(int(e[7:]))
    elif e[0] == 'f':
        print('yes' if find(int(e[5:])) else 'no')
    else:
        print(in_order(root))
        print(pre_order(root))
"
4508682,ALDS1_8_B,"from collections import deque
import sys
readline = sys.stdin.readline
write = sys.stdout.write

class Node:
    __slots__ = ['key', 'left', 'right']
    def __init__(self, key):
        self.key = key
        self.left = self.right = None


root = None

def insert(key):
    global root
    x = root #Tの根
    y = None #親を設定
    while x is not None:
        y = x
        if key < x.key:
            x = x.left #左の子へ移動
        else:
            x = x.right  #右の子へ移動

    if y is None: #Tが空の場合
        root = Node(key)
    elif key < y.key:
        y.left = Node(key) #keyをyの左の子にする
    else:
        y.right = Node(key) #keyをyの右の子にする

# def find(key):
#     x = root
#     while x and key != x.key:
#         x = x.left if key < x.key else x.right
#     return x is None

def find(target):
    result = root
    while result and target != result.key:
        result = result.left if target < result.key else result.right
    return result is None # result が None ⇒ false

def inorder(node):
    return   inorder(node.left) + "" ""+ str(node.key) + inorder(node.right) if node else ''
def preorder(node):
    return   "" "" + str(node.key) + preorder(node.left) + preorder(node.right) if node else ''
input()
for e in sys.stdin:
    if e[0] == ""i"":
        insert(int(e[7:]))
    elif e[0] == 'f':
        if find(int(e[5:])):
            print(""no"")
        else:
            print(""yes"")
        # print(['yes','no'][find(int(e[5:]))])
    else:
        print(inorder(root))
        print(preorder(root))
"
8786985,ALDS1_8_B,"# from icecream import ic

n = int(input())

opeList = []
for i in range(n):
    operation = list(map(str,input().split()))
    if len(operation) == 2:
        operation[1] = int(operation[1])
    opeList.append(operation)
# ic(opeList)

root = opeList[0][1]
# ic(root)

left, parent, right = 0, 1, 2

def parse(T:dict,z,p):
    if z < p:
        if T[p][left] == None:
            T[p][left] = z
            T[z][parent] = p
        else:
            parse(T,z,T[p][left])
    elif z > p:
        if T[p][right] == None:
            T[p][right] = z
            T[z][parent] = p
        else:
            parse(T,z,T[p][right])

def insert(T:dict,z):
    if len(T) == 0:
        T[""root""] = z
        T[z] = [None, None, None] # left, parent, right
    
    else:
        T[z] = [None, None, None] # left, parent, right
        parse(T,z,T[""root""])
    # ic(z,T)
        
def find(T:dict,z):
    return True if z in T else False

def pretw(i):
    if i != None:
        print(f"" {i}"",end="""")
        pretw(treeDict[i][left])
        pretw(treeDict[i][right])

def intw(i):
    if i != None:
        intw(treeDict[i][left])
        print(f"" {i}"",end="""")
        intw(treeDict[i][right])

# treeDict -> {key:[left, parent, right], key:[...], key:[...], ...}
treeDict = {}
for i in opeList:
    if len(i) == 2:
        if i[0] == ""insert"":
            # ic(i[1], treeDict)
            insert(treeDict, i[1])
        elif i[0] == ""find"":
            print(""yes"") if find(treeDict,i[1]) == True else print(""no"")
    else:
        if i[0] == ""print"":
            intw(root)
            print()
            pretw(root)
            print()
"
6063168,ALDS1_8_B,"import sys


class Node:
    __slots__ = ['key', 'left', 'right']

    def __init__(self, key):
        self.key = key
        self.left = self.right = None


root = None


def insert(key):
    global root
    x, y = root, None
    while x: x, y = x.left if key < x.key else x.right, x
    if y is None:
        root = Node(key)
    elif key < y.key:
        y.left = Node(key)
    else:
        y.right = Node(key)


def find(target):
    result = root
    while result and target != result.key:
        result = result.left if target < result.key else result.right
    return result is None


def inorder(node):
    return inorder(node.left) + f' {node.key}' + inorder(node.right) if node else ''


def preorder(node):
    return f' {node.key}' + preorder(node.left) + preorder(node.right) if node else ''


sys.stdin.readline()
for line in sys.stdin:
    line = line.split()
    if line[0] == 'insert':
        insert(int(line[1]))
    elif line[0] == 'find':
        print(['yes', 'no'][find(int(line[1]))])
    else:
        print(inorder(root))
        print(preorder(root))
"
3574433,ALDS1_8_B,"class BinarySearchTree(object):
    __slots__ = ['root']

    def __init__(self):
        self.root = None

    def insert(self, key):
        new_node = [key, None, None]

        if self.root is None:
            self.root = new_node
            return

        parent, child = None, self.root
        while child:
            parent = child
            child = child[1] if key < child[0] else child[2]

        if key < parent[0]:
            parent[1] = new_node
        else:
            parent[2] = new_node

    def find(self, key):
        current = self.root
        while current and current[0] != key:
            current = current[1] if key < current[0] else current[2]

        return current

    def walk(self, walk_type):
        a = []
        self._walk(self.root, a, walk_type)
        return a

    def _walk(self, node, a, walk_type):
        if walk_type == 0:
            a.append(node[0])
        if node[1]:
            self._walk(node[1], a, walk_type)
        if walk_type == 1:
            a.append(node[0])
        if node[2]:
            self._walk(node[2], a, walk_type)


if __name__ == '__main__':
    import sys
    input()
    tree = BinarySearchTree()

    for cmd in (l.split() for l in sys.stdin):
        if cmd[0] == 'insert':
            tree.insert(int(cmd[1]))
        elif cmd[0] == 'find':
            print('yes' if tree.find(int(cmd[1])) else 'no')
        else:
            print('', *tree.walk(1))
            print('', *tree.walk(0))
"
3986028,ALDS1_8_B,"from collections import deque
import sys
readline = sys.stdin.readline
write = sys.stdout.write

root = None
def insert(z):
    global root
    y = None
    x = root
    while x is not None:
        y = x
        if z[2] < x[2]:
            x = x[0]
        else:
            x = x[1]
    z[3] = y

    if y is None:
        root = z
    elif z[2] < y[2]:
        y[0] = z
    else:
        y[1] = z

def find(k):
    x = root
    while x is not None:
        if x[2] == k:
            return 1
        if k < x[2]:
            x = x[0]
        else:
            x = x[1]
    return 0

def debug():
    s0 = [""""]
    s1 = [""""]

    def dfs(nd):
        v = str(nd[2])
        s0.append(v)
        if nd[0] is not None:
            dfs(nd[0])
        s1.append(v)
        if nd[1] is not None:
            dfs(nd[1])
    dfs(root)
    return "" "".join(s1), "" "".join(s0)


M = int(readline())
ans = []
for m in range(M):
    cmd, *V, = readline().split()
    if cmd == ""print"":
        ans.extend(debug())
    elif cmd == ""find"":
        ans.append(""yes"" if find(int(V[0])) else ""no"")
    else:
        insert([None, None, int(V[0]), None])
write(""\n"".join(ans))
write(""\n"")


"
6955788,ALDS1_8_B,"from collections import deque
import sys
readline = sys.stdin.readline
write = sys.stdout.write

root = None
def insert(z):
    global root
    y = None
    x = root
    while x is not None:
        y = x
        if z[2] < x[2]:
            x = x[0]
        else:
            x = x[1]
    z[3] = y

    if y is None:
        root = z
    elif z[2] < y[2]:
        y[0] = z
    else:
        y[1] = z

def find(k):
    x = root
    while x is not None:
        if x[2] == k:
            return 1
        if k < x[2]:
            x = x[0]
        else:
            x = x[1]
    return 0

def debug():
    s0 = [""""]
    s1 = [""""]

    def dfs(nd):
        v = str(nd[2])
        s0.append(v)
        if nd[0] is not None:
            dfs(nd[0])
        s1.append(v)
        if nd[1] is not None:
            dfs(nd[1])
    dfs(root)
    return "" "".join(s1), "" "".join(s0)


M = int(readline())
ans = []
for m in range(M):
    cmd, *V, = readline().split()
    if cmd == ""print"":
        ans.extend(debug())
    elif cmd == ""find"":
        ans.append(""yes"" if find(int(V[0])) else ""no"")
    else:
        insert([None, None, int(V[0]), None])
write(""\n"".join(ans))
write(""\n"")

"
3698424,ALDS1_8_B,"from collections import deque
import sys
readline = sys.stdin.readline
write = sys.stdout.write
 
root = None
def insert(z):
    global root
    y = None
    x = root
    while x is not None:
        y = x
        if z[2] < x[2]:
            x = x[0]
        else:
            x = x[1]
    z[3] = y
 
    if y is None:
        root = z
    elif z[2] < y[2]:
        y[0] = z
    else:
        y[1] = z
 
def find(k):
    x = root
    while x is not None:
        if x[2] == k:
            return 1
        if k < x[2]:
            x = x[0]
        else:
            x = x[1]
    return 0
 
def debug():
    s0 = [""""]
    s1 = [""""]
 
    def dfs(nd):
        v = str(nd[2])
        s0.append(v)
        if nd[0] is not None:
            dfs(nd[0])
        s1.append(v)
        if nd[1] is not None:
            dfs(nd[1])
    dfs(root)
    return "" "".join(s1), "" "".join(s0)
 
 
M = int(readline())
ans = []
for m in range(M):
    cmd, *V, = readline().split()
    if cmd == ""print"":
        ans.extend(debug())
    elif cmd == ""find"":
        ans.append(""yes"" if find(int(V[0])) else ""no"")
    else:
        insert([None, None, int(V[0]), None])
write(""\n"".join(ans))
write(""\n"")
"
7610176,ALDS1_8_B,"from collections import deque
import sys
readline = sys.stdin.readline
write = sys.stdout.write

root = None
def insert(z):
    global root
    y = None
    x = root
    while x is not None:
        y = x
        if z[2] < x[2]:
            x = x[0]
        else:
            x = x[1]
    z[3] = y

    if y is None:
        root = z
    elif z[2] < y[2]:
        y[0] = z
    else:
        y[1] = z

def find(k):
    x = root
    while x is not None:
        if x[2] == k:
            return 1
        if k < x[2]:
            x = x[0]
        else:
            x = x[1]
    return 0

def debug():
    s0 = [""""]
    s1 = [""""]

    def dfs(nd):
        v = str(nd[2])
        s0.append(v)
        if nd[0] is not None:
            dfs(nd[0])
        s1.append(v)
        if nd[1] is not None:
            dfs(nd[1])
    dfs(root)
    return "" "".join(s1), "" "".join(s0)


M = int(readline())
ans = []
for m in range(M):
    cmd, *V, = readline().split()
    if cmd == ""print"":
        ans.extend(debug())
    elif cmd == ""find"":
        ans.append(""yes"" if find(int(V[0])) else ""no"")
    else:
        insert([None, None, int(V[0]), None])
write(""\n"".join(ans))
write(""\n"")


"
6814137,ALDS1_8_B,"import sys
root = None
class Node:
    __slots__ = ['key', 'left', 'right']

    def __init__(self, key):
        self.key = key
        self.left = self.right = None
def insert(key):
    global root
    x, y = root, None
    while x: x, y = x.left if key < x.key else x.right, x
    if y is None:
        root = Node(key)
    elif key < y.key:
        y.left = Node(key)
    else:
        y.right = Node(key)
def find(key, node):
    if node and node.key == key:
        return print(""yes"")
    elif not node:
        return print(""no"")

    if node and key < node.key:
        find(key, node.left)
    elif node:
        find(key, node.right)
def preorder(node):
    return f' {node.key}' + preorder(node.left) + preorder(node.right) if node else ''
def inorder(node):
    return inorder(node.left) + f' {node.key}' + inorder(node.right) if node else ''

input()
for e in sys.stdin:
    if e[0] == ""i"": insert(int(e[7:]))
    elif e[0] == ""f"": find(int(e[5:]), root)
    else: print(inorder(root)); print(preorder(root))

"
8388815,ALDS1_8_B,"# Nodeクラスの定義。二分探索木の各ノードを表します。
class Node:
    def __init__(self, key):
        self.key = key  # ノードのキー値
        self.right = None  # 右の子ノードへの参照
        self.left = None  # 左の子ノードへの参照
        self.parent = None  # 親ノードへの参照

# 二分探索木を表すクラス
class BinarySearchTree:
    def __init__(self):
        self.root = None  # 木のルートノード

    # キー値kを持つノードを探す関数
    def find(self, k):
        u = self.root
        while u and k != u.key:
            if k < u.key:
                u = u.left
            else:
                u = u.right
        return u

    # キー値kを持つ新しいノードを木に挿入する関数
    def insert(self, k):
        y = None
        x = self.root
        z = Node(k)

        while x:
            y = x
            if z.key < x.key:
                x = x.left
            else:
                x = x.right

        z.parent = y
        if y is None:
            self.root = z
        elif z.key < y.key:
            y.left = z
        else:
            y.right = z

    # 中順巡回を行い、キーのリストを返す関数
    def inorder(self, u):
        if not u:
            return []
        return self.inorder(u.left) + [u.key] + self.inorder(u.right)

    # 前順巡回を行い、キーのリストを返す関数
    def preorder(self, u):
        if not u:
            return []
        return [u.key] + self.preorder(u.left) + self.preorder(u.right)

# メインの実行部分
if __name__ == ""__main__"":
    bst = BinarySearchTree()  # 二分探索木のインスタンスを作成
    n = int(input())  # コマンドの数を入力

    for _ in range(n):
        command = input().split()  # コマンドを入力
        if command[0] == ""find"":
            x = int(command[1])
            t = bst.find(x)
            if t:
                print(""yes"")
            else:
                print(""no"")
        elif command[0] == ""insert"":
            x = int(command[1])
            bst.insert(x)
        elif command[0] == ""print"":
            print(f' {"" "".join(map(str, bst.inorder(bst.root)))}')
            print(f' {"" "".join(map(str, bst.preorder(bst.root)))}')

"
4906507,ALDS1_8_B,"import sys
class Node:
    # slotsで使用する属性を指定することで処理が早くなるらしい
    __slots__ = [""key"", ""left"", ""right""]
    def __init__(self, key):
        self.key = key
        self.left = self.right = None

root = None

def insert(key):
    global root
    x, y = root, None
    while x:
        # 連続で書いてあるため見えづらいが、xはx.left if key < x.key else x.rightの条件式の結果を代入
        # はxを代入している
        x,y = x.left if key < x.key else x.right, x
    if y is None: root = Node(key)
    elif key < y.key: y.left = Node(key)
    else: y.right = Node(key)

def find(key, node):
    if node and node.key == key:
        return print(""yes"")
    elif not node:
        return print(""no"")

    if node and key < node.key:
        find(key, node.left)
    elif node:
        find(key, node.right)

def inorder(node):
    # 左,根,右の順で表示する
    return inorder(node.left) + f' {node.key}' + inorder(node.right) if node else ''
def preorder(node):
    # 根,左,右の順で表示する
    return f' {node.key}' + preorder(node.left) + preorder(node.right) if node else ''

input()
for e in sys.stdin:
    if e[0] == ""i"": insert(int(e[7:]))
    elif e[0] == ""f"": find(int(e[5:]), root)
    else: print(inorder(root)); print(preorder(root))
"
6814001,ALDS1_8_B,"import sys
root = None
class Node:
    __slots__ = ['key', 'left', 'right']

    def __init__(self, key):
        self.key = key
        self.left = self.right = None
def insert(key):
    global root
    x, y = root, None
    while x: x, y = x.left if key < x.key else x.right, x
    if y is None:
        root = Node(key)
    elif key < y.key:
        y.left = Node(key)
    else:
        y.right = Node(key)
def find(key, node):
    if node and node.key == key:
        return print(""yes"")
    elif not node:
        return print(""no"")

    if node and key < node.key:
        find(key, node.left)
    elif node:
        find(key, node.right)
def preorder(node):
    return f' {node.key}' + preorder(node.left) + preorder(node.right) if node else ''
def inorder(node):
    return inorder(node.left) + f' {node.key}' + inorder(node.right) if node else ''

input()
for e in sys.stdin:
    if e[0] == ""i"": insert(int(e[7:]))
    elif e[0] == ""f"": find(int(e[5:]), root)
    else: print(inorder(root)); print(preorder(root))

"
3185540,ALDS1_8_B,"from collections import deque
import sys
readline = sys.stdin.readline
write = sys.stdout.write

root = None
def insert(z):
    global root
    y = None
    x = root
    while x is not None:
        y = x
        if z[2] < x[2]:
            x = x[0]
        else:
            x = x[1]
    z[3] = y

    if y is None:
        root = z
    elif z[2] < y[2]:
        y[0] = z
    else:
        y[1] = z

def find(k):
    x = root
    while x is not None:
        if x[2] == k:
            return 1
        if k < x[2]:
            x = x[0]
        else:
            x = x[1]
    return 0

def debug():
    s0 = [""""]
    s1 = [""""]

    def dfs(nd):
        v = str(nd[2])
        s0.append(v)
        if nd[0] is not None:
            dfs(nd[0])
        s1.append(v)
        if nd[1] is not None:
            dfs(nd[1])
    dfs(root)
    return "" "".join(s1), "" "".join(s0)


M = int(readline())
ans = []
for m in range(M):
    cmd, *V, = readline().split()
    if cmd == ""print"":
        ans.extend(debug())
    elif cmd == ""find"":
        ans.append(""yes"" if find(int(V[0])) else ""no"")
    else:
        insert([None, None, int(V[0]), None])
write(""\n"".join(ans))
write(""\n"")

"
2702229,ALDS1_8_B,"import sys
readline = sys.stdin.readline
class Node:
    __slots__ = ['value', 'left', 'right']
    def __init__(self, value = None, left = None, right = None):
        self.value = value
        self.left = left
        self.right = right
class BinTree:
    __slots__ = ['_tree', 'result']
    def __init__(self):
        self._tree = None
    def insert(self, value):
        p = None
        c = self._tree
        while c is not None:
            p = c
            if value < c.value:
                c = c.left
            else:
                c = c.right
        if p is None:
            self._tree = Node(value)
        elif value < p.value:
            p.left = Node(value)
        else:
            p.right = Node(value)
    def find(self, value):
        c = self._tree
        while c is not None:
            if value == c.value:
                return True
            elif value < c.value:
                c = c.left
            else:
                c = c.right
        return False
    def preoder_walk(self):
        self.result = []
        def preoder(node):
            if node is not None:
                self.result.append(node.value)
                preoder(node.left)
                preoder(node.right)
        preoder(self._tree)
        print("" "" + "" "".join(map(str, self.result)))
    def inorder_walk(self):
        self.result = []
        def inorder(node):
            if node is not None:
                inorder(node.left)
                self.result.append(node.value)
                inorder(node.right)
        inorder(self._tree)
        print("" "" + "" "".join(map(str, self.result)))
n = int(input())
tree = BinTree()
for _ in range(n):
    com = readline().split()
    if com[0] == ""insert"":
        tree.insert(int(com[1]))
    elif com[0] == ""find"":
        print(""yes"" if tree.find(int(com[1])) else ""no"")
    else:
        tree.inorder_walk()
        tree.preoder_walk()

"
8803114,ALDS1_8_B,"# 2分探索木


class Node:
  """"""2分探索木のノード""""""
  def __init__(self, key, value, left = None, right = None):
    """"""コンストラクタ""""""
    self.key = key      # キー
    # self.value = value  # 値
    self.left = left    # 左ポインタ（左の子への参照）
    self.right = right  # 右ポインタ（右の子への参照）
    

class BinarySeachTree:
  """"""2分探索木を実現するクラス""""""
  def __init__(self):
    self.root = None   # 根への参照
  
  def search(self, key):
    """"""キーkeyを持つノードを探索""""""
    p = self.root
    while True:
      if p is None:
        return None
      if key == p.key:
        return p.value
      elif key < p.key:
        p = p.left
      else:
        p = p.right
        
  def add(self, key) -> bool:
    """"""キーがkeyで値がvalueのノードを挿入""""""
    def add_node(node, key) -> None:
      """"""nodeを根とする部分木にキーがkeyで値がvalueのノードを挿入""""""
      if key == node.key:
        return False  # keyは2分探索木上に既に存在
      elif key < node.key:
        if node.left is None:
          node.left = Node(key, None, None)
        else:
          add_node(node.left, key)
      else:
        if node.right is None:
          node.right = Node(key, None, None)
        else:
          add_node(node.right, key)
      return True
    if self.root is None:
      self.root = Node(key, None, None)
    else:
      return add_node(self.root, key)
    
  def search(self, key):
    """"""キーkeyを持つノードを探索""""""
    p = self.root
    while True:
      if p is None:
        return ""no""
      if key == p.key:
        return ""yes""
      elif key < p.key:
        p = p.left
      else:
        p = p.right
        
  def dump(self) -> None:
    """"""ダンプする""""""
    def print_subtree_in(node):
      """"""nodeを根とする部分木のノードをキーの昇順（中間順）に表示""""""
      if node is not None:
        print_subtree_in(node.left)
        print(f' {node.key}', end='')
        print_subtree_in(node.right)
    
    def print_subtree_pre(node):
      """"""nodeを根とする部分木のノードを先行順で表示""""""
      if node is not None:
        print(f' {node.key}', end='')
        print_subtree_pre(node.left)
        print_subtree_pre(node.right)
        
    print_subtree_in(self.root)
    print()
    print_subtree_pre(self.root)
    print()
  
  
tree = BinarySeachTree()         # ２分探索木を生成  

m = int(input())

for i in range(m):
  s = input().split(' ')
  if s[0] == ""insert"":
    x = int(s[1])
    tree.add(x)
  elif s[0] == ""print"":
    tree.dump()
  elif s[0] == ""find"":
    t = tree.search(int(s[1]))
    print(t)
"
4174268,ALDS1_8_B,"import sys
input = sys.stdin.readline
print = sys.stdout.write

class Node:
    __slots__ = [""data"", ""left"", ""right""]
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

class BinarySearchTree:
    __slots__ = [""root""]
    def __init__(self):
        self.root = None
    
    def insert(self, data):
        parent = self.root
        if parent is None:
            self.root = Node(data)
            return
        while parent:
            parent_old = parent
            parent = parent.left if data < parent.data else parent.right
        if data < parent_old.data:
            parent_old.left = Node(data)
        else:
            parent_old.right = Node(data)
        
    def find(self, data):
        parent = self.root
        if parent is None:
            print(""no\n"")
            return
        while parent:
            if parent.data == data:
                print(""yes\n"")
                return
            parent = parent.left if data < parent.data else parent.right
        print(""no\n"")
        return


def print_preorder(node):
    print("" {}"".format(node.data))
    if node.left:
        print_preorder(node.left)
    if node.right:
        print_preorder(node.right)

def print_inorder(node):
    if node.left:
        print_inorder(node.left)
    print("" {}"".format(node.data))
    if node.right:
        print_inorder(node.right)

if __name__ == ""__main__"":
    n = int(input())
    binary_search_tree = BinarySearchTree()
    for _ in range(n):
        operation, *num = input().split()
        if operation[0] == ""i"":
            binary_search_tree.insert(int(num[0]))
        elif operation[0] == ""f"":
            binary_search_tree.find(int(num[0]))
        elif binary_search_tree.root is not None:
            print_inorder(binary_search_tree.root)
            print(""\n"")
            print_preorder(binary_search_tree.root)
            print(""\n"")
"
4812824,ALDS1_8_B,"import bisect, collections, copy, heapq, itertools, math, string
import sys
def I(): return int(sys.stdin.readline().rstrip())
def MI(): return map(int, sys.stdin.readline().rstrip().split())
def LI(): return list(map(int, sys.stdin.readline().rstrip().split()))
def S(): return sys.stdin.readline().rstrip()
def LS(): return list(sys.stdin.readline().rstrip().split())

from collections import  defaultdict
def main():
    M = I()
    D = defaultdict()
    root = None
    def insert(D, z, id_root):
        y = None
        x = id_root
        while x != None:
            y = x
            if z < x:
                x = D[x][0]
            else:
                x = D[x][1]

        if y is None:
            id_root = z
        elif z < y:
            D[y][0] = z
        else:
            D[y][1] = z
        return id_root

    def find(D, z, id_root):
        x = id_root
        while x != None:
            if z == x:
                return 'yes'
            elif z < x:
                x = D[x][0]
            else:
                x = D[x][1]
        return 'no'


    def PreorderTreeWalk(D, B, id):
        B.append(id)
        left = D[id][0]
        right = D[id][1]
        if left != None:
            PreorderTreeWalk(D, B, left)
        if right != None:
            PreorderTreeWalk(D, B, right)

    def InorderTreeWalk(D,  B, id):
        left = D[id][0]
        right = D[id][1]
        if left != None:
            InorderTreeWalk(D, B, left)
        B.append(id)
        if right != None:
            InorderTreeWalk(D, B, right)

    for i in range(M):
        ord = S()
        if ord[0] == 'i':
            z = int(ord[7:])
            D[z] = [None, None]
            root = insert(D, z, root)
        elif ord[0] == 'f':
            z = int(ord[5:])
            print(find(D, z, root))
        else:
            Ans_pre = []
            Ans_in = []
            InorderTreeWalk(D, Ans_in, root)
            PreorderTreeWalk(D, Ans_pre, root)
            print(' ' + ' '.join(map(str, Ans_in)))
            print(' ' + ' '.join(map(str, Ans_pre)))

if __name__ == ""__main__"":
    main()

"
8812932,ALDS1_8_B,"#参考 : ALDS1_8_C 二分木の実装 https://zenn.dev/usma11dia0/articles/solve-alds-1-8-c
class node:
    def __init__(self, key) -> None:
        self.key = key
        self.left = None
        self.right = None
        
class BinarySearchTree:
    def __init__(self) -> None:
        self.root = None
    
    def insert(self, key) -> None:
        if self.root is None:
            self.root = node(key)
            return
        def _insert(Node, key) -> node:
            #現在ノードの有無確認
            if Node is None:
                return node(key)
            #大小比較
            if key < Node.key:
                Node.left = _insert(Node.left, key)
            else:
                Node.right = _insert(Node.right, key)
            return Node
        _insert(self.root, key)
        
    def find(self, key):
        def _find(Node, key):
            if Node is None:
                return False
            if key == Node.key:
                return True
            elif key < Node.key:
                return _find(Node.left, key)
            else:
                return _find(Node.right, key)
        return _find(self.root, key)
        
    def print(self) -> str:
        def inorder(node) -> None:
            if node is not None:
                inorder(node.left)
                output.append(str(node.key))
                inorder(node.right)
        def preorder(node) -> None:
            if node is not None:
                output.append(str(node.key))
                preorder(node.left)
                preorder(node.right)
                
                
        output = []
        inorder(self.root)
        inorder_output = "" "".join(output)
        output = []
        preorder(self.root)
        preorder_output = "" "".join(output)
        
        return "" "" + inorder_output + ""\n"" + "" "" + preorder_output
        
m = int(input())
T = BinarySearchTree()
output = []

for _ in range(m):
    command = list(map(str, input().split()))
    if command[0] == ""insert"":
        T.insert(int(command[1]))
    elif command[0] == ""print"":
        output.append(T.print())
    elif command[0] == ""find"":
        if T.find(int(command[1])):
            output.append(""yes"")
        else:
            output.append(""no"")

print(""\n"".join(output))    
"
2636750,ALDS1_8_B,"# -*- coding:utf-8 -*-
import sys


class Node(object):
    __slots__ = [""value"", ""left"", ""right""]

    def __init__(self, value, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right


class BinTree(object):
    def __init__(self):
        self._tree = None

    def insert(self, value):
        parent = None
        current = self._tree

        while current is not None:
            parent = current
            if value < current.value:
                current = current.left
            else:
                current = current.right

        if parent is None:
            self._tree = Node(value)
        elif value < parent.value:
            parent.left = Node(value)
        else:
            parent.right = Node(value)

    def find(self, value):
        current = self._tree

        while current is not None:
            if value == current.value:
                return True
            elif value < current.value:
                current = current.left
            else:
                current = current.right

        return False

    def preoder_walk(self):
        def preoder(node):
            result = []
            if node is None:
                pass
            else:
                result.append(node.value)
                result.extend(preoder(node.left))
                result.extend(preoder(node.right))
            return result

        return preoder(self._tree)

    def inorder_walk(self):
        def inorder(node):
            result = []
            if node is None:
                pass
            else:
                result.extend(inorder(node.left))
                result.append(node.value)
                result.extend(inorder(node.right))
            return result

        return inorder(self._tree)


def print_tree(tree):
    print("" "" + "" "".join([str(val) for val in tree.inorder_walk()]))
    print("" "" + "" "".join([str(val) for val in tree.preoder_walk()]))


def print_yes_no(boolean):
    if boolean:
        print(""yes"")
    else:
        print(""no"")


def main(commands):
    tree = BinTree()
    for com in commands:
        if com[0] == ""insert"":
            tree.insert(int(com[1]))
        elif com[0] == ""print"":
            print_tree(tree)
        elif com[0] == ""find"":
            print_yes_no(tree.find(int(com[1])))
        else:
            raise ValueError


if __name__ == ""__main__"":
    n = int(input())
    commands = [com.split() for com in sys.stdin.readlines()]
    main(commands)
"
6236794,ALDS1_8_B,"import sys
import math
import bisect
from heapq import heapify, heappop, heappush
from collections import deque, defaultdict, Counter
from functools import lru_cache
from itertools import accumulate, combinations, permutations

sys.setrecursionlimit(1000000)
MOD = 10 ** 9 + 7
MOD99 = 998244353

input = lambda: sys.stdin.readline().strip()
NI = lambda: int(input())
NMI = lambda: map(int, input().split())
NLI = lambda: list(NMI())
SI = lambda: input()
SMI = lambda: input().split()
SLI = lambda: list(SMI())


class Node:
    __slots__ = [""left"", ""right"", ""par""]
    def __init__(self, left=None, right=None, par=None):
        self.left = left
        self.right = right
        self.par = par


class BinarySearchTree:
    def __init__(self):
        self.V = {}
        self.root = None

    def insert(self, key):
        # 初期化
        self.V[key] = Node()

        # 最初のノードならrootにして終了
        if self.root is None:
            self.root = key
            return

        # 木を潜る
        now = self.root
        par = None
        while now:
            par = now
            if key <= now:
                now = self.V[now].left
            else:
                now = self.V[now].right

        # keyのノードの親を定める
        self.V[key].par = par
        # parのノードのどちらの子かを定める
        if key <= par:
            self.V[par].left = key
        else:
            self.V[par].right = key

    def find(self, key):
        return key in self.V

    def preorder(self):
        res = self._preorder_rec(self.root)
        return res

    def _preorder_rec(self, now):
        v = self.V[now]
        res = [now]
        res += [] if v.left is None else self._preorder_rec(v.left)
        res += [] if v.right is None else self._preorder_rec(v.right)
        return res

    def inorder(self):
        res = self._inorder_rec(self.root)
        return res

    def _inorder_rec(self, now):
        v = self.V[now]
        res = [] if v.left is None else self._inorder_rec(v.left)
        res += [now]
        res += [] if v.right is None else self._inorder_rec(v.right)
        return res


def main():
    M = NI()
    T = BinarySearchTree()
    for _ in range(M):
        query = SI()
        if query == ""print"":
            ino = T.inorder()
            preo = T.preorder()
            print("" "", end="""")
            print(*ino)
            print("" "", end="""")
            print(*preo)

        else:
            q, k = query.split()
            k = int(k)

            if q == ""find"":
                print(""yes"" if T.find(k) else ""no"")
            else:
                T.insert(k)


if __name__ == ""__main__"":
    main()

"
8250400,ALDS1_8_B,"class Node:
  def __init__(self, idx, key, parent, child):
    self.idx = idx
    self.key = key
    self.parent = parent
    self.child = child

def insert(T, k):
  global root
  y = None #Node(None, None, None, [None, None]) # NIL
  x = root #find_root(T) # root if there is no root, dummy data will be returned.
  z = Node(None, k, None, [None, None]) # the node should be inserted

  while x is not None:
    #print(""x.key:"", x.key, ""z.key:"", z.key)
    y = x
    if z.key < x.key:
      x = T[x.child[0]] if x.child[0] is not None else None
    else:
      x = T[x.child[1]] if x.child[1] is not None else None

  #print(f""y={y}"")
  if y is not None:
    #print(""y.idx:"", y.idx, ""y.key:"", y.idx)
    z.parent = y.idx
    #print(f""y.idx={y.idx} y.key={y.key} z.key={z.key}"")

  if y is None: # root
    z.idx = 0
    T.append(z)
    root = T[-1]
    #print(f""z.idx={z.idx} is root"")

  elif z.key < y.key: # zをyの左の子にする
    z.idx = len(T)
    T.append(z)
    y.child[0] = z.idx
    #print(f""left: z.idx={z.idx}"")
  else: # zを右の子にする
    z.idx = len(T)
    T.append(z)
    y.child[1] = z.idx
    #print(f""right: z.idx={z.idx}"")

  #for v in T:
  #  print(f""idx={v.idx} key={v.key} parent={v.parent} child={v.child}"")

def find(T, root, key):
  if root is None:
    return False

  if root.key == key:
    return True
  else:
    if key < root.key:
      return find(T, T[root.child[0]] if root.child[0] is not None else None, key)
    else:
      return find(T, T[root.child[1]] if root.child[1] is not None else None, key)

# 二分木を行きがけ順でなぞる
def preorder(T, i, S):
  if i is None:
    return
  #print(f"" {T[i].key}"", end="""")
  S.append(T[i].key)
  preorder(T, T[i].child[0], S) # left
  preorder(T, T[i].child[1], S) # right

# 二分木を通りがけ順でなぞる
def inorder(T, i, S):
  if i is None:
    return
  inorder(T, T[i].child[0], S) # left
  #print(f"" {T[i].key}"", end="""")
  S.append(T[i].key)
  inorder(T, T[i].child[1], S) # right

# 二分木を帰りがけ順でなぞる
def postorder(T, i, S):
  if i is None:
    return
  postorder(T, T[i].child[0], S) # left
  postorder(T, T[i].child[1], S) # right
  #print(f"" {T[i].key}"", end="""")
  S.append(T[i].key)
  
trees = []
root = None
n = int(input())
for _ in range(n):
  command, *value = input().split()

  if command == ""insert"":
    insert(trees, int(value[0]))
  elif command == ""find"":
    ret = find(trees, root, int(value[0]))
    print(""yes"" if ret else ""no"")
  else:
    #print(""pass"")
    S1 = []
    inorder(trees, root.idx, S1)
    print("" "" + "" "".join(map(str, S1)))
    # preorder
    S2 = []
    preorder(trees, root.idx, S2)
    print("" "" + "" "".join(map(str, S2)))
    
"
8551838,ALDS1_8_B,"class TreeNode:
    def __init__(self, value: int) -> None:
        """"""ノードを初期化します。
        
        Args:
            value (int): ノードの値
        
        Returns:
            None
        """"""
        self.value: int = value
        self.left: int = None
        self.right: int = None

class BinarySearchTree:
    def __init__(self) -> None:
        """"""二分探索木を初期化します。
        
        Args:
            None
        
        Returns:
            None
        """"""
        self.root: int = None

    def insert(self, value):
        """"""値を挿入します。
        
        Args:
            value: 挿入する値
        
        Returns:
            None
        """"""
        if self.root is None:
            self.root = TreeNode(value)
        else:
            self._insert_recursive(self.root, value)

    def _insert_recursive(self, node, value):
        """"""再帰的に値を挿入します。
        
        Args:
            node: 現在のノード
            value: 挿入する値
        
        Returns:
            None
        """"""
        if value < node.value:
            if node.left is None:
                node.left = TreeNode(value)
            else:
                self._insert_recursive(node.left, value)
        else:
            if node.right is None:
                node.right = TreeNode(value)
            else:
                self._insert_recursive(node.right, value)

    def find(self, value):
        if self.root is None:
            return ""no""
        else:
            return self._find_recursive(self.root, value)
    
    def _find_recursive(self, node, value):
        if node.value == value:
            return ""yes""
        elif value < node.value:
            if node.left is None:
                return ""no""
            else:
                return self._find_recursive(node.left, value)
        else:
            if node.right is None:
                return ""no""
            else:
                return self._find_recursive(node.right, value)

    def Preorder(self):
        result = []
        self._Preorder_recursive(self.root, result)
        return result
            
    def _Preorder_recursive(self, node, result):
        if node is None:
            return
        result.append(node.value)
        self._Preorder_recursive(node.left, result)
        self._Preorder_recursive(node.right, result)

    def Inorder(self):
        result = []
        self._Inorder_recursive(self.root, result)
        return result
    
    def _Inorder_recursive(self, node, result):
        if node is None:
            return
        else:
            self._Inorder_recursive(node.left, result)
            result.append(node.value)
            self._Inorder_recursive(node.right, result)

debug_mode = False
if debug_mode:
    n = 9
    method_list = [
        [""insert"", 30],
        [""find"", 29],
        [""insert"", 88],
        [""insert"", 12],
        [""insert"", 1],
        [""insert"", 20],
        [""insert"", 17],
        [""insert"", 25],
        [""find"", 30],
        [""print""],
    ]
else:
    n = int(input())
    method_list = [input().split() for _ in range(n)]
    

BST = BinarySearchTree()
for method in method_list:

    if method[0] == ""insert"":
        BST.insert(int(method[1]))

    elif method[0] == ""print"":
        # 中順循環
        In_result = BST.Inorder()
        print("" "", end="""")
        print(*In_result)
        # 前順循環
        Pre_result = BST.Preorder()
        print("" "", end="""")
        print(*Pre_result)

    elif method[0] == ""find"":
        print(BST.find(int(method[1])))

"
3872325,ALDS1_8_B,"import sys

m = int(input())

l, r = {}, {}

def insert(num):
    y = None
    x = root
    while True:
        y = x
        if num < x:
            try:
                x = l[x]
            except KeyError:
                break
        else:
            try:
                x = r[x]
            except KeyError:
                break
    if num < y:
        l[y] = num
    else:
        r[y] = num

def find(num):
    x = root
    while True:
        if num == x:
            print('yes')
            return
        elif num < x:
            try:
                x = l[x]
            except KeyError:
                print('no')
                return
        else:
            try:
                x = r[x]
            except KeyError:
                print('no')
                return

def inorder(num):
    try:
        inorder(l[num])
    except KeyError:
        pass
    print(' ' + str(num), end='')
    try:
        inorder(r[num])
    except KeyError:
        pass

def preorder(num):
    print(' ' + str(num), end='')
    try:
        preorder(l[num])
    except KeyError:
        pass
    try:
        preorder(r[num])
    except KeyError:
        pass

for i in range(m):
    order = sys.stdin.readline()
    if i == 0:
        global root
        root = int(order[7:])
        continue
    if order[0] == 'i':
        insert(int(order[7:]))
    elif order[0] == 'p':
        inorder(root)
        print()
        preorder(root)
        print()
    else:
        find(int(order[5:]))
"
9041371,ALDS1_8_B,"class Node:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None

class BinarySearchTree:
    def __init__(self):
        self.root = None

    def insert(self, key):
        self.root = self.insertrec(self.root, key)

    def insertrec(self, root, key):
        if root is None:
            return Node(key)
        if key < root.key:
            root.left = self.insertrec(root.left, key)
        elif key > root.key:
            root.right = self.insertrec(root.right, key)
        return root

    def find(self, key):
        return self.findrec(self.root, key)

    def findrec(self, root, key):
        if root is None:
            return False
        if root.key == key:
            return True
        elif key < root.key:
            return self.findrec(root.left, key)
        else:
            return self.findrec(root.right, key)

    def inorderwalk(self, root):
        if root:
            self.inorderwalk(root.left)
            print(f"" {root.key}"", end="""")
            self.inorderwalk(root.right)

    def preorderwalk(self, root):
        if root:
            print(f"" {root.key}"", end="""")
            self.preorderwalk(root.left)
            self.preorderwalk(root.right)

if __name__ == ""__main__"":
    m = int(input())
    bst = BinarySearchTree()

    for _ in range(m):
        op = input().split()
        if op[0] == ""insert"":
            key = int(op[1])
            bst.insert(key)
        elif op[0] == ""find"":
            key = int(op[1])
            if bst.find(key):
                print(""yes"")
            else:
                print(""no"")
        elif op[0] == ""print"":
            bst.inorderwalk(bst.root)
            print()
            bst.preorderwalk(bst.root)
            print()
"
3883286,ALDS1_8_B,"import sys
input = sys.stdin.readline

class Node:
    __slots__ = ['value', 'parent', 'left', 'right']
    def __init__(self, value: int, parent: 'Node' = None):
        self.value = value
        self.parent = parent
        self.left: Node = None
        self.right: Node = None
    def inParse(self):
        if self.value == None:
            return
        if self.left != None:
            self.left.inParse()
        print(' {}'.format(self.value), end='')
        if self.right != None:
            self.right.inParse()
    def preParse(self):
        if self.value == None:
            return
        print(' {}'.format(self.value), end='')
        if self.left != None:
            self.left.preParse()
        if self.right != None:
            self.right.preParse()

class BinarySearchTree:
    __slots__ = ['root']
    def __init__(self):
        self.root: Node = None
    def insert(self, x: int):
        if self.root == None:
            self.root = Node(x)
            return
        parent, current = None, self.root
        while current:
            parent = current
            if x < current.value:
                current = current.left
            else:
                current = current.right
        if x < parent.value:
            parent.left = Node(x, parent)
        else:
            parent.right = Node(x, parent)
    def find(self, x: int):
        y = self.root
        while y != None and y.value != x:
            if y.value > x:
                y = y.left
            else:
                y = y.right
        return y

def main():
    tree = BinarySearchTree()
    n = int(input())
    for _ in range(n):
        inp = input()
        if inp[0] == 'i':
            com, num = inp.split()
            tree.insert(int(num))
        elif inp[0] == 'f':
            com, num = inp.split()
            if tree.find(int(num)):
                print('yes')
            else:
                print('no')
        else:
            tree.root.inParse()
            print()
            tree.root.preParse()
            print()

if __name__=='__main__': main()
"
4300696,ALDS1_8_B,"# Binary Search Tree 2

import sys
sys.setrecursionlimit(10**6)


class Node():
    __slots__ = ['key', 'parent', 'left', 'right']

    def __init__(self, key=None, parent=None, left=None, right=None):
        self.key = key
        self.parent = parent
        self.left = left
        self.right = right

    def __repr__(self):
        k = str(self.key)
        p = str(self.parent.key) if self.parent else 'None'
        l = str(self.left.key) if self.left else 'None'
        r = str(self.right.key) if self.right else 'None'
        s = ""<Node %s: parent=%s, left=%s, right=%s>"" % (k, p, l, r)
        return s


class BinaryTree():
    def __init__(self, n=0):
        self.T = [Node() for _ in range(n)]
        self.root = None

    def preorder(self):
        self.preorder_key = []
        self.preorder_rec(self.root)
        print('', *(self.preorder_key))

    def preorder_rec(self, node):
        if node == None:
            return
        self.preorder_key.append(node.key)
        self.preorder_rec(node.left)
        self.preorder_rec(node.right)

    def inorder(self):
        self.inorder_key = []
        self.inorder_rec(self.root)
        print('', *(self.inorder_key))

    def inorder_rec(self, node):
        if node == None:
            return
        self.inorder_rec(node.left)
        self.inorder_key.append(node.key)
        self.inorder_rec(node.right)

    def insert(self, key):
        node = Node(key)

        y = None
        x = self.root

        while x != None:
            y = x
            if key < x.key:
                x = x.left
            else:
                x = x.right

        node.parent = y
        if y == None:
            self.root = node
        elif key < y.key:
            y.left = node
        else:
            y.right = node

    def find(self, x, key):
        while x != None and key != x.key:
            if key < x.key:
                x = x.left
            else:
                x = x.right
        return x

    def has(self, key):
        if self.find(self.root, key):
            return True
        else:
            return False


N = int(input())
S = [input() for _ in range(N)]
tree = BinaryTree()

for s in S:
    if 'print' in s:
        tree.inorder()
        tree.preorder()
    else:
        command, key = s.split()
        key = int(key)

        if 'find' in command:
            print('yes' if tree.has(key) else 'no')

        elif 'insert' in command:
            tree.insert(key)

"
5439368,ALDS1_8_B,"import sys


class Node():
    def __init__(self, key):
        self.parent = None
        self.left = None
        self.right = None
        self.key = key


root = None


def insert(key):
    global root
    z = Node(key)
    y = Node(-1)
    x = root
    while x:
        y = x
        if z.key < x.key:
            x = x.left
        else:
            x = x.right
    z.parent = y

    if y.key == -1:
        root = z
    elif z.key < y.key:
        y.left = z
    else:
        y.right = z


def find(key):
    x = root
    while x is not None:
        if x.key == key:
            return True
        elif key < x.key:
            x = x.left
        else:
            x = x.right
    return False


def inorder(node):
    return inorder(node.left) + f' {node.key}' + inorder(node.right) if node else ''


def preorder(node):
    return f' {node.key}' + preorder(node.left) + preorder(node.right) if node else ''


input()
for e in sys.stdin:
    if e[0] == 'i':
        insert(int(e[7:]))
    elif e[0] == ""f"":
        ans = find(int(e[5:]))
        if ans:
            print(""yes"")
        else:
            print(""no"")
    else:
        print(inorder(root))
        print(preorder(root))

"
6822586,ALDS1_8_B,"import sys


class Node(object):
    __slots__ = ['key', 'parent', 'left', 'right']

    def __init__(self, key):
        self.key = key
        self.parent = None
        self.left = None
        self.right = None


def preoder(node):
    print(f' {str(node.key)}', end='')

    if node.left != None:
        preoder(node.left)
    if node.right != None:
        preoder(node.right)


def inorder(node):
    if node == None:
        return

    inorder(node.left)
    print(f' {str(node.key)}', end='')
    inorder(node.right)


def insert(z_key):
    global root_node
    x = root_node
    y = None
    z = Node(z_key)

    while x != None:
        y = x
        if z.key < x.key:
            x = x.left
        else:
            x = x.right
    z.parent = y

    if y == None:
        root_node = z
    elif z.key < y.key:
        y.left = z
    else:
        y.right = z


def find(node, z_key):
    while node != None and node.key != z_key:
        if node.key > z_key:
            node = node.left
        else:
            node = node.right
    return 'no' if node == None else 'yes'


def main():
    global root_node

    input = sys.stdin.readline
    n = int(input())
    root_node = None

    for _ in range(n):
        line = input().split()
        if line[0] == 'insert':
            insert(int(line[1]))
        elif line[0] == 'find':
            print(find(root_node, int(line[1])))
        else:
            inorder(root_node)
            print('')
            preoder(root_node)
            print('')


root_node = None
main()
"
6831423,ALDS1_8_B,"# T:辞書{値：[左の子、右の子]}
def insert(T, z):
    global root
    y = -1
    x = root
    
    while x != None:
        y = x
        if z < x:
            x = T[x][0]
        else:
            x = T[x][1]
    
    T[z] = [None, None]
    
    if y == -1:
        root = z
    
    elif z < y:
        T[y][0] = z
    
    else:
        T[y][1] = z
        

def walk_tree(now):
    global pre_order, in_order
    if now == None:
        return
    
    pre_order.append(now)
    
    x, y = T[now]
    
    if x != None:
        walk_tree(x)
    
    in_order.append(now)
    
    if y != None:
        walk_tree(y)

def find(k):
    return k in T
    

n = int(input())
T = dict()
root = None

for _ in range(n):
    com, *arg = input().split()
    if com == ""insert"":
        insert(T, int(arg[0]))
    
    elif com == ""find"":
        if find(int(arg[0])):
            print(""yes"")
        else:
            print(""no"")
    
    else:
        in_order = []
        pre_order = []
        
        walk_tree(root)
        
        print("""", *in_order)
        print("""", *pre_order)

"
6318093,ALDS1_8_B,"from sys import stdin

class node:
    def __init__(self, x):
        self.k = x
        self.l = self.r = None

def insert(z):
    global root
    x, y = root, None
    while x:
        y = x
        x = x.l if z < x.k else x.r
    
    if y == None:
        root = node(z)
    elif z < y.k:
        y.l = node(z)
    else:
        y.r = node(z)

def find(k, root):
    i = root
    while i:
        if k == i.k:
            return 'yes'
        elif k < i.k:
            i = i.l
        else:
            i = i.r
    return 'no'
            

def rec(i, m):
    if i == None:
        return ''
    
    c = ' ' + str(i.k)
    l, r = rec(i.l, m), rec(i.r, m)
    
    if m == 0:
        return l + c + r
    else:
        return c + l + r


input()
root = None
for l in stdin:
    if l[0] == 'i':
        insert(int(l[7:]))
    elif l[0] == 'f':
        print(find(int(l[5:]), root))
    else:
        for i in range(2):
            print(rec(root, i))
"
5462059,ALDS1_8_B,"import sys

class Node:
    def __init__(self, value, p = None, l = None, r = None):
        self.key = value
        self.p = p
        self.left = l
        self.right = r

def getroot(x):
    if x.p != None:
        return getroot(x.p)
    return x

def preorder(x, A):
    if x == None:
        return
    A.append(x.key)
    preorder(x.left, A)
    preorder(x.right, A)

def inorder(x, A):
    if x == None:
        return
    inorder(x.left, A)
    A.append(x.key)
    inorder(x.right, A)

def postorder(x, A):
    if x == None:
        return
    postorder(x.left, A)
    postorder(x.right, A)
    A.append(x.key)

def ptree(root):
    pre = [""""]
    ino = [""""]
    preorder(root, pre)
    inorder(root, ino)
    print("" "".join(map(str,ino)))
    print("" "".join(map(str,pre)))

def find(value, root):
    if root == None:
        return ""no""
    elif value < root.key:
        return find(value,root.left)
    elif value > root.key:
        return find(value,root.right)
    return ""yes""

def insert(Tree, root, z):
    y = None 
    x = root  
    while x != None:
        y = x 
        if z.key < x.key:
            x = x.left 
        else:
            x = x.right 
    z.p = y

    Tree.append(z)
    if y == None: 
        return z
    elif z.key < y.key:
        y.left = z 
    else:
        y.right = z 
    return root

def main():

    num = int(input().strip())
    istr = sys.stdin.read()
    cmds = list(istr.splitlines())
    Tree = []
    root = None
    for i in range(num):
        cmd = cmds[i][0]
        if cmd == ""i"":
            n = Node(int(cmds[i][7:]))
            root = insert(Tree, root, n)
        elif cmd == ""f"":
            print(find(int(cmds[i][5:]),root))
        elif cmd == ""p"":
            ptree(root)
    

if __name__ == '__main__':
    main()

"
5216525,ALDS1_8_B,"from sys import stdin

class node:
    def __init__(self, x):
        self.k = x
        self.l = self.r = None

def insert(z):
    global root
    x, y = root, None
    while x:
        y = x
        x = x.l if z < x.k else x.r
    
    if y == None:
        root = node(z)
    elif z < y.k:
        y.l = node(z)
    else:
        y.r = node(z)

def find(k, root):
    i = root
    while i:
        if k == i.k:
            return 'yes'
        elif k < i.k:
            i = i.l
        else:
            i = i.r
    return 'no'
            

def rec(i, m):
    if i == None:
        return ''
    
    c = ' ' + str(i.k)
    l, r = rec(i.l, m), rec(i.r, m)
    
    if m == 0:
        return l + c + r
    else:
        return c + l + r


input()
root = None
for l in stdin:
    if l[0] == 'i':
        insert(int(l[7:]))
    elif l[0] == 'f':
        print(find(int(l[5:]), root))
    else:
        for i in range(2):
            print(rec(root, i))


"
3892567,ALDS1_8_B,"import sys
class Tree():
    def __init__(self):
        self.root = None
    def insert(self, key):
        z = Node(key)
        y = None
        x = self.root
        while x:
            y = x
            if z.key < x.key:
                x = x.left
            else:
                x = x.right
        z.parent = y
        if y == None:
            self.root = z
        elif z.key < y.key:
            y.left = z
        else:
            y.right = z
    def find(self, key):
        x = self.root
        while x and x.key != key:
            if x.key < key:
                x = x.right
            else:
                x = x.left
        print('yes' if x else 'no')
    def print(self):
        print('',' '.join(map(str, self.root.inwalk())))
        print('',' '.join(map(str, self.root.prewalk())))
    
class Node():
    def __init__(self, key):
        self.key = key
        self.parent = self.left = self.right = None
    def prewalk(self):
        ret = [self.key]
        if self.left:
            ret += self.left.prewalk()
        if self.right:
            ret += self.right.prewalk()
        return ret
    def inwalk(self):
        ret = []
        if self.left:
            ret += self.left.inwalk()
        ret += [self.key]
        if self.right:
            ret += self.right.inwalk()
        return ret
tree = Tree()
n = sys.stdin.readline()
for line in sys.stdin:
    if line[0] == 'i':
        tree.insert(int(line.split()[1]))
    elif line[0] == 'f':
        tree.find(int(line.split()[1]))
    else:
        tree.print()
"
4947741,ALDS1_8_B,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-

def inorder(nodes, index, answer):
    if nodes[index]['left'] != -1:
        inorder(nodes, nodes[index]['left'], answer)
    answer.append(nodes[index]['key'])
    if nodes[index]['right'] != -1:
        inorder(nodes, nodes[index]['right'], answer)

def preorder(nodes, index, answer):
    answer.append(nodes[index]['key'])
    if nodes[index]['left'] != -1:
        preorder(nodes, nodes[index]['left'], answer)
    if nodes[index]['right'] != -1:
        preorder(nodes, nodes[index]['right'], answer)


def insert(nodes, z):
    if not nodes:
        nodes.append(z)
    else:
        y = -1
        x = 0
        while x != -1:
            y = x
            if z['key'] < nodes[x]['key']:
                x = nodes[x]['left']
            else:
                x = nodes[x]['right']

        if z['key'] < nodes[y]['key']:
            nodes[y]['left'] = z['index']
            nodes.append(z)
        else:
            nodes[y]['right'] = z['index']
            nodes.append(z)

def find(nodes, key):
    x = -1
    if nodes:
        x = nodes[0]['index']
    while x != -1:
        if key == nodes[x]['key']:
            print('yes')
            return
        elif key < nodes[x]['key']:
            x = nodes[x]['left']
        else:
            x = nodes[x]['right']
    print('no')


def print_order(nodes, root):
    if root != -1:
        tmp = []
        inorder(nodes, root, tmp)
        print('',' '.join(map(str, tmp)))
        tmp_ = []
        preorder(nodes, root, tmp_)
        print('',' '.join(map(str, tmp_)))

if __name__ == ""__main__"":
    N = int(input())
    nodes = []
    commands = []
    for i in range(N):
        commands.append(input())
    root_index = 0
    for i, command in enumerate(commands):
        if command[0] == 'i':
            z = {
                'key':int(command[7:]),
                'left': -1,
                'right': -1,
                'index': len(nodes)
            }
            insert(nodes, z)
        elif command[0] == 'p':
            print_order(nodes, root_index)
        elif command[0] == 'f':
            find(nodes, int(command[5:]))


"
3389659,ALDS1_8_B,"# -*- coding: utf-8 -*-

import sys
sys.setrecursionlimit(10 ** 9)
def input(): return sys.stdin.readline().strip()
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(): return list(map(int, input().split()))

from collections import defaultdict

class Node:
    def __init__(self, key):
        self.key = key
        self.par = -1
        self.left = -1
        self.right = -1

root = None
nodes = defaultdict(lambda: None)

def insert(z):
    global root
    # yはxの親
    y = None
    x = root
    # zの親となるべきノードを探す
    while x is not None:
        y = x
        if z.key < x.key:
            # 左の子に移動
            x = nodes[x.left]
        else:
            # 右の子に移動
            x = nodes[x.right]
    if y is None:
        z.par = -1
    else:
        z.par = y.key
    
    if y is None:
        # Tが空の場合
        root = z
    elif z.key < y.key:
        # zをyの左の子にする
        y.left = z.key
    else:
        # zをyの右の子にする
        y.right = z.key

def find(key):
    if nodes[key]:
        print('yes')
    else:
        print('no')

def tree_walk(node):
    preo.append(node.key)
    if node.left != -1:
        tree_walk(nodes[node.left])
    ino.append(node.key)
    if node.right != -1:
        tree_walk(nodes[node.right])
    return

N = INT()

for _ in range(N):
    instr = input()
    if instr == 'print':
        preo = []
        ino = []
        tree_walk(root)
        print('', *ino)
        print('', *preo)
    elif instr.startswith('insert'):
        _, key = instr.split()
        key = int(key)
        node = Node(key)
        nodes[key] = node
        insert(node)
    else:
        _, key = instr.split()
        find(int(key))

"
3805219,ALDS1_8_B,"import sys
class Node:
    parent = -1
    left = -1
    right = -1

    def __init__(self, key):
        self.key = key

    def __repr__(self):
        return ""k:{},p:{},l:{},r:{}"".format(self.key, self.parent, self.left, self.right)

root_node_no = -1

def insert(nodes :dict, in_node :Node):
    global root_node_no

    cur_node_no = root_node_no
    parent_node_no = -1
    while cur_node_no != -1:
        parent_node_no = cur_node_no
        if in_node.key < cur_node_no:
            cur_node_no = nodes[cur_node_no].left
        else:
            cur_node_no = nodes[cur_node_no].right

    in_node.parent = parent_node_no

    if root_node_no == -1:
        root_node_no = in_node.key
    elif in_node.key < parent_node_no:
        nodes[parent_node_no].left = in_node.key
    else:
        nodes[parent_node_no].right = in_node.key

    nodes[in_node.key] = in_node

def inorder_tree_walk(nodes, node_no ,inorder):
    if node_no == -1:
        return
    inorder_tree_walk(nodes, nodes[node_no].left, inorder)
    inorder.append(node_no)
    inorder_tree_walk(nodes, nodes[node_no].right, inorder)

def preorder_tree_walk(nodes, node_no, preorder):
    if node_no == -1:
        return
    preorder.append(node_no)
    preorder_tree_walk(nodes, nodes[node_no].left, preorder)
    preorder_tree_walk(nodes, nodes[node_no].right, preorder)


def find(nodes, tgt_node_no):
    cur_node_no = root_node_no
    while cur_node_no != -1:
        cur_node = nodes[cur_node_no]
        if cur_node.key == tgt_node_no:
            return True
        elif tgt_node_no < cur_node.key:
            cur_node_no = cur_node.left
        else:
            cur_node_no = cur_node.right

    return False


def main():
    num_com = int(input())
    commands = sys.stdin.readlines()
    nodes = {}
    for i in range(num_com):
        if commands[i][0] == 'i':
            insert(nodes, Node(int(commands[i][7:])))
        elif commands[i][0] == 'p':
            # inorder
            inorder = []
            inorder_tree_walk(nodes, root_node_no, inorder)
            print("" "" + "" "".join(map(str, inorder)))
            # preorder
            preorder = []
            preorder_tree_walk(nodes, root_node_no, preorder)
            print("" "" + "" "".join(map(str, preorder)))
        elif commands[i][0] == 'f':
            if find(nodes, int(commands[i][5:])):
                print('yes')
            else:
                print('no')


main()

"
5566607,ALDS1_8_B,"class Node(object):
    __slots__ = [""value"", ""parent"", ""left"", ""right""]

    def __init__(self, value: int, parent: 'Node' = None) -> None:
        self.value = value
        self.parent = parent
        self.left: Node = None
        self.right: Node = None

    def inPerse(self, a: list) -> list:
        if self.left:
            self.left.inPerse(a)
        a.append(self.value)
        if self.right:
            self.right.inPerse(a)
        return a

    def prePerse(self, a: list) -> list:
        a.append(self.value)
        if self.left:
            self.left.prePerse(a)
        if self.right:
            self.right.prePerse(a)
        return a


class BinarySearchTree(object):
    __slots__ = [""root""]

    def __init__(self) -> None:
        self.root: Node = None

    def insert(self, target: int):
        if self.root is None:
            self.root = Node(target)
            return
        parent, current = None, self.root

        while current:
            parent = current
            if target < current.value:
                current = current.left
            else:
                current = current.right

        if target < parent.value:
            parent.left = Node(target, parent)
        else:
            parent.right = Node(target, parent)

    def find(self, k: int):
        x = self.root
        while x != None and k != x.value:
            if k < x.value:
                x = x.left
            else:
                x = x.right
        return x


if __name__ == ""__main__"":
    tree = BinarySearchTree()
    for i in range(int(input())):
        order = input()
        if order == ""print"":
            inp = tree.root.inPerse([])
            print("""", *inp)
            prp = tree.root.prePerse([])
            print("""", *prp)
        elif order.startswith(""find""):
            _, target = order.split()
            target = int(target)
            if tree.find(target) is not None:
                print(""yes"")
            else:
                print(""no"")
        elif order.startswith(""insert""):
            _, target = order.split()
            target = int(target)
            tree.insert(target)

"
8452618,ALDS1_8_C,"a = []

for _ in range(int(input())):
    i = input()
    w = a
    if i[0] == 'i':
        n = int(i[7:])
        while w: w = w[1] if w[0] > n else w[2]
        w += [n, [], []]
    elif i[0] in 'df':
        n = int(i.split()[1])
        while w:
            if w[0] == n:
                if i[0] == 'f':
                    print('yes')
                    break
                if w[1] and w[2]:
                    i = w[2]
                    while i[1]: i = i[1]
                    w[0], w = i[0], i
                i = w.pop(1) if w[1] else w.pop()
                w.clear()
                if i: w += i
                break
            w = w[1] if w[0] > n else w[2]
        else: print('no')
    else:
        w, l = [], [a]
        while l:
            i = l.pop()
            if len(i) == 1: print('', i[0], end='')
            elif i:
                l += [i[2], [i[0]], i[1]]
                w += [i[0]]
        print('\n', *w)
"
8390742,ALDS1_8_C,"# 複数のノードが同じ key をもつことはないとする.

class Node():
    def __init__(self, key):
        self.key = key
        self.parent = None
        self.left = None
        self.right = None


class Tree():
    def __init__(self):
        self.root = None


    def insert(self, k):
        z = Node(k)
        y = None
        x = self.root
        while x:
            y = x
            if z.key < x.key:
                x = x.left
            else:
                x = x.right
        z.parent = y
        if not y:
            self.root = z
        elif z.key < y.key:
            y.left = z
        else:
            y.right = z


    def delete(self, k):
        x = self.root
        while x:
            if x.key == k:
                break
            if k < x.key:
                x = x.left
            else:
                x = x.right
        if x and x.key == k:
            if x.left:
                if x.right:
                    # y:= x の右部分木の最左の葉ノード. x の右部分木の中で最も小さく, x の左部分木の任意のノードよりも大きい key をもつ.
                    # x.key に y.key を代入し, y を削除する.
                    y = x.right
                    while y.left:
                        y = y.left
                    x.key = y.key
                    if y.right:
                        y.right.parent = y.parent
                        if y.parent == x:
                            y.parent.right = y.right
                        else:
                            y.parent.left = y.right

                    else:
                        if y.parent == x:
                            y.parent.right = None
                        else:
                            y.parent.left = None
                else:
                    # x.parent と x.left をつなぐ. x.parent が存在しない場合は根を x.left とする.
                    x.left.parent = x.parent
                    if x.parent:
                        if x.key < x.parent.key:
                            x.parent.left = x.left
                        else:
                            x.parent.right = x.left
                    else:
                        self.root = x.left
            else:
                if x.right:
                    # x.parent と x.right をつなぐ. x.parent が存在しない場合は根を x.right とする.
                    x.right.parent = x.parent
                    if x.parent:
                        if x.key < x.parent.key:
                            x.parent.left = x.right
                        else:
                            x.parent.right = x.right
                    else:
                        self.root = x.right
                else:
                    # x.parent の 子ノード を None とする. x.parent が存在しない場合は根を None とする.
                    if x.parent:
                        if x.key < x.parent.key:
                            x.parent.left = None
                        else:
                            x.parent.right = None
                    else:
                        self.root = None


    def find(self, k):
        x = self.root
        while x:
            if k == x.key:
                return True
            elif k < x.key:
                x = x.left
            else:
                x = x.right
        return False


    def in_order(self):
        def exe(x):
            if x:
                exe(x.left)
                print("" {}"".format(x.key), end="""")
                exe(x.right)
        exe(self.root)


    def pre_order(self):
        def exe(x):
            if x:
                print("" {}"".format(x.key), end="""")
                exe(x.left)
                exe(x.right)
        exe(self.root)


def main():
    n = int(input())
    T = Tree()
    for i in range(n):
        cmd = input().split()
        if cmd[0] == ""insert"":
            T.insert(int(cmd[1]))
        elif cmd[0] == ""delete"":
            T.delete(int(cmd[1]))
        elif cmd[0] == ""find"":
            if T.find(int(cmd[1])):
                print(""yes"")
            else:
                print(""no"")
        else:
            T.in_order()
            print()
            T.pre_order()
            print()


if __name__ == ""__main__"":
    main()

"
9017895,ALDS1_8_C,"class Node:
    def __init__(self, key):
        self.key=key
        self.left=None
        self.right=None
        self.p=None
root=None
def insert(z):
    global root
    y=None
    x=root
    while x is not None:
        y=x
        if z.key < x.key:
            x=x.left
        else:
            x=x.right
    z.p=y
    if y is None:
        root=z
    elif z.key < y.key:
        y.left=z
    else:
        y.right=z

def find(z):
    global root
    x=root
    while x is not None:
        if z.key == x.key:
            print(""yes"")
            break
        if z.key < x.key:
            x=x.left
        else:
            x=x.right
    else:
        print(""no"")

def delete(z):
    global root
    x=root
    while x is not None:
        if z.key == x.key:
            break
        elif z.key < x.key:
            x=x.left
        else:
            x=x.right
    else:
        return
    _delete(x)

def _delete(x):
    global root
    if (x.left is not None) and (x.right is not None):
        y=x.right
        while y.left is not None:
            y=y.left
        x.key=y.key
        _delete(y)
    elif (x.left is None) and (x.right is None):
        if x.p is not None:
            p=x.p
            if p.left==x:
                p.left=None
            else:
                p.right=None
        else:
            root=None
        del x
    elif x.left is not None:
        y=x.left
        if x.p is not None:
            p=x.p
            y.p=p
            if p.left==x:
                p.left=y
            else:
                p.right=y
        else:
            y.p=None
            root=y
        del x
    else:
        y=x.right
        if x.p is not None:
            p=x.p
            y.p=p
            if p.left==x:
                p.left=y
            else:
                p.right=y
        else:
            y.p=None
            root=y
        del x

def print_order(num):
    global inorder, preorder
    preorder.append(str(num.key))
    if num.left is not None:
        print_order(num.left)
    inorder.append(str(num.key))
    if num.right is not None:
        print_order(num.right)    

m=int(input())
for _ in range(m):
    order = list(input().split())
    if order[0] == ""insert"":
        insert(Node(int(order[1])))
    elif order[0] == ""find"":
        find(Node(int(order[1])))
    elif order[0] == ""delete"":
        delete(Node(int(order[1])))
    else:
        inorder=[]
        preorder=[]
        print_order(root)
        print("" ""+"" "".join(inorder))
        print("" ""+"" "".join(preorder))
"
8415919,ALDS1_8_C,"COMMAND_ID = 0
VALUE_ID = 1

class Node:
    def __init__(self, key, left, right):
        self.key = key
        self.left = left
        self.right = right

class BinaryTree:
    def __init__(self, root):
        self.root = root

    # 値の挿入
    def insert_node(self, z):
        y = None
        x = self.root
        while x:
            y = x
            if z.key < x.key:
                x = x.left
            else:
                x = x.right
        
        if not(y):
            self.root = z
        elif z.key < y.key:
            y.left = z
        else:
            y.right = z

    # 値の検索
    def find_node(self, node, k):
        # 終端条件
        if node == None:
            return False
        elif node.key == k:
            return True
        # 再帰
        elif node.key > k:
            return self.find_node(node.left, k)
        elif node.key < k:
            return self.find_node(node.right, k)

    # 値の削除
    def delete_node(self, node, k):
        # 終端条件
        if node == None:
            return node
        elif node.key == k:
            # 1.子ノードのない親ノードを削除する場合
            # 2.子ノードが1つの親ノードを削除する場合
            if node.left == None:
                return node.right
            elif node.right == None:
                return node.left
            # 3.子ノードが2つの親ノードを削除する場合
            else:
                # 通りがけ順で削除対象の次に出力されるノード(=置き換えるノード)を探索
                cdd = node.right
                while cdd.left:
                    cdd = cdd.left
                # 置き換えるノードの値をコピー&元の位置から削除
                node.key = cdd.key
                node.right = self.delete_node(node.right, cdd.key)
        # 再帰
        # 削除するノード位置に新しく入るノードで親ノードを更新
        if node.key > k:
            node.left = self.delete_node(node.left, k)
        if node.key < k:
            node.right = self.delete_node(node.right, k)
        return node


    # 行きがけ順で出力
    def print_preorder(self, node):
        print(f' {node.key}', end='')
        # 再帰
        if node.left:
            self.print_preorder(node.left)
        if node.right:
            self.print_preorder(node.right)
    
    # 通りがけ順で出力
    def print_inorder(self, node):
        # 再帰
        if node.left:
            self.print_inorder(node.left)   
        print(f' {node.key}', end='')
        if node.right:
            self.print_inorder(node.right)



def main():
    m = int(input())

    tree = BinaryTree(None)
    for _ in range(m):
        cmd = input().split()
        if cmd[COMMAND_ID] == 'print':
            tree.print_inorder(tree.root)
            print()
            tree.print_preorder(tree.root)
            print()
        if cmd[COMMAND_ID] == 'insert':
            value = int(cmd[VALUE_ID])
            node = Node(value, None, None)
            tree.insert_node(node)
        if cmd[COMMAND_ID] == 'find':
            k = int(cmd[VALUE_ID])
            is_find = tree.find_node(tree.root, k)
            if is_find:
                print('yes')
            if not is_find:
                print('no')
        if cmd[COMMAND_ID] == 'delete':
            k = int(cmd[VALUE_ID])
            tree.delete_node(tree.root, k)

if __name__ == '__main__':
    main()
"
8934619,ALDS1_8_C,"import sys
sys.setrecursionlimit(10**6)

class Node:
    def __init__(self, data: int) -> None:
        self.data = data
        self.left = None
        self.right = None

class BinarySearchTree:
    def __init__(self, number_list: list = []) -> None:
        """"""初期化""""""
        self.root = None
        for num in number_list:
            self.insert(num)

    def insert(self, data) -> None:
        """"""挿入""""""
        n = self.root
        if n == None:
            self.root = Node(data)
            return
        else:
            while 1:
                entry = n.data
                if data < entry:
                    if n.left is None:
                        n.left = Node(data)
                        return
                    n = n.left
                elif data > entry:
                    if n.right is None:
                        n.right = Node(data)
                        return
                    n = n.right
                else:
                    n.data = data
                    return

    def search(self, search: int) -> bool:
        """"""探索(存在するか)""""""
        searcher = self._search_bool(search)
        if searcher is None:
            raise Exception
        return searcher

    def delete(self, node: Node, data: int) -> Node:
        """"""ノード削除""""""
        if node:
            if data == node.data:
                if node.left is None:
                    return node.right
                elif node.right is None:
                    return node.left
                else:
                    node.data = self.search_min(node.right)
                    node.right = self.delete_min(node.right)
            elif data < node.data:
                node.left = self.delete(node.left, data)
            else:
                node.right = self.delete(node.right, data)
        return node

    def delete_min(self, node: Node) -> Node:
        """"""最小値を削除""""""
        if node.left is None:
            return node.right
        node.left = self.delete_min(node.left)
        return node

    def search_min(self, node: Node) -> Node:
        """"""最小値を探索""""""
        if node.left is None:
            return node.data
        return self.search_min(node.left)

    def preorder(self, root: int = None) -> list:
        """"""先行順探索""""""
        res = []
        def _preorder(node: int) -> None:
            if node is None:
                return
            res.append(node.data)
            _preorder(node.left)
            _preorder(node.right)

        if root is None:
            root = self.root
        _preorder(root)
        return res

    def inorder(self, root: int = None) -> list:
        """"""中間順探索""""""
        res = []
        def _inorder(node: int) -> None:
            if node is None:
                return
            _inorder(node.left)
            res.append(node.data)
            _inorder(node.right)

        if root is None:
            root = self.root
        _inorder(root)
        return res

    def postorder(self, root: int = None) -> list:
        """"""後行順探索""""""
        res = []
        def _postorder(node: int) -> None:
            if node is None:
                return
            _postorder(node.left)
            _postorder(node.right)
            res.append(node.data)

        if root is None:
            root = self.root
        _postorder(root)
        return res

    def _search_bool(self, search) -> bool:
        n = self.root
        if n is None:
            raise Exception
        while n:
            if n.data == search:
                return True
            if search < n.data:
                n = n.left
            else:
                n = n.right
        return False

m = int(input())
t = BinarySearchTree()
for _ in range(m):
    s = input().split()
    if s[0] == ""insert"":
        k = int(s[1])
        t.insert(data=k)
    elif s[0] == ""print"":
        print("""", *t.inorder())
        print("""", *t.preorder())
    elif s[0] == ""find"":
        k = int(s[1])
        res = t.search(k)
        print(""yes"" if res else ""no"")
    elif s[0] == ""delete"":
        k = int(s[1])
        t.delete(t.root, k)

"
9100512,ALDS1_8_C,"class Node:
    def __init__(self, key:int) -> None:
        self.key: int = key
        self.parent: Node = None
        self.left: Node = None
        self.right: Node = None
    
    def fr(self) -> list[str]:
        rtn = []
        if self.left != None: rtn.append(""left"")
        if self.right != None: rtn.append(""right"")
        return rtn
       
    def order(self, mode: str):
        li = {
            ""Pre"": [0, 1, 2],  # 先行順巡回 node -> left -> right 
            ""In"": [1, 0, 2],   # 中間順巡回 left -> node -> right
            ""Post"": [1, 2, 0]  # 後方順巡回 right -> left -> right
        }
        for i in li[mode]:
            if i == 0: print(f"" {self.key}"", end = """")
            elif i == 1 and self.left != None : self.left.order(mode)
            elif i == 2 and self.right != None: self.right.order(mode)
        
class BinarySearchTree:
    def __init__(self) -> None:
        self.node: Node = None

def insert(t: BinarySearchTree, z : Node) -> None:
    y: Node = None  # x の親
    x: Node = t.node
    while x != None:
        y = x # 親を設定
        if z.key < x.key:
            x = x.left
        else:
            x = x.right
    z.parent = y
    if y == None:
        t.node = z
    elif z.key < y.key:
        y.left = z
    else:
        y.right = z

def ans(t: BinarySearchTree):
    t.node.order(""In"")  
    print()
    t.node.order(""Pre"")
    print() 
        
def find(t: BinarySearchTree, k: Node):
    x: Node = t.node
    while x != None:
        if x.key == k.key:
            print(""yes"")
            return
        if x.key < k.key: x = x.right
        else: x = x.left
    print(""no"")

def delete(t: BinarySearchTree, k: Node):
    y: Node = None
    x: Node = t.node
    r: bool = False
    while x != None:
        y = x
        if x.key < k.key: 
            x = y.right
            r = True
        else: 
            x = y.left
            r = False
        if x.key == k.key: break
    else: return # x == Noneで終了したなら終わり。
    
    def delete2(z: Node, r: bool):
        c = z.fr()
        if len(c) == 2: # z has left and right
            y = z.right
            x = z.right.left
            r = True
            while x != None:
                y = x
                x = x.left
                r = False
            z.key = y.key
            delete2(y, r)
        elif len(c) == 1:
            if c[0] == ""left"":
                if r: z.parent.right = z.left
                else: z.parent.left = z.left
                z.left.parent = z.parent
            else:
                if r: z.parent.right = z.right
                else: z.parent.left = z.right 
                z.right.parent = z.parent
        else: # z does not have left or right
            if r: z.parent.right = None
            else: z.parent.left = None
    delete2(x, r)

n = int(input())
t = BinarySearchTree()
for _ in range(n):
    order = input()
    if order[0] == ""i"": insert(t, Node(int(order[7:])))
    elif order[0] == ""f"": find(t, Node(int(order[5:])))
    elif order[0] == ""d"": delete(t, Node(int(order[7:])))
    else: ans(t)

"
8281871,ALDS1_8_C,"class Node:
    def __init__(self, key: int, left = None, right = None, parent = None):
        self.key = key
        self.left = left
        self.right = right
        self.parent = parent
    def __str__(self):
        return self.key

class BinarySearchTree:
    def __init__(self, root = None):
        self.root = root
    
    def insert(self, z: Node) -> None:
        x = self.root # Tの根
        y = None # xの親
        # 木を探索
        while x != None:
            y = x # 親を設定
            if z.key < x.key:
                x = x.left
            else:
                x = x.right
        z.parent = y

        if y == None:
            self.root = z
        elif z.key < y.key:
            y.left = z
        else:
            y.right = z
    
    def find(self, k: int) -> Node:
        node = self.root
        while node != None and node.key != k:
            #print(node.key, k)
            if node.key < k:
                node = node.right
            else:
                node = node.left
        return node
    
    def delete(self, k: int) -> None:
        #print(k)
        k_node = self.find(k)
        if k_node == None:
            return 0
        if k_node.left == None and k_node.right == None:
            #print(""0delete"", k)
            parent = k_node.parent
            #print(parent.key)
            if parent.left == k_node:
                parent.left = None
            else:
                parent.right = None
        elif k_node.left == None and k_node.right != None:
            #print(""1delete"", k)
            parent = k_node.parent
            if parent.left == k_node:
                parent.left = k_node.right
                k_node.right.parent = parent
            else:
                parent.right = k_node.right
                k_node.right.parent = parent
        elif k_node.left != None and k_node.right == None:
            #print(""2delete"", k)
            parent = k_node.parent
            if parent.left == k_node:
                parent.left = k_node.left
                k_node.left.parent = parent
            else:
                parent.right = k_node.left
                k_node.left.parent = parent
        # z が子を２つ持つ場合、 z の次節点 y のキーを z のキーへコピーし、 y を削除する。 y の削除では 1. または 2. を適用する。ここで、 z の次節点とは、中間順巡回で z の次に得られる節点である。
        elif k_node.left != None and k_node.right != None:
            #print(""3delete"", k)
            next_node = self.search_next_node(k_node)
            self.delete(next_node.key)
            k_node.key = next_node.key
            
            
    
    def search_next_node(self, node: Node) -> Node:
        node = node.right
        while node.left != None:
            node = node.left
        return node
            

    def inorder(self, left: Node, root: Node, right: Node) -> list:
        if left != None and right != None:
            left = self.inorder(left.left, left, left.right)
            right = self.inorder(right.left, right, right.right)
            return left + [root] + right
        elif left != None and right == None:
            left = self.inorder(left.left, left, left.right)
            return left + [root]
        elif left == None and right != None:
            right = self.inorder(right.left, right, right.right)
            return [root] + right
        else:
            return [root]
    
    def print_inorder(self) -> list:
        inorder_list = self.inorder(self.root.left, self.root, self.root.right)
        ans = []
        for node in inorder_list:
            ans.append(node.key)
        return ans
    
    def preorder(self, left: Node, root: Node, right: Node) -> list:
        if left != None and right != None:
            left = self.preorder(left.left, left, left.right)
            right = self.preorder(right.left, right, right.right)
            return [root] + left + right
        elif left != None and right == None:
            left = self.preorder(left.left, left, left.right)
            return [root] + left
        elif left == None and right != None:
            right = self.preorder(right.left, right, right.right)
            return [root] + right
        else:
            return [root]
        
    def print_preorder(self) -> list:
        preorder_list = self.preorder(self.root.left, self.root, self.root.right)
        ans = []
        for node in preorder_list:
            ans.append(node.key)
        return ans
    
    def postorder(self, left: Node, root: Node, right: Node) -> list:
        if left != None and right != None:
            left = self.postorder(left.left, left, left.right)
            right = self.postorder(right.left, right, right.right)
            return left + right + [root]
        elif left != None and right == None:
            left = self.postorder(left.left, left, left.right)
            return left + [root]
        elif left == None and right != None:
            right = self.postorder(right.left, right, right.right)
            return right + [root]
        else:
            return [root]
        
    def print_postorder(self) -> list:
        postorder_list = self.postorder(self.root.left, self.root, self.root.right)
        ans = []
        for node in postorder_list:
            ans.append(node.key)
        return ans


if __name__==""__main__"":
    BST = BinarySearchTree()
    n = int(input())
    for i in range(n):
        mei, *key = input().split()
        if key != []:
            key = int(key[0])
        if mei == ""insert"":
            BST.insert(Node(key))
        elif mei == ""print"":
            print("""", *BST.print_inorder())
            print("""", *BST.print_preorder())
        elif mei == ""find"":
            ans = BST.find(key)
            if ans == None:
                print(""no"")
            else:
                print(""yes"")
        elif mei == ""delete"":
            BST.delete(key)
"
8527806,ALDS1_8_C,"class Node:
  def __init__(self, key, left=None, right=None):
    self.key = key
    self.left = left
    self.right = right

def insert(key):
  global root
  if root:
    ch = root
    while ch:
      pa, ch = ch, ch.left if key < ch.key else ch.right
    if key < pa.key:
      pa.left = Node(key)
    else:
      pa.right = Node(key)
  else:
    root = Node(key)

def find(key):
  node = root
  while node and node.key != key:
    node = node.left if key < node.key else node.right
  print(""yes"" if node else ""no"")

def delete(key):
  global root
  pa, node = None, root
  while node.key != key:
    pa, node = node, node.left if key < node.key else node.right
  if node.left and node.right:
    pa, to_del = node, node.right
    while to_del.left:
      pa, to_del = to_del, to_del.left
    node.key = to_del.key
  else:
    to_del = node
  ch = to_del.left or to_del.right
  if not pa:
    root = ch
  elif pa.left == to_del:
    pa.left = ch
  else:
    pa.right = ch

def walk(node, order):
  walked = """"
  if node:
    if order == ""Pre"":
      walked += f"" {node.key}""
    walked += walk(node.left, order)
    if order == ""In"":
      walked += f"" {node.key}""
    walked += walk(node.right, order)
  return walked

def show():
  for order in [""In"", ""Pre""]:
    print(walk(root, order))

root = None
cmds = {""print"":show, ""insert"":insert, ""find"":find, ""delete"":delete}
for _ in range(int(input())):
  cmd_name, *key = input().split()
  cmds[cmd_name](*map(int, key))

"
4305793,ALDS1_8_C,"import sys

class Node:
    __slots__ = [""key"",""left"",""right""]
    def __init__(self,key):
        self.key = key
        self.left = self.right = None

root = None

def insert(key):
    global root
    x,y = root,None
    while x:
        y = x
        x = x.left if key < x.key else x.right
    if y is None:root = Node(key)
    elif key < y.key:y.left = Node(key)
    else:y.right = Node(key)

def find(target):
    result = root
    while result and target != result.key:
        result = result.left if target < result.key else result.right
    return result is None

def delete(target):
    def remove_node(p,c,a):
        if p.left == c: p.left = a
        else: p.right = a
    p,c = None,root
    while c.key != target:
        p,c = c,c.left if target < c.key else c.right
    if c.left is None:
        remove_node(p,c,c.right)
    elif c.right is None:
        remove_node(p,c,c.left)
    elif c.right.left is None:
        c.right.left = c.left#親の上書き
        remove_node(p,c,c.right)
    else:
        g = c.right
        while g.left.left:g = g.left
        c.key = g.left.key
        g.left = g.left.right

def inorder(node):
    return inorder(node.left) + f' {node.key}' + inorder(node.right) if node else """"

def preorder(node):
    return f' {node.key}' + preorder(node.left) + preorder(node.right) if node else """"

input()
for e in sys.stdin:
    if e[0] == ""i"":insert(int(e[7:]))
    elif e[0] ==""d"":delete(int(e[7:]))
    elif e[0] ==""f"":print([""yes"",""no""][find(int(e[5:]))])
    else:print(inorder(root));print(preorder(root))

"
8571351,ALDS1_8_C,"from functools import total_ordering


@total_ordering
class Node:
    def __init__(self, key: int) -> None:
        self.key: int = key
        self.parent: Node = None
        self.left: Node = None
        self.right: Node = None

    def __eq__(self, __value: object) -> bool:
        if not isinstance(__value, Node):
            return NotImplemented
        return self.key == __value.key

    def __lt__(self, __value: object) -> bool:
        if not isinstance(__value, Node):
            return NotImplemented
        return self.key < __value.key


class BinarySearchTree:
    def __init__(self) -> None:
        self.root: Node = None

    def insert(self, z: Node) -> None:
        y: Node = None
        x: Node = self.root
        while x is not None:
            y = x
            if z < x:
                x = x.left
            else:
                x = x.right
        z.parent = y

        if y is None:  # the root is empty
            self.root = z
        elif z < y:
            y.left = z
        else:
            y.right = z

    def _preorder(self, root: Node) -> list:
        if root.left is None:
            left = []
        else:
            left = self._preorder(root.left)

        if root.right is None:
            right = []
        else:
            right = self._preorder(root.right)

        return [root.key] + left + right

    def print_preorder(self) -> None:
        print("" "" + "" "".join(map(str, self._preorder(self.root))))

    def _inorder(self, root: Node) -> list:
        if root.left is None:
            left = []
        else:
            left = self._inorder(root.left)

        if root.right is None:
            right = []
        else:
            right = self._inorder(root.right)

        return left + [root.key] + right

    def print_inorder(self) -> None:
        print("" "" + "" "".join(map(str, self._inorder(self.root))))

    def find(self, key: int) -> Node:
        x = self.root
        while x is not None:
            if x.key == key:
                return x
            elif x.key < key:
                x = x.right
            else:
                x = x.left
        return None

    def delete(self, key: int) -> None:
        node = self.find(key)
        if node is None:
            return
        elif node.left is None and node.right is None:
            if node.parent is None:
                self.root = None
            elif node.parent.left == node:
                node.parent.left = None
            else:
                node.parent.right = None
        elif node.left is None:
            if node.parent is None:
                self.root = node.right
            elif node.parent.left == node:
                node.parent.left = node.right
            else:
                node.parent.right = node.right
            node.right.parent = node.parent
        elif node.right is None:
            if node.parent is None:
                self.root = node.left
            elif node.parent.left == node:
                node.parent.left = node.left
            else:
                node.parent.right = node.left
            node.left.parent = node.parent
        else:
            y = node.right
            while y.left is not None:
                y = y.left
            next_node = y
            self.delete(next_node.key)
            node.key = next_node.key


n = int(input())
binary_search_tree = BinarySearchTree()

for _ in range(n):
    command = input().split()
    if command[0] == ""insert"":
        node = Node(int(command[1]))
        binary_search_tree.insert(node)
    elif command[0] == ""print"":
        binary_search_tree.print_inorder()
        binary_search_tree.print_preorder()
    elif command[0] == ""find"":
        if binary_search_tree.find(int(command[1])):
            print(""yes"")
        else:
            print(""no"")
    elif command[0] == ""delete"":
        binary_search_tree.delete(int(command[1]))

"
2721890,ALDS1_8_C,"import sys

class Node:
    __slots__ = ['key', 'left', 'right']
    def __init__(self, key):
        self.key = key
        self.left = self.right = None

root = None

def insert(key):
    global root
    x, y = root, None
    while x: x, y = x.left if key < x.key else x.right, x
    if y is None: root = Node(key)
    elif key < y.key: y.left = Node(key)
    else: y.right = Node(key)

def find(target):
    result = root
    while result and target != result.key:
        result = result.left if target < result.key else result.right
    return result is None

def delete(target):
    def remove_node(p, c, a):
        if p.left == c: p.left = a
        else: p.right = a
    p, c = None, root
    while c.key != target: p, c = c, c.left if target < c.key else c.right
    if c.left is None:
        remove_node(p, c, c.right)
    elif c.right is None:
        remove_node(p, c, c.left)
    elif c.right.left is None:
        c.right.left = c.left
        remove_node(p, c, c.right)
    else:
        g = c.right
        while g.left.left: g = g.left
        c.key = g.left.key
        g.left = g.left.right

def inorder(node):
    return inorder(node.left) + f' {node.key}' + inorder(node.right) if node else ''
def preorder(node):
    return f' {node.key}' + preorder(node.left) + preorder(node.right) if node else ''

input()
for e in sys.stdin:
    if e[0] == 'i': insert(int(e[7:]))
    elif e[0] == 'd': delete(int(e[7:]))
    elif e[0] == 'f': print(['yes','no'][find(int(e[5:]))])
    else: print(inorder(root)); print(preorder(root))
"
5329398,ALDS1_8_C,"import sys

class Node:
    __slots__ = ['key', 'left', 'right']
    def __init__(self, key):
        self.key = key
        self.left = self.right = None

root = None

def insert(key):
    global root
    x, y = root, None
    while x: x, y = x.left if key < x.key else x.right, x
    if y is None: root = Node(key)
    elif key < y.key: y.left = Node(key)
    else: y.right = Node(key)

def find(target):
    result = root
    while result and target != result.key:
        result = result.left if target < result.key else result.right
    return result is None

def delete(target):
    def remove_node(p, c, a):
        if p.left == c: p.left = a
        else: p.right = a
    p, c = None, root
    while c.key != target: p, c = c, c.left if target < c.key else c.right
    if c.left is None:
        remove_node(p, c, c.right)
    elif c.right is None:
        remove_node(p, c, c.left)
    elif c.right.left is None:
        c.right.left = c.left
        remove_node(p, c, c.right)
    else:
        g = c.right
        while g.left.left: g = g.left
        c.key = g.left.key
        g.left = g.left.right

def inorder(node):
    return inorder(node.left) + f' {node.key}' + inorder(node.right) if node else ''
def preorder(node):
    return f' {node.key}' + preorder(node.left) + preorder(node.right) if node else ''

input()
for e in sys.stdin:
    if e[0] == 'i': insert(int(e[7:]))
    elif e[0] == 'd': delete(int(e[7:]))
    elif e[0] == 'f': print(['yes','no'][find(int(e[5:]))])
    else: print(inorder(root)); print(preorder(root))
"
4254234,ALDS1_8_C,"import sys

class Node:
    __slots__ = ['key', 'left', 'right']
    def __init__(self, key):
        self.key = key
        self.left = self.right = None

root = None

def insert(key):
    global root
    x, y = root, None
    while x: x, y = x.left if key < x.key else x.right, x
    if y is None: root = Node(key)
    elif key < y.key: y.left = Node(key)
    else: y.right = Node(key)

def find(target):
    result = root
    while result and target != result.key:
        result = result.left if target < result.key else result.right
    return result is None

def delete(target):
    def remove_node(p, c, a):
        if p.left == c: p.left = a
        else: p.right = a
    p, c = None, root
    while c.key != target: p, c = c, c.left if target < c.key else c.right
    if c.left is None:
        remove_node(p, c, c.right)
    elif c.right is None:
        remove_node(p, c, c.left)
    elif c.right.left is None:
        c.right.left = c.left
        remove_node(p, c, c.right)
    else:
        g = c.right
        while g.left.left: g = g.left
        c.key = g.left.key
        g.left = g.left.right

def inorder(node):
    return inorder(node.left) + f' {node.key}' + inorder(node.right) if node else ''
def preorder(node):
    return f' {node.key}' + preorder(node.left) + preorder(node.right) if node else ''

input()
for e in sys.stdin:
    if e[0] == 'i': insert(int(e[7:]))
    elif e[0] == 'd': delete(int(e[7:]))
    elif e[0] == 'f': print(['yes','no'][find(int(e[5:]))])
    else: print(inorder(root)); print(preorder(root))

"
5847497,ALDS1_8_C,"import sys

class Node:
    __slots__ = ['key', 'left', 'right']
    def __init__(self, key):
        self.key = key
        self.left = self.right = None

root = None

def insert(key):
    global root
    x, y = root, None
    while x: x, y = x.left if key < x.key else x.right, x
    if y is None: root = Node(key)
    elif key < y.key: y.left = Node(key)
    else: y.right = Node(key)

def find(target):
    result = root
    while result and target != result.key:
        result = result.left if target < result.key else result.right
    return result is None

def delete(target):
    def remove_node(p, c, a):
        if p.left == c: p.left = a
        else: p.right = a
    p, c = None, root
    while c.key != target: p, c = c, c.left if target < c.key else c.right
    if c.left is None:
        remove_node(p, c, c.right)
    elif c.right is None:
        remove_node(p, c, c.left)
    elif c.right.left is None:
        c.right.left = c.left
        remove_node(p, c, c.right)
    else:
        g = c.right
        while g.left.left: g = g.left
        c.key = g.left.key
        g.left = g.left.right

def inorder(node):
    return inorder(node.left) + f' {node.key}' + inorder(node.right) if node else ''
def preorder(node):
    return f' {node.key}' + preorder(node.left) + preorder(node.right) if node else ''

input()
for e in sys.stdin:
    if e[0] == 'i': insert(int(e[7:]))
    elif e[0] == 'd': delete(int(e[7:]))
    elif e[0] == 'f': print(['yes','no'][find(int(e[5:]))])
    else: print(inorder(root)); print(preorder(root))

"
3120674,ALDS1_8_C,"import sys
class Node:
    __slots__ = ['key', 'left', 'right']
    def __init__(self, key):
        self.key = key
        self.left = self.right = None

root = None
def delete(target):
    def remove_node(p, c, a):
        if p.left == c:
            p.left = a
        else:
            p.right = a
    p, c = None, root
    while c.key != target:
        p, c = c, c.left if target < c.key else c.right
    if c.left is None:
        remove_node(p, c, c.right)
    elif c.right is None:
        remove_node(p, c, c.left)
    elif c.right.left is None:
        c.right.left = c.left
        remove_node(p, c, c.right)
    else:
        g = c.right
        while g.left.left:
            g = g.left
        c.key = g.left.key
        g.left = g.left.right

def find(target):
    result = root
    while result and target != result.key:
        result = result.left if target < result.key else result.right
    if result is None:
        return False
    else:
        return True

def insert(key):
    global root
    y = None  # xの親
    x = root
    while x:
        y = x
        x = x.left if key < x.key else x.right
    if y is None:  # Tが空の場合
        root = Node(key)
    elif key < y.key:
        y.left = Node(key)
    else:
        y.right = Node(key)

def in_order(node):
    if node is None:
        return ''
    return in_order(node.left) + f' {node.key}' + in_order(node.right)
def pre_order(node):
    if node is None:
        return ''
    return f' {node.key}' + pre_order(node.left) + pre_order(node.right)
input()
for e in sys.stdin:
    if e[0] == 'i':
        insert(int(e[7:]))
    elif e[0] == 'd':
        delete(int(e[7:]))
    elif e[0] == 'f':
        print('yes' if find(int(e[5:])) else 'no')
    else:
        print(in_order(root))
        print(pre_order(root))
"
4518372,ALDS1_8_C,"from collections import deque
import sys
readline = sys.stdin.readline
write = sys.stdout.write

class Node:
    __slots__ = ['key', 'left', 'right']
    def __init__(self, key):
        self.key = key
        self.left = self.right = None


root = None

def insert(key):
    global root
    x = root #Tの根
    y = None #親を設定
    while x is not None:
        y = x
        if key < x.key:
            x = x.left #左の子へ移動
        else:
            x = x.right  #右の子へ移動

    if y is None: #Tが空の場合
        root = Node(key)
    elif key < y.key:
        y.left = Node(key) #keyをyの左の子にする
    else:
        y.right = Node(key) #keyをyの右の子にする

def delete(target):
    def remove_node(p,c,a):
        if p.left == c: p.left = a
        else: p.right = a
    p,c = None,root
    while c.key != target: p,c = c,c.left if target < c.key else c.right
    if c.left is None:
        remove_node(p, c, c.right)
    elif c.right is None:
        remove_node(p, c, c.left)
    elif c.right.left is None:
        c.right.left = c.left
        remove_node(p, c, c.right)
    else:
        g = c.right
        while g.left.left: g = g.left
        c.key = g.left.key
        g.left = g.left.right

# def find(key):
#     x = root
#     while x and key != x.key:
#         x = x.left if key < x.key else x.right
#     return x is None

def find(target):
    result = root
    while result and target != result.key:
        result = result.left if target < result.key else result.right
    return result is None # result が None ⇒ false

def inorder(node):
    return   inorder(node.left) + "" ""+ str(node.key) + inorder(node.right) if node else ''
def preorder(node):
    return   "" "" + str(node.key) + preorder(node.left) + preorder(node.right) if node else ''
input()
for e in sys.stdin:
    if e[0] == ""i"":
        insert(int(e[7:]))
    elif e[0] == 'f':
        if find(int(e[5:])):
            print(""no"")
        else:
            print(""yes"")
        # print(['yes','no'][find(int(e[5:]))])

    elif e[0] == 'd':
        delete(int(e[7:]))

    else:
        print(inorder(root))
        print(preorder(root))

"
4624430,ALDS1_8_C,"import sys
# def input():
#     return sys.stdin.readline()[:-1]

# n = int(input())
# A = [input() for i in range(n)]

class Node():
    __slots__ = ['key', 'left', 'right','parent']
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.parent = None


def insert(key):
    global root
    x = root # x is current node
    y = None  #  parent of x 
    while x:
        y = x # set parent
        if key < x.key:
            x = x.left # move to left child
        else:
            x = x.right #move to right child
    
    if root is None:
        root = Node(key)
    elif key < y.key: # set z as left child of y
        y.left = Node(key)
        y.left.parent = y
    else: 
        y.right = Node(key) # set z as right child of y
        y.right.parent = y
        
def find(key):
    global root
    x = root
    while x:
        if key==x.key:
            print('yes')
            return
        elif key < x.key:
            x = x.left
        else:
            x = x.right
    print('no')
    
    
def minimum(x):
    while x.left:
        x = x.left
    return x
    
    
def successor(x):
    if x.right:
        return minimum(x.right)
    y = x.parent
    while (y) and (x==y.right):
        x = y
        y = y.parent
    return y
    
    
    
def delete(key):
    global root
    
    # find z
    z = None
    x = root
    while x:
        if key==x.key:
            z = x
            break
        elif key < x.key:
            x = x.left
        else:
            x = x.right
    if z is None:
        return
    
    # determin y
    if (z.left==None) or (z.right==None):
        y = z
    else:
        y = successor(z)
        
    if y.left:
        x = y.left
    else:
        x = y.right
        
    if x:
        x.parent = y.parent
    
    if y.parent is None:
        root = x
    elif y==y.parent.left:
        y.parent.left = x
    else:
        y.parent.right = x
        
    if y!=z:
        z.key = y.key
    

def inorder(inorder_list, node):
    if node.left is not None:
        inorder(inorder_list, node.left)
    inorder_list.append(str(node.key))
    if node.right is not None:
        inorder(inorder_list, node.right)
    return inorder_list
        
def preorder(preorder_list, node):
    preorder_list.append(str(node.key))
    if node.left is not None:
        preorder(preorder_list, node.left)
    if node.right is not None:
        preorder(preorder_list, node.right)
    return preorder_list
        
root = None

input()
for o in sys.stdin:
    if o[0]=='i':
        insert(int(o[7:]))
    elif o[0]=='f':
        find(int(o[5:]))
    elif o[0]=='d':
        delete(int(o[7:]))
    else:
        x = root
        inorder_list = inorder([], x)
        print(' '+' '.join(inorder_list))
        preorder_list = preorder([], x)
        print(' '+' '.join(preorder_list))
"
8388809,ALDS1_8_C,"# Nodeクラスの定義。二分探索木の各ノードを表します。
class Node:
    def __init__(self, key):
        self.key = key  # ノードのキー値
        self.right = None  # 右の子ノードへの参照
        self.left = None  # 左の子ノードへの参照
        self.parent = None  # 親ノードへの参照

# 二分探索木を表すクラス
class BinarySearchTree:
    def __init__(self):
        self.root = None  # 木のルートノード

    # キー値kを持つノードを探す関数
    def find(self, k):
        u = self.root
        while u and k != u.key:
            if k < u.key:
                u = u.left
            else:
                u = u.right
        return u

    # キー値kを持つ新しいノードを木に挿入する関数
    def insert(self, k):
        y = None
        x = self.root
        z = Node(k)

        while x:
            y = x
            if z.key < x.key:
                x = x.left
            else:
                x = x.right

        z.parent = y
        if y is None:
            self.root = z
        elif z.key < y.key:
            y.left = z
        else:
            y.right = z
            
    # 木の中で最小のキーを持つノードを見つける関数です。
    def tree_minimum(self, x):
        
        # 左の子がNoneになるまで、左の子ノードに移動し続けます。
        while x.left != None:
            x = x.left
        
        # 最小のキーを持つノードを返します。
        return x

    # 与えられたノードの次のノード（中順後継者）を見つける関数です。
    # xを削除したら、そこに新しく位置づけるのは、どのノードになるか
    def tree_successor(self, x):
        
        # xに右の子がある場合、右の部分木で最小の要素を返します。
        if x.right != None:
            return self.tree_minimum(x.right)
        
        # 右の子がない場合、""上""に移動して後継者を見つけます。
        y = x.parent
        while y != None and x == y.right: # xがyの右の子である間くり返す
            x = y
            y = y.parent
            
        return y


    # 木から特定のノードを削除する関数です。
    def tree_delete(self, z):
        global root  # グローバル変数rootを使用します。

        # 削除すべきノードを確認します。
        # zが2つの子を持つ場合、zの位置に来るべきノードは、zの後継者です。
        if z.left != None and z.right != None:
            y = self.tree_successor(z)   # yは後継者です。
        else:
            y = z  # zが0個または1個の子を持つ場合、yはz自身です。

        # yの子xを決定します。yには高々1つの非Noneの子があるので、その子（存在する場合）をxとします。
        if y.left != None:
            x = y.left
        else:
            x = y.right  # 注: xはNoneかもしれません（yが子を持たない場合）。

        # xの親をyの親にリンクします。yを削除するため、yの親はxを指さなければなりません。
        if x != None:
            x.parent = y.parent  # xの親を設定

        # yの親を更新します。yが根の場合はrootを更新し、
        # そうでない場合はyが左の子か右の子かを確認して、適切な子をxに設定します。
        if y.parent is None:
            root = x
        else:
            if y == y.parent.left:
                y.parent.left = x
            else:
                y.parent.right = x

        # もしyがzの後継者だった場合、yのキーをzにコピーします
        # （これにより、「zを削除」したことになります）。
        if y != z:
            z.key = y.key  # yのデータをzに移す

        # yが削除されるノードなので、必要に応じてメモリ解放処理を行います（Pythonでは不要ですが、他の言語では必要です）。
        del y  # Pythonのガベージコレクタが後で清掃しますが、他のプログラミング言語では明示的なメモリ解放が必要です。

          # 削除されたオリジナルのノードを返します
          # （これはオプションで、削除成功の確認や他の目的に使用できます）。
        return z


    # 中順巡回を行い、キーのリストを返す関数
    def inorder(self, u):
        if not u:
            return []
        return self.inorder(u.left) + [u.key] + self.inorder(u.right)

    # 前順巡回を行い、キーのリストを返す関数
    def preorder(self, u):
        if not u:
            return []
        return [u.key] + self.preorder(u.left) + self.preorder(u.right)

# メインの実行部分
if __name__ == ""__main__"":
    bst = BinarySearchTree()  # 二分探索木のインスタンスを作成
    n = int(input())  # コマンドの数を入力

    for _ in range(n):
        command = input().split()  # コマンドを入力
        if command[0] == ""find"":
            x = int(command[1])
            t = bst.find(x)
            if t:
                print(""yes"")
            else:
                print(""no"")
        elif command[0] == ""insert"":
            x = int(command[1])
            bst.insert(x)
        elif command[0] == ""print"":
            print(f' {"" "".join(map(str, bst.inorder(bst.root)))}')
            print(f' {"" "".join(map(str, bst.preorder(bst.root)))}')
        elif command[0] == ""delete"":
            x = int(command[1])
            bst.tree_delete(bst.find(x))


"
6955790,ALDS1_8_C,"from collections import deque
import sys
readline = sys.stdin.readline
write = sys.stdout.write

root = None
def insert(z):
    global root
    y = None
    x = root
    while x:
        y = x
        x = x[z[2] >= x[2]]
    z[3] = y

    if not y:
        root = z
    else:
        y.__setitem__(z[2] >= y[2], z)

def find(k):
    x = root
    while x:
        if x[2] == k:
            return 1
        x = x[k >= x[2]]
    return 0

def __delete(x):
    global root
    if x[0] and x[1]:
        y = x[1]
        while y[0]:
            y = y[0]
        x[2] = y[2]
        __delete(y)
    elif not x[0] and not x[1]:
        if x[3]:
            p = x[3]
            p.__setitem__(p[1] is x, None)
        else:
            root = None
        del x
    else:
        y = x[0] or x[1]

        if x[3]:
            p = x[3]

            y[3] = p
            p[p[1] is x] = y
        else:
            y[3] = None
            root = y
        del x

def delete(k):
    x = root
    while x:
        if x[2] == k:
            break
        x = x[k >= x[2]]
    if not x:
        return
    __delete(x)

def debug():
    s0 = [""""]
    s1 = [""""]

    def dfs(nd):
        v = str(nd[2])
        s0.append(v)
        if nd[0]:
            dfs(nd[0])
        s1.append(v)
        if nd[1]:
            dfs(nd[1])
    dfs(root)
    return "" "".join(s1), "" "".join(s0)


M = int(readline())
ans = []
for m in range(M):
    cmd, *V, = readline().split()
    if cmd == ""print"":
        ans.extend(debug())
    elif cmd == ""find"":
        ans.append(""yes"" if find(int(V[0])) else ""no"")
    elif cmd == ""delete"":
        delete(int(V[0]))
    else:
        insert([None, None, int(V[0]), None])
write(""\n"".join(ans))
write(""\n"")
"
7610185,ALDS1_8_C,"from collections import deque
import sys
readline = sys.stdin.readline
write = sys.stdout.write

root = None
def insert(z):
    global root
    y = None
    x = root
    while x:
        y = x
        x = x[z[2] >= x[2]]
    z[3] = y

    if not y:
        root = z
    else:
        y.__setitem__(z[2] >= y[2], z)

def find(k):
    x = root
    while x:
        if x[2] == k:
            return 1
        x = x[k >= x[2]]
    return 0

def __delete(x):
    global root
    if x[0] and x[1]:
        y = x[1]
        while y[0]:
            y = y[0]
        x[2] = y[2]
        __delete(y)
    elif not x[0] and not x[1]:
        if x[3]:
            p = x[3]
            p.__setitem__(p[1] is x, None)
        else:
            root = None
        del x
    else:
        y = x[0] or x[1]

        if x[3]:
            p = x[3]

            y[3] = p
            p[p[1] is x] = y
        else:
            y[3] = None
            root = y
        del x

def delete(k):
    x = root
    while x:
        if x[2] == k:
            break
        x = x[k >= x[2]]
    if not x:
        return
    __delete(x)

def debug():
    s0 = [""""]
    s1 = [""""]

    def dfs(nd):
        v = str(nd[2])
        s0.append(v)
        if nd[0]:
            dfs(nd[0])
        s1.append(v)
        if nd[1]:
            dfs(nd[1])
    dfs(root)
    return "" "".join(s1), "" "".join(s0)


M = int(readline())
ans = []
for m in range(M):
    cmd, *V, = readline().split()
    if cmd == ""print"":
        ans.extend(debug())
    elif cmd == ""find"":
        ans.append(""yes"" if find(int(V[0])) else ""no"")
    elif cmd == ""delete"":
        delete(int(V[0]))
    else:
        insert([None, None, int(V[0]), None])
write(""\n"".join(ans))
write(""\n"")



"
2705457,ALDS1_8_C,"import sys
readline = sys.stdin.readline
class Node:
    __slots__ = ['value', 'left', 'right']
    def __init__(self, value = None, left = None, right = None):
        self.value = value
        self.left = left
        self.right = right
class BinTree:
    __slots__ = ['_tree', 'result']
    def __init__(self):
        self._tree = None
    def insert(self, value):
        p = None
        c = self._tree
        while c is not None:
            p = c
            if value < c.value:
                c = c.left
            else:
                c = c.right
        if p is None:
            self._tree = Node(value)
        elif value < p.value:
            p.left = Node(value)
        else:
            p.right = Node(value)
    def find(self, value):
        c = self._tree
        while c is not None:
            if value == c.value:
                return True
            elif value < c.value:
                c = c.left
            else:
                c = c.right
        return False
    def delete(self, value):
        def node_move(p, c, a):
            if p.left == c:
                p.left = a
            else:
                p.right = a
        p = None
        c = self._tree
        while c.value != value:
            p = c
            if c is None:
                return
            if value < c.value:
                c = c.left
            else:
                c = c.right
        if c.left is None:
            node_move(p, c, c.right)
        elif c.right is None:
            node_move(p, c, c.left)
        elif c.right.left is None:
            c.right.left = c.left
            node_move(p, c, c.right)
        else:
            q = c.right
            while q.left.left is not None:
                q = q.left
            c.value = q.left.value
            q.left = q.left.right
        return
    def preoder_walk(self):
        self.result = []
        def preoder(node):
            if node is not None:
                self.result.append(node.value)
                preoder(node.left)
                preoder(node.right)
        preoder(self._tree)
        print("" "" + "" "".join(map(str, self.result)))
    def inorder_walk(self):
        self.result = []
        def inorder(node):
            if node is not None:
                inorder(node.left)
                self.result.append(node.value)
                inorder(node.right)
        inorder(self._tree)
        print("" "" + "" "".join(map(str, self.result)))
n = int(input())
tree = BinTree()
for _ in range(n):
    com = readline().split()
    if com[0] == ""insert"":
        tree.insert(int(com[1]))
    elif com[0] == ""find"":
        print(""yes"" if tree.find(int(com[1])) else ""no"")
    elif com[0] == ""delete"":
        tree.delete(int(com[1]))
    else:
        tree.inorder_walk()
        tree.preoder_walk()

"
3185588,ALDS1_8_C,"from collections import deque
import sys
readline = sys.stdin.readline
write = sys.stdout.write

root = None
def insert(z):
    global root
    y = None
    x = root
    while x:
        y = x
        x = x[z[2] >= x[2]]
    z[3] = y

    if not y:
        root = z
    else:
        y.__setitem__(z[2] >= y[2], z)

def find(k):
    x = root
    while x:
        if x[2] == k:
            return 1
        x = x[k >= x[2]]
    return 0

def __delete(x):
    global root
    if x[0] and x[1]:
        y = x[1]
        while y[0]:
            y = y[0]
        x[2] = y[2]
        __delete(y)
    elif not x[0] and not x[1]:
        if x[3]:
            p = x[3]
            p.__setitem__(p[1] is x, None)
        else:
            root = None
        del x
    else:
        y = x[0] or x[1]

        if x[3]:
            p = x[3]

            y[3] = p
            p[p[1] is x] = y
        else:
            y[3] = None
            root = y
        del x

def delete(k):
    x = root
    while x:
        if x[2] == k:
            break
        x = x[k >= x[2]]
    if not x:
        return
    __delete(x)

def debug():
    s0 = [""""]
    s1 = [""""]

    def dfs(nd):
        v = str(nd[2])
        s0.append(v)
        if nd[0]:
            dfs(nd[0])
        s1.append(v)
        if nd[1]:
            dfs(nd[1])
    dfs(root)
    return "" "".join(s1), "" "".join(s0)


M = int(readline())
ans = []
for m in range(M):
    cmd, *V, = readline().split()
    if cmd == ""print"":
        ans.extend(debug())
    elif cmd == ""find"":
        ans.append(""yes"" if find(int(V[0])) else ""no"")
    elif cmd == ""delete"":
        delete(int(V[0]))
    else:
        insert([None, None, int(V[0]), None])
write(""\n"".join(ans))
write(""\n"")

"
8393286,ALDS1_8_C,"input_queue = '''43
insert 30
insert 17
insert 88
insert 53
insert 5
insert 20
insert 18
insert 28
insert 27
insert 60
print
find -1
find 2
find 3
find 4
find 5
find 6
find 10
find 17
find 28
find 29
find 30
find 31
find 50
find 51
find 52
find 53
find 54
find 60
find 88
find 89
insert 2000000000
insert 55
insert 63
insert -1
insert 8
print
delete 53
delete 2000000000
delete 20
delete 5
delete 8
print'''.splitlines()
def input_():
  return input_queue.pop(0)


class Node:
  def __init__(self, key):
    self.key = key

    self.left  = None
    self.right = None

  def check(self):
    if self.key is None:
      if self.left is not None:
        self.left.check()
    else:
      if self.left is not None:
        if not self.left.key < self.key:
          print('Check:', self.key, ': left key is invalid:', self.left.key)
        self.left.check()
      if self.right is not None:
        if not self.right.key > self.key:
          print('Check:', self.key, ': right key is invalid:', self.right.key)
        self.right.check()


def get_node(key):
  node = tree
  parent = None
  is_at_left = None
  while True:
    if key == node.key:
      return node, parent, is_at_left, True
    elif node.key == None:
      if node.left is None:
        break
      # Move to left.
      is_at_left = True
      parent = node
      node = node.left
    elif key < node.key:
      if node.left is None:
        break
      # Move to left.
      is_at_left = True
      parent = node
      node = node.left
    else:
      if node.right is None:
        break
      # Move to right.
      is_at_left = False
      parent = node
      node = node.right
  return node, parent, is_at_left, False

def find_inst(key):
  _, _, _, found = get_node(key)
  print('yes' if found else 'no')

def insert_inst(new_key):
  new_node = Node(new_key)

  node, _, _, _ = get_node(new_key)

  if node.key == None:
    # Insert `new_node` as left of root.
    node.left = new_node
  elif new_node.key < node.key:
    # Insert `new_node` as left of `node`.
    node.left = new_node
  else:
    # Insert `new_node` as right of `node`.
    node.right = new_node

def delete_inst(key):
  def delete(node, parent, is_at_left):
    num_children = 0
    if node.left is not None: num_children += 1
    if node.right is not None: num_children += 1

    if num_children == 0:
      # Delete `node`.
      if is_at_left: parent.left = None
      else: parent.right = None
    elif num_children == 1:
      if node.left is not None: child = node.left
      else: child = node.right
      if is_at_left: parent.left = child
      else: parent.right = child
    elif num_children == 2:
      next_node = node.right
      next_node_parent = node
      is_next_at_left = False
      while next_node.left is not None:
        next_node_parent = next_node
        next_node = next_node.left
        is_next_at_left = True
      # Copy `next_node.key` to `node.key`.
      node.key = next_node.key
      # Delete `node`.
      delete(next_node, next_node_parent, is_next_at_left)

  node, parent, is_at_left, _ = get_node(key)
  delete(node, parent, is_at_left)

def walk_tree(tree, fns):
  def walk(tree):
    if tree is None:
      return
    for f in fns:
      f(walk, tree)
  walk(tree)

def print_inst():
  # Print as inorder.
  walk_tree(tree, [
    lambda walk, node: walk(node.left),
    lambda walk, node: None if node.key == None else print(' ' + str(node.key), end=''),
    lambda walk, node: walk(node.right),
    ])
  print()

  # Print as preorder.
  walk_tree(tree, [
    lambda walk, node: None if node.key == None else print(' ' + str(node.key), end=''),
    lambda walk, node: walk(node.left),
    lambda walk, node: walk(node.right),
    ])
  print()


# Init tree.
tree = Node(None)

# Run.
num_insts = int(input())

for _ in range(num_insts):
  toks = input().split()
  if toks[0] == 'find':
    find_inst(int(toks[1]))
  elif toks[0] == 'insert':
    insert_inst(int(toks[1]))
  elif toks[0] == 'delete':
    delete_inst(int(toks[1]))
  elif toks[0] == 'print':
    print_inst()
"
4174591,ALDS1_8_C,"import sys
input = sys.stdin.readline
print = sys.stdout.write

class Node:
    __slots__ = [""data"", ""left"", ""right""]
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

class BinarySearchTree:
    __slots__ = [""root""]
    def __init__(self):
        self.root = None
    
    def insert(self, data):
        parent = self.root
        if parent is None:
            self.root = Node(data)
            return
        while parent:
            parent_old = parent
            parent = parent.left if data < parent.data else parent.right
        if data < parent_old.data:
            parent_old.left = Node(data)
        else:
            parent_old.right = Node(data)
        
    def find(self, data):
        parent = self.root
        if parent is None:
            print(""no\n"")
            return
        while parent:
            if parent.data == data:
                print(""yes\n"")
                return
            parent = parent.left if data < parent.data else parent.right
        print(""no\n"")
        return
    
    def delete(self, data):
        target = self.root
        if target is None:
            return
        while target:
            if target.data == data:
                if target.right and target.left:
                    next_target = target.right
                    if next_target.left is None:
                        if target == self.root:
                            self.root = next_target
                        target.data = next_target.data
                        target.right = next_target.right
                        return
                    while next_target.left:
                        parent = next_target
                        next_target = next_target.left
                    if target == self.root:
                        self.root = next_target
                    target.data = next_target.data
                    parent.left = next_target.right
                    return
                else:
                    child = target.right or target.left
                    if target == self.root:
                        self.root = child
                        if child is None:
                            return
                    if child:
                        target.data, target.left, target.right = child.data, child.left, child.right
                    else:
                        if data < parent.data:
                            parent.left = None
                        else:
                            parent.right = None
                    return
            parent = target
            target = target.left  if data < target.data else target.right


def print_preorder(node):
    print("" {}"".format(node.data))
    if node.left:
        print_preorder(node.left)
    if node.right:
        print_preorder(node.right)

def print_inorder(node):
    if node.left:
        print_inorder(node.left)
    print("" {}"".format(node.data))
    if node.right:
        print_inorder(node.right)

if __name__ == ""__main__"":
    n = int(input())
    binary_search_tree = BinarySearchTree()
    for _ in range(n):
        operation, *num = input().split()
        if operation[0] == ""i"":
            binary_search_tree.insert(int(num[0]))
        elif operation[0] == ""f"":
            binary_search_tree.find(int(num[0]))
        elif operation[0] == ""d"":
            binary_search_tree.delete(int(num[0]))
        elif binary_search_tree.root is not None:
            print_inorder(binary_search_tree.root)
            print(""\n"")
            print_preorder(binary_search_tree.root)
            print(""\n"")
"
8812956,ALDS1_8_C,"#参考 : ALDS1_8_C 二分木の実装 https://zenn.dev/usma11dia0/articles/solve-alds-1-8-c
class node:
    def __init__(self, key) -> None:
        self.key = key
        self.left = None
        self.right = None
        
class BinarySearchTree:
    def __init__(self) -> None:
        self.root = None
    
    def insert(self, key) -> None:
        if self.root is None:
            self.root = node(key)
            return
        def _insert(Node, key) -> node:
            #現在ノードの有無確認
            if Node is None:
                return node(key)
            #大小比較
            if key < Node.key:
                Node.left = _insert(Node.left, key)
            else:
                Node.right = _insert(Node.right, key)
            return Node
        _insert(self.root, key)
        
    def find(self, key):
        def _find(Node, key):
            if Node is None:
                return False
            if key == Node.key:
                return True
            elif key < Node.key:
                return _find(Node.left, key)
            else:
                return _find(Node.right, key)
        return _find(self.root, key)
        
    def min_key(self, Node):
        current_node = Node
        while current_node.left is not None:
            current_node = current_node.left
        return current_node
        
    def delete(self, key):
        def _delete(Node, key):
            if Node is None:
                return Node
            if key < Node.key:
                Node.left = _delete(Node.left, key)
            elif key > Node.key:
                Node.right = _delete(Node.right, key)
            else:
                #子ノードが1つもない場合: if Node.left内を実行。Node.right->Noneを返す
                #子ノードが1つの場合: 子ノードを削除対象ノードkeyの場所へ代入
                if Node.left is None:
                    return Node.right
                elif Node.right is None:
                    return Node.left
                #子ノードが2つの場合
                #右部分木の採用ノードを取得
                tmp = self.min_key(Node.right)
                #削除するノードの値へ最小値の値をコピー
                Node.key = tmp.key
                #右部分木内に残った最小値ノードを削除して、削除対象ノードkeyの場所へ移す
                Node.right = _delete(Node.right, tmp.key)
            return Node
        _delete(self.root, key)
        
    def print(self) -> str:
        def inorder(node) -> None:
            if node is not None:
                inorder(node.left)
                output.append(str(node.key))
                inorder(node.right)
        def preorder(node) -> None:
            if node is not None:
                output.append(str(node.key))
                preorder(node.left)
                preorder(node.right)
                
                
        output = []
        inorder(self.root)
        inorder_output = "" "".join(output)
        output = []
        preorder(self.root)
        preorder_output = "" "".join(output)
        
        return "" "" + inorder_output + ""\n"" + "" "" + preorder_output
        
m = int(input())
T = BinarySearchTree()
output = []

for _ in range(m):
    command = list(map(str, input().split()))
    if command[0] == ""insert"":
        T.insert(int(command[1]))
    elif command[0] == ""print"":
        output.append(T.print())
    elif command[0] == ""find"":
        if T.find(int(command[1])):
            output.append(""yes"")
        else:
            output.append(""no"")
    elif command[0] == ""delete"":
        T.delete(int(command[1]))

print(""\n"".join(output))    
"
7617982,ALDS1_8_C,"from collections import deque
import sys
readline = sys.stdin.readline
write = sys.stdout.write

root = None
def insert(z):
    global root
    y = None
    x = root
    while x:
        y = x
        x = x[z[2] >= x[2]]
    z[3] = y

    if not y:
        root = z
    else:
        y.__setitem__(z[2] >= y[2], z)

def find(k):
    x = root
    while x:
        if x[2] == k:
            return 1
        x = x[k >= x[2]]
    return 0

def __delete(x):
    global root
    if x[0] and x[1]:
        y = x[1]
        while y[0]:
            y = y[0]
        x[2] = y[2]
        __delete(y)
    elif not x[0] and not x[1]:
        if x[3]:
            p = x[3]
            p.__setitem__(p[1] is x, None)
        else:
            root = None
        del x
    else:
        y = x[0] or x[1]

        if x[3]:
            p = x[3]

            y[3] = p
            p[p[1] is x] = y
        else:
            y[3] = None
            root = y
        del x
def delete(k):
    x=root
    while x:
        if x[2]==k:
            break
        x=x[k>=x[2]]
    if not x:
        return
    __delete(x)
def debug():
    s0=[""""]
    s1=[""""]
    def dfs(nd):
        v=str(nd[2])
        s0.append(v)
        if nd[0]:
            dfs(nd[0])
        s1.append(v)
        if nd[1]:
            dfs(nd[1])
    dfs(root)
    return "" "".join(s1), "" "".join(s0)
M=int(readline())
ans=[]
for m in range(M):
    cmd,*V,=readline().split()
    if cmd==""print"":
        ans.extend(debug())
    elif cmd==""find"":
        ans.append(""yes"" if find(int(V[0])) else ""no"")
    elif cmd==""delete"":
        delete(int(V[0]))
    else:
        insert([None,None,int(V[0]),None])
write(""\n"".join(ans))
write(""\n"")
    
    
        
"
2640107,ALDS1_8_C,"# -*- coding:utf-8 -*-
import sys


class Node(object):
    __slots__ = [""value"", ""left"", ""right""]

    def __init__(self, value, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right


class BinTree(object):
    def __init__(self):
        self._tree = None

    def insert(self, value):
        parent = None
        current = self._tree

        while current is not None:
            parent = current
            if value < current.value:
                current = current.left
            else:
                current = current.right

        if parent is None:
            self._tree = Node(value)
        elif value < parent.value:
            parent.left = Node(value)
        else:
            parent.right = Node(value)

    def find(self, value):
        current = self._tree

        while current is not None:
            if value == current.value:
                return True
            elif value < current.value:
                current = current.left
            else:
                current = current.right

        return False

    def delete(self, value):
        parent = None
        current = self._tree

        while current.value != value:
            parent = current
            if current is None:
                return
            elif value < current.value:
                current = current.left
            else:
                current = current.right

        if current.left is None and current.right is None:
            if parent.left is current:
                parent.left = None
            else:
                parent.right = None
        elif current.left is None:
            if parent.left is current:
                parent.left = current.right
            else:
                parent.right = current.right
        elif current.right is None:
            if parent.left is current:
                parent.left = current.left
            else:
                parent.right = current.left
        else:
            next_node_parent = current
            next_node = current.right
            while next_node.left is not None:
                next_node_parent = next_node
                next_node = next_node.left

            if next_node.right is None:
                if next_node_parent.left is next_node:
                    next_node_parent.left = None
                else:
                    next_node_parent.right = None
            else:
                if next_node_parent.left is next_node:
                    next_node_parent.left = next_node.right
                else:
                    next_node_parent.right = next_node.right

            current.value = next_node.value

    def preoder_walk(self):
        def preoder(node):
            result = []
            if node is None:
                pass
            else:
                result.append(node.value)
                result.extend(preoder(node.left))
                result.extend(preoder(node.right))
            return result

        return preoder(self._tree)

    def inorder_walk(self):
        def inorder(node):
            result = []
            if node is None:
                pass
            else:
                result.extend(inorder(node.left))
                result.append(node.value)
                result.extend(inorder(node.right))
            return result

        return inorder(self._tree)


def print_tree(tree):
    print("" "" + "" "".join([str(val) for val in tree.inorder_walk()]))
    print("" "" + "" "".join([str(val) for val in tree.preoder_walk()]))


def print_yes_no(boolean):
    if boolean:
        print(""yes"")
    else:
        print(""no"")


def main(commands):
    tree = BinTree()
    for com in commands:
        if com[0] == ""insert"":
            tree.insert(int(com[1]))
        elif com[0] == ""print"":
            print_tree(tree)
        elif com[0] == ""find"":
            print_yes_no(tree.find(int(com[1])))
        elif com[0] == ""delete"":
            tree.delete(int(com[1]))
        else:
            raise ValueError


if __name__ == ""__main__"":
    n = int(input())
    commands = [com.split() for com in sys.stdin.readlines()]
    main(commands)
"
6318094,ALDS1_8_C,"from sys import stdin

class node:
    def __init__(self, x, p):
        self.k = x
        self.l = self.r = None
        self.p = p

def insert(z):
    global root
    x, y = root, None
    while x:
        y = x
        x = x.l if z < x.k else x.r
    
    if y == None:
        root = node(z, None)
    elif z < y.k:
        y.l = node(z, y)
    else:
        y.r = node(z, y)

def find(k):
    global root
    i = root
    while i:
        if k == i.k:
            return i
        i = i.l if k < i.k else i.r
    return None

def delete(k):
    global root
    
    i = find(k)
    p = i.p
    f = p.l == i
    
    if i.l == None and i.r == None:
        if f: p.l = None
        else: p.r = None
    elif i.l == None or i.r == None:
        c = i.l if i.l else i.r
        c.p = p
        if f: p.l = c
        else: p.r = c
    else:
        j = i.r
        while j.l: j = j.l
        i.k = j.k
        jp = j.p
        if j.r: j.r.p = jp
        if jp == i:
            i.r = j.r
        else:
            jp.l = j.r


def rec(i, m):
    if i == None:
        return ''
    
    c = ' ' + str(i.k)
    l, r = rec(i.l, m), rec(i.r, m)
    
    if m == 0:
        return l + c + r
    else:
        return c + l + r


input()
root = None
for l in stdin:
    if l[0] == 'i':
        insert(int(l[7:]))
    elif l[0] == 'f':
        f = find(int(l[5:]))
        print('yes' if f else 'no')
    elif l[0] == 'd':
        delete(int(l[7:]))
    else:
        for i in (0, 1): print(rec(root, i))
"
3883598,ALDS1_8_C,"import sys
input = sys.stdin.readline

class Node:
    __slots__ = ['value', 'parent', 'left', 'right']
    def __init__(self, value: int, parent: 'Node' = None):
        self.value = value
        self.parent = parent
        self.left: Node = None
        self.right: Node = None
    def inParse(self):
        if self.value == None:
            return
        if self.left != None:
            self.left.inParse()
        print(' {}'.format(self.value), end='')
        if self.right != None:
            self.right.inParse()
    def preParse(self):
        if self.value == None:
            return
        print(' {}'.format(self.value), end='')
        if self.left != None:
            self.left.preParse()
        if self.right != None:
            self.right.preParse()

class BinarySearchTree:
    __slots__ = ['root']
    def __init__(self):
        self.root: Node = None
    def insert(self, x: int):
        if self.root == None:
            self.root = Node(x)
            return
        parent, current = None, self.root
        while current:
            parent = current
            if x < current.value:
                current = current.left
            else:
                current = current.right
        if x < parent.value:
            parent.left = Node(x, parent)
        else:
            parent.right = Node(x, parent)
    def find(self, x: int):
        y = self.root
        while y != None and y.value != x:
            if y.value > x:
                y = y.left
            else:
                y = y.right
        return y
    def getMinimum(self, x: Node):
        while x.left != None:
            x = x.left
        return x
    def getSuccer(self, x: Node):
        if x.right != None:
            return self.getMinimum(x.right)
        y = x.parent
        while y != None and x == y.right:
            x = y
            y = y.parent
        return y
    def deleteNode(self, z: Node):
        if z.left == None or z.right == None:
            y = z
        else:
            y = self.getSuccer(z)
        if y.left != None:
            x = y.left
        else:
            x = y.right
        if x != None:
            x.parent = y.parent
        if y.parent == None:
            self.root = x
        elif y.parent.left == y:
            y.parent.left = x
        else:
            y.parent.right = x
        if y != z:
            z.value = y.value
        
def main():
    tree = BinarySearchTree()
    n = int(input())
    for _ in range(n):
        inp = input()
        if inp[0] == 'i':
            com, num = inp.split()
            tree.insert(int(num))
        elif inp[0] == 'f':
            com, num = inp.split()
            if tree.find(int(num)):
                print('yes')
            else:
                print('no')
        elif inp[0] == 'd':
            com, num = inp.split()
            y = tree.find(int(num))
            tree.deleteNode(y)
        else:
            tree.root.inParse()
            print()
            tree.root.preParse()
            print()

if __name__=='__main__': main()
"
5224136,ALDS1_8_C,"from sys import stdin

class node:
    def __init__(self, x, p):
        self.k = x
        self.l = self.r = None
        self.p = p

def insert(z):
    global root
    x, y = root, None
    while x:
        y = x
        x = x.l if z < x.k else x.r
    
    if y == None:
        root = node(z, None)
    elif z < y.k:
        y.l = node(z, y)
    else:
        y.r = node(z, y)

def find(k):
    global root
    i = root
    while i:
        if k == i.k:
            return i
        i = i.l if k < i.k else i.r
    return None

def delete(k):
    global root
    
    i = find(k)
    p = i.p
    f = p.l == i
    
    if i.l == None and i.r == None:
        if f: p.l = None
        else: p.r = None
    elif i.l == None or i.r == None:
        c = i.l if i.l else i.r
        c.p = p
        if f: p.l = c
        else: p.r = c
    else:
        j = i.r
        while j.l: j = j.l
        i.k = j.k
        jp = j.p
        if j.r: j.r.p = jp
        if jp == i:
            i.r = j.r
        else:
            jp.l = j.r


def rec(i, m):
    if i == None:
        return ''
    
    c = ' ' + str(i.k)
    l, r = rec(i.l, m), rec(i.r, m)
    
    if m == 0:
        return l + c + r
    else:
        return c + l + r


input()
root = None
for l in stdin:
    if l[0] == 'i':
        insert(int(l[7:]))
    elif l[0] == 'f':
        f = find(int(l[5:]))
        print('yes' if f else 'no')
    elif l[0] == 'd':
        delete(int(l[7:]))
    else:
        for i in (0, 1): print(rec(root, i))



"
4300930,ALDS1_8_C,"# Binary Search Tree 3

import sys
sys.setrecursionlimit(10**6)


class Node():
    __slots__ = ['key', 'parent', 'left', 'right']

    def __init__(self, key=None, parent=None, left=None, right=None):
        self.key = key
        self.parent = parent
        self.left = left
        self.right = right

    def __repr__(self):
        k = str(self.key)
        p = str(self.parent.key) if self.parent else 'None'
        l = str(self.left.key) if self.left else 'None'
        r = str(self.right.key) if self.right else 'None'
        s = ""<Node %s: parent=%s, left=%s, right=%s>"" % (k, p, l, r)
        return s


class BinaryTree():
    def __init__(self, n=0):
        self.T = [Node() for _ in range(n)]
        self.root = None

    def preorder(self):
        self.preorder_key = []
        self.preorder_rec(self.root)
        print('', *(self.preorder_key))

    def preorder_rec(self, node):
        if node == None:
            return
        self.preorder_key.append(node.key)
        self.preorder_rec(node.left)
        self.preorder_rec(node.right)

    def inorder(self):
        self.inorder_key = []
        self.inorder_rec(self.root)
        print('', *(self.inorder_key))

    def inorder_rec(self, node):
        if node == None:
            return
        self.inorder_rec(node.left)
        self.inorder_key.append(node.key)
        self.inorder_rec(node.right)

    def insert(self, key):
        node = Node(key)

        y = None
        x = self.root

        while x != None:
            y = x
            if key < x.key:
                x = x.left
            else:
                x = x.right

        node.parent = y
        if y == None:
            self.root = node
        elif key < y.key:
            y.left = node
        else:
            y.right = node

    def find(self, x, key):
        while x != None and key != x.key:
            if key < x.key:
                x = x.left
            else:
                x = x.right
        return x

    def has(self, key):
        if self.find(self.root, key) != None:
            return True
        else:
            return False

    def get_successor(self, x):
        # 次節点
        if x.right != None:
            return self.get_minimum(x.right)

        y = x.parent
        while y != None and x == y.right:
            x, y = y, y.parent
        return y

    def get_minimum(self, x):
        # xを根とする部分木のうち最小のキーを持つノードを返す
        while x.left != None:
            x = x.left
        return x

    def delete(self, key):
        # 削除
        z = self.find(self.root, key)
        if z.left != None and z.right != None:
            y = self.get_successor(z)
            z.key = y.key
        else:
            y = z

        # 子xを決める
        x = y.left if y.left != None else y.right
        if x != None:
            x.parent = y.parent

        if y.parent == None:  # 根のとき
            self.root = x
        elif y == y.parent.left:
            y.parent.left = x
        else:
            y.parent.right = x


N = int(input())
S = [input() for _ in range(N)]
tree = BinaryTree()

for s in S:
    if 'print' in s:
        tree.inorder()
        tree.preorder()
    else:
        command, key = s.split()
        key = int(key)

        if 'find' in command:
            print('yes' if tree.has(key) else 'no')

        if 'delete' in command:
            tree.delete(key)

        elif 'insert' in command:
            tree.insert(key)

"
8141274,ALDS1_8_C,"import sys

class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left_child = None
        self.right_child = None

tree_root = None

def tree_insert(value):
    global tree_root
    current_node, parent_node = tree_root, None
    while current_node:
        current_node, parent_node = (current_node.left_child if value < current_node.value else current_node.right_child), current_node
    if parent_node is None:
        tree_root = TreeNode(value)
    elif value < parent_node.value:
        parent_node.left_child = TreeNode(value)
    else:
        parent_node.right_child = TreeNode(value)

def tree_find(target_value):
    result_node = tree_root
    while result_node and target_value != result_node.value:
        result_node = result_node.left_child if target_value < result_node.value else result_node.right_child
    return result_node is None

def tree_delete(target_value):
    def remove_tree_node(parent, child, new_child):
        if parent.left_child == child:
            parent.left_child = new_child
        else:
            parent.right_child = new_child
    parent, child = None, tree_root
    while child.value != target_value:
        parent, child = child, (child.left_child if target_value < child.value else child.right_child)
    if child.left_child is None:
        remove_tree_node(parent, child, child.right_child)
    elif child.right_child is None:
        remove_tree_node(parent, child, child.left_child)
    elif child.right_child.left_child is None:
        child.right_child.left_child = child.left_child
        remove_tree_node(parent, child, child.right_child)
    else:
        grandparent = child.right_child
        while grandparent.left_child.left_child:
            grandparent = grandparent.left_child
        child.value = grandparent.left_child.value
        grandparent.left_child = grandparent.left_child.right_child

def tree_inorder(node):
    return (tree_inorder(node.left_child) + f' {node.value}' + tree_inorder(node.right_child)) if node else ''

def tree_preorder(node):
    return (f' {node.value}' + tree_preorder(node.left_child) + tree_preorder(node.right_child)) if node else ''

input()
for command in sys.stdin:
    if command[0] == 'i':
        tree_insert(int(command[7:]))
    elif command[0] == 'd':
        tree_delete(int(command[7:]))
    elif command[0] == 'f':
        print(['yes', 'no'][tree_find(int(command[5:]))])
    else:
        print(tree_inorder(tree_root))
        print(tree_preorder(tree_root))

"
6833398,ALDS1_8_C,"import sys


class Node(object):
    __slots__ = ['key', 'parent', 'left', 'right']

    def __init__(self, key):
        self.key = key
        self.parent = None
        self.left = None
        self.right = None

    def children(self):
        list = []
        if self.left:
            list.append(self.left)
        if self.right:
            list.append(self.right)
        return list


def preoder(node):
    print(f' {str(node.key)}', end='')

    if node.left != None:
        preoder(node.left)
    if node.right != None:
        preoder(node.right)


def inorder(node):
    if node == None:
        return

    inorder(node.left)
    print(f' {str(node.key)}', end='')
    inorder(node.right)


def print_order():
    inorder(root_node)
    print('')
    preoder(root_node)
    print('')


def insert(z_key):
    global root_node
    x = root_node
    y = None
    z = Node(z_key)

    while x != None:
        y = x
        if z.key < x.key:
            x = x.left
        else:
            x = x.right
    z.parent = y

    if y == None:
        root_node = z
    elif z.key < y.key:
        y.left = z
    else:
        y.right = z


def find(node, z_key):
    while node != None and node.key != z_key:
        if node.key > z_key:
            node = node.left
        else:
            node = node.right
    return 'no' if node == None else 'yes'


def delete(z_key):
    global root_node

    node = root_node

    while node.key != z_key:
        if node.key > z_key:
            node = node.left
        else:
            node = node.right

    if node.left == None or node.right == None:
        delete_node = node
    else:
        delete_node = get_successor(node)

    if delete_node.left != None:
        child = delete_node.left
    else:
        child = delete_node.right

    if child != None:
        child.parent = delete_node.parent

    if delete_node.parent == None:
        root_node = child
    elif delete_node.parent.left == delete_node:
        delete_node.parent.left = child
    else:
        delete_node.parent.right = child

    if delete_node != node:
        node.key = delete_node.key


def get_successor(node):
    if node.right != None:
        return get_minimum(node.right)

    parent = node.parent
    while parent != None and parent.left != node:
        node = parent
        parent = parent.parent

    return parent


def get_minimum(node):
    while node.left != None:
        node = node.left

    return node


def main():
    global root_node

    input = sys.stdin.readline
    n = int(input())
    root_node = None

    for _ in range(n):
        line = input().split()
        if line[0] == 'insert':
            insert(int(line[1]))
        elif line[0] == 'find':
            print(find(root_node, int(line[1])))
        elif line[0] == 'delete':
            delete(int(line[1]))
        else:
            print_order()


root_node = None
main()
"
5516106,ALDS1_8_C,"import sys


class Node():
    def __init__(self, key):
        self.parent = None
        self.left = None
        self.right = None
        self.key = key


root = None


def insert(key):
    global root
    z = Node(key)
    y = Node(-1)
    x = root
    while x:
        y = x
        if z.key < x.key:
            x = x.left
        else:
            x = x.right
    z.parent = y

    if y.key == -1:
        root = z
    elif z.key < y.key:
        y.left = z
    else:
        y.right = z


def find(key):
    x = root
    while x is not None:
        if x.key == key:
            return x
        elif key < x.key:
            x = x.left
        else:
            x = x.right
    return None


def treeMinimum(x):
    while x.left != None:
        x = x.left
    return x


def treeSuccessor(x):
    if x.right != None:
        return treeMinimum(x.right)
    y = x.parent
    while y != None and x == y.right:
        x = y
        y = y.parent
    return y


def delete(z):
    if z.left == None or z.right == None:
        y = z
    else:
        y = treeSuccessor(z)

    if y.left != None:
        x = y.left
    else:
        x = y.right

    if x != None:
        x.parent = y.parent

    if y.parent == None:
        root = x
    elif y == y.parent.left:
        y.parent.left = x
    else:
        y.parent.right = x

    if y != z:
        z.key = y.key


def inorder(node):
    return inorder(node.left) + f' {node.key}' + inorder(node.right) if node else ''


def preorder(node):
    return f' {node.key}' + preorder(node.left) + preorder(node.right) if node else ''


input()
for e in sys.stdin:
    if e[0] == 'i':
        insert(int(e[7:]))
    elif e[0] == ""f"":
        ans = find(int(e[5:]))
        if ans:
            print(""yes"")
        else:
            print(""no"")
    elif e[0] == ""d"":
        delete(find(int(e[7:])))
    else:
        print(inorder(root))
        print(preorder(root))

"
4813181,ALDS1_8_C,"import bisect, collections, copy, heapq, itertools, math, string
import sys
def I(): return int(sys.stdin.readline().rstrip())
def MI(): return map(int, sys.stdin.readline().rstrip().split())
def LI(): return list(map(int, sys.stdin.readline().rstrip().split()))
def S(): return sys.stdin.readline().rstrip()
def LS(): return list(sys.stdin.readline().rstrip().split())

from collections import  defaultdict
def main():
    M = I()
    D = defaultdict()
    root = None
    def insert(D, z, id_root):
        y = None
        x = id_root
        while x != None:
            y = x
            if z < x:
                x = D[x][0]
            else:
                x = D[x][1]
        D[z][2] = y
        if y is None:
            id_root = z
        elif z < y:
            D[y][0] = z
        else:
            D[y][1] = z
        return id_root

    def find(D, z, id_root):
        x = id_root
        while x != None:
            if z == x:
                return 'yes'
            elif z < x:
                x = D[x][0]
            else:
                x = D[x][1]
        return 'no'

    def delete(D, z, id_root):
        if z == id_root:
            if D[z][0] == D[z][1] == None:
                id_root = None
                return id_root

            elif D[z][0] != None and D[z][1] == None:
                chi = D[z][0]
                D[chi][2] = None
                id_root = chi
                return id_root

            elif D[z][0] == None and D[z][1] != None:
                chi = D[z][1]
                D[chi][2] = None
                id_root = chi
                return id_root
            else:
                chi_1 = D[z][0]
                chi_2 = D[z][1]
                In = []
                InorderTreeWalk(D, In, root)
                ind = In.index(z)
                y = In[ind + 1]
                par_ = D[y][2]
                chi_3 = D[y][0]
                chi_4 = D[y][1]
                D[y][2] = None
                if chi_2 != y:
                    D[y][0] = chi_1
                    D[y][1] = chi_2
                    D[chi_1][2] = y
                    D[chi_2][2] = y
                else:
                    D[y][0] = chi_1
                    D[chi_1][2] = y

                if chi_3 == chi_4 == None:
                    if y < par_:
                        D[par_][0] = None
                    else:
                        D[par_][1] = None


                elif chi_3 != None and chi_4 == None:
                    if chi_3 < par_:
                        D[par_][0] = chi_3
                    else:
                        D[par_][1] = chi_3
                    D[chi_3][2] = par_

                elif chi_3 == None and chi_4 != None:
                    if chi_4 < par_:
                        D[par_][0] = chi_4
                    else:
                        D[par_][1] = chi_4
                    D[chi_4][2] = par_

                id_root = y
                return id_root
        else:
            par = D[z][2]
            if D[z][0] == D[z][1] == None:
                if z < par:
                    D[par][0] = None
                else:
                    D[par][1] = None

            elif D[z][0] != None and D[z][1] == None:
                chi = D[z][0]
                if chi < par:
                    D[par][0] = chi
                else:
                    D[par][1] = chi
                D[chi][2] = par

            elif D[z][0] == None and D[z][1] != None:
                chi = D[z][1]
                if chi < par:
                    D[par][0] = chi
                else:
                    D[par][1] = chi
                D[chi][2] = par
            else:
                chi_1 = D[z][0]
                chi_2 = D[z][1]
                In = []
                InorderTreeWalk(D, In, root)
                ind = In.index(z)
                y = In[ind + 1]
                par_ = D[y][2]
                chi_3 = D[y][0]
                chi_4 = D[y][1]
                if z < par:
                    D[par][0] = y
                else:
                    D[par][1] = y
                D[y][2] = par
                if chi_2 != y:
                    D[y][0] = chi_1
                    D[y][1] = chi_2
                    D[chi_1][2] = y
                    D[chi_2][2] = y
                else:
                    D[y][0] = chi_1
                    D[chi_1][2] = y

                if chi_3 == chi_4 == None:
                    if y < par_:
                        D[par_][0] = None
                    else:
                        D[par_][1] = None

                elif chi_3 != None and chi_4 == None:
                    if chi_3 < par_:
                        D[par_][0] = chi_3
                    else:
                        D[par_][1] = chi_3
                    D[chi_3][2] = par_

                elif chi_3 == None and chi_4 != None:
                    if chi_4 < par_:
                        D[par_][0] = chi_4
                    else:
                        D[par_][1] = chi_4
                    D[chi_4][2] = par_
            return id_root



    def PreorderTreeWalk(D, B, id):
        B.append(id)
        left = D[id][0]
        right = D[id][1]
        if left != None:
            PreorderTreeWalk(D, B, left)
        if right != None:
            PreorderTreeWalk(D, B, right)

    def InorderTreeWalk(D,  B, id):
        left = D[id][0]
        right = D[id][1]
        if left != None:
            InorderTreeWalk(D, B, left)
        B.append(id)
        if right != None:
            InorderTreeWalk(D, B, right)

    for i in range(M):
        ord = S()
        if ord[0] == 'i':
            z = int(ord[7:])
            #D[a] = [left, right, parent]で取得
            D[z] = [None, None,None]
            root = insert(D, z, root)
        elif ord[0] == 'f':
            z = int(ord[5:])
            print(find(D, z, root))
        elif ord[0] == 'd':
            z = int(ord[7:])
            root = delete(D, z, root)
        else:
            Ans_pre = []
            Ans_in = []
            InorderTreeWalk(D, Ans_in, root)
            PreorderTreeWalk(D, Ans_pre, root)
            print(' ' + ' '.join(map(str, Ans_in)))
            print(' ' + ' '.join(map(str, Ans_pre)))

if __name__ == ""__main__"":
    main()

"
3986069,ALDS1_8_C,"import sys
class Tree():
    def __init__(self):
        self.root = None
    def insert(self, key):
        z = Node(key)
        y = None
        x = self.root
        while x:
            y = x
            if z.key < x.key:
                x = x.left
            else:
                x = x.right
        z.parent = y
        if y == None:
            self.root = z
        elif z.key < y.key:
            y.left = z
        else:
            y.right = z
    def find(self, key):
        x = self.root
        while x and x.key != key:
            if x.key < key:
                x = x.right
            else:
                x = x.left
        return x
    def delete(self, key):
        z = self.find(key)
        y = self.successor(z) if z.left and z.right else z
        x = y.left if y.left else y.right

        if x:
            x.parent = y.parent
        if y.parent == None:
            self.root = x 
        elif y == y.parent.left:
            y.parent.left = x
        else:
            y.parent.right = x
        if y != z:
            z.key = y.key
    def successor(self, x):
        if x.right:
            return self.minimum(x.right)
        y = x.parent
        while y and x == y.right:
            x = y
            y = y.parent
        return y

    def minimum(self, x):
        while x.left:
            x = x.left
        return x
    
    def print(self):
        print('',' '.join(map(str, self.root.inwalk())))
        print('',' '.join(map(str, self.root.prewalk())))
    
class Node():
    def __init__(self, key):
        self.key = key
        self.parent = self.left = self.right = None
    def prewalk(self):
        ret = [self.key]
        if self.left:
            ret += self.left.prewalk()
        if self.right:
            ret += self.right.prewalk()
        return ret
    def inwalk(self):
        ret = []
        if self.left:
            ret += self.left.inwalk()
        ret += [self.key]
        if self.right:
            ret += self.right.inwalk()
        return ret
tree = Tree()
n = sys.stdin.readline()
for line in sys.stdin:
    if line[0] == 'i':
        tree.insert(int(line.split()[1]))
    elif line[0] == 'f':
        print('yes' if tree.find(int(line.split()[1])) else 'no')
    elif line[0] == 'd':
        tree.delete(int(line.split()[1]))            
    else:
        tree.print()

"
3225695,ALDS1_8_C,"import sys

class Node:
    parent = None
    left = None
    right = None

    def __init__(self, key):
        self.key = key

    def __repr__(self):
        return ""({},{},{},{})"".format(self.key, self.parent, self.left, self.right)

    def is_root(self):
        return self.parent is None

    def is_leaf(self):
        return self.left is None and self.right is None

    def has_one_child(self):
        if self.is_leaf():
            return False
        elif (self.left is None) and (self.right is not None):
            return self.right
        elif (self.left is not None) and (self.right is None):
            return self.left
        else:
            return False

    def has_two_child(self):
        return (self.left is not None) and (self.right is not None)


root_node_no = None

def insert(nodes :dict, in_node :Node):
    global root_node_no

    cur_node_no = root_node_no
    parent_node_no = None
    while cur_node_no is not None:
        parent_node_no = cur_node_no
        if in_node.key < cur_node_no:
            cur_node_no = nodes[cur_node_no].left
        else:
            cur_node_no = nodes[cur_node_no].right

    in_node.parent = parent_node_no

    if root_node_no is None:
        root_node_no = in_node.key
    elif in_node.key < parent_node_no:
        nodes[parent_node_no].left = in_node.key
    else:
        nodes[parent_node_no].right = in_node.key

    nodes[in_node.key] = in_node

def inorder_tree_walk(nodes, node_no ,inorder):
    if node_no is None:
        return
    inorder_tree_walk(nodes, nodes[node_no].left, inorder)
    inorder.append(node_no)
    inorder_tree_walk(nodes, nodes[node_no].right, inorder)

def preorder_tree_walk(nodes, node_no, preorder):
    if node_no is None:
        return
    preorder.append(node_no)
    preorder_tree_walk(nodes, nodes[node_no].left, preorder)
    preorder_tree_walk(nodes, nodes[node_no].right, preorder)


def find(nodes, tgt_node_no):
    cur_node_no = root_node_no
    while cur_node_no is not None:
        cur_node = nodes[cur_node_no]
        if cur_node.key == tgt_node_no:
            return True
        elif tgt_node_no < cur_node.key:
            cur_node_no = cur_node.left
        else:
            cur_node_no = cur_node.right
    return False


def switch_child_of_parent(nodes: dict, del_node: Node, switch_node_no):
    if nodes[del_node.parent].left == del_node.key:
        nodes[del_node.parent].left = switch_node_no
    elif nodes[del_node.parent].right == del_node.key:
        nodes[del_node.parent].right = switch_node_no
    return


def delete_node(nodes: dict, delete_node_no: int):
    del_node = nodes[delete_node_no]

    if del_node.is_leaf():
        # delete leaf
        switch_child_of_parent(nodes, del_node, None)
    elif not del_node.has_two_child():
        # delete one child node
        child = del_node.has_one_child()
        switch_child_of_parent(nodes, del_node, child)
        nodes[child].parent = del_node.parent
    else:
        # delete two child node
        inorder = []
        inorder_tree_walk(nodes, del_node.right, inorder)
        swap_node = Node(inorder[0])
        switch_child_of_parent(nodes, del_node, swap_node.key)

        swap_node.parent = del_node.parent
        swap_node.left = del_node.left
        if swap_node.key == del_node.right:
            swap_node.right = None
        else:
            swap_node.right = del_node.right
            nodes[swap_node.right].parent = swap_node.key
        nodes[swap_node.left].parent = swap_node.key
        delete_node(nodes, swap_node.key)
        nodes[swap_node.key] = swap_node

    del nodes[delete_node_no]
    return


def main():
    num_com = int(input())
    commands = sys.stdin.readlines()
    nodes = {}
    for i in range(num_com):
        if commands[i][0] == 'i':
            insert(nodes, Node(int(commands[i][7:])))
        elif commands[i][0] == 'p':
            # inorder
            inorder = []
            inorder_tree_walk(nodes, root_node_no, inorder)
            print("" "" + "" "".join(map(str, inorder)))
            # preorder
            preorder = []
            preorder_tree_walk(nodes, root_node_no, preorder)
            print("" "" + "" "".join(map(str, preorder)))
        elif commands[i][0] == 'f':
            if find(nodes, int(commands[i][5:])):
                print('yes')
            else:
                print('no')
        elif commands[i][0] == 'd':
            delete_node(nodes, int(commands[i][7:]))

main()
"
5426598,ALDS1_8_C,"import sys
class Tree():
    def __init__(self):
        self.root = None
    def insert(self, key):
        z = Node(key)
        y = None
        x = self.root
        while x:
            y = x
            if z.key < x.key:
                x = x.left
            else:
                x = x.right
        z.parent = y
        if y == None:
            self.root = z
        elif z.key < y.key:
            y.left = z
        else:
            y.right = z
    def find(self, key):
        x = self.root
        while x and x.key != key:
            if x.key < key:
                x = x.right
            else:
                x = x.left
        return x
    def delete(self, key):
        z = self.find(key)
        y = self.successor(z) if z.left and z.right else z
        x = y.left if y.left else y.right

        if x:
            x.parent = y.parent
        if y.parent == None:
            self.root = x 
        elif y == y.parent.left:
            y.parent.left = x
        else:
            y.parent.right = x
        if y != z:
            z.key = y.key
    def successor(self, x):
        if x.right:
            return self.minimum(x.right)
        y = x.parent
        while y and x == y.right:
            x = y
            y = y.parent
        return y

    def minimum(self, x):
        while x.left:
            x = x.left
        return x
    
    def print(self):
        print('',' '.join(map(str, self.root.inwalk())))
        print('',' '.join(map(str, self.root.prewalk())))
    
class Node():
    def __init__(self, key):
        self.key = key
        self.parent = self.left = self.right = None
    def prewalk(self):
        ret = [self.key]
        if self.left:
            ret += self.left.prewalk()
        if self.right:
            ret += self.right.prewalk()
        return ret
    def inwalk(self):
        ret = []
        if self.left:
            ret += self.left.inwalk()
        ret += [self.key]
        if self.right:
            ret += self.right.inwalk()
        return ret
tree = Tree()
n = sys.stdin.readline()
for line in sys.stdin:
    if line[0] == 'i':
        tree.insert(int(line.split()[1]))
    elif line[0] == 'f':
        print('yes' if tree.find(int(line.split()[1])) else 'no')
    elif line[0] == 'd':
        tree.delete(int(line.split()[1]))            
    else:
        tree.print()
"
3284058,ALDS1_8_C,"import sys


class Node:
    __slots__ = ['key', 'parent', 'left', 'right']

    def __init__(self, key):
        self.key = key
        self.parent = self.left = self.right = None

    def replace(self, child, new_child):
        if child is self.left:
            self.left = new_child
        else:
            self.right = new_child
        if new_child:
            new_child.parent = self

    def __str__(self):
        return f'({str(self.left or ""_"")} {self.key} {str(self.right or ""_"")})'


def insert(root, z):
    if root is None:
        return z

    y = None
    x = root
    while x is not None:
        y = x
        if z.key < x.key:
            x = x.left
        else:
            x = x.right

    z.parent = y

    if z.key < y.key:
        y.left = z
    else:
        y.right = z

    return root


def find(node, key):
    while node and node.key != key:
        if key < node.key:
            node = node.left
        elif key > node.key:
            node = node.right
    return node


def next_node(node):
    while node.left:
        node = node.left
    return node


def delete(root, key):
    node = find(root, key)
    if not node:
        return root
    if node is root:
        return None

    delete_node(node)
    return root


def delete_node(node):
    if not node.left and not node.right:
        node.parent.replace(node, None)
    elif node.left and node.right:
        next = next_node(node.right)
        node.key = next.key
        delete_node(next)
    else:  # node.left xor node.right
        node.parent.replace(node, node.left or node.right)


def inorder(node):
    if not node:
        return
    yield from inorder(node.left)
    yield node.key
    yield from inorder(node.right)


def preorder(node):
    if not node:
        return
    yield node.key
    yield from preorder(node.left)
    yield from preorder(node.right)


def print_tree(root):
    print(''.join(' ' + str(key) for key in inorder(root)))
    print(''.join(' ' + str(key) for key in preorder(root)))


root = None

n = int(sys.stdin.readline())
for _ in range(n):
    command, *args = sys.stdin.readline().split()
    if command == 'insert':
        root = insert(root, Node(int(args[0])))
    elif command == 'find':
        print('yes' if find(root, int(args[0])) else 'no')
    elif command == 'delete':
        root = delete(root, int(args[0]))
    else:
        print_tree(root)

"
5568173,ALDS1_8_C,"class Node(object):
    __slots__ = [""value"", ""parent"", ""left"", ""right""]

    def __init__(self, value: int, parent: 'Node' = None) -> None:
        self.value = value
        self.parent = parent
        self.left: Node = None
        self.right: Node = None

    def inPerse(self, a: list) -> list:
        if self.left:
            self.left.inPerse(a)
        a.append(self.value)
        if self.right:
            self.right.inPerse(a)
        return a

    def prePerse(self, a: list) -> list:
        a.append(self.value)
        if self.left:
            self.left.prePerse(a)
        if self.right:
            self.right.prePerse(a)
        return a


class BinarySearchTree(object):
    __slots__ = [""root""]

    def __init__(self) -> None:
        self.root: Node = None

    def insert(self, target: int):
        if self.root is None:
            self.root = Node(target)
            return
        parent, current = None, self.root

        while current:
            parent = current
            if target < current.value:
                current = current.left
            else:
                current = current.right

        if target < parent.value:
            parent.left = Node(target, parent)
        else:
            parent.right = Node(target, parent)

    def find(self, k: int):
        x = self.root
        while x != None and k != x.value:
            if k < x.value:
                x = x.left
            else:
                x = x.right
        return x

    def getMinimum(self, target: Node) -> Node:
        while target.left is not None:
            target = target.left
        return target

    def getSuccesser(self, target: Node):
        if target.right is not None:
            return self.getMinimum(target.right)

        parent = target.parent
        # while parent is not None and parent.right == target:
        #     target = parent
        #     parent = parent.parent
        # return parent

    def delete(self, target: Node):
        if target.left is None or target.right is None:
            temp = target
        else:
            temp = self.getSuccesser(target)

        child = None
        if temp.left is not None:
            child = temp.left
        elif temp.right is not None:
            child = temp.right

        if child is not None:
            child.parent = temp.parent

        if temp.parent == self.root:
            self.root = child
        elif temp == temp.parent.left:
            temp.parent.left = child
        elif temp == temp.parent.right:
            temp.parent.right = child

        if temp != target:
            target.value = temp.value


if __name__ == ""__main__"":
    tree = BinarySearchTree()
    for i in range(int(input())):
        order = input()
        if order == ""print"":
            inp = tree.root.inPerse([])
            print("""", *inp)
            prp = tree.root.prePerse([])
            print("""", *prp)
        elif order.startswith(""find""):
            _, target = order.split()
            target = int(target)
            if tree.find(target) is not None:
                print(""yes"")
            else:
                print(""no"")
        elif order.startswith(""insert""):
            _, target = order.split()
            target = int(target)
            tree.insert(target)
        elif order.startswith(""delete""):
            _, target = order.split()
            target = int(target)
            tree.delete(tree.find(target))

"
6861643,ALDS1_8_C,"import sys
sys.setrecursionlimit(10 ** 7)


def insert(k):
    global root, tree, in_tree
    in_tree[k] = True
    
    y = None
    x = root
    
    while x != None:
        y = x
        if k < x:
            x = tree[x][1]
        
        else:
            x = tree[x][2]
    
    tree[k] = [y, None, None]
    
    if y == None:
        root = k
    elif k < y:
        tree[y][1] = k
    else:
        tree[y][2] = k

def find(k):
    return k in in_tree and in_tree[k]

def find_next(k):
    res = tree[k][2]
    while tree[res][1] != None:
        res = tree[res][1]
    
    return res

def delete(k):
    global root, tree, in_tree
    if find(k):
        in_tree[k] = False
        p, cL, cR = tree[k]
        
        if cL == cR == None:
            if root == k:
                root = None
                tree[k][0] = None
            else:
                tree[p][tree[p].index(k)] = None
                tree[k][0] = None
        
        elif cL == None or cR == None:
            if cL == None:
                c = cR
            else:
                c = cL
            
            if root == k:
                root = c
                tree[c][0] = None
                tree[k] = [None, None, None]
                
            else:
                tree[p][tree[p].index(k)] = c
                tree[c][0] = p
                tree[k] = [None, None, None]
        
        else:
            y = find_next(k)
            delete(y)
            in_tree[y] = True
            
            if root == k:
                root = y
            else:
                tree[p][tree[p].index(k)] = y
            
            cR = tree[k][2]
            
            tree[y] = [p, cL, cR]
            tree[cL][0] = y
            
            if cR != None:
                tree[cR][0] = y
            
            tree[k] = [None, None, None]
            
def tree_walk(now):
    global PTW, ITW
    if now != None:
        PTW.append(now)
        
        tree_walk(tree[now][1])
        
        ITW.append(now)
        
        tree_walk(tree[now][2])


m = int(input())
root = None
tree = dict()
in_tree = dict()

for _ in range(m):
    com, *arg = input().split()
    if com == ""insert"":
        insert(int(arg[0]))
    
    elif com == ""find"":
        if find(int(arg[0])):
            print(""yes"")
        else:
            print(""no"")
    
    elif com == ""delete"":
        delete(int(arg[0]))
    
    else:
        ITW = []
        PTW = []
        
        tree_walk(root)
        
        print("""", *ITW)
        print("""", *PTW)
    
"
4875949,ALDS1_8_C,"class Node:
    def __init__(self, key):
        self.key = key
        self.parent = None
        self.left_child = None
        self.right_child = None

class BSTree: # Binary Search Tree
    def __init__(self, init_list):
        self.root = None
        for ii in init_list:
            self.insert(ii)
    
    def insert(self, z_key):
        y = None # parent of x
        x = self.root
        z = Node(z_key)
        while x!=None:
            y = x # set parent
            if z.key < x.key:
                x = x.left_child
            else:
                x = x.right_child
        z.parent = y
        if y == None: # no root exists
            self.root = z
        elif z.key < y.key:
            y.left_child = z
        else:
            y.right_child = z
        return

    def deleteNode(self, z_key):
        z=find(temp_tree.root,z_key)
        if z.left_child==None or z.right_child==None:
            y=z
        else:
            y=getSuccessor(z)
        
        if y.left_child!=None:
            x=y.left_child
        else:
            x=y.right_child
        
        if x!=None:
            x.parent=y.parent
            
        if y.parent==None:
            self.root=x
        elif y==y.parent.left_child:
            y.parent.left_child=x
        else:
            y.parent.right_child=x
        
        if y!=z:
            z.key=y.key
            
        return
    
def getSuccessor(x):
    if x.right_child != None:
        return(getMinimum(x.right_child))
    
    y=x.parent
    while y!=None and x==y.right_child:
        x=y
        y=y.parent
        
    return y

def getMinimum(x):
    while x.left_child!=None:
        x=x.left_child
    return x
        
def find(x, k):
    while x!=None and k!=x.key:
        if k<x.key:
            x=x.left_child
        else:
            x=x.right_child
    return x

def preParse(u,ss):
    if u==None:
        return
    ss.append(u.key)
    preParse(u.left_child,ss)
    preParse(u.right_child,ss)
    return
    
def inParse(u,ss):
    if u==None:
        return
    inParse(u.left_child,ss)
    ss.append(u.key)
    inParse(u.right_child,ss)
    return
""""""    
def postParse(u,ss):
    if u==None:
        return
    postParse(u.left_child,ss)
    postParse(u.right_child,ss)
    ss.append(u.key)
    return
""""""
import sys
input = sys.stdin.readline # for speed up
#sys.setrecursionlimit(10**9)

n=int(input())

temp_tree = BSTree([])
for ii in range(n):
    a=input().split()
    if a[0]==""insert"":
        temp_tree.insert(int(a[1]))
    elif a[0]==""print"":
        #print(""Inorder"")
        ss=[]
        inParse(temp_tree.root,ss)
        print("""","" "".join([str(sss) for sss in ss]))
        #print(""Preorder"")
        ss=[]
        preParse(temp_tree.root,ss)
        print("""","" "".join([str(sss) for sss in ss]))
    elif a[0]==""find"":
        if find(temp_tree.root,int(a[1])):
            print(""yes"")
        else:
            print(""no"")
    elif a[0]==""delete"":
        temp_tree.deleteNode(int(a[1]))
""""""
import bisect
t=[]
for ii in range(n):
    a=input().split()
    if a[0]==""insert"":
        #jj=bisect.bisect(t,int(a[1]))
        bisect.insort(t,int(a[1]))
    elif a[0]==""print"":
        # inorder
        print("" "".join([str(jj) for jj in t]))
""""""
"
6221936,ALDS1_8_C,"from sys import stdin

class Node():
  def __init__(self,key=None,left=None,right=None):
    # ノード自身の値
    self.key=key
    self.left=left
    self.right=right

root=None

def insert(key):
  global root

  if root:
    ch=root
    while ch is not None:
      pa,ch=ch,ch.left if key<ch.key else ch.right
    if key<pa.key:
      pa.left=Node(key)
    else:
      pa.right=Node(key)
  elif not root:
    root=Node(key)

def find(key):
  global root

  if root:
    ch=root
    while ch is not None:
      if key<ch.key:
        pa,ch=ch,ch.left
      elif key>ch.key:
        pa,ch=ch,ch.right
      else:
          return True
  return False

def delete(key):
  global root
  pa,node=None,root
  while node.key!=key:
    pa,node=node,node.left if key<node.key else node.right
  if node.left and node.right:
    pa,to_del=node,node.right
    while to_del.left:
      pa,to_del=to_del,to_del.left
    node.key=to_del.key
  else:
    to_del=node
  ch=to_del.left or to_del.right
  if not pa:
    root=ch
  elif pa.left==to_del:
    pa.left=ch
  else:
    pa.right=ch

pre_l=[]
def pre_parse(node):
  global pre_l

  if node is None:
    return
  
  pre_l.append(node.key)
  pre_parse(node.left)
  pre_parse(node.right)

in_l=[]
def in_parse(node):
  global in_l

  if node is None:
    return
  
  in_parse(node.left)
  in_l.append(node.key)
  in_parse(node.right)

n=int(input())
key=0
for i in range(n):
  input_=stdin.readline()
  try:
    st,key=input_.split()
  except:
    st=input_
  key=int(key)
  if st==""insert"":
    insert(key)
  elif st==""find"":
    print(""yes"" if find(key) else ""no"")
  elif st==""delete"":
    delete(key)
  else:
    pre_parse(root)
    in_parse(root)
    print("""",*in_l)
    print("""",*pre_l)
    in_l=[]
    pre_l=[]

"
7443341,ALDS1_8_C,"class Node:
    __slots__ = (""parent"", ""left"", ""right"", ""key"")

    def __init__(self, key):
        self.key = key
        self.parent = None
        self.left = None
        self.right = None


ROOT = Node(2_000_000_010)


def insert(key):
    global ROOT

    node = Node(key)
    parent = ROOT
    cur = ROOT.left

    while cur:
        parent = cur
        if key < parent.key:
            cur = parent.left
        else:
            cur = parent.right

    node.parent = parent
    if key < parent.key:
        parent.left = node
    else:
        parent.right = node


def find(key):
    global ROOT
    cur = ROOT

    while cur:
        if key < cur.key:
            cur = cur.left
        elif key == cur.key:
            print(""yes"")
            return
        else:
            cur = cur.right
    print(""no"")


def delete(key):
    global ROOT
    cur = ROOT

    while cur.key != key:
        if key < cur.key:
            cur = cur.left
        else:
            cur = cur.right

    if cur.left and cur.right:
        suc = cur.right
        while suc.left:
            suc = suc.left
        cur.key = suc.key
        cur = suc

    child = cur.left
    if cur.right:
        child = cur.right

    if child:
        child.parent = cur.parent
    if cur.parent.left is cur:
        cur.parent.left = child
    else:
        cur.parent.right = child


def display():
    global ROOT

    inorder = []
    bcl = [ROOT]
    while bcl:
        node = bcl.pop()
        if node is None:
            continue

        if isinstance(node, int):
            inorder.append(node)
        else:
            bcl.append(node.right)
            bcl.append(node.key)
            bcl.append(node.left)

    print("" "" + "" "".join(map(str, inorder[:-1])))

    preorder = []
    bcl = [ROOT]
    while bcl:
        node = bcl.pop()
        if node is None:
            continue

        preorder.append(node.key)
        bcl.append(node.right)
        bcl.append(node.left)

    print("" "" + "" "".join(map(str, preorder[1:])))


if __name__ == ""__main__"":
    n = int(input())

    for _ in range(n):
        line = input()

        if line == ""print"":
            display()
        elif line.startswith(""insert""):
            key = int(line.split()[1])
            insert(key)
        elif line.startswith(""find""):
            key = int(line.split()[1])
            find(key)
        elif line.startswith(""delete""):
            key = int(line.split()[1])
            delete(key)

"
7519825,ALDS1_8_C,"def insert(k):
    global root, tree, in_tree
    in_tree[k] = True
    
    y = None
    x = root
    
    while x != None:
        y = x
        if k < x:
            x = tree[x][1]
        
        else:
            x = tree[x][2]
    
    tree[k] = [y, None, None]
    
    if y == None:
        root = k
    elif k < y:
        tree[y][1] = k
    else:
        tree[y][2] = k

def find(k):
    return k in in_tree and in_tree[k]

def find_next(k):
    res = tree[k][2]
    while tree[res][1] != None:
        res = tree[res][1]
    
    return res

def delete(k):
    global root, tree, in_tree
    if find(k):
        in_tree[k] = False
        p, cL, cR = tree[k]
        
        if cL == cR == None:
            if root == k:
                root = None
                tree[k][0] = None
            else:
                tree[p][tree[p].index(k)] = None
                tree[k][0] = None
        
        elif cL == None or cR == None:
            if cL == None:
                c = cR
            else:
                c = cL
            
            if root == k:
                root = c
                tree[c][0] = None
                tree[k] = [None, None, None]
                
            else:
                tree[p][tree[p].index(k)] = c
                tree[c][0] = p
                tree[k] = [None, None, None]
        
        else:
            y = find_next(k)
            delete(y)
            in_tree[y] = True
            
            if root == k:
                root = y
            else:
                tree[p][tree[p].index(k)] = y
            
            cR = tree[k][2]
            
            tree[y] = [p, cL, cR]
            tree[cL][0] = y
            
            if cR != None:
                tree[cR][0] = y
            
            tree[k] = [None, None, None]
            
def tree_walk(now):
    global PTW, ITW
    if now != None:
        PTW.append(now)
        
        tree_walk(tree[now][1])
        
        ITW.append(now)
        
        tree_walk(tree[now][2])


m = int(input())
root = None
tree = dict()
in_tree = dict()

for _ in range(m):
    com, *arg = input().split()
    if com == ""insert"":
        insert(int(arg[0]))
    
    elif com == ""find"":
        if find(int(arg[0])):
            print(""yes"")
        else:
            print(""no"")
    
    elif com == ""delete"":
        delete(int(arg[0]))
    
    else:
        ITW = []
        PTW = []
        
        tree_walk(root)
        
        print("""", *ITW)
        print("""", *PTW)
    

"
2914507,ALDS1_8_C,"class NullNode():
    def __init__(self):
        self.id = None

null_node = NullNode()
class Node():
    def __init__(self, id):
        global null_node
        self.id = id
        self.parent = null_node
        self.left = null_node
        self.right =  null_node

def preorder(node, out_list=[]):
    if node.id is not None:
        out_list.append(str(node.id))
        out_list = preorder(node.left, out_list)
        out_list = preorder(node.right, out_list)
    return out_list

def inorder(node, out_list=[]):
    if node.id is not None:
        out_list = inorder(node.left, out_list)
        out_list.append(str(node.id))
        out_list = inorder(node.right, out_list)
    return out_list

def insert(node, root_node):
    temp_node_parent = root_node.parent
    temp_node = root_node

    while temp_node.id is not None:
        temp_node_parent = temp_node
        if node.id < temp_node.id:
            temp_node = temp_node.left
        else:
            temp_node = temp_node.right

    node.parent = temp_node_parent
    if node.id < temp_node_parent.id:
        temp_node_parent.left = node
    else:
        temp_node_parent.right = node

def find(id,root_node):
    node = root_node
    while node.id is not None:
        if id < node.id:
            node = node.left
        elif id > node.id:
            node = node.right
        else:
            print('yes')
            break
    else:
        print('no')

def get_successor(node):
    successor = node.right
    while(successor.left.id is not None):
        successor = successor.left
    return successor

def delete(id, root_node):
    global null_node
    node = root_node
    while node.id != id:
        if id < node.id:
            node = node.left
        else:
            node = node.right

    if node.left.id is None or node.right.id is None:
        del_node = node

    else:
        del_node = get_successor(node)
        node.id = del_node.id

    if del_node.left.id is not None:
        change_node = del_node.left
    else:
        change_node = del_node.right

    if change_node.id is not None:
        change_node.parent = del_node.parent

    if del_node.parent.id is None:
        root_node = change_node
    elif del_node.id == del_node.parent.left.id:
        del_node.parent.left = change_node
    else:
        del_node.parent.right = change_node




import sys

n = int(sys.stdin.readline())
input_lines = sys.stdin.readlines()
root_node = NullNode()
for i in range(n):
    input_line = input_lines[i].split()
    command = input_line[0]
    if command == 'insert':
        id = int(input_line[1])
        id_node = Node(id)
        if root_node.id is None:
            root_node = id_node
        else:
            insert(id_node, root_node)

    elif command == 'find':
        id = int(input_line[1])
        find(id, root_node)

    elif command == 'delete':
        id = int(input_line[1])
        delete(id, root_node)
    else:
        inorder_list = inorder(root_node, [])
        preorder_list = preorder(root_node, [])
        out = ' ' + ' '.join(inorder_list)
        print(out)
        out = ' ' + ' '.join(preorder_list)
        print(out)

"
4560578,ALDS1_8_C,"import sys, collections
input = lambda: sys.stdin.readline().rstrip() 
sys.setrecursionlimit(10**7)
INF = 10**10
def I(): return int(input())
def F(): return float(input())
def SS(): return input()
def LI(): return [int(x) for x in input().split()]
def LI_(): return [int(x)-1 for x in input().split()]
def LF(): return [float(x) for x in input().split()]
def LSS(): return input().split()

class Node():
    key = None
    p = None
    left = None
    right = None

    def __init__(self, key):
        self.key = key

class BinarySearchTree():
    root = None

    def insert(self, z):
        y = None
        x = self.root
        while x is not None:
            y = x
            if z.key < x.key:
                x = x.left
            else:
                x = x.right
        
        z.p = y

        if y is None:
            self.root = z
        elif z.key < y.key:
            y.left = z
        else:
            y.right = z

    def find(self, k):
        x = self.root
        while x is not None:
            if x.key==k:
                return x
            elif x.key>k:
                x = x.left
            else:
                x = x.right
        return None

    def next_node(self, z):
        if z.right is None:
            x = z
            y = z.p
            while y is not None and y.left!=x:
                x = y
                y = y.p
            # print(z.key, y.key)
            return y
        else:
            x = z.right
            while x is not None:
                y = x
                x = x.left
            return y

    def delete(self, k):
        z = self.find(k)
        if z.left is None and z.right is None:
            if z.p.key > z.key:
                z.p.left = None
            else:
                z.p.right = None
        elif z.left is not None and z.right is not None:
            y = self.next_node(z)
            tmp = y.key
            self.delete(y.key)
            z.key = tmp
        else:
            if z.right is None:
                z_child = z.left
            else:
                z_child = z.right
            z_child.p = z.p
            if z.p.key > z.key:
                z.p.left = z_child
            else:
                z.p.right = z_child
            
    def print_nodes(self):
        inorder = []
        preorder = []

        def dfs(v):
            v_key = v.key
            preorder.append(v_key)
            if v.left is not None:
                dfs(v.left)
            inorder.append(v_key)
            if v.right is not None:
                dfs(v.right)

        dfs(self.root)

        print('', *inorder)
        print('', *preorder)

def resolve():
    m = I()
    T = BinarySearchTree()
    for _ in range(m):
        q = LSS()
        if q[0]=='insert':
            k = int(q[1])
            z = Node(k)
            T.insert(z)
        elif q[0]=='find':
            k = int(q[1])
            if T.find(k):
                print('yes')
            else:
                print('no')
        elif q[0]=='delete':
            k = int(q[1])
            T.delete(k)
        else:
            T.print_nodes()
    # print(T.next_node(T.find(1)).key)
    # print(T.next_node(T.find(2)).key)
    # print(T.next_node(T.find(3)).key)
    # print(T.next_node(T.find(7)).key)
    # print(T.next_node(T.find(8)).key)
    # print(T.next_node(T.find(22)).key)

if __name__ == '__main__':
    resolve()

"
5462684,ALDS1_8_C,"#1_8_A 二分探索木１
#1_8_B 二分探索木2
#1_8_C 二分探索木3

from sys import stdin

class Node():
    def __init__(self,key=None,left=None,right=None):
        #そのノード自身の値！！！
        self.key=key
        self.left=left
        self.right=right

######↓rootはたった一つh￥なのでグローバル変数で良い！！！
root=None
#####↓今回は、Nodeクラスにkeyを保持するので、tree辞書はいらない！！！
tree={} 

#↓1_8_A 二分探索木１
def insert(key):
    global root

    if root:
        ch=root
        while ch is not None:
            pa,ch=ch,ch.left if key<ch.key else ch.right
        if key<pa.key:
            pa.left=Node(key)
        else:
            pa.right=Node(key)

    #↓rootがNoneだった場合（最初だけ）
    elif not root:
        root=Node(key)

def find(key):
    global root

    ch=root
    out=""no""
    while ch is not None:
        if key==ch.key:
            out=""yes""
            break
    #########↓これだとinvalid syntax!!!
        #pa,ch=ch,ch.left if key<ch.key else ch.right if key>ch.key
        #pa,ch=ch,ch.left if key<ch.key else ch.right if key>ch.key else pass
        elif key<ch.key:
            pa,ch=ch,ch.left
        else:
            pa,ch=ch,ch.right
    
    print(out)

#↓複雑！！！
def delete(key):
    global root

    pa,node=None,root
########↓二分木を探索して、目的のキーのところまで移動する。(nodeは現在のノード)
    while node.key!=key:
    ######↓pa,nodeはあくまでもNode()クラスのインスタンスなので、.keyを与えてはいけない！！！
        #pa,node=node.key,node.left if key<node.key else node.right
        pa,node=node,node.left if key<node.key else node.right
##########↓現在いるノードが二つの子ノードを持っているとき(この時の処理が一番複雑！！！)
    if node.right and node.left:
    ######↓目的のノードが二つの子ノードを持っている場合は、左部分木の最大のノードと置換する！！！
        #####↓nodeは現在のノードとして保持しておきたいのでnoedではなく、to_delとして考える！！！
        ####↓この時のpaはあくまでも消去するto_delの親!!!paは現在のノードの親ではないことに要注意！！！
        #pa,node=node,node.left
        pa,to_del=node,node.left
    #####↓なぜか、このループ条件にしても、うまくいく　よくわからない、、、、、、
        while node.right is not None:
        #while to_del.right:
            #####↓nodeは現在のノードとして保持しておきたいのでnoedではなく、to_delとして考える！！！
            #pa,node=node,node.right
            #pa,to_del=node,node.right
            pa,to_del=to_del,to_del.right
        node.key=to_del.key
    
    else:
        to_del=node
######↑to_delは子ノードが高々１個であるノードとして保持している！！！(後で削除しないといけない！！)
#####↓to_delはleftかrightどちらかしかないか、どっちもない。なのでchにはどちらかある方が代入される！！！
    ch=to_del.left or to_del.right
######↓paはto_del(削除するノード)の親ノード！！！ chはto_delの子ノード！！！
    if pa is None:
        root=ch
    elif pa.left==to_del:
        pa.left=ch
    #elif pa.right==to_del:
    else:
        pa.right=ch

####↓参考にしたコード！！！
def delete_(key):
  global root
  pa, node = None, root
  while node.key != key:
    pa, node = node, node.left if key < node.key else node.right
  if node.left and node.right:
    pa, to_del = node, node.right
    while to_del.left:
      pa, to_del = to_del, to_del.left
    node.key = to_del.key
  else:
    to_del = node
  ch = to_del.left or to_del.right
  if not pa:
    root = ch
  elif pa.left == to_del:
    pa.left = ch
  else:
    pa.right = ch

pre_l=[]
def pre_parse(node):
    global pre_l

    if node is None:
        return
    
    pre_l.append(node.key)
    pre_parse(node.left)
    pre_parse(node.right)

in_l=[]
def in_parse(node):
    global in_l

    if node is None:
        return
    
    in_parse(node.left)
    in_l.append(node.key)
    in_parse(node.right)


n=int(input())
key=0
for i in range(n):
    #st,key=stdin.readline().split()
    input_=stdin.readline()
    try:
        st,key=input_.split()
    except:
        st=input_
    key=int(key)
    if st==""insert"":
        insert(key)
    elif st==""find"":
        find(key)
    elif st==""delete"":
        delete_(key)
    else:
        pre_parse(root)
        in_parse(root)
        print("""",*in_l)
        print("""",*pre_l)
    ######↓printする毎にlist初期化していかないといけない！！！
        in_l=[]
        pre_l=[]
"
3204489,ALDS1_8_C,"import sys, os
from io import StringIO

class BinaryTree:

    class Node:
        def __init__(self, key):
            self.key = key
            self.left = None
            self.right = None
            self.parent = None


    def __init__(self):
        self.root = None
        self.output = StringIO()

    def insert(self, key):
        if self.root is None:
            self.root = self.Node(key)
        else:
            root = self.root
            temp = None
            while True:
                temp = root
                if key > root.key:
                    root = root.right
                    if root is None:
                        temp.right = self.Node(key)
                        n = temp.right
                        n.parent = temp
                        break
                else:
                    root = root.left
                    if root is None:
                        temp.left = self.Node(key)
                        n = temp.left
                        n.parent = temp
                        break

    def ini_print_inorder(self):
        self.output = StringIO()
        self.print_inorder(self.root)
        return self.output.getvalue()

    def ini_print_preorder(self):
        self.output = StringIO()
        self.print_preorder(self.root)
        return self.output.getvalue()

    def print_inorder(self, node):
        if node is not None:
            self.print_inorder(node.left)
            print(node.key, end = "" "", file = self.output)
            self.print_inorder(node.right)

    def print_preorder(self, node):
        if node is not None:
            print(node.key, end = "" "", file = self.output)
            self.print_preorder(node.left)
            self.print_preorder(node.right)

    def test_insert(self, keys):
        for k in keys:
            self.insert(k)

    def ini_find(self, key):
        print(self.find(key))

    def find(self, key):
        root = self.root
        while root is not None:
            if key == root.key:
                return ""yes""
            elif key < root.key:
                root = root.left
            else:
                root = root.right
        return ""no""

    def get_successor(self, node):
        parent = node
        while True:
            node = node.left
            if node is None:
                return parent, parent.parent
            parent = node
        return None

    def delete(self, key):
        root = self.root
        temp = root
        act = """"
        while root is not None:
            if key == root.key:
                # print(root.key, root.left, root.right, root.parent)
                rest = None
                new_leaf = None
                if root.left is None:
                    new_leaf = root.right
                elif root.right is None:
                    new_leaf = root.left
                else:
                    new_leaf, new_leaf_parent = self.get_successor(root.right)
                    rest = 1
                    rest_left = root.left
                    rest_right = root.right
                    if new_leaf == rest_right:
                        rest_right = None
                    # print(rest_left.key, new_leaf.key, new_leaf_parent.key)
                if act != """":
                    setattr(temp, act, new_leaf)
                    # print(new_leaf)
                    if new_leaf is not None:
                        new_node = getattr(temp, act)
                        setattr(new_node, ""parent"", temp)
                        # print(act, temp.key, key, new_leaf.key, new_node.parent.key)
                else:
                    self.root = new_leaf
                if rest is not None:
                    temp = getattr(temp, act)
                    if rest_right is not None:
                        setattr(temp, ""right"", rest_right)
                        setattr(rest_right, ""parent"", temp)
                    setattr(temp, ""left"", rest_left)
                    setattr(rest_left, ""parent"", temp)
                    setattr(new_leaf_parent, ""left"", None)
                    # print(""00"", temp.key, new_leaf.key, new_leaf.parent.key, new_leaf_parent.key)
                return
            else:
                temp = root
                if key < root.key:
                    root = root.left
                    act = ""left""
                else:
                    root = root.right
                    act = ""right""

b = BinaryTree()
length = int(input())
for comm in sys.stdin:
    if comm[0] == ""i"":
        com, num = comm.split("" "")
        b.insert(int(num))
    elif comm[0] == ""p"":
        print("" "", end = """")
        print((b.ini_print_inorder())[:-1])
        print("" "", end = """")
        print(b.ini_print_preorder()[:-1])
    elif comm[0] == ""f"":
        com, num = comm.split("" "")
        b.ini_find(int(num))
    else:
        com, num = comm.split("" "")
        b.delete(int(num))
"
5914349,ALDS1_8_C,"# ALDS1_8_C
# dic: Node{値:[左の値,右の値]}
def Inorder(N):
    if N == 'NIL' : return []
    A = []
    A += Inorder(Node[N][0])
    A += [N]
    A += Inorder(Node[N][1])
    return A

def Preorder(N):
    if N == 'NIL' : return []
    A = []
    A += [N]
    A += Preorder(Node[N][0])
    A += Preorder(Node[N][1])
    return A

def insert(Node,z):
    parent = 0
    x = root
    while x != 'NIL' :
        if z < x :
            parent = x
            x = Node[x][0]
            LR = 0
        else : 
            parent = x
            x = Node[x][1]
            LR = 1
    Node[parent][LR] = z
    Node[z] = ['NIL','NIL']

def delete(Node,z):
    parent = 0
    x = root
    while x != z :
        if z < x :
            parent = x
            x = Node[x][0]
            LR = 0
        else : 
            parent = x
            x = Node[x][1]
            LR = 1
    if Node[z] == ['NIL','NIL'] : 
        Node[parent][LR] = 'NIL'
        Node.pop(z)
    elif Node[z][0] == 'NIL' : 
        Node[parent][LR] = Node[z][1]
        Node.pop(z)
    elif Node[z][1] == 'NIL' :
        Node[parent][LR] = Node[z][0]
        Node.pop(z)
    else :
        z_parent = parent
        parent = z
        parent2 = z
        x = Node[z][1]
        while x != 'NIL' :
            parent2 = parent
            parent = x
            x = Node[x][0]
        delete(Node,parent)
        Node[z_parent][LR] = parent
        Node[parent] = Node[z]
        Node.pop(z)

n = int(input())
Node = {}
root = 'NIL'
# XX = list(input().split()) ##
# y = [] ##
# for i in range(len(XX)) : ##
#     if XX[i] == 'insert' : y.append([XX[i],XX[i+1]])
#     elif XX[i] == 'find' : y.append([XX[i],XX[i+1]])
#     elif XX[i] == 'print' : y.append([XX[i]])
#     elif XX[i] == 'delete' : y.append([XX[i],XX[i+1]])

for _ in range(n) :
    x = list(input().split()) #
    # x = y[_] ##
    if x[0] == 'insert' :
        if root == 'NIL' : root = int(x[1]) ; Node[root] = ['NIL','NIL'] ; continue
        insert(Node,int(x[1]))
    elif x[0] == 'find' :
        if int(x[1]) in Node : print('yes')
        else : print('no')
    elif x[0] == 'print' :
        print('',*Inorder(root))
        print('',*Preorder(root))
    elif x[0] == 'delete' :
        delete(Node,int(x[1]))
"
7629070,ALDS1_8_C,"import sys
import os

class Node:
    def __init__(self, v):
        self.parent = None
        self.left = None
        self.right = None
        self.key = v

class Tree:
    def __init__(self):
        self.root = None

    def insert2(self, node):
        y = None
        x = self.root
        while x:
            y = x
            if node.key < x.key:
                x = x.left
            else:
                x = x.right

        node.parent = y
        if y == None:
            self.root = node
        elif node.key < y.key:
            y.left = node
        else:
            y.right = node
            
    def tree_walk2(self, node):
        preorder.append(node.key)
        if node.left != None:
            self.tree_walk2(node.left)
        inorder.append(node.key)
        if node.right != None:
            
            self.tree_walk2(node.right)
        # postorder.append(node.key)

        
    def find(self,node,t):
        if not node:
            return node
        if node.key==t:
            return node
        if node.key<t:
            return self.find(node.right,t)
        else:
            return self.find(node.left,t)
                                      
    def deletenode(self,node):    
        if node.left==None or node.right==None:
            replace_node=node.left if node.left!=None else node.right
            if node.parent.left==node:
                node.parent.left=replace_node
            else:
                node.parent.right=replace_node
            if replace_node:
                replace_node.parent=node.parent
            return
        node_next=node.right
        while(node_next.left):
            node_next=node_next.left
        node.key=node_next.key
        self.deletenode(node_next)

fn = ""inputdata.txt""
if os.path.exists(fn):
    sys.stdin = open(fn)
n = int(sys.stdin.readline())

root = None
tree = Tree()
for _ in range(n):
    cmd = sys.stdin.readline().split()
    if cmd[0] == ""insert"":
        node = Node(int(cmd[1]))
        tree.insert2(node)
    if cmd[0]==""find"":
        if tree.find(tree.root,int(cmd[1])):
            print(""yes"")
        else:
            print(""no"")
    if cmd[0]==""delete"":
        node=tree.find(tree.root,int(cmd[1]))
        if node:
            tree.deletenode(node)
    if cmd[0] == ""print"":
        preorder = []
        inorder = []
        # postorder = []
        results = [
            (""Inorder"", inorder),
            (""Preorder"", preorder),
        ]
        tree.tree_walk2(tree.root)
        for name, result in results:
            print(end="" "")
            print(*result)
"
6990237,ALDS1_8_C,"class Node:
    def __init__(self, val):
        self.val = val
        self.parent = None
        self.left = None
        self.right = None 
        
    
    
class BST:
    def __init__(self):
        self.root = None
        
    
    def insert(self, node):
        parent = None
        ptr = self.root 
        while ptr is not None:
            parent = ptr
            if node.val < ptr.val:
                ptr = ptr.left 
            else:
                ptr = ptr.right
                
        node.parent = parent 
        if parent is None:
            self.root = node 
        elif node.val < parent.val:
            parent.left = node
        else:
            parent.right = node
            
            
    def delete(self, node):
        if node.left is None:
            self.transplant(node, node.right)
        elif node.right is None:
            self.transplant(node, node.left)
        else:
            y = self.search_min(node.right)
            if y.parent != node:
                self.transplant(y, y.right)
                y.right = node.right
                y.right.parent = y
            self.transplant(node, y)
            y.left = node.left
            y.left.parent = y
    
    
    def transplant(self, u, v): #node uを削除し、uの位置にnode vを移動する。
        if u.parent is None:
            self.root = v
        elif u.parent.left == u:
            u.parent.left = v
        else:
            u.parent.right = v
        
        if v is not None:
            v.parent = u.parent 
           
            
    def search(self, node, key): #nodeを根とする部分木にkeyがあるかを検索。
        if node is None or node.val == key:
            return node 
        elif key < node.val:
            return self.search(node.left, key)
        else:
            return self.search(node.right, key)
        
        
    def search_min(self, node):
        while node.left is not None:
            node = node.left 
        return node 
    
    
    def walk(self, r=None, Pre=None, In=None, Post=None):
        if r is None:
            r = self.root 
        if Pre is None:
            Pre = []
        if In is None:
            In = []
        if Post is None:
            Post = []
            
        Pre.append(r.val)
        if r.left is not None:
            self.walk(r.left, Pre, In)
        In.append(r.val)
        if r.right is not None:
            self.walk(r.right, Pre, In)
        Post.append(r.val)
        return Pre, In, Post
        
    

from sys import stdin 
input = stdin.readline 

n = int(input())
T = BST()

for _ in range(n):
    query = input().split()
    if query[0] == 'insert':
        key = int(query[1])
        T.insert(Node(key))
    elif query[0] == 'find':
        key = int(query[1])
        res = T.search(T.root, key)
        if res is None:
            print('no')
        else:
            print('yes')  
    elif query[0] == 'delete':
        key = int(query[1])
        res = T.search(T.root, key)
        if res is not None:
            T.delete(res)
    else:
        Pre, In, Post = T.walk()
        print('', *In)
        print('', *Pre)
"
6753535,ALDS1_8_C,"from typing import Optional
import sys
sys.setrecursionlimit(10 ** 6)
input = sys.stdin.readline


class TreeNode:
    def __init__(self, key=0, left=None, right=None):
        self.key = key
        self.left = left
        self.right = right


class BinarySearchTree:
    def __init__(self):
        self.root = None

    def insert(self, key: int):
        z = TreeNode(key)
        y = None
        x = self.root
        while x:
            y = x
            if z.key < x.key:
                x = x.left
            else:
                x = x.right
        z.parent = y
        if y is None:
            self.root = z
        elif z.key < y.key:
            y.left = z
        else:
            y.right = z

    def find(self, key: int):
        x = self.root
        while x:
            if x.key == key:
                return x
            if key < x.key:
                x = x.left
            else:
                x = x.right
        return None

    def delete(self, key: int):
        node = self.find(key)
        if node is None:
            return
        parent_node = node.parent
        # have no child: leaf node
        if node.left is None and node.right is None:
            if node is self.root:
                self.root = None
                return
            if node is parent_node.left:
                parent_node.left = None
            else:
                parent_node.right = None

        # have one child
        if (node.left is None and node.right is not None) or (node.left is not None and node.right is None):
            if node.left is None:
                if node is self.root:
                    self.root.right.parent = None
                    self.root = self.root.right
                    return
                if node is parent_node.left:
                    parent_node.left = node.right
                else:
                    parent_node.right = node.right
                node.right.parent = node.parent
            else:
                if node is self.root:
                    self.root.left.parent = None
                    self.root = self.root.left
                    return
                if node is parent_node.left:
                    parent_node.left = node.left
                else:
                    parent_node.right = node.left
                node.left.parent = node.parent

        # have two child
        if node.left is not None and node.right is not None:
            # get successor
            successor = node.right
            while successor.left is not None:
                successor = successor.left
            # key swap
            node.key, successor.key = successor.key, node.key
            # delete successor node
            parent_successor = successor.parent
            if parent_successor.left == successor:
                parent_successor.left = None
            else:
                parent_successor.right = None

    def preorder_traversal(self, node: Optional[TreeNode]):
        if node is None:
            return []
        ret = [node.key]
        ret += self.preorder_traversal(node.left)
        ret += self.preorder_traversal(node.right)
        return ret

    def inorder_traversal(self, node: Optional[TreeNode]):
        if node is None:
            return []
        ret = []
        ret += self.inorder_traversal(node.left)
        ret += [node.key]
        ret += self.inorder_traversal(node.right)
        return ret

    def postorder_traversal(self, node: Optional[TreeNode]):
        if node is None:
            return []
        ret = []
        ret += self.inorder_traversal(node.left)
        ret += self.inorder_traversal(node.right)
        ret += [node.key]
        return ret


m = int(input())
bst = BinarySearchTree()
for _ in range(m):
    command = input().split()
    if command[0] == 'insert':
        key = int(command[1])
        bst.insert(key)
    if command[0] == 'delete':
        key = int(command[1])
        bst.delete(key)
    if command[0] == 'find':
        key = int(command[1])
        node = bst.find(key)
        if node is not None:
            print('yes')
        else:
            print('no')
    if command[0] == 'print':
        in_order = bst.inorder_traversal(bst.root)
        print("""", *in_order)
        pre_order = bst.preorder_traversal(bst.root)
        print("""", *pre_order)
"
4952168,ALDS1_8_C,"# coding: utf-8
import sys

input=sys.stdin.readline
#ノードクラスの定義
class Node:
    def __init__(self, data): #コンストラクタ
        self.data = data #ノードがもつ数値
        self.parent=None
        self.left = None #左エッジ
        self.right = None #右エッジ

class BST:
    def __init__(self,num_list):
        self.root=None
        for node in num_list:
            self.insert(node)
    
    def insert(self,data):
        y=None
        x=self.root
        z=Node(data)
        while not x is None:
            y=x
            if data<x.data:
                x=x.left
            else:
                x=x.right
        z.parent=y
        if y==None:
            self.root=z
        elif z.data<y.data:
            y.left=z
        else:
            y.right=z
            
def find(node,k):
    while node!=None and k!=node.data:
        if k<node.data:
            node=node.left
        else:
            node=node.right
    return node

def delete(tree,node):
    #削除対象=y
    if node.left is None or node.right is None:
        y=node
    else:
        y=getSeccessor(node)
    #yの子=x
    if not y.left is None:
        x=y.left
    else:
        x=y.right
    if not x is None:
        x.parent=y.parent
    if y.parent is None:
        t.root=x
    elif y==y.parent.left:
        y.parent.left=x
    else:
        y.parent.right=x
    
    if y!=node:
        node.data=y.data

def getSeccessor(node):
    if node.right!=None:
        return getMinimum(node.right)
    y=node.parent
    while y!=None and node==y.right:
        node=y
        y=y.parent
    return y

def getMinimum(node):
    while node.left!=None:
        node=node.left
    return node
    
def inOrder(node):
    if node is None:
        return
    inOrder(node.left)
    print("" %d"" % node.data,end="""")
    inOrder(node.right)
    
def preOrder(node):
    if node is None:
        return
    print("" %d"" % node.data,end="""")
    preOrder(node.left)
    preOrder(node.right)
    
if __name__==""__main__"":
    t=BST([])
    n=int(input())
    for _ in range(n):
        tmp=input().split()
        if tmp[0]==""insert"":
            t.insert(int(tmp[1]))
            #print(t.root.data)
        elif tmp[0]==""print"":
            inOrder(t.root)
            print()
            preOrder(t.root)
            print()
        elif tmp[0]==""find"":
            ans=find(t.root,int(tmp[1]))
            print(""yes"" if ans!=None else ""no"")
        elif tmp[0]==""delete"":
            z=find(t.root,int(tmp[1]))
            delete(t,z)


"
4189133,ALDS1_8_C,"if __name__ == '__main__':
    import sys
    input = sys.stdin.readline

    NIL = -1

    m = int(input())

    root = NIL

    def insert(k):
        global root
        y = NIL
        x = root
        z = {'key':k, 'left':NIL, 'right':NIL}
        while x != NIL:
            y = x
            if z['key'] < x['key']:
                x = x['left']
            else:
                x = x['right']
        z['parent'] = y

        if y == NIL:
            root = z
        elif z['key'] < y['key']:
            y['left'] = z
        else:
            y['right'] = z

    def find(u, k):
        while u != NIL and k != u['key']:
            if k < u['key']:
                u = u['left']
            else:
                u = u['right']
        return u

    def tree_minimum(x):
        while x['left'] != NIL:
            x = x['left']
        return x

    def tree_successor(x):
        if x['right'] != NIL:
            return tree_minimum(x['right'])
        y = x['parent']
        while y != NIL and x == y['right']:
            x = y
            y = y['parent']
        return y

    def tree_delete(z):
        global root
        if z['left'] == NIL or z['right'] == NIL:
            y = z
        else:
            y = tree_successor(z)
        # yの子xを決める
        if y['left'] != NIL:
            x = y['left']
        else:
            x = y['right']

        if x != NIL:
            x['parent'] = y['parent']

        if y['parent'] == NIL:
            root = x
        elif y == y['parent']['left']:
            y['parent']['left'] = x
        else:
            y['parent']['right'] = x

        if y != z:
            z['key'] = y['key']

    def inorder(u):
        if u == NIL:
            return
        inorder(u['left'])
        print(' ' + str(u['key']), end='')
        inorder(u['right'])

    def preorder(u):
        if u == NIL:
            return
        print(' ' + str(u['key']), end='')
        preorder(u['left'])
        preorder(u['right'])

    for _ in range(m):
        command = input()
        if command[0] == 'f':
            _, x = command.split()
            x = int(x)
            t = find(root, x)
            if t != NIL:
                print('yes')
            else:
                print('no')
        elif command[:6] == 'insert':
            _, x = command.split()
            x = int(x)
            insert(x)
        elif command[:5] == 'print':
            inorder(root)
            print('')
            # pythonのprintは最後に改行記号をつけてくれるので、これで改行できる
            preorder(root)
            print('')
        else:
            _, x = command.split()
            x = int(x)
            tree_delete(find(root, x))

"
5445323,ALDS1_8_C,"import sys
input = sys.stdin.readline

NIL = -1

m = int(input())

root = NIL

def insert(k):
    global root
    y = NIL
    x = root
    z = {'key':k, 'left':NIL, 'right':NIL}
    while x != NIL:
        y = x
        if z['key'] < x['key']:
            x = x['left']
        else:
            x = x['right']
    z['parent'] = y

    if y == NIL:
        root = z
    elif z['key'] < y['key']:
        y['left'] = z
    else:
        y['right'] = z

def find(u, k):
    while u != NIL and k != u['key']:
        if k < u['key']:
            u = u['left']
        else:
            u = u['right']
    return u

def tree_minimum(x):
    while x['left'] != NIL:
        x = x['left']
    return x

def tree_successor(x):
    if x['right'] != NIL:
        return tree_minimum(x['right'])
    y = x['parent']
    while y != NIL and x == y['right']:
        x = y
        y = y['parent']
    return y

def tree_delete(z):
    global root
    if z['left'] == NIL or z['right'] == NIL:
        y = z
    else:
        y = tree_successor(z)
    # yの子xを決める
    if y['left'] != NIL:
        x = y['left']
    else:
        x = y['right']

    if x != NIL:
        x['parent'] = y['parent']

    if y['parent'] == NIL:
        root = x
    elif y == y['parent']['left']:
        y['parent']['left'] = x
    else:
        y['parent']['right'] = x

    if y != z:
        z['key'] = y['key']

def inorder(u):
    if u == NIL:
        return
    inorder(u['left'])
    print(' ' + str(u['key']), end='')
    inorder(u['right'])

def preorder(u):
    if u == NIL:
        return
    print(' ' + str(u['key']), end='')
    preorder(u['left'])
    preorder(u['right'])

for _ in range(m):
    command = input()
    if command[0] == 'f':
        _, x = command.split()
        x = int(x)
        t = find(root, x)
        if t != NIL:
            print('yes')
        else:
            print('no')
    elif command[:6] == 'insert':
        _, x = command.split()
        x = int(x)
        insert(x)
    elif command[:5] == 'print':
        inorder(root)
        print('')
        # pythonのprintは最後に改行記号をつけてくれるので、これで改行できる
        preorder(root)
        print('')
    else:
        _, x = command.split()
        x = int(x)
        tree_delete(find(root, x))
"
2829364,ALDS1_8_C,"import sys

class BinarySearchTree:
    class Node:
        __slots__ = ('value', 'left', 'right')

        def __init__(self, value):
            self.value = value
            self.left = None
            self.right = None

        def has_left(self):
            return self.left is not None

        def has_right(self):
            return self.right is not None

        def __str__(self):
            return str(self.value)

    def __init__(self):
        self.root = None

    def insert(self, value):
        if self.root is None:
            self.root = self.Node(value)
            return

        node = self.root
        while True:
            if node.value > value:
                if node.has_left():
                    node = node.left
                else:
                    node.left = self.Node(value)
                    break
            else:
                if node.has_right():
                    node = node.right
                else:
                    node.right = self.Node(value)
                    break

    def find(self, value):
        if self.root is None:
            return False

        node = self.root
        while True:
            if node.value > value:
                if node.has_left():
                    node = node.left
                else:
                    return False
            elif node.value < value:
                if node.has_right():
                    node = node.right
                else:
                    return False
            else:
                return True

    def delete(self, value):
        def _delete(node):
            if not node.has_left():
                right = node.right
                node.right = None
                return right
            elif not node.has_right():
                left = node.left
                node.left = None
                return left
            elif not node.right.has_left():
                right = node.right
                right.left = node.left
                node.left = None
                node.right = None
                return right
            else:
                repl = node.right
                while repl.has_left() and repl.left.has_left():
                    repl = repl.left

                left = repl.left
                node.value = left.value
                repl.left = left.right
                left.right = None
                return node

        if self.root is None:
            return
        elif self.root.value == value:
            self.root = _delete(self.root)
            return

        node = self.root
        while True:
            if node.value > value:
                if not node.has_left():
                    break
                if node.left.value == value:
                    node.left = _delete(node.left)
                    break
                else:
                    node = node.left
            elif node.value < value:
                if not node.has_right():
                    break
                if node.right.value == value:
                    node.right = _delete(node.right)
                    break
                else:
                    node = node.right
            else:
                raise Exception('should not reached')

    def preorder(self):
        def _preorder(node):
            yield node
            if node.has_left():
                yield from _preorder(node.left)
            if node.has_right():
                yield from _preorder(node.right)
        if self.root is not None:
            yield from _preorder(self.root)

    def inorder(self):
        def _inorder(node):
            if node.has_left():
                yield from _inorder(node.left)
            yield node
            if node.has_right():
                yield from _inorder(node.right)
        if self.root is not None:
            yield from _inorder(self.root)

    def postorder(self):
        def _postorder(node):
            if node.has_left():
                yield from _postorder(node.left)
            if node.has_right():
                yield from _postorder(node.right)
            yield node
        if self.root is not None:
            yield from _postorder(self.root)


def run():
    _ = int(input())
    tree = BinarySearchTree()

    for line in sys.stdin:
        if line.startswith('insert'):
            tree.insert(int(line[7:]))
        elif line.startswith('find'):
            if tree.find(int(line[5:])):
                print(""yes"")
            else:
                print(""no"")
        elif line.startswith('delete'):
            tree.delete(int(line[7:]))
        elif line.startswith('print'):
            print(' {}'.format(' '.join([str(n) for n in tree.inorder()])))
            print(' {}'.format(' '.join([str(n) for n in tree.preorder()])))
        else:
            raise ValueError('invalid command')


if __name__ == '__main__':
    run()

"
5333248,ALDS1_8_C,"class Node:

    def __init__(self, key=None):
        self.key = key
        self.p = None
        self.left = None
        self.right = None
    
    def delete(self):
        self.key = self.p = self.left = self.right = None

class BST:

    def __init__(self):
        self.root = None


def inorder(node):

    if node is not None:
        return inorder(node.left) + f' {node.key}' + inorder(node.right)
    else:
        return  ''

def inorderSuccessor(node):

    cur = node
    while cur is not None:
        if cur.left is None:
            break
        cur = cur.left

    return cur


def preorder(node):

    if node is not None:
        return f' {node.key}' + preorder(node.left) + preorder(node.right)
    else:
        return ''

def insert(T, z):

    y = None
    x = T.root

    while x != None:

        y = x

        if z.key < x.key:
            x = x.left
        else:
            x = x.right
    
    z.p = y

    if y is None:
        T.root = z
    elif z.key < y.key:
        y.left = z
    else:
        y.right = z

def find(s, k):

    if s is None or s.key == k:
        return s
    elif s.key > k:
        return find(s.left, k)
    else:
        return find(s.right, k)

def delete(s, k):

    node = find(s, k)
    if node is None:
        return None
    
    if node.left is None and node.right is None:
        if node.p.left == node:
            node.p.left = None
        else:
            node.p.right = None
        node.delete()
    
    elif node.left and node.right:
        replace = inorderSuccessor(node.right)
        node.key = replace.key
        delete(node.right, replace.key)
    
    else:
        if node.left is None:
            child = node.right
        else:
            child = node.left

        if node.p.left == node:
            node.p.left = child
        else:
            node.p.right = child
        
        child.p = node.p
        node.delete()

T = BST()
n = int(input())
y = []

for i in range(n):
    y.append(input())

for j in y:

    if j[0] == 'i':
        insert(T, Node(int(j[7:])))
    elif j[0] == 'f':
        if find(T.root, int(j[5:])) is None:
            print('no')
        else:
            print('yes')
    elif j[0] == 'd':
        delete(T.root, int(j[7:]))
    else:
        print(inorder(T.root))
        print(preorder(T.root))
"
2433781,ALDS1_8_C,"import sys


class Node():
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.parent = None

    def preorder(self):
        nodeList = [self.key]
        if self.left:
            nodeList += self.left.preorder()
        if self.right:
            nodeList += self.right.preorder()
        return nodeList

    def inorder(self):
        nodeList = []
        if self.left:
            nodeList += self.left.inorder()
        nodeList += [self.key]
        if self.right:
            nodeList += self.right.inorder()
        return nodeList


class BinaryTree():
    def __init__(self):
        self.root = None

    def insert(self, key):
        z = Node(key)
        y = None
        x = self.root
        while x:
            y = x
            if z.key < x.key:
                x = x.left
            else:
                x = x.right
        z.parent = y

        if y is None:
            self.root = z
        elif z.key < y.key:
            y.left = z
        else:
            y.right = z

    def find(self, key):
        x = self.root
        while x is not None and key != x.key:
            if key < x.key:
                x = x.left
            else:
                x = x.right
        return x

    def delete(self, key):
        z = self.find(key)
        if z is not None:
            if z.left is not None and z.right is not None:
                temp = self.getMinimum(z.right)
                self.delete(temp.key)
                z.key = temp.key
            elif z.left is not None:
                if z.parent is None:
                    self.root = z.left
                    z.left.parent = None
                else:
                    if z.parent.left is z:
                        z.parent.left = z.left
                    else:
                        z.parent.right = z.left
                    z.left.parent = z.parent
            elif z.right is not None:
                if z.parent is None:
                    self.root = z.right
                    z.right.parent = None
                else:
                    if z.parent.left is z:
                        z.parent.left = z.right
                    else:
                        z.parent.right = z.right
                    z.right.parent = z.parent
            else:
                if z.parent is None:
                    self.root = None
                else:
                    if z.parent.left is z:
                        z.parent.left = None
                    else:
                        z.parent.right = None

    def getMinimum(self, node):
        while node.left is not None:
            node = node.left
        return node

    def print(self):
        print("" "" + "" "".join(map(str, self.root.inorder())))
        print("" "" + "" "".join(map(str, self.root.preorder())))


if __name__ == ""__main__"":
    tree = BinaryTree()
    n = int(sys.stdin.readline())
    for inp in sys.stdin.readlines():
        inp = inp.split()
        if inp[0] == ""insert"":
            tree.insert(int(inp[1]))
        elif inp[0] == ""find"":
            if tree.find(int(inp[1])) is None:
                print(""no"")
            else:
                print(""yes"")
        elif inp[0] == ""delete"":
            tree.delete(int(inp[1]))
        else:
            tree.print()
"
4450477,ALDS1_8_C,"n = int(input())
inst_k = [-1]*n
inst = [-1]*n
for i in range(n):
    tmp = input().split()
    inst[i] = tmp[0]
    if len(tmp) == 2:
        inst_k[i] = int(tmp[1])

class BST:
    def __init__(self):
        self.key = []
        self.parent = []
        self.left_child = []
        self.right_child = []
        self.root = None

    def insert(self,new_key):
        new_node = len(self.key)
        self.key.append(new_key)
        self.left_child.append(None)
        self.right_child.append(None)
        self.parent.append(None)

        searching_node = self.root
        searching_node_parent = None
        while searching_node != None:
            searching_node_parent = searching_node
            if new_key < self.key[searching_node]:
                searching_node = self.left_child[searching_node]
            else:
                searching_node = self.right_child[searching_node]
        if searching_node_parent == None:
            self.root = new_node
        else:
            self.parent[new_node] = searching_node_parent
            if new_key < self.key[searching_node_parent]:
                self.left_child[searching_node_parent] = new_node
            else:
                self.right_child[searching_node_parent] = new_node
    
    def print_clear(self):
        self.preorder_ans = []
        self.inorder_ans = []
    
    def preorder(self,node):
        if node != None:
            self.preorder_ans.append(self.key[node])
            self.preorder(self.left_child[node])
            self.preorder(self.right_child[node])
    
    def inorder(self,node):
        if node != None:
            self.inorder(self.left_child[node])
            self.inorder_ans.append(self.key[node])
            self.inorder(self.right_child[node])
    
    def find(self,key,node):
        if node == None:
            return None
        else:
            if self.key[node] == key:
                return node
            else:
                if key < self.key[node]:
                    return self.find(key,self.left_child[node])
                else:
                    return self.find(key,self.right_child[node])
     
    def delete(self,key):
        del_node = self.find(key,self.root)
        if self.left_child[del_node] == None or self.right_child[del_node] == None:
            instead_node = del_node
        else:
            instead_node = self.getSuccessor(del_node)
        
        if self.left_child[instead_node] != None:
            instead_node_child = self.left_child[instead_node]
        else:
            instead_node_child = self.right_child[instead_node]
        
        if instead_node_child != None:
            self.parent[instead_node_child] = self.parent[instead_node]

        if self.root == instead_node:
            self.root = instead_node_child
        elif self.left_child[self.parent[instead_node]] == instead_node:
            self.left_child[self.parent[instead_node]] = instead_node_child
        else:
            self.right_child[self.parent[instead_node]] = instead_node_child
        
        if instead_node != del_node:
            self.key[del_node] = self.key[instead_node]



    def getSuccessor(self,node):
        if self.right_child[node] != None:
            return self.getMinimum(self.right_child[node])
        else:
            ret = node
            while self.left_child[self.parent[ret]] != ret and ret != None:
                ret = self.parent[ret]
            return self.parent[ret]
    
    def getMinimum(self,node):
        while self.left_child[node] != None:
            node = self.left_child[node]
        return node
        
        

            



tree = BST()
for i in range(n):
    if inst[i] == ""insert"":
        tree.insert(inst_k[i])

    elif inst[i] == ""find"":
        if tree.find(inst_k[i],tree.root) != None:
            print(""yes"")
        else:
            print(""no"")

    elif inst[i] == ""delete"":
        tree.delete(inst_k[i])

    elif inst[i] == ""print"":
        tree.print_clear()
        tree.preorder(tree.root)
        tree.inorder(tree.root)
        print("" "",end = """")
        print(*tree.inorder_ans)
        print("" "",end = """")
        print(*tree.preorder_ans)

"
6077342,ALDS1_8_C,"import sys

class BinarySearchTree:
    def __init__(self):
        self.root = None
    def show_keys(self):
        in_order_from(self.root)
        print('')
        pre_order_from(self.root)
        print('')
    def insert(self, key):
        node = Node(key)
        insert(self, node)
    def find(self, key):
        if find_from(self.root, key):
            print('yes')
        else:
            print('no')
    def delete_key(self, key):
        node = find_from(self.root, key)
        delete_node(self, node)

class Node:
    def __init__(self, key):
        self.key = key
        self.parent = None
        self.left = None
        self.right = None

def insert(T, z):
    y = None
    x = T.root
    while x != None:
        y = x
        if z.key < x.key:
            x = x.left
        else:
            x = x.right
    z.parent = y
    if y == None:
        T.root = z
    elif z.key < y.key:
        y.left = z
    else:
        y.right = z

def delete_node(T, node):
    if node.left and node.right:
        x = node.right
        while x.left:
            x = x.left
        node.key = x.key
        delete_node(T, x)
    elif node.left or node.right:
        child = node.left or node.right
        if node is T.root:
            T.root = child
            child.parent = None
        else:
            if node.parent.left is node:
                node.parent.left = child
                child.parent = node.parent
            else:
                node.parent.right = child
                child.parent = node.parent
    else:
        if node.parent.left is node:
            node.parent.left = None
        else:
            node.parent.right = None

def in_order_from(node):
    if node:
        in_order_from(node.left)
        print(f' {node.key}', end = '')
        in_order_from(node.right)

def pre_order_from(node):
    if node:
        print(f' {node.key}', end = '')
        pre_order_from(node.left)
        pre_order_from(node.right)

def find_from(node, k):
    while node:
        if node.key == k:
            return node
        if k < node.key:
            node = node.left
        else:
            node = node.right

binary_tree = BinarySearchTree()

sys.stdin.readline()
for line in sys.stdin:
    line = line.split()
    if line[0] == 'insert':
        binary_tree.insert(int(line[1]))
    elif line[0] == 'find':
        binary_tree.find(int(line[1]))
    elif line[0] == 'delete':
        binary_tree.delete_key(int(line[1]))
    else:
        binary_tree.show_keys()
"
2195535,ALDS1_8_C,"import sys

class Node():
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.parent = None

    def prewalk(self):
        nodeList = [self.key]
        if self.left:
            nodeList += self.left.prewalk()
        if self.right:
            nodeList += self.right.prewalk()
        return nodeList

    def inwalk(self):
        nodeList = []
        if self.left:
            nodeList += self.left.inwalk()
        nodeList += [self.key]
        if self.right:
            nodeList += self.right.inwalk()
        return nodeList

class Tree():
    def __init__(self):
        self.root = None

    def insert(self, key):
        Nz = Node(key)
        Ny = None  # ???????£?
        Nx = self.root
        while Nx:
            Ny = Nx
            if Nz.key < Ny.key:
                Nx = Nx.left
            else:
                Nx = Nx.right
        Nz.parent = Ny
        if Ny == None:
            self.root = Nz
        elif Nz.key < Ny.key:
            Ny.left = Nz
        else:
            Ny.right = Nz

    def find(self, key):
        Nx = self.root
        while Nx and Nx.key != key:
            if key < Nx.key:
                Nx = Nx.left
            else:
                Nx = Nx.right
        return Nx

    def delete(self, key):
        Nz = self.find(key)
        # Ny: the node to be deleted
        if Nz.left and Nz.right:
            Ny = self.successor(Nz)
        else:
            Ny = Nz
        # Nx: y's child
        if Ny.left:
            Nx = Ny.left
        else:
            Nx = Ny.right

        if Nx:
            Nx.parent = Ny.parent

        if Ny.parent == None:
            self.root = Nx
        elif Ny == Ny.parent.left:
            Ny.parent.left = Nx
        else:
            Ny.parent.right = Nx

        if Ny != Nz:
            Nz.key = Ny.key

    def successor(self, Nx):
        if Nx.right:
            return self.minimum(Nx.right)

        Ny = Nx.parent
        while Ny != None and Nx == Ny.right:
            Nx = Ny
            Ny = Ny.parent
        return Ny

    def minimum(self, Nx):
        while Nx.left:
            Nx = Nx.left
        return Nx

    def print(self):
        print('', ' '.join(map(str, self.root.inwalk())))
        print('', ' '.join(map(str, self.root.prewalk())))

tree = Tree()

n = sys.stdin.readline()
for line in sys.stdin:
    if line[0] == 'i':
        tree.insert(int(line.split()[1]))
    elif line[0] == 'f':
        if tree.find(int(line.split()[1])):
            print('yes')
        else:
            print('no')
    elif line[0] == 'd':
        tree.delete(int(line.split()[1]))
    else:
        tree.print()
"
8393220,ALDS1_8_D,"import sys

class Node:
    def __init__(self, key, priority):
        self.key = key
        self.priority = priority
        self.left = None
        self.right = None

def rightRotate(t):
    s = t.left
    t.left = s.right
    s.right = t
    return s

def leftRotate(t):
    s = t.right
    t.right = s.left
    s.left = t
    return s

def insert(t, key, priority):
    if t is None:
        return Node(key, priority)
    if key == t.key:
        return t
    if key < t.key:
        t.left = insert(t.left, key, priority)
        if t.priority < t.left.priority:
            t = rightRotate(t)
    else:
        t.right = insert(t.right, key, priority)
        if t.priority < t.right.priority:
            t = leftRotate(t)
    return t

def delete(t, key):
    if t is None:
        return None
    if key < t.key:
        t.left = delete(t.left, key)
    elif key > t.key:
        t.right = delete(t.right, key)
    else:
        return _delete(t, key)
    return t

def _delete(t, key):
    if t.left is None and t.right is None:
        return None
    elif t.left is None:
        t = leftRotate(t)
    elif t.right is None:
        t = rightRotate(t)
    else:
        if t.left.priority > t.right.priority:
            t = rightRotate(t)
        else:
            t = leftRotate(t)
    return delete(t, key)

def find(t, key):
    if t is None:
        return False
    if key == t.key:
        return True
    if key < t.key:
        return find(t.left, key)
    else:
        return find(t.right, key)

def inorder(t):
    if t is None:
        return []
    return inorder(t.left) + [t.key] + inorder(t.right)

def preorder(t):
    if t is None:
        return []
    return [t.key] + preorder(t.left) + preorder(t.right)

def main():
    n = int(input())
    treap = None
    for i in range(n):
        cmd = input().split()
        if cmd[0] == ""insert"":
            treap = insert(treap, int(cmd[1]), int(cmd[2]))
        elif cmd[0] == ""delete"":
            treap = delete(treap, int(cmd[1]))
        elif cmd[0] == ""find"":
            if find(treap, int(cmd[1])):
                print(""yes"")
            else:
                print(""no"")
        else:
            inorder_keys = inorder(treap)
            preorder_keys = preorder(treap)
            print("" "" + "" "".join(str(key) for key in inorder_keys))
            print("" "" + "" "".join(str(key) for key in preorder_keys))

if __name__ == ""__main__"":
    main()

"
8417355,ALDS1_8_D,"COMMAND_ID = 0
KEY_ID = 1
PRIORITY_ID = 2

class Node:
    def __init__(self, key, priority, left, right):
        self.key = key
        self.priority = priority
        self.left = left
        self.right = right

class BinaryTree:
    def __init__(self, root):
        self.root = root

    # 右回転
    def right_rotate(self, t):
        s = t.left
        t.left = s.right
        s.right = t
        return s

    # 左回転
    def left_rotate(self, t):
        s = t.right
        t.right = s.left
        s.left = t
        return s

    # 値の挿入
    def insert_node(self, t, key, priority):
        # 終端条件
        # 根・再帰的な部分木の根
        if t == None:
            return Node(key, priority, None, None)
        # 値が重複する場合、挿入しない
        if key == t.key:
            return t

        # 再帰
        if key < t.key:
            t.left = self.insert_node(t.left, key, priority)
            # 優先度のヒープ条件を満たしていなければ回転
            if t.priority < t.left.priority:
                t = self.right_rotate(t)
        else:
            t.right = self.insert_node(t.right, key, priority)
            # 優先度のヒープ条件を満たしていなければ回転
            if t.priority < t.right.priority:
                t = self.left_rotate(t)
        return t
    
    # 値の検索
    def find_node(self, t, key):
        # 終端条件
        if t == None:
            return False
        elif t.key == key:
            return True
        # 再帰
        if t.key > key:
            return self.find_node(t.left, key)
        else:
            return self.find_node(t.right, key)

    # 値の削除
    def delete_node(self, t, key):
        # 終端条件
        if t == None:
            return None
        elif t.key == key:
            return self.delete(t, key)
        # 再帰
        if key < t.key:
            t.left = self.delete_node(t.left, key)
        elif key > t.key:
            t.right = self.delete_node(t.right, key)
        return t
    # 指定されたノードを削除
    def delete(self, t, key):
        # 1.子ノードのない親ノードを削除する場合
        if (t.left == None) and (t.right == None):
            return None
        # 2.子ノードが1つの親ノードを削除する場合
        # 回転させて削除対象を葉の方に持って行く
        elif t.left == None:
            t = self.left_rotate(t)
        elif t.right == None:
            t = self.right_rotate(t)
        # 3.子ノードが2つの親ノードを削除する場合
        # 優先度のヒープ条件を保つように回転させて削除対象を葉の方に持って行く
        else:
            if t.left.priority > t.right.priority:
                t = self.right_rotate(t)
            else:
                t = self.left_rotate(t)
        # 削除対象はtの子ノードの位置に移動する
        # 削除対象が1回の回転で葉まで移動しなければ、
        # 葉の位置に来るまで、部分木に対してdelete_nodeを適用する
        return self.delete_node(t, key)


    # 行きがけ順で出力
    def print_preorder(self, node):
        print(f' {node.key}', end='')
        # 再帰
        if node.left:
            self.print_preorder(node.left)
        if node.right:
            self.print_preorder(node.right)
    
    # 通りがけ順で出力
    def print_inorder(self, node):
        # 再帰
        if node.left:
            self.print_inorder(node.left)   
        print(f' {node.key}', end='')
        if node.right:
            self.print_inorder(node.right)



def main():
    m = int(input())

    tree = BinaryTree(None)
    for _ in range(m):
        cmd = input().split()
        if cmd[COMMAND_ID] == 'print':
            tree.print_inorder(tree.root)
            print()
            tree.print_preorder(tree.root)
            print()
        if cmd[COMMAND_ID] == 'insert':
            k = int(cmd[KEY_ID])
            p = int(cmd[PRIORITY_ID])
            tree.root = tree.insert_node(tree.root, k, p)
        if cmd[COMMAND_ID] == 'find':
            k = int(cmd[KEY_ID])
            is_find = tree.find_node(tree.root, k)
            if is_find:
                print('yes')
            if not is_find:
                print('no')
        if cmd[COMMAND_ID] == 'delete':
            k = int(cmd[KEY_ID])
            tree.root = tree.delete_node(tree.root, k)

if __name__ == '__main__':
    main()
"
9022153,ALDS1_8_D,"class Node:
    def __init__(self, key=0, priority_=0):
        self.key=key
        self.left=None
        self.right=None
        self.p=None
        self.priority=priority_

def rightRotate(z):
    s=z.left
    z.left=s.right
    s.right=z
    return s

def leftRotate(z):
    s=z.right
    z.right=s.left
    s.left=z
    return s

def insert(z, key_, priority_):
    if z is None:
        return Node(key_, priority_)
    if key_ == z.key:
        return z
    if key_ < z.key:
        z.left=insert(z.left, key_, priority_)
        if z.priority < z.left.priority:
            z=rightRotate(z)
    else:
        z.right=insert(z.right, key_, priority_)
        if z.priority < z.right.priority:
            z=leftRotate(z)
    return z

def find(z, key_):
    if z is None:
        print(""no"")
        return None
    if key_ == z.key:
        print(""yes"")
        return key_
    elif key_ < z.key:
        return find(z.left, key_)
    else:
        return find(z.right, key_)

def delete(z, key_):
    if z is None:
        return None
    if key_ < z.key:
        z.left=delete(z.left, key_)
    elif key_ > z.key:
        z.right=delete(z.right, key_)
    else:
        return _delete(z, key_)
    return z

def _delete(z, key_):
    if z.left is None and z.right is None:
        return None
    elif z.left is None:
        z=leftRotate(z)
    elif z.right is None:
        z=rightRotate(z)
    else:
        if z.left.priority > z.right.priority:
            z=rightRotate(z)
        else:
            z=leftRotate(z)
    return delete(z, key_)

def print_order(num):
    global inorder, preorder
    preorder.append(str(num.key))
    if num.left is not None:
        print_order(num.left)
    inorder.append(str(num.key))
    if num.right is not None:
        print_order(num.right)    

m=int(input())
root=None
for _ in range(m):
    order = list(input().split())
    if order[0] == ""insert"":
        root=insert(root, int(order[1]), int(order[2]))
    elif order[0] == ""find"":
        find(root, int(order[1]))
    elif order[0] == ""delete"":
        root=delete(root, int(order[1]))
    else:
        inorder=[]
        preorder=[]
        print_order(root)
        print("" ""+"" "".join(inorder))
        print("" ""+"" "".join(preorder))
"
8494515,ALDS1_8_D,"def r(w, i): i[:], w[:] = (w[:3] + [i[2]], i[:2] + [w[3], i[3]]) if i[2] == w else (w[:2] + [i[3], w[3]], i[:3] + [w[2]])
a = []

for _ in range(int(input())):
    i = input()
    l, w = [a], a
    if i[0] == 'i':
        n, p = (int(i) for i in i[7:].split())
        while w and (w := w[2] if w[0] > n else w[3]): l += [w]
        w += [n, p, [], []]
        while l and (i := w)[1] > (w := l.pop())[1]: r(i, w)
    elif i[0] in 'df':
        n = int(i.split()[1])
        while w or i[0] =='f' and print('no'):
            if w[0] == n:
                if i[0] == 'f':
                    print('yes')
                    break
                while (i := w)[2] and i[3]:
                    w = i[2] if i[2][1] > i[3][1] else i[3]
                    r(w, i)
                i = w.pop(2) if w[2] else w.pop()
                w.clear()
                if i: w += i
                break
            w = w[2] if w[0] > n else w[3]
    else:
        w = []
        while l:
            if len(i := l.pop()) == 1: print('', i[0], end='')
            elif i:
                l += [i[3], [i[0]], i[2]]
                w += [i[0]]
        print('\n', *w)
"
8420814,ALDS1_8_D,"class Node:
  def __init__(self, key, priority):
    self.key      = key
    self.priority = priority
    self.left  = None
    self.right = None
  
  def check(self):
    if self.key is None:
      if self.left is not None:
        self.left.check()
    else:
      if self.left is not None:
        if not self.left.key < self.key:
          print('Check:', self.key, ': left key is invalid:', self.left.key)
        self.left.check()
      if self.right is not None:
        if not self.right.key > self.key:
          print('Check:', self.key, ': right key is invalid:', self.right.key)
        self.right.check()


def left_rotate(tree):
  new_tree = tree.right  # `new_tree` gets `tree.right`.
  tree.right = new_tree.left  # `tree` gets back `new_tree.left` and put it to
                              # `tree.right`.
  new_tree.left = tree  # Last, Put `tree` to `new_tree.left`.
  return new_tree

def right_rotate(tree):  # Right edition of left_rotate().
  new_tree = tree.left
  tree.left = new_tree.right
  new_tree.right = tree
  return new_tree


def insert(tree, key, priority):
  # Ret Node if found a leaf or tree is None.
  # Else, call insert() recursively. Then, check that the tree is keeping heap
  # condition, and rotate to fix if the tree isn't keeping heap condition.
  # The Node inserted will be at valid position because caller, caller's caller
  # ... do this process too.

  if tree is None:  # Return if found a leaf or tree is None.
    return Node(key, priority)

  if key < tree.key:  # Move to the left.
    tree.left = insert(tree.left, key, priority)  # Update (insert to) the left.
    if tree.priority < tree.left.priority:  # Right rotate if the tree isn't
                                            # keeping heap condition.
      tree = right_rotate(tree)
  else:  # Move to the right.
    tree.right = insert(tree.right, key, priority)
    if tree.priority < tree.right.priority:
      tree = left_rotate(tree)

  return tree


def delete(tree, key):
  # Go to a node to delete.
  # If found tgt, call delete_node() to delete it.
  # When a node to delete has a child:
  #   If the node has 1 child, repeat rotating and going to a node to delete.
  #   If the node has 2 children, do like 1 child case but rotate direction will
  #   be decided by `tree.left.priority > tree.right.priority`.

  def search_and_delete_node(tree, key):
    if tree is None:  # If only 0 nodes.
      return None
    if key < tree.key:  # Search deleting node.
      tree.left = search_and_delete_node(tree.left, key)
    elif key > tree.key:
      tree.right = search_and_delete_node(tree.right, key)
    else:  # Delete.
      return delete_node_and_rotate(tree, key)
    return tree

  def delete_node_and_rotate(tree, key):
    # Delete deleting node.
    if tree.left is None and tree.right is None:  # If `tree` is a leaf.
      return None  # Delete.
    elif tree.left is None:  # If `tree` has only right.
      tree = left_rotate(tree)  # Left rotate `tree` to move deleting node to
                                # down.
    elif tree.right is None:  # If `tree` has only right.
      tree = right_rotate(tree)
    else:  # If `tree` has the left and the right.
      if tree.left.priority > tree.right.priority:  # Move deleting node to
                                                    # down. This `if` is to keep
                                                    # heap condition.
        tree = right_rotate(tree)  # Left rotate `tree` to move deleting node to
                                   # down.
      else:
        tree = left_rotate(tree)
    return search_and_delete_node(tree, key)
  
  return search_and_delete_node(tree, key)

def find(tree, key):
  while tree is not None:
    if key < tree.key:
      tree = tree.left  # Move to left.
    elif key > tree.key:
      tree = tree.right
    else:
      return True
  return False

def walk_tree(tree, fns):
  def walk(tree):
    if tree is None:
      return
    for f in fns:
      f(walk, tree)
  walk(tree)

def print_tree(tree):
  # Print as inorder.
  walk_tree(tree, [
    lambda walk, node: walk(node.left),
    lambda walk, node: None if node.key == None else print(' ' + str(node.key), end=''),
    lambda walk, node: walk(node.right),
    ])
  print()

  # Print as preorder.
  walk_tree(tree, [
    lambda walk, node: None if node.key == None else print(' ' + str(node.key), end=''),
    lambda walk, node: walk(node.left),
    lambda walk, node: walk(node.right),
    ])
  print()


# Init tree.
tree = None

# Run.
num_insts = int(input())

for _ in range(num_insts):
  toks = input().split()
  if toks[0] == 'find':
    print('yes' if find(tree, int(toks[1])) else 'no')
  elif toks[0] == 'insert':
    tree = insert(tree, int(toks[1]), int(toks[2]))
  elif toks[0] == 'delete':
    tree = delete(tree, int(toks[1]))
  elif toks[0] == 'print':
    print_tree(tree)
  # tree.check()
"
8409410,ALDS1_8_D,"class Node:
    # Nodeクラスの初期化。keyはノードの値、priorityは優先度を表す。leftとrightは子ノードへの参照。
    def __init__(self, key, priority):
        self.key = key
        self.priority = priority
        self.left = None
        self.right = None

class Treap:
    # Treapクラスの初期化。rootはツリーの根ノードを指す。
    def __init__(self):
        self.root = None

    # 指定されたキーを持つノードが存在するかどうかを検索。
    def find(self, x):
        p = self.root
        while p:
            if p.key == x:
                return True  # キーが見つかった場合
            elif p.key > x:
                p = p.left  # キーが現在のノードのキーより小さい場合、左の子ノードに移動
            else:
                p = p.right  # そうでない場合、右の子ノードに移動
        return False  # キーが見つからなかった場合

    # 中順順でツリーをトラバースしてキーを出力。
    def inorder(self, p):
        if p:
            self.inorder(p.left)  # 左のサブツリーをトラバース
            print(f' {p.key}', end='')  # 現在のノードのキーを出力
            self.inorder(p.right)  # 右のサブツリーをトラバース

    # 前順順でツリーをトラバースしてキーを出力。
    def preorder(self, p):
        if p:
            print(f' {p.key}', end='')  # 現在のノードのキーを出力
            self.preorder(p.left)  # 左のサブツリーをトラバース
            self.preorder(p.right)  # 右のサブツリーをトラバース

    # 中順および前順のトラバース結果を表示。
    def print(self, p):
        self.inorder(p)
        print()  # 新しい行で出力を分ける
        self.preorder(p)
        print()  # 新しい行で出力を分ける

    # 新しいノードを作成して返す。
    def makenode(self, x, y):
        return Node(x, y)

    # 右回転を実行して、部分ツリーのバランスを調整する。
    def rightRotate(self, p):
        q = p.left
        p.left = q.right
        q.right = p
        return q

    # 左回転を実行して、部分ツリーのバランスを調整する。
    def leftRotate(self, p):
        q = p.right
        p.right = q.left
        q.left = p
        return q

    # 新しいノードを挿入する。
    def insert(self, key, priority):
        self.root = self._insert(self.root, key, priority)

    # ヘルパー関数で、実際の挿入操作を再帰的に実行する。
    def _insert(self, t, key, priority):
        if t is None:
            return self.makenode(key, priority)  # 新しいノードを作成
        if t.key == key:
            return t  # キーが既に存在する場合は、何もしない

        if key < t.key:
            t.left = self._insert(t.left, key, priority)  # 左のサブツリーに挿入
            if t.priority < t.left.priority:
                t = self.rightRotate(t)  # 優先度の条件に基づいて右回転
        else:
            t.right = self._insert(t.right, key, priority)  # 右のサブツリーに挿入
            if t.priority < t.right.priority:
                t = self.leftRotate(t)  # 優先度の条件に基づいて左回転

        return t

    # 指定されたキーを持つノードを削除する。
    def delete(self, key):
        self.root = self._delete(self.root, key)

    # ヘルパー関数で、実際の削除操作を再帰的に実行する。
    def _delete(self, t, key):
        if t is None:
            return None  # 削除するノードが見つからない場合

        if key < t.key:
            t.left = self._delete(t.left, key)  # 左のサブツリーから削除
        elif key > t.key:
            t.right = self._delete(t.right, key)  # 右のサブツリーから削除
        else:
            # キーが一致するノードを見つけた場合、そのノードを削除
            if t.left is None and t.right is None:
                return None  # リーフノードの場合、単に削除
            elif t.left is None:
                t = self.leftRotate(t)  # 子が右にのみある場合、左回転して削除
            elif t.right is None:
                t = self.rightRotate(t)  # 子が左にのみある場合、右回転して削除
            else:
                # 両方の子がいる場合、優先度に基づいて回転
                if t.left.priority > t.right.priority:
                    t = self.rightRotate(t)  # 左の子の優先度が高い場合、右回転
                else:
                    t = self.leftRotate(t)  # 右の子の優先度が高い場合、左回転
            # 回転後、削除を続行
            t = self._delete(t, key)
        return t

# 以下はメインの実行部分です。

# Treapのインスタンスを作成
treap = Treap()

# コマンドの数を入力として受け取る
n = int(input())
for _ in range(n):
    # 各コマンドとそのパラメーターを読み取る
    cmd, *args = input().split()
    if cmd == 'insert':
        # 挿入コマンドの場合、新しいノードを追加
        key, priority = map(int, args)
        treap.insert(key, priority)
    elif cmd == 'delete':
        # 削除コマンドの場合、指定されたキーのノードを削除
        key = int(args[0])
        treap.delete(key)
    elif cmd == 'find':
        # 検索コマンドの場合、指定されたキーが存在するか確認
        key = int(args[0])
        print(""yes"" if treap.find(key) else ""no"")
    elif cmd == 'print':
        # 印刷コマンドの場合、Treapの内容を印刷
        treap.print(treap.root)

"
9100771,ALDS1_8_D,"import random
class Node:
    def __init__(self, key:int, priority:int) -> None:
        self.key: int = key
        self.parent: Node = None
        self.left: Node = None
        self.right: Node = None
        self.priority: int = priority
    
    def fr(self) -> list[str]:
        rtn = []
        if self.left != None: rtn.append(""left"")
        if self.right != None: rtn.append(""right"")
        return rtn
       
    def order(self, mode: str):
        li = {
            ""Pre"": [0, 1, 2],  # 先行順巡回 node -> left -> right 
            ""In"": [1, 0, 2],   # 中間順巡回 left -> node -> right
            ""Post"": [1, 2, 0]  # 後方順巡回 right -> left -> right
        }
        for i in li[mode]:
            if i == 0: print(f"" {self.key}"", end = """")
            elif i == 1 and self.left != None : self.left.order(mode)
            elif i == 2 and self.right != None: self.right.order(mode)
        
def ans(t: Node):
    t.order(""In"")  
    print()
    t.order(""Pre"")
    print() 
        
def find(t: Node, k: int):
    x: Node = t
    while x != None:
        if x.key == k:
            print(""yes"")
            return
        if x.key < k: x = x.right
        else: x = x.left
    print(""no"")

def rightRotate(t: Node) -> Node:
    s = t.left
    t.left = s.right
    s.right = t
    return s  # root of subtree

def leftRotate(t: Node) -> Node:
    s = t.right
    t.right = s.left
    s.left = t
    return s  # root of subtree

def insert(t: Node, key: int, priority: int) -> Node:
    if t == None:
        return Node(key, priority)  # 葉に到達したら新しい接点を生成
    if key == t.key:
        return t  # 重複したkeyは無視
    
    if key < t.key:
        t.left = insert(t.left, key, priority)
        if t.priority < t.left.priority:
            t = rightRotate(t)
    else:
        t.right = insert(t.right, key, priority)
        if t.priority < t.right.priority:
            t = leftRotate(t)
    return t

def delete(t: Node, key: int):
    if t == None: return None
    if key < t.key: t.left = delete(t.left, key)
    elif key > t.key: t.right = delete(t.right, key)
    else: return _delete(t, key)
    return t
def _delete(t: Node, key:int):
    if t.left == None and t.right == None: return None
    elif t.left == None: t = leftRotate(t)
    elif t.right == None: t = rightRotate(t)
    else:
        if t.left.priority > t.right.priority: t = rightRotate(t)
        else: t = leftRotate(t)
    return delete(t, key)

n = int(input())
t = None
for _ in range(n):
    order = input()
    if order[0] == ""i"": 
        key, priority = map(int, order[7:].split())
        t = insert(t, key, priority)
    elif order[0] == ""f"": find(t, int(order[5:]))
    elif order[0] == ""d"": t = delete(t, int(order[7:]))
    else: ans(t)


"
8282508,ALDS1_8_D,"import random
class Node:
    def __init__(self, key, priority = None, left = None, right = None, parent = None):
        self.key = key
        self.left = left
        self.right = right
        self.parent = parent
        self.priority = priority

class Treap:
    def __init__(self):
        self.root = None
        self.priority_set = set()
    
    def right_rotate(self, t: Node) -> Node:
        """"""
        右回転 
        """"""
        s = t.left
        t.left = s.right
        s.right = t
        if t == self.root:
            self.root = s
        return s
    
    def left_rotate(self, t: Node) -> Node:
        """"""
        左回転
        """"""
        s = t.right
        t.right = s.left
        s.left = t
        if t == self.root:
            self.root = s
        return s
    
    def insert(self, key: int, priority = None):
        if priority == None:
            priority = random.randint(0, 10**18)
            while priority in self.priority_set:
                priority = random.randint()
            self.priority_set.add(priority)
        if self.root == None:
            self.root = Node(key, priority=priority)
        else:
            self._insert(self.root, key, priority, self.root)
        #print(*Tr.print_inorder())
    
    def _insert(self, t: Node, key: int, priority: int, t_parent: Node):
        if t == None:
            t = Node(key, priority=priority, parent=t_parent)
            #print(t.key, t.parent.key)
            if t_parent.key > key:
                t_parent.left = t
            else:
                t_parent.right = t
            return t
        if key == t.key:
            return t
        
        if key < t.key:
            #print(""ddd"", key, t.key, key < t.key)
            #print(self._insert(t.left, key, priority, t_parent))
            t.left = self._insert(t.left, key, priority, t)
            if t.priority < t.left.priority:
                t = self.right_rotate(t)
        else:
            #print(""siu"", t.right, t.key)
            #print(self._insert(t.right, key, priority, t_parent))
            t.right = self._insert(t.right, key, priority, t)
            if t.priority < t.right.priority:
                t = self.left_rotate(t)
        #print(""a"", t.key, t_parent.key)
        return t
    
    def delete(self, t: Node, key: int):
        if t == None:
            return None
        if key < t.key:
            t.left = self.delete(t.left, key)
        elif key > t.key:
            t.right = self.delete(t.right, key)
        else:
            return self._delete(t, key)
        return t
    
    def _delete(self, t: Node, key):
        if t.left == None and t.right == None:
            return None
        elif t.left == None:
            t = self.left_rotate(t)
        elif t.right == None:
            t = self.right_rotate(t)
        else:
            if t.left.priority > t.right.priority:
                t = self.right_rotate(t)
            else:
                t = self.left_rotate(t)
        return self.delete(t, key)
    
    def find(self, k: int) -> Node:
        """"""
        探索 O(h)
        """"""
        node = self.root
        while node != None and node.key != k:
            if node.key < k:
                node = node.right
            else:
                node = node.left
        return node
    
    def inorder(self, left: Node, root: Node, right: Node) -> list:
        """"""
        先行順巡回 O(N)
        """"""
        if left != None and right != None:
            left = self.inorder(left.left, left, left.right)
            right = self.inorder(right.left, right, right.right)
            return left + [root] + right
        elif left != None and right == None:
            left = self.inorder(left.left, left, left.right)
            return left + [root]
        elif left == None and right != None:
            right = self.inorder(right.left, right, right.right)
            return [root] + right
        else:
            return [root]
    
    def print_inorder(self) -> list:
        #print(self.root)
        inorder_list = self.inorder(self.root.left, self.root, self.root.right)
        ans = []
        for node in inorder_list:
            ans.append(node.key)
        return ans
    
    def preorder(self, left: Node, root: Node, right: Node) -> list:
        """"""
        中間順巡回 O(N)
        """"""
        if left != None and right != None:
            left = self.preorder(left.left, left, left.right)
            right = self.preorder(right.left, right, right.right)
            return [root] + left + right
        elif left != None and right == None:
            left = self.preorder(left.left, left, left.right)
            return [root] + left
        elif left == None and right != None:
            right = self.preorder(right.left, right, right.right)
            return [root] + right
        else:
            return [root]
        
    def print_preorder(self) -> list:
        preorder_list = self.preorder(self.root.left, self.root, self.root.right)
        ans = []
        for node in preorder_list:
            ans.append(node.key)
        return ans
    
    def postorder(self, left: Node, root: Node, right: Node) -> list:
        """"""
        後行順巡回 O(N)
        """"""
        if left != None and right != None:
            left = self.postorder(left.left, left, left.right)
            right = self.postorder(right.left, right, right.right)
            return left + right + [root]
        elif left != None and right == None:
            left = self.postorder(left.left, left, left.right)
            return left + [root]
        elif left == None and right != None:
            right = self.postorder(right.left, right, right.right)
            return right + [root]
        else:
            return [root]
        
    def print_postorder(self) -> list:
        postorder_list = self.postorder(self.root.left, self.root, self.root.right)
        ans = []
        for node in postorder_list:
            ans.append(node.key)
        return ans

if __name__==""__main__"":
    Tr = Treap()
    n = int(input())
    for i in range(n):
        mei, *key = input().split()
        if mei == ""insert"":
            Tr.insert(int(key[0]), int(key[1]))
        elif mei == ""print"":
            print("""", *Tr.print_inorder())
            print("""", *Tr.print_preorder())
        elif mei == ""find"":
            ans = Tr.find(int(key[0]))
            if ans == None:
                print(""no"")
            else:
                print(""yes"")
        elif mei == ""delete"":
            Tr.delete(Tr.root, int(key[0]))
"
5498350,ALDS1_8_D,"from collections import deque
import sys
readline = sys.stdin.readline
write = sys.stdout.write

def rotate(nd, d):
    c = nd[d]
    if d:
        nd[1] = c[0]
        c[0] = nd
    else:
        nd[0] = c[1]
        c[1] = nd
    return c


root = None
def insert(val, pri):
    global root
    st = []
    dr = []
    x = root
    while x:
        st.append(x)
        if x[2] == val:
            return
        d = (x[2] < val)
        dr.append(d)
        x = x[d]
    nd = [None, None, val, pri]
    while st:
        x = st.pop(); d = dr.pop()
        c = x[d] = nd
        if x[3] >= c[3]:
            break
        rotate(x, d)
    else:
        root = nd

def __delete(nd):
    st = []; dr = []
    while nd[0] or nd[1]:
        l = nd[0]; r = nd[1]
        d = (l[3] <= r[3]) if l and r else (l is None)
        st.append(rotate(nd, d))
        dr.append(d ^ 1)
    nd = x = None
    while st:
        nd = x; x = st.pop(); d = dr.pop()
        x[d] = nd
    return x

def delete(val):
    global root
    x = root

    y = None
    while x:
        if val == x[2]:
            break
        y = x; d = (x[2] < val)
        x = x[d]
    else:
        return

    if y:
        y[d] = __delete(x)
    else:
        root = __delete(x)

def find(val):
    x = root
    while x:
        if val == x[2]:
            return 1
        x = x[x[2] < val]
    return 0

def debug():
    s0 = [""""]
    s1 = [""""]

    def dfs(nd):
        v = str(nd[2])
        s0.append(v)
        if nd[0]:
            dfs(nd[0])
        s1.append(v)
        if nd[1]:
            dfs(nd[1])
    dfs(root)
    return "" "".join(s1), "" "".join(s0)


M = int(readline())
ans = []
for m in range(M):
    cmd, *V, = readline().split()
    if cmd == ""print"":
        ans.extend(debug())
    elif cmd == ""find"":
        ans.append(""yes"" if find(int(V[0])) else ""no"")
    elif cmd == ""delete"":
        delete(int(V[0]))
    else:
        val, pri = map(int, V)
        insert(val, pri)
write(""\n"".join(ans))
write(""\n"")


"
3185647,ALDS1_8_D,"from collections import deque
import sys
readline = sys.stdin.readline
write = sys.stdout.write

def rotate(nd, d):
    c = nd[d]
    if d:
        nd[1] = c[0]
        c[0] = nd
    else:
        nd[0] = c[1]
        c[1] = nd
    return c


root = None
def insert(val, pri):
    global root
    st = []
    dr = []
    x = root
    while x:
        st.append(x)
        if x[2] == val:
            return
        d = (x[2] < val)
        dr.append(d)
        x = x[d]
    nd = [None, None, val, pri]
    while st:
        x = st.pop(); d = dr.pop()
        c = x[d] = nd
        if x[3] >= c[3]:
            break
        rotate(x, d)
    else:
        root = nd

def __delete(nd):
    st = []; dr = []
    while nd[0] or nd[1]:
        l = nd[0]; r = nd[1]
        d = (l[3] <= r[3]) if l and r else (l is None)
        st.append(rotate(nd, d))
        dr.append(d ^ 1)
    nd = x = None
    while st:
        nd = x; x = st.pop(); d = dr.pop()
        x[d] = nd
    return x

def delete(val):
    global root
    x = root

    y = None
    while x:
        if val == x[2]:
            break
        y = x; d = (x[2] < val)
        x = x[d]
    else:
        return

    if y:
        y[d] = __delete(x)
    else:
        root = __delete(x)

def find(val):
    x = root
    while x:
        if val == x[2]:
            return 1
        x = x[x[2] < val]
    return 0

def debug():
    s0 = [""""]
    s1 = [""""]

    def dfs(nd):
        v = str(nd[2])
        s0.append(v)
        if nd[0]:
            dfs(nd[0])
        s1.append(v)
        if nd[1]:
            dfs(nd[1])
    dfs(root)
    return "" "".join(s1), "" "".join(s0)


M = int(readline())
ans = []
for m in range(M):
    cmd, *V, = readline().split()
    if cmd == ""print"":
        ans.extend(debug())
    elif cmd == ""find"":
        ans.append(""yes"" if find(int(V[0])) else ""no"")
    elif cmd == ""delete"":
        delete(int(V[0]))
    else:
        val, pri = map(int, V)
        insert(val, pri)
write(""\n"".join(ans))
write(""\n"")

"
3986095,ALDS1_8_D,"from collections import deque
import sys
readline = sys.stdin.readline
write = sys.stdout.write

def rotate(nd, d):
    c = nd[d]
    if d:
        nd[1] = c[0]
        c[0] = nd
    else:
        nd[0] = c[1]
        c[1] = nd
    return c


root = None
def insert(val, pri):
    global root
    st = []
    dr = []
    x = root
    while x:
        st.append(x)
        if x[2] == val:
            return
        d = (x[2] < val)
        dr.append(d)
        x = x[d]
    nd = [None, None, val, pri]
    while st:
        x = st.pop(); d = dr.pop()
        c = x[d] = nd
        if x[3] >= c[3]:
            break
        rotate(x, d)
    else:
        root = nd

def __delete(nd):
    st = []; dr = []
    while nd[0] or nd[1]:
        l = nd[0]; r = nd[1]
        d = (l[3] <= r[3]) if l and r else (l is None)
        st.append(rotate(nd, d))
        dr.append(d ^ 1)
    nd = x = None
    while st:
        nd = x; x = st.pop(); d = dr.pop()
        x[d] = nd
    return x

def delete(val):
    global root
    x = root

    y = None
    while x:
        if val == x[2]:
            break
        y = x; d = (x[2] < val)
        x = x[d]
    else:
        return

    if y:
        y[d] = __delete(x)
    else:
        root = __delete(x)

def find(val):
    x = root
    while x:
        if val == x[2]:
            return 1
        x = x[x[2] < val]
    return 0

def debug():
    s0 = [""""]
    s1 = [""""]

    def dfs(nd):
        v = str(nd[2])
        s0.append(v)
        if nd[0]:
            dfs(nd[0])
        s1.append(v)
        if nd[1]:
            dfs(nd[1])
    dfs(root)
    return "" "".join(s1), "" "".join(s0)


M = int(readline())
ans = []
for m in range(M):
    cmd, *V, = readline().split()
    if cmd == ""print"":
        ans.extend(debug())
    elif cmd == ""find"":
        ans.append(""yes"" if find(int(V[0])) else ""no"")
    elif cmd == ""delete"":
        delete(int(V[0]))
    else:
        val, pri = map(int, V)
        insert(val, pri)
write(""\n"".join(ans))
write(""\n"")


"
4508015,ALDS1_8_D,"from collections import deque
import sys
readline = sys.stdin.readline
write = sys.stdout.write

def rotate(nd, d):
    c = nd[d]
    if d:
        nd[1] = c[0]
        c[0] = nd
    else:
        nd[0] = c[1]
        c[1] = nd
    return c


root = None
def insert(val, pri):
    global root
    st = []
    dr = []
    x = root
    while x:
        st.append(x)
        if x[2] == val:
            return
        d = (x[2] < val)
        dr.append(d)
        x = x[d]
    nd = [None, None, val, pri]
    while st:
        x = st.pop(); d = dr.pop()
        c = x[d] = nd
        if x[3] >= c[3]:
            break
        rotate(x, d)
    else:
        root = nd

def __delete(nd):
    st = []; dr = []
    while nd[0] or nd[1]:
        l = nd[0]; r = nd[1]
        d = (l[3] <= r[3]) if l and r else (l is None)
        st.append(rotate(nd, d))
        dr.append(d ^ 1)
    nd = x = None
    while st:
        nd = x; x = st.pop(); d = dr.pop()
        x[d] = nd
    return x

def delete(val):
    global root
    x = root

    y = None
    while x:
        if val == x[2]:
            break
        y = x; d = (x[2] < val)
        x = x[d]
    else:
        return

    if y:
        y[d] = __delete(x)
    else:
        root = __delete(x)

def find(val):
    x = root
    while x:
        if val == x[2]:
            return 1
        x = x[x[2] < val]
    return 0

def debug():
    s0 = [""""]
    s1 = [""""]

    def dfs(nd):
        v = str(nd[2])
        s0.append(v)
        if nd[0]:
            dfs(nd[0])
        s1.append(v)
        if nd[1]:
            dfs(nd[1])
    dfs(root)
    return "" "".join(s1), "" "".join(s0)


M = int(readline())
ans = []
for m in range(M):
    cmd, *V, = readline().split()
    if cmd == ""print"":
        ans.extend(debug())
    elif cmd == ""find"":
        ans.append(""yes"" if find(int(V[0])) else ""no"")
    elif cmd == ""delete"":
        delete(int(V[0]))
    else:
        val, pri = map(int, V)
        insert(val, pri)
write(""\n"".join(ans))
write(""\n"")
"
6318096,ALDS1_8_D,"from collections import deque
import sys
readline = sys.stdin.readline
write = sys.stdout.write

def rotate(nd, d):
    c = nd[d]
    if d:
        nd[1] = c[0]
        c[0] = nd
    else:
        nd[0] = c[1]
        c[1] = nd
    return c


root = None
def insert(val, pri):
    global root
    st = []
    dr = []
    x = root
    while x:
        st.append(x)
        if x[2] == val:
            return
        d = (x[2] < val)
        dr.append(d)
        x = x[d]
    nd = [None, None, val, pri]
    while st:
        x = st.pop(); d = dr.pop()
        c = x[d] = nd
        if x[3] >= c[3]:
            break
        rotate(x, d)
    else:
        root = nd

def __delete(nd):
    st = []; dr = []
    while nd[0] or nd[1]:
        l = nd[0]; r = nd[1]
        d = (l[3] <= r[3]) if l and r else (l is None)
        st.append(rotate(nd, d))
        dr.append(d ^ 1)
    nd = x = None
    while st:
        nd = x; x = st.pop(); d = dr.pop()
        x[d] = nd
    return x

def delete(val):
    global root
    x = root

    y = None
    while x:
        if val == x[2]:
            break
        y = x; d = (x[2] < val)
        x = x[d]
    else:
        return

    if y:
        y[d] = __delete(x)
    else:
        root = __delete(x)

def find(val):
    x = root
    while x:
        if val == x[2]:
            return 1
        x = x[x[2] < val]
    return 0

def debug():
    s0 = [""""]
    s1 = [""""]

    def dfs(nd):
        v = str(nd[2])
        s0.append(v)
        if nd[0]:
            dfs(nd[0])
        s1.append(v)
        if nd[1]:
            dfs(nd[1])
    dfs(root)
    return "" "".join(s1), "" "".join(s0)


M = int(readline())
ans = []
for m in range(M):
    cmd, *V, = readline().split()
    if cmd == ""print"":
        ans.extend(debug())
    elif cmd == ""find"":
        ans.append(""yes"" if find(int(V[0])) else ""no"")
    elif cmd == ""delete"":
        delete(int(V[0]))
    else:
        val, pri = map(int, V)
        insert(val, pri)
write(""\n"".join(ans))
write(""\n"")
"
6416356,ALDS1_8_D,"""""""
Treep
""""""
import sys
readline=sys.stdin.readline
write=sys.stdout.write

def rotate(nd,d):
    c=nd[d]
    if d:
        nd[1]=c[0]
        c[0]=nd
    else:
        nd[0]=c[1]
        c[1]=nd
    return c

root=None
def insert(val,pri):
    global root
    st,dr=[],[]
    x=root
    while x:
        st.append(x)
        if x[2]==val:
            return
        d=(x[2]<val)
        dr.append(d)
        x=x[d]
    nd=[None,None,val,pri]
    while st:
        x=st.pop()
        d=dr.pop()
        c=x[d]=nd
        if x[3]>=c[3]:
            break
        rotate(x,d)
    else:
        root=nd

def __delete(nd):
    st,dr=[],[]
    while nd[0] or nd[1]:
        l,r=nd[0],nd[1]
        d=(l[3]<=r[3]) if l and r else (l is None)
        st.append(rotate(nd,d))
        dr.append(d^1)
    nd=x=None
    while st:
        nd=x
        x=st.pop()
        d=dr.pop()
        x[d]=nd
    return x

def delete(val):
    global root
    x=root
    y=None
    while x:
        if val==x[2]:
            break
        y=x
        d=(x[2]<val)
        x=x[d]
    else:
        return

    if y:
        y[d]=__delete(x)
    else:
        root=__delete(x)

def find(val):
    x=root
    while x:
        if val==x[2]:
            return 1
        x=x[x[2]<val]
    return 0

def debug():
    s0,s1=[''],['']

    def dfs(nd):
        v=str(nd[2])
        s0.append(v)
        if nd[0]:
            dfs(nd[0])
        s1.append(v)
        if nd[1]:
            dfs(nd[1])
    dfs(root)
    return ' '.join(s1),' '.join(s0)

M=int(readline())
ans=[]
for m in range(M):
    cmd,*V=readline().split()
    if cmd=='print':
        ans.extend(debug())
    elif cmd=='find':
        ans.append('yes' if find(int(V[0])) else 'no')
    elif cmd=='delete':
        delete(int(V[0]))
    else:
        val,pri=map(int,V)
        insert(val,pri)
write(""\n"".join(ans))
write(""\n"")
"
7610226,ALDS1_8_D,"from collections import deque
import sys
readline = sys.stdin.readline
write = sys.stdout.write

def rotate(nd, d):
    c = nd[d]
    if d:
        nd[1] = c[0]
        c[0] = nd
    else:
        nd[0] = c[1]
        c[1] = nd
    return c


root = None
def insert(val, pri):
    global root
    st = []
    dr = []
    x = root
    while x:
        st.append(x)
        if x[2] == val:
            return
        d = (x[2] < val)
        dr.append(d)
        x = x[d]
    nd = [None, None, val, pri]
    while st:
        x = st.pop(); d = dr.pop()
        c = x[d] = nd
        if x[3] >= c[3]:
            break
        rotate(x, d)
    else:
        root = nd

def __delete(nd):
    st = []; dr = []
    while nd[0] or nd[1]:
        l = nd[0]; r = nd[1]
        d = (l[3] <= r[3]) if l and r else (l is None)
        st.append(rotate(nd, d))
        dr.append(d ^ 1)
    nd = x = None
    while st:
        nd = x; x = st.pop(); d = dr.pop()
        x[d] = nd
    return x

def delete(val):
    global root
    x = root

    y = None
    while x:
        if val == x[2]:
            break
        y = x; d = (x[2] < val)
        x = x[d]
    else:
        return

    if y:
        y[d] = __delete(x)
    else:
        root = __delete(x)

def find(val):
    x = root
    while x:
        if val == x[2]:
            return 1
        x = x[x[2] < val]
    return 0

def debug():
    s0 = [""""]
    s1 = [""""]

    def dfs(nd):
        v = str(nd[2])
        s0.append(v)
        if nd[0]:
            dfs(nd[0])
        s1.append(v)
        if nd[1]:
            dfs(nd[1])
    dfs(root)
    return "" "".join(s1), "" "".join(s0)


M = int(readline())
ans = []
for m in range(M):
    cmd, *V, = readline().split()
    if cmd == ""print"":
        ans.extend(debug())
    elif cmd == ""find"":
        ans.append(""yes"" if find(int(V[0])) else ""no"")
    elif cmd == ""delete"":
        delete(int(V[0]))
    else:
        val, pri = map(int, V)
        insert(val, pri)
write(""\n"".join(ans))
write(""\n"")



"
4254252,ALDS1_8_D,"from collections import deque
import sys
readline = sys.stdin.readline
write = sys.stdout.write

def rotate(nd, d):
    c = nd[d]
    if d:
        nd[1] = c[0]
        c[0] = nd
    else:
        nd[0] = c[1]
        c[1] = nd
    return c


root = None
def insert(val, pri):
    global root
    st = []
    dr = []
    x = root
    while x:
        st.append(x)
        if x[2] == val:
            return
        d = (x[2] < val)
        dr.append(d)
        x = x[d]
    nd = [None, None, val, pri]
    while st:
        x = st.pop(); d = dr.pop()
        c = x[d] = nd
        if x[3] >= c[3]:
            break
        rotate(x, d)
    else:
        root = nd

def __delete(nd):
    st = []; dr = []
    while nd[0] or nd[1]:
        l = nd[0]; r = nd[1]
        d = (l[3] <= r[3]) if l and r else (l is None)
        st.append(rotate(nd, d))
        dr.append(d ^ 1)
    nd = x = None
    while st:
        nd = x; x = st.pop(); d = dr.pop()
        x[d] = nd
    return x

def delete(val):
    global root
    x = root

    y = None
    while x:
        if val == x[2]:
            break
        y = x; d = (x[2] < val)
        x = x[d]
    else:
        return

    if y:
        y[d] = __delete(x)
    else:
        root = __delete(x)

def find(val):
    x = root
    while x:
        if val == x[2]:
            return 1
        x = x[x[2] < val]
    return 0

def debug():
    s0 = [""""]
    s1 = [""""]

    def dfs(nd):
        v = str(nd[2])
        s0.append(v)
        if nd[0]:
            dfs(nd[0])
        s1.append(v)
        if nd[1]:
            dfs(nd[1])
    dfs(root)
    return "" "".join(s1), "" "".join(s0)


M = int(readline())
ans = []
for m in range(M):
    cmd, *V, = readline().split()
    if cmd == ""print"":
        ans.extend(debug())
    elif cmd == ""find"":
        ans.append(""yes"" if find(int(V[0])) else ""no"")
    elif cmd == ""delete"":
        delete(int(V[0]))
    else:
        val, pri = map(int, V)
        insert(val, pri)
write(""\n"".join(ans))
write(""\n"")


"
7618308,ALDS1_8_D,"from collections import deque
import sys
readline = sys.stdin.readline
write = sys.stdout.write

def rotate(nd, d):
    c = nd[d]
    if d:
        nd[1] = c[0]
        c[0] = nd
    else:
        nd[0] = c[1]
        c[1] = nd
    return c


root = None
def insert(val, pri):
    global root
    st = []
    dr = []
    x = root
    while x:
        st.append(x)
        if x[2] == val:
            return
        d = (x[2] < val)
        dr.append(d)
        x = x[d]
    nd = [None, None, val, pri]
    while st:
        x = st.pop(); d = dr.pop()
        c = x[d] = nd
        if x[3] >= c[3]:
            break
        rotate(x, d)
    else:
        root = nd

def __delete(nd):
    st = []; dr = []
    while nd[0] or nd[1]:
        l = nd[0]; r = nd[1]
        d = (l[3] <= r[3]) if l and r else (l is None)
        st.append(rotate(nd, d))
        dr.append(d ^ 1)
    nd = x = None
    while st:
        nd = x; x = st.pop(); d = dr.pop()
        x[d] = nd
    return x

def delete(val):
    global root
    x = root

    y = None
    while x:
        if val == x[2]:
            break
        y = x; d = (x[2] < val)
        x = x[d]
    else:
        return

    if y:
        y[d] = __delete(x)
    else:
        root = __delete(x)

def find(val):
    x = root
    while x:
        if val == x[2]:
            return 1
        x = x[x[2] < val]
    return 0

def debug():
    s0 = [""""]
    s1 = [""""]

    def dfs(nd):
        v = str(nd[2])
        s0.append(v)
        if nd[0]:
            dfs(nd[0])
        s1.append(v)
        if nd[1]:
            dfs(nd[1])
    dfs(root)
    return "" "".join(s1), "" "".join(s0)


M = int(readline())
ans = []
for m in range(M):
    cmd, *V, = readline().split()
    if cmd == ""print"":
        ans.extend(debug())
    elif cmd == ""find"":
        ans.append(""yes"" if find(int(V[0])) else ""no"")
    elif cmd == ""delete"":
        delete(int(V[0]))
    else:
        val, pri = map(int, V)
        insert(val,pri)
write(""\n"".join(ans))
write(""\n"")
"
6955794,ALDS1_8_D,"from collections import deque
import sys
readline = sys.stdin.readline
write = sys.stdout.write

def rotate(nd, d):
    c = nd[d]
    if d:
        nd[1] = c[0]
        c[0] = nd
    else:
        nd[0] = c[1]
        c[1] = nd
    return c


root = None
def insert(val, pri):
    global root
    st = []
    dr = []
    x = root
    while x:
        st.append(x)
        if x[2] == val:
            return
        d = (x[2] < val)
        dr.append(d)
        x = x[d]
    nd = [None, None, val, pri]
    while st:
        x = st.pop(); d = dr.pop()
        c = x[d] = nd
        if x[3] >= c[3]:
            break
        rotate(x, d)
    else:
        root = nd

def __delete(nd):
    st = []; dr = []
    while nd[0] or nd[1]:
        l = nd[0]; r = nd[1]
        d = (l[3] <= r[3]) if l and r else (l is None)
        st.append(rotate(nd, d))
        dr.append(d ^ 1)
    nd = x = None
    while st:
        nd = x; x = st.pop(); d = dr.pop()
        x[d] = nd
    return x

def delete(val):
    global root
    x = root

    y = None
    while x:
        if val == x[2]:
            break
        y = x; d = (x[2] < val)
        x = x[d]
    else:
        return

    if y:
        y[d] = __delete(x)
    else:
        root = __delete(x)

def find(val):
    x = root
    while x:
        if val == x[2]:
            return 1
        x = x[x[2] < val]
    return 0

def debug():
    s0 = [""""]
    s1 = [""""]

    def dfs(nd):
        v = str(nd[2])
        s0.append(v)
        if nd[0]:
            dfs(nd[0])
        s1.append(v)
        if nd[1]:
            dfs(nd[1])
    dfs(root)
    return "" "".join(s1), "" "".join(s0)


M = int(readline())
ans = []
for m in range(M):
    cmd, *V, = readline().split()
    if cmd == ""print"":
        ans.extend(debug())
    elif cmd == ""find"":
        ans.append(""yes"" if find(int(V[0])) else ""no"")
    elif cmd == ""delete"":
        delete(int(V[0]))
    else:
        val, pri = map(int, V)
        insert(val, pri)
write(""\n"".join(ans))
write(""\n"")
"
8149514,ALDS1_8_D,"# Treap
# ネットの解答参照
# 全く分からなかった

from collections import deque
import sys
readline = sys.stdin.readline
write = sys.stdout.write

def rotate(nd, d):
    c = nd[d]
    if d:
        nd[1] = c[0]
        c[0] = nd
    else:
        nd[0] = c[1]
        c[1] = nd
    return c


root = None
def insert(val, pri):
    global root
    st = []
    dr = []
    x = root
    while x:
        st.append(x)
        if x[2] == val:
            return
        d = (x[2] < val)
        dr.append(d)
        x = x[d]
    nd = [None, None, val, pri]
    while st:
        x = st.pop(); d = dr.pop()
        c = x[d] = nd
        if x[3] >= c[3]:
            break
        rotate(x, d)
    else:
        root = nd

def __delete(nd):
    st = []; dr = []
    while nd[0] or nd[1]:
        l = nd[0]; r = nd[1]
        d = (l[3] <= r[3]) if l and r else (l is None)
        st.append(rotate(nd, d))
        dr.append(d ^ 1)
    nd = x = None
    while st:
        nd = x; x = st.pop(); d = dr.pop()
        x[d] = nd
    return x

def delete(val):
    global root
    x = root

    y = None
    while x:
        if val == x[2]:
            break
        y = x; d = (x[2] < val)
        x = x[d]
    else:
        return

    if y:
        y[d] = __delete(x)
    else:
        root = __delete(x)

def find(val):
    x = root
    while x:
        if val == x[2]:
            return 1
        x = x[x[2] < val]
    return 0

def debug():
    s0 = [""""]
    s1 = [""""]

    def dfs(nd):
        v = str(nd[2])
        s0.append(v)
        if nd[0]:
            dfs(nd[0])
        s1.append(v)
        if nd[1]:
            dfs(nd[1])
    dfs(root)
    return "" "".join(s1), "" "".join(s0)


M = int(readline())
ans = []
for m in range(M):
    cmd, *V, = readline().split()
    if cmd == ""print"":
        ans.extend(debug())
    elif cmd == ""find"":
        ans.append(""yes"" if find(int(V[0])) else ""no"")
    elif cmd == ""delete"":
        delete(int(V[0]))
    else:
        val, pri = map(int, V)
        insert(val, pri)
write(""\n"".join(ans))
write(""\n"")
"
7061543,ALDS1_8_D,"class Treap:
    def __init__(self):
        self.root = None
        self.tree = dict()
        # tree[node] = [priority, parent, left, right]

    def _rotate(self, k):
        p = self.tree[k][1]
        if p is None:
            return
        pp = self.tree[p][1]
        if pp is None:
            pass
        elif p < pp:
            self.tree[pp][2] = k
        else:
            self.tree[pp][3] = k

        if k < p:
            c = self.tree[k][3]
            self.tree[p][2] = c
            self.tree[k][3] = p
            if c:
                self.tree[c][1] = p
        else:
            c = self.tree[k][2]
            self.tree[p][3] = c
            self.tree[k][2] = p
            if c:
                self.tree[c][1] = p

        self.tree[k][1] = pp
        self.tree[p][1] = k

        if p == self.root:
            self.root = k

    def insert(self, k, p):
        parent = None
        y = self.root
        while y is not None:
            parent = y
            if k < y:
                y = self.tree[y][2]
            else:
                y = self.tree[y][3]

        self.tree[k] = [p, parent, None, None]
        if parent is None:
            self.root = k
        elif k < parent:
            self.tree[parent][2] = k
        else:
            self.tree[parent][3] = k

        while self.tree[k][1] is not None:
            p = self.tree[k][1]
            if self.tree[k][0] < self.tree[p][0]:
                break
            else:
                self._rotate(k)

    def find(self, k):
        target = self.root
        while target is not None:
            if target == k:
                return True
            elif k < target:
                target = self.tree[target][2]
            else:
                target = self.tree[target][3]

        return False

    def delete(self, k):
        if self.find(k):
            while True:
                if self.tree[k][2] is None and self.tree[k][3] is None:
                    break

                elif self.tree[k][3] is None:
                    self._rotate(self.tree[k][2])

                elif self.tree[k][2] is None:
                    self._rotate(self.tree[k][3])

                else:
                    L, R = self.tree[k][2], self.tree[k][3]
                    if self.tree[L][0] > self.tree[R][0]:
                        self._rotate(L)
                    else:
                        self._rotate(R)

            p = self.tree[k][1]
            self.tree[k][1] = None
            if k < p:
                self.tree[p][2] = None
            else:
                self.tree[p][3] = None

    def print_tree(self):
        def tree_walk(now):
            nonlocal inorder_tree, preorder_tree
            if now is None:
                return
            preorder_tree.append(now)
            tree_walk(self.tree[now][2])
            inorder_tree.append(now)
            tree_walk(self.tree[now][3])

        inorder_tree = []
        preorder_tree = []
        tree_walk(self.root)
        print("""", *inorder_tree)
        print("""", *preorder_tree)


tr = Treap()
for _ in range(int(input())):
    com, *arg = input().split()
    if com == ""insert"":
        tr.insert(int(arg[0]), int(arg[1]))

    elif com == ""find"":
        if tr.find(int(arg[0])):
            print(""yes"")
        else:
            print(""no"")

    elif com == ""delete"":
        tr.delete(int(arg[0]))

    else:
        tr.print_tree()

"
6836778,ALDS1_8_D,"from collections import deque
import sys
readline = sys.stdin.readline
write = sys.stdout.write

def rotate(nd, d):
    c = nd[d]
    if d:
        nd[1] = c[0]
        c[0] = nd
    else:
        nd[0] = c[1]
        c[1] = nd
    return c


root = None
def insert(val, pri):
    global root
    st = []
    dr = []
    x = root
    while x:
        st.append(x)
        if x[2] == val:
            return
        d = (x[2] < val)
        dr.append(d)
        x = x[d]
    nd = [None, None, val, pri]
    while st:
        x = st.pop(); d = dr.pop()
        c = x[d] = nd
        if x[3] >= c[3]:
            break
        rotate(x, d)
    else:
        root = nd

def __delete(nd):
    st = []; dr = []
    while nd[0] or nd[1]:
        l = nd[0]; r = nd[1]
        d = (l[3] <= r[3]) if l and r else (l is None)
        st.append(rotate(nd, d))
        dr.append(d ^ 1)
    nd = x = None
    while st:
        nd = x; x = st.pop(); d = dr.pop()
        x[d] = nd
    return x

def delete(val):
    global root
    x = root

    y = None
    while x:
        if val == x[2]:
            break
        y = x; d = (x[2] < val)
        x = x[d]
    else:
        return

    if y:
        y[d] = __delete(x)
    else:
        root = __delete(x)

def find(val):
    x = root
    while x:
        if val == x[2]:
            return 1
        x = x[x[2] < val]
    return 0

def debug():
    s0 = [""""]
    s1 = [""""]

    def dfs(nd):
        v = str(nd[2])
        s0.append(v)
        if nd[0]:
            dfs(nd[0])
        s1.append(v)
        if nd[1]:
            dfs(nd[1])
    dfs(root)
    return "" "".join(s1), "" "".join(s0)


M = int(readline())
ans = []
for m in range(M):
    cmd, *V, = readline().split()
    if cmd == ""print"":
        ans.extend(debug())
    elif cmd == ""find"":
        ans.append(""yes"" if find(int(V[0])) else ""no"")
    elif cmd == ""delete"":
        delete(int(V[0]))
    else:
        val, pri = map(int, V)
        insert(val, pri)
write(""\n"".join(ans))
write(""\n"")
"
3582916,ALDS1_8_D,"import sys
import time
input = sys.stdin.readline

def left_rot(node):
    s = node['right'].copy()
    node['right'] = s['left']#.copy()
    s['left'] = node
    return s

def right_rot(node):
    s = node['left'].copy()
    node['left'] = s['right']#.copy()
    s['right'] = node
    return s

def insert(node,k,p):
    if(node is None):
        child = {
            'left' : None,
            'right' : None,
            'key' : k,
            'priority' : p}
        return child
    if(k == node['key']):
        return node
    # Left side
    if(k < node['key']):
        node['left'] = insert(node['left'],k,p)
        #追加したらあとは優先度による回転を行う
        if(node['priority'] < node['left']['priority']):
            node = right_rot(node)
    # Right side
    else:
        node['right'] = insert(node['right'],k,p)
        #追加したらあとは以下略
        if(node['priority'] < node['right']['priority']):
            node = left_rot(node)

    return node

def find(node, k):
    if(node is None):
        return 'no'
    if(node['key'] == k):
        return 'yes'
    if(k < node['key']):
        return find(node['left'],k)
    else:
        return find(node['right'],k)

def delete(node, k):
    if(node is None):
        return None

    if(node['key'] == k):
        if(node['left'] is None and node['right'] is None):
            return None
        elif(node['left'] is None):
            node = left_rot(node)
        elif(node['right'] is None):
            node = right_rot(node)
        else:
            if(node['left']['priority'] > node['right']['priority']):
                node = right_rot(node)
            else:
                node = left_rot(node)
        return delete(node, k)
    if(k < node['key']):
        node['left'] = delete(node['left'], k)
    else:
        node['right'] = delete(node['right'], k)

    return node

def print_treap(node,values):
    if(node is None):
        return values
    values.append(node['key'])
    values = print_treap(node['left'],values)
    values = print_treap(node['right'],values)
    return values

num = int(input())
req = [input().split() for _ in range(num)]
node = None
values = []
for q in req:
    if(q[0] == 'insert'):
        node = insert(node, int(q[1]),int(q[2]))
    elif(q[0] == 'find'):
        print(find(node,int(q[1])))
    elif(q[0] == 'delete'):
        node = delete(node, int(q[1]))
    else:
        print_treap(node, values)
        print("" ""+"" "".join(map(str, sorted(values))))
        print("" ""+"" "".join(map(str, values)))
        values.clear()

"
8072603,ALDS1_8_D,"if __name__ == '__main__':
    def rotate(nd, d):
        c = nd[d]
        if d:
            nd[1] = c[0]
            c[0] = nd
        else:
            nd[0] = c[1]
            c[1] = nd
        return c

    t = None
    def insert(k, p):
        global t
        st = []
        dr = []
        x = t
        while x:
            st.append(x)
            if x[2] == k:
                return
            d = (x[2] < k)
            dr.append(d)
            x = x[d]
        nd = [None, None, k, p]
        while st:
            x = st.pop(); d = dr.pop()
            c = x[d] = nd
            if x[3] >= c[3]:
                break
            rotate(x, d)
        else:
            t = nd

    def _delete(nd):
        st = []; dr = []
        while nd[0] or nd[1]:
            l = nd[0]; r = nd[1]
            d = (l[3] <= r[3]) if l and r else (l is None)
            st.append(rotate(nd, d))
            dr.append(d ^ 1)
        nd = x = None
        while st:
            nd = x; x = st.pop(); d = dr.pop()
            x[d] = nd
        return x

    def delete(k):
        global t
        x = t

        y = None
        while x:
            if k == x[2]:
                break
            y = x; d = (x[2] < k)
            x = x[d]
        else:
            return

        if y:
            y[d] = _delete(x)
        else:
            t = _delete(x)

    def find(k):
        x = t
        while x:
            if k == x[2]:
                return 1
            x = x[x[2] < k]
        return 0

    def _print():
        s0 = [""""]
        s1 = [""""]

        def dfs(nd):
            v = str(nd[2])
            s0.append(v)
            if nd[0]:
                dfs(nd[0])
            s1.append(v)
            if nd[1]:
                dfs(nd[1])
        dfs(t)
        return "" "".join(s1), "" "".join(s0)


    m = int(input())
    ans = []
    for _ in range(m):
        com, *val, = input().split()
        if com == ""print"":
            ans.extend(_print())
        elif com == ""find"":
            ans.append(""yes"" if find(int(val[0])) else ""no"")
        elif com == ""delete"":
            delete(int(val[0]))
        else:
            k, p = map(int, val)
            insert(k, p)
    for i in range(len(ans)):
        print(ans[i])
"
7520517,ALDS1_8_D,"class Treap:
    def __init__(self):
        self.root = None
        self.tree = dict()
        # tree[node] = [priority, parent, left, right]

    def _rotate(self, k):
        p = self.tree[k][1]
        if p is None:
            return
        pp = self.tree[p][1]
        if pp is None:
            pass
        elif p < pp:
            self.tree[pp][2] = k
        else:
            self.tree[pp][3] = k

        if k < p:
            c = self.tree[k][3]
            self.tree[p][2] = c
            self.tree[k][3] = p
            if c:
                self.tree[c][1] = p
        else:
            c = self.tree[k][2]
            self.tree[p][3] = c
            self.tree[k][2] = p
            if c:
                self.tree[c][1] = p

        self.tree[k][1] = pp
        self.tree[p][1] = k

        if p == self.root:
            self.root = k

    def insert(self, k, p):
        parent = None
        y = self.root
        while y is not None:
            parent = y
            if k < y:
                y = self.tree[y][2]
            else:
                y = self.tree[y][3]

        self.tree[k] = [p, parent, None, None]
        if parent is None:
            self.root = k
        elif k < parent:
            self.tree[parent][2] = k
        else:
            self.tree[parent][3] = k

        while self.tree[k][1] is not None:
            p = self.tree[k][1]
            if self.tree[k][0] < self.tree[p][0]:
                break
            else:
                self._rotate(k)

    def find(self, k):
        target = self.root
        while target is not None:
            if target == k:
                return True
            elif k < target:
                target = self.tree[target][2]
            else:
                target = self.tree[target][3]

        return False

    def delete(self, k):
        if self.find(k):
            while True:
                if self.tree[k][2] is None and self.tree[k][3] is None:
                    break

                elif self.tree[k][3] is None:
                    self._rotate(self.tree[k][2])

                elif self.tree[k][2] is None:
                    self._rotate(self.tree[k][3])

                else:
                    L, R = self.tree[k][2], self.tree[k][3]
                    if self.tree[L][0] > self.tree[R][0]:
                        self._rotate(L)
                    else:
                        self._rotate(R)

            p = self.tree[k][1]
            self.tree[k][1] = None
            if k < p:
                self.tree[p][2] = None
            else:
                self.tree[p][3] = None

    def print_tree(self):
        def tree_walk(now):
            nonlocal inorder_tree, preorder_tree
            if now is None:
                return
            preorder_tree.append(now)
            tree_walk(self.tree[now][2])
            inorder_tree.append(now)
            tree_walk(self.tree[now][3])

        inorder_tree = []
        preorder_tree = []
        tree_walk(self.root)
        print("""", *inorder_tree)
        print("""", *preorder_tree)


tr = Treap()
for i in range(int(input())):
    data = list(map(str, input().split()))
    if data[0] == ""print"":
        tr.print_tree()
    else:
        data[1] = int(data[1])
        if data[0] == ""insert"":
            data[2] = int(data[2])
            tr.insert(data[1], data[2])
        elif data[0] == ""delete"":
            tr.delete(data[1])
        elif data[0] == ""find"":
            if tr.find(data[1]):
                print(""yes"")
            else:
                print(""no"")
        else :
            pass


"
4177732,ALDS1_8_D,"import sys
input = sys.stdin.readline
print = sys.stdout.write

class Node:
    __slots__ = [""key"", ""priority"", ""left"", ""right""]
    def __init__(self, key, priority):
        self.key = key
        self.priority = priority
        self.left = None
        self.right = None
        
class Treap:
    def insert(self, node, key, priority):
        if node is None:
            return Node(key, priority)
        if key == node.key:
            return node
        if key < node.key:
            node.left = self.insert(node.left, key, priority)
            if node.priority < node.left.priority:
                node = right_rotate(node)
        else:
            node.right = self.insert(node.right, key, priority)
            if node.priority < node.right.priority:
                node = left_rotate(node)
        return node

    def delete(self, node, key):
        if node is None:
            return None
        if key < node.key:
            node.left = self.delete(node.left, key)
        elif key > node.key:
            node.right = self.delete(node.right, key)
        else:
            return self._delete(node, key)
        return node
    
    def _delete(self, node, key):
        if node.left is None and node.right is None:
            return None
        if node.left is None:
            node = left_rotate(node)
        elif node.right is None:
            node = right_rotate(node)
        else:
            if node.left.priority > node.right.priority:
                node = right_rotate(node)
            else:
                node = left_rotate(node)
        return self.delete(node, key)
    
    def find(self, node, key):
        if node is None:
            print(""no\n"")
            return
        while node:
            if node.key == key:
                print(""yes\n"")
                return
            node = node.left if key < node.key else node.right
        print(""no\n"")
        return
            

def right_rotate(node):
    child = node.left
    node.left, child.right = child.right, node
    return child

def left_rotate(node):
    child = node.right
    node.right, child.left = child.left, node
    return child

def print_preorder(node):
    print("" {}"".format(node.key))
    if node.left:
        print_preorder(node.left)
    if node.right:
        print_preorder(node.right)

def print_inorder(node):
    if node.left:
        print_inorder(node.left)
    print("" {}"".format(node.key))
    if node.right:
        print_inorder(node.right)

if __name__ == ""__main__"":
    n = int(input())
    treap = Treap()
    root = None
    for _ in range(n):
        operation, *num = input().split()
        if operation[0] == ""i"":
            root = treap.insert(root, int(num[0]), int(num[1]))
        elif operation[0] == ""f"":
            treap.find(root, int(num[0]))
        elif operation[0] == ""d"":
            root = treap.delete(root, int(num[0]))
        elif root is not None:
            print_inorder(root)
            print(""\n"")
            print_preorder(root)
            print(""\n"")
"
5065124,ALDS1_8_D,"class binary_tree:

    def __init__(self):
        self.root = -1
        self.num = 0
        self.pa = []
        self.chl = []
        self.chr = []
        self.contents = []
        self.priority = []
    
    def insert(self, x, y):

        self.contents.append(x)
        self.priority.append(y)
        ind = self.root
        ind_p = ind
        
        while ind != -1:
            ind_p = ind
            if x < self.contents[ind]:
                ind = self.chl[ind]
            else:
                ind = self.chr[ind]
        self.pa.append(ind_p)

        if ind_p == -1:
            self.root = self.num
        elif x < self.contents[ind_p]:
            self.chl[ind_p] = self.num
        else:
            self.chr[ind_p] = self.num

        self.chl.append(-1)
        self.chr.append(-1)

        ind = self.num

        while True:
            ind_p = self.pa[ind]
            if ind_p != -1:
                if self.priority[ind_p] < self.priority[ind]:
                    if self.chl[ind_p] == ind:
                        self.rotate_r(ind_p)
                    else:
                        self.rotate_l(ind_p)
                    continue
            break

        self.num += 1

    def print(self):
    
        for config in [""Inorder"", ""Preorder""]:

            btp_vlist = []
            ind = self.root
            btp_marked = [False] * self.num

            while ind != -1:
                
                if self.chl[ind] != -1 and not btp_marked[self.chl[ind]]:
                    if config == ""Preorder"":
                        btp_vlist.append(self.contents[ind])
                        btp_marked[ind] = True        
                    ind = self.chl[ind]

                elif self.chr[ind] != -1 and not btp_marked[self.chr[ind]]:
                    if self.chl[ind] == -1 and config == ""Preorder"":
                        btp_vlist.append(self.contents[ind])
                        btp_marked[ind] = True
                    if config == ""Inorder"":
                        btp_vlist.append(self.contents[ind])
                        btp_marked[ind] = True
                    ind = self.chr[ind]

                else:
                    if btp_marked[ind] == False:
                        btp_vlist.append(self.contents[ind])
                        btp_marked[ind] = True
                    ind = self.pa[ind]
            
            print("""", *btp_vlist)

    def find(self, x):

        ind = self.root

        while ind != -1:
            if self.contents[ind] > x:
                ind = self.chl[ind]
            elif self.contents[ind] < x:
                ind = self.chr[ind]
            else:
                return ind
        else:
            return -1

    def delete(self, x, ind=None):
        
        if ind is None:
            ind = self.find(x)

        if ind == -1:
            return False
        
        while True:
            ind_cr = self.chr[ind]
            ind_cl = self.chl[ind]
            if ind_cr != -1:
                if ind_cl != -1:
                    if self.priority[ind_cl] > self.priority[ind_cr]:
                        self.rotate_r(ind)
                    else:
                        self.rotate_l(ind)
                    continue
                else:
                    self.rotate_l(ind)
                    continue
            else:
                if ind_cl != -1:
                    self.rotate_r(ind)
                    continue
                else:
                    ind_p = self.pa[ind]        
                    if self.chl[ind_p] == ind:
                        self.chl[ind_p] = -1
                    else:
                        self.chr[ind_p] = -1
            break

    def rotate_r(self, ind_y):

        ind_x = self.chl[ind_y]
        ind_b = self.chr[ind_x]
        
        self.pa[ind_x] = self.pa[ind_y]
        self.chr[ind_x] = ind_y
        self.pa[ind_y] = ind_x
        self.chl[ind_y] = ind_b
        if ind_b != -1:
            self.pa[ind_b] = ind_y

        if self.pa[ind_x] != -1:
            ind_p = self.pa[ind_x]
            if self.chl[ind_p] == ind_y:
                self.chl[ind_p] = ind_x
            else:
                self.chr[ind_p] = ind_x
        else:
            self.root = ind_x

    def rotate_l(self, ind_x):

        ind_y = self.chr[ind_x]
        ind_b = self.chl[ind_y]
        
        self.pa[ind_y] = self.pa[ind_x]
        self.chl[ind_y] = ind_x
        self.pa[ind_x] = ind_y
        self.chr[ind_x] = ind_b
        if ind_b != -1:
            self.pa[ind_b] = ind_x

        if self.pa[ind_y] != -1:
            ind_p = self.pa[ind_y]
            if self.chl[ind_p] == ind_x:
                self.chl[ind_p] = ind_y
            else:
                self.chr[ind_p] = ind_y
        else:
            self.root = ind_y



def main():

    n = int(input())
    bt = binary_tree()

    for _ in range(n):
        query = input()

        if ""insert"" in query:
            _, x, y = query.split()
            x, y = int(x), int(y)
            bt.insert(x, y)

        elif ""print"" in query:
            bt.print()

        elif ""find"" in query:
            _, x = query.split()
            x = int(x)
            if bt.find(x) != -1:
                print(""yes"")
            else:
                print(""no"")
        
        elif ""delete"" in query:
            _, x = query.split()
            x = int(x)
            bt.delete(x)


main()
"
6820975,ALDS1_8_D,"def rotate(nd, d):
    c = nd[d]
    if d:
        nd[1] = c[0]
        c[0] = nd
    else:
        nd[0] = c[1]
        c[1] = nd
    return c


root = None
def insert(key, pri):
    global root
    st = []
    dr = []
    x = root
    while x:
        st.append(x)
        if x[2] == key:
            return
        d = (x[2] < key)
        dr.append(d)
        x = x[d]
    nd = [None, None, key, pri]
    while st:
        x = st.pop(); d = dr.pop()
        c = x[d] = nd
        if x[3] >= c[3]:
            break
        rotate(x, d)
    else:
        root = nd

def __delete(nd):
    st = []; dr = []
    while nd[0] or nd[1]:
        l = nd[0]; r = nd[1]
        d = (l[3] <= r[3]) if l and r else (l is None)
        st.append(rotate(nd, d))
        dr.append(d ^ 1)
    nd = x = None
    while st:
        nd = x; x = st.pop(); d = dr.pop()
        x[d] = nd
    return x

def delete(key):
    global root
    x = root

    y = None
    while x:
        if key == x[2]:
            break
        y = x; d = (x[2] < key)
        x = x[d]
    else:
        return

    if y:
        y[d] = __delete(x)
    else:
        root = __delete(x)

def find(key):
    x = root
    while x:
        if key == x[2]:
            return 1
        x = x[x[2] < key]
    return 0

def debug():
    s0 = [""""]
    s1 = [""""]

    def dfs(nd):
        v = str(nd[2])
        s0.append(v)
        if nd[0]:
            dfs(nd[0])
        s1.append(v)
        if nd[1]:
            dfs(nd[1])
    dfs(root)
    return "" "".join(s1), "" "".join(s0)


M = int(input())
ans = []
for m in range(M):
    cmd, *V, = map(str, input().split())
    if cmd == ""print"":
        ans.extend(debug())
    elif cmd == ""find"":
        ans.append(""yes"" if find(int(V[0])) else ""no"")
    elif cmd == ""delete"":
        delete(int(V[0]))
    else:
        k, p = map(int, V)
        insert(k, p)

for i in ans:
    print(i)
"
6990651,ALDS1_8_D,"class Node:
    def __init__(self, val, pri):
        self.val = val
        self.pri = pri
        self.parent = None
        self.left = None
        self.right = None 
    
    
class Treap: 
    def __init__(self):
        self.root = None
        
    
    def insert(self, node): 
        parent = None
        ptr = self.root 
        while ptr is not None:
            parent = ptr
            if node.val < ptr.val:
                ptr = ptr.left 
            else:
                ptr = ptr.right
                
        node.parent = parent 
        if parent is None:
            self.root = node 
        elif node.val < parent.val:
            parent.left = node
        else:
            parent.right = node
            
        while True:
            if node.parent is not None:
                if node.parent.left is not None and node.val == node.parent.left.val and node.pri > node.parent.pri:
                    node = self.rotate_right(node)          
                elif node.parent.right is not None and node.val == node.parent.right.val and node.pri > node.parent.pri:
                    node = self.rotate_left(node)
                else:
                    break 
            else:
                self.root = node
                break
            
            
    def rotate_right(self, node):
        p = node.parent
        if p.parent is not None:
            node.parent = p.parent 
        else:
            node.parent = None 
            
        p.left = node.right 
        if node.right is not None:
            node.right.parent = p
        node.right = p 
        node.right.parent = node 
        if node.parent is not None:
            if node.parent.right is not None and node.parent.right.val == p.val:
                node.parent.right = node 
            elif node.parent.left is not None and node.parent.left.val == p.val:
                node.parent.left = node
        else:
            self.root = node
        return node
 
    
    def rotate_left(self, node):
        p = node.parent
        if p.parent is not None:
            node.parent = p.parent 
        else:
            node.parent = None 
            
        p.right = node.left 
        if node.left is not None:
            node.left.parent = p
        node.left = p 
        node.left.parent = node 
        if node.parent is not None:
            if node.parent.right is not None and node.parent.right.val == p.val:
                node.parent.right = node 
            elif node.parent.left is not None and node.parent.left.val == p.val:
                node.parent.left = node
        else:
            self.root = node
         
        return node
            
            
    def delete(self, node): #nodeの存在可否をあらかじめsearch関数で調べること。
        while True: 
            if node.left is None and node.right is None:
                break 
            elif node.left is None:
                node = self.rotate_left(node.right).left
            elif node.right is None:
                node = self.rotate_right(node.left).right
            else:    
                if node.left.pri > node.right.pri:
                    node = self.rotate_right(node.left).right
                else:
                    node = self.rotate_left(node.right).left
            #print(node.val)
                             
        if node.parent is not None:
            if node.parent.right is not None and node.val == node.parent.right.val:
                node.parent.right = None 
            elif node.parent.left is not None and node.val == node.parent.left.val:
                node.parent.left = None
        else:
            self.root = None 
            
            
    def search(self, node, key): #nodeを根とする部分木にkeyがあるかを検索。
        if node is None or node.val == key:
            return node 
        elif key < node.val:
            return self.search(node.left, key)
        else:
            return self.search(node.right, key)
        
        
    def search_min(self, node):
        while node.left is not None:
            node = node.left 
        return node 
    
    
    def walk(self, r=None, Pre=None, In=None, Post=None): #verified ALDS8A
        if r is None:
            r = self.root 
        if Pre is None:
            Pre = []
        if In is None:
            In = []
        if Post is None:
            Post = []
        
        if r is None:
            return [], [], []
        
        Pre.append(r.val)
        if r.left is not None:
            self.walk(r.left, Pre, In)
        In.append(r.val)
        if r.right is not None:
            self.walk(r.right, Pre, In)
        Post.append(r.val)
        return Pre, In, Post
   
    
from sys import stdin 
input = stdin.readline   

T = Treap()
n = int(input())

for _ in range(n):
    query = input().split()
    if query[0] == 'insert':
        key, pri = int(query[1]), int(query[2])
        T.insert(Node(key, pri))
    elif query[0] == 'find':
        key = int(query[1])
        res = T.search(T.root, key)
        if res is None:
            print('no')
        else:
            print('yes')  
    elif query[0] == 'delete':
        key = int(query[1])
        res = T.search(T.root, key)
        if res is not None:
            T.delete(res)
    else:
        Pre, In, Post = T.walk()
        print('', *In)
        print('', *Pre)
"
5415956,ALDS1_8_D,"class Node:

    def __init__(self, key=None, priority=None):
        self.key = key
        self.priority = priority

        self.p = None
        self.left = None
        self.right = None

    def delete(self):
        self.key = self.p = self.left = self.right = None

class Treap:

    def __init__(self):
        self.root = None

#================

def leftRotate(T, node):

    h = node.right
    h.p = node.p
    
    if h.p is not None:
        if h.p.left == node:
            h.p.left = h
        else:
            h.p.right = h

    node.right = h.left

    if node.right is not None:
        node.right.p = node

    node.p = h
    h.left = node

    if node == T.root:
        T.root = h
        T.root.p = None

#================

def rightRotate(self, node):

    h = node.left
    h.p = node.p

    if h.p is not None:
        if h.p.right == node:
            h.p.right = h
        else:
            h.p.left = h

    node.left = h.right

    if node.left is not None:
        node.left.p = node

    node.p = h
    h.right = node

    if node == T.root:
        T.root = h
        T.root.p = None

#================

def inorderSuccessor(node):

    cur = node
    while cur is not None:
        if cur.left is None:
            break
        cur = cur.left

    return cur

#================

def inorder(node):

    if node is not None:
        return inorder(node.left) + f' {node.key}' + inorder(node.right)
    else:
        return  ''

#================

def preorder(node):

    if node is not None:
        return f' {node.key}' + preorder(node.left) + preorder(node.right)
    else:
        return ''

#================

def insert(T, z):

    y = None
    x = T.root

    while x != None:

        y = x

        if z.key < x.key:
            x = x.left
        else:
            x = x.right
    
    z.p = y

    if y is None:
        T.root = z
        return
    elif z.key < y.key:
        y.left = z
    else:
        y.right = z

    while (z.p is not None) and (z.p.priority < z.priority):
        if z.p.right == z:
            leftRotate(T, z.p)
        else:
            rightRotate(T, z.p)

    if z.p is None:
        T.root = z

#================

def find(s, k):

    if s is None or s.key == k:
        return s
    elif s.key > k:
        return find(s.left, k)
    else:
        return find(s.right, k)

#================

def delete(s, k):

    s = find(s, k)

    if s is None:
        return -1
    
    while (s.left is not None) or (s.right is not None):

        if s.left is None:
            leftRotate(T, s)

        elif s.right is None:
            rightRotate(T, s)

        elif s.left.priority > s.right.priority:
            rightRotate(T, s)

        else:
            leftRotate(T, s)

        if T.root == s:
            T.root = s.p
    
    if s.p.left == s:
        s.p.left = None
    else:
        s.p.right = None        


#================================================

T = Treap()
m = int(input())

for i in range(m):

    i = input().split()

    if i[0][0] == ""i"":
        insert(T, Node(int(i[1]), int(i[2])))
    elif i[0][0] == ""f"":
        if find(T.root, int(i[1])) is None:
            print('no')
        else:
            print('yes')
    elif i[0][0] == ""d"":
        delete(T.root, int(i[1]))
    else:
        print(inorder(T.root))
        print(preorder(T.root))

"
7141635,ALDS1_8_D,"import sys

from random import random


class Node:

    def __init__(self, key, priority):
        self.key = key
        self.left = None
        self.right = None
        self.priority = priority


class TreapSortedSet:

    def __init__(self, default_min_key=1 << 70, default_max_key=-1 << 70):
        self.root = None
        self.size = 0
        self.min_key = default_min_key
        self.max_key = default_max_key

    def __bool__(self):
        return self.root is not None

    def __len__(self):
        return self.size

    def __contains__(self, key):
        return self.search_key(key)

    def is_empty(self):
        return self.root is None

    def search_key(self, key):

        current_node = self.root
        while current_node is not None:

            if key < current_node.key:
                current_node = current_node.left
            elif current_node.key < key:
                current_node = current_node.right
            elif key == current_node.key:
                return True
            else:
                raise KeyError

        return False

    def insert(self, key, priority):

        new_node = Node(key, priority)

        if self.root is None:
            self.size = 1
            self.root = new_node
            self.min_key = key
            self.max_key = key
            return

        if key < self.min_key:
            self.min_key = key
        elif self.max_key < key:
            self.max_key = key

        parent_node_list = []
        current_node = self.root

        while current_node is not None:

            parent_node_list.append(current_node)
            if key < current_node.key:
                current_node = current_node.left
            elif current_node.key < key:
                current_node = current_node.right
            elif key == current_node.key:
                return
            else:
                raise KeyError

        parent_node_list.append(new_node)

        while 1 < len(parent_node_list):
            current_node = parent_node_list.pop()
            parent_node = parent_node_list[-1]

            if current_node.key < parent_node.key:
                parent_node.left = current_node
            elif parent_node.key < current_node.key:
                parent_node.right = current_node
            else:
                raise KeyError

            if current_node.key < parent_node.key:
                if parent_node.priority < current_node.priority:
                    parent_node.left, current_node.right = current_node.right, parent_node
                    parent_node_list[-1] = current_node
                else:
                    break
            elif parent_node.key < current_node.key:
                if parent_node.priority < current_node.priority:
                    parent_node.right, current_node.left = current_node.left, parent_node
                    parent_node_list[-1] = current_node
                else:
                    break
            else:
                raise KeyError

        self.root = parent_node_list[0]
        self.size += 1

    def erase(self, key):

        result = False
        if self.root is None:
            return False

        if key == self.root.key and self.size == 1:
            self.size = 0
            self.root = None
            self.min_key = 1 << 70
            self.max_key = -1 << 70

            return True

        current_node = self.root
        parent_node_list = []
        node_path_count = 0

        while current_node is not None:

            if key != current_node.key:
                node_path_count += 1
                parent_node_list.append(current_node)

                if key < current_node.key:
                    current_node = current_node.left
                elif current_node.key < key:
                    current_node = current_node.right
                else:
                    raise KeyError
            else:

                child_node = None

                if current_node.left is None or current_node.right is None:

                    if current_node.left is None and current_node.right is None:

                        if key < parent_node_list[-1].key:
                            parent_node_list[-1].left = None
                        elif parent_node_list[-1].key < key:
                            parent_node_list[-1].right = None
                        else:
                            raise KeyError

                        if key == self.min_key:
                            self.min_key = parent_node_list[-1].key
                        elif key == self.max_key:
                            self.max_key = parent_node_list[-1].key

                        self.size -= 1
                        result = True
                        current_node = None
                        break
                    elif current_node.left is None:
                        child_node = current_node.right
                        current_node.right, child_node.left = child_node.left, current_node
                    elif current_node.right is None:
                        child_node = current_node.left
                        current_node.left, child_node.right = child_node.right, current_node
                    else:
                        raise KeyError
                else:
                    if current_node.left.priority <= current_node.right.priority:
                        child_node = current_node.right
                        current_node.right, child_node.left = child_node.left, current_node
                    else:
                        child_node = current_node.left
                        current_node.left, child_node.right = child_node.right, current_node

                parent_node_list.append(child_node)

        if result ^ 1:
            return result

        node_path_count = max(node_path_count, 1)
        limit_count = len(parent_node_list) - node_path_count

        while 0 < limit_count:

            current_node = parent_node_list.pop()
            parent_node = parent_node_list[-1]

            if current_node.key < parent_node.key:
                parent_node.left = current_node
            elif parent_node.key < current_node.key:
                parent_node.right = current_node
            else:
                raise KeyError

            limit_count -= 1

        self.root = parent_node_list[0]
        return result

    def min_(self):
        return self.min_key

    def max_(self):
        return self.max_key

    def lower_bound(self, key):

        result = None
        current_node = self.root

        while current_node is not None:

            if key < current_node.key:
                result = current_node.key
                current_node = current_node.left
            elif current_node.key < key:
                current_node = current_node.right
            elif key == current_node.key:
                return key
            else:
                raise KeyError

        return result

    def upper_bound(self, key):

        result = None
        current_node = self.root

        while current_node is not None:

            if current_node.key < key:
                result = current_node.key
                current_node = current_node.right
            elif key <= current_node.key:
                current_node = current_node.left
            else:
                raise KeyError

        return result

    def left_rotate(self, parent_node) -> Node:
        child_node = parent_node.right
        parent_node.right, child_node.left = child_node.left, parent_node
        return child_node

    def right_rotate(self, parent_node) -> Node:
        child_node = parent_node.left
        parent_node.left, child_node.right = child_node.right, parent_node
        return child_node

    """"""
        in_order left root right
        pre_order root left right
        post_order left right root
    """"""

    def in_order(self) -> None:

        def _in_order(node: Node) -> None:
            if node is not None:
                _in_order(node.left)
                node_path_list.append(node.key)
                _in_order(node.right)

        node_path_list = []
        _in_order(self.root)
        print(' ', end='')
        print(*node_path_list)

    def pre_order(self) -> None:

        def _pre_order(node: Node) -> None:

            if node is not None:
                node_path_list.append(node.key)
                _pre_order(node.left)
                _pre_order(node.right)

        node_path_list = []
        _pre_order(self.root)
        print(' ', end='')
        print(*node_path_list)

    def post_order(self) -> None:

        def _post_order(node: Node) -> None:

            if node is not None:
                _post_order(node.left)
                _post_order(node.right)
                node_path_list.append(node.key)

        node_path_list = []
        _post_order(self.root)
        # print(*node_path_list)
        return node_path_list

    def level_order(self) -> None:

        from collections import deque


        if self.root is None:
            return

        que = deque()
        que.append(self.root)
        node_path_list = []

        while que:

            current_node = que.popleft()
            node_path_list.append(current_node.key)

            if current_node.left:
                que.append(current_node.left)

            if current_node.right:
                que.append(current_node.right)

        # print(*node_path_list)
        return node_path_list


input = sys.stdin.readline
N = int(input())
queries = [input().split() for _ in range(N)]
tp = TreapSortedSet()

for i in range(N):

    if queries[i][0] == 'insert':
        tp.insert(int(queries[i][1]), int(queries[i][2]))
    elif queries[i][0] == 'find':
        if tp.search_key(int(queries[i][1])):
            print('yes')
        else:
            print('no')
    elif queries[i][0] == 'delete':
        tp.erase(int(queries[i][1]))
    else:
        tp.in_order()
        tp.pre_order()
"
4326744,ALDS1_8_D,"from random import random
from collections import deque
from copy import deepcopy
import sys
input = sys.stdin.readline

class Treap:
    def __init__(self, iterable=None):
        # vertex = [left, right, key, priority, #descendants, sum of descendants]
        self.root = None
        if iterable: self._construct(iterable)
    
    def _construct(self, iterable):
        for it in iterable: self.insert(it)
    
    def __len__(self): return self._count(self.root)
    
    @staticmethod
    def _count(v): return v[4] if v is not None else 0

    def _rotate(self, v, direction): # rotate the vertex v to the given direction
        c = v[1 - direction] # direction == 1: right rotation
        v[1 - direction], t = c[direction], c[1 - direction]
        c[direction] = v
        # update vertex's information
        n_desc, sum_desc = c[4:] = v[4:]
        v[4:] = n_desc - 1 - self._count(t), sum_desc - (c[2] if c[2] else 0) - (t[5] if t else 0)
        return c # new parent
    
    def __contains__(self, key): # check whether the given key is in the treap
        if self.root is None: return False
        v = self.root
        while v:
            k = v[2]
            if k == key: return True
            v = v[key > k] # key > v[2] -> v = v[1] (right child)
        return False
    
    def __getitem__(self, i): # get the i-th smallest element in the treap
        count = self._count
        if i < 0: i = count(self.root) + i
        if i >= count(self.root) or i < 0: raise IndexError
        v = self.root
        while True:
            n_left = count(v[0])
            if i == n_left: return v[2]
            elif i > n_left: i -= n_left + 1; v = v[1]
            else: v = v[0]
    
    def __repr__(self): # visualize the treap
        if not self.root: return 'Treap([])'
        elements = []
        q = deque([self.root])
        while q:
            v = q.popleft()
            if v is None: elements.append(v); continue
            elements.append((v[2], v[3]))
            q.append(v[0]); q.append(v[1])
        return 'Treap({})'.format(str(elements))
    
    @classmethod
    def _treap(cls, treapnode):
        tp = cls(); tp.root = deepcopy(treapnode)
        return tp
            
    def sort(self):
        if not self.root: return []
        elements = []
        stack = [(self.root, 0)]
        while stack:
            v, st = stack.pop()
            [left, right, k, _, _, _] = v
            if st == 0:
                if right: stack.append((right, 0))
                stack.append((v, 1))
                if left: stack.append((left, 0))
            if st == 1: elements.append(k)
        return elements
    
    def bisect(self, key): # bisect_right
        if self.root is None: return 0
        v = self.root; idx = 0
        count = self._count
        while v:
            left, right, k, _, _, _ = v
            if key >= k: idx += count(left) + 1; v = right
            else: v = left
        return idx
    
    def insert(self, key, priority=None):
        if priority is None: priority = random()
        rotate = self._rotate
        v = self.root; p = None; direction = None
        stack = []
        while v:
            direction = (key >= v[2])
            stack.append((v, direction))
            v, p = v[direction], v
        v = [None, None, key, priority, 1, key]
        while stack:
            p, direction = stack.pop()
            p[direction] = v
            p[4] += 1; p[5] += key # update vertex's information
            if p[3] >= v[3]: break
            v = rotate(p, 1 - direction)
        else: self.root = v
        for p, _ in stack: p[4] += 1; p[5] += key # update vertex's information
        return self.root
    
    def delete(self, key):
        v = self.root; p = None; direction = None
        stack = []
        while v:
            if key == v[2]: break # vertex to be deleted has been found
            direction = (key > v[2])
            stack.append((v, direction))
            v, p = v[direction], v
        else: return self.root # the given key is not in the treap
        rotate = self._rotate
        while v[0] or v[1]: # while v is not a leaf
            left, right, _, _, _, _ = v
            direction = (left[3] > right[3]) if left and right else (right is None)
            p = rotate(v, direction)
            stack.append((p, direction)); v = p[direction]
        v = None # delete
        while stack:
            p, direction = stack.pop()
            p[direction] = v
            p[4] -= 1; p[5] -= (key if key else 0) # update vertex's information
            v = p
        self.root = v
        return self.root
    
    def merge(self, other):
        r, o = self.root, other.root
        temp_v = [r, o, None, float('inf'), 1 + r[4] + o[4], r[5] + o[5]]
        virtual = self._treap(temp_v)
        self.root = virtual.delete(None)
        return self.root
    
    def split(self, i):
        count = self._count
        if i < 0: i = count(self.root) + i
        if i >= count(self.root) or i < 0: raise IndexError
        rotate = self._rotate
        v = self.root; p = None; direction = None
        stack = []
        while v:
            n_left = count(v[0])
            direction = (i > n_left)
            stack.append((v, direction))
            if direction: i -= n_left + 1
            v, p = v[direction], v
        v = [None, None, None, float('inf'), 1, 0]
        while stack:
            p, direction = stack.pop()
            p[direction] = v
            p[4] += 1; p[5] += 0 # update vertex's information
            v = rotate(p, 1 - direction)
        l, r = v[:2]
        self.root = l
        return self._treap(r)

def print_treap(tr):
    preorder = ['']
    inorder = ['']
    def dfs(vtx):
        v = str(vtx[2])
        preorder.append(v)
        if vtx[0]: dfs(vtx[0])
        inorder.append(v)
        if vtx[1]: dfs(vtx[1])
    dfs(tr.root)
    print(' '.join(inorder))
    print(' '.join(preorder))
    return
    
m = int(input())
tr = Treap()
for _ in range(m):
    query, *args, = input().split()
    if query == 'insert':
        k, p = map(int, args)
        tr.insert(k, p)
    elif query == 'find':
        k = int(args[0])
        print('yes' if k in tr else 'no')
    elif query == 'delete':
        k = int(args[0])
        tr.delete(k)
    else:
        print_treap(tr)
"
5132276,ALDS1_8_D,"import sys
from random import random
sys.setrecursionlimit(10**9)
readline = sys.stdin.readline

class Node():
    def __init__(self, key, priority):
        self.key = key
        self.priority = priority
        self.left = None
        self.right = None
        self.parent = None

def RightRotate(x):
    y = x.left
    x.left = y.right
    y.right = x
    return y

def LeftRotate(y):
    x = y.right
    y.right = x.left
    x.left = y
    return x

def insert(x, key, priority):
    if x == None:
        return Node(key, priority)
    if key == x.key:
        return x

    if key < x.key:
        x.left = insert(x.left,key, priority)
        if x.priority < x.left.priority:
            x = RightRotate(x)
    else:
        x.right = insert(x.right, key, priority)
        if x.priority < x.right.priority:
            x = LeftRotate(x)
    return x

def delete(x, key):
    if x == None:
        return None
    if key < x.key:
        x.left = delete(x.left, key)
    elif key > x.key:
        x.right = delete(x.right, key)
    else:
        return _delete(x, key)
    return x

def _delete(x, key):
    if x.left == None and x.right == None:
        return None
    elif x.left == None:
        x = LeftRotate(x)
    elif x.right == None:
        x = RightRotate(x)
    else:
        if x.left.priority > x.right.priority:
            x = RightRotate(x)
        else:
            x = LeftRotate(x)
    return delete(x, key)

def find(x, key):
    if x == None:
        return False
    if x.key == key:
        return True

    if key < x.key:
        return find(x.left, key)
    else:
        return find(x.right, key)

def preorder(x, log):
    if x == None:
        return
    log.append(x.key)
    preorder(x.left, log)
    preorder(x.right, log)

def inorder(x, log):
    if x == None:
        return
    inorder(x.left, log)
    log.append(x.key)
    inorder(x.right, log)

def postorder(x, log):
    if x == None:
        return
    postorder(x.left, log)
    postorder(x.right, log)
    log.append(x.key)

def main():
    N = int(readline())
    treap = None
    for _ in range(N):
        q = readline().split()
        if q[0] == 'insert':
            key, priority = map(int, q[1:])
            treap = insert(treap, key, priority)
        elif q[0] == 'find':
            key = int(q[1])
            print(""yes"" if find(treap, key) else ""no"")
        elif q[0] == 'delete':
            key = int(q[1])
            treap = delete(treap, key)
        elif q[0] == 'print':
            log = []
            inorder(treap, log)
            print('', *log)
            log = []
            preorder(treap, log)
            print('', *log)

if __name__ == ""__main__"":
    main()


"
5333228,ALDS1_8_D,"class Node:
    def __init__(self, key, priority):
        self.key = key
        self.priority = priority
        self.left = None
        self.right = None

def right_rotate(t):
    s = t.left
    t.left = s.right
    s.right = t
    return s

def left_rotate(t):
    s = t.right
    t.right = s.left
    s.left = t
    return s

def insert(t, key, priority):
    if t == None:
        return Node(key, priority)
    if key == t.key:
        return t
    if key < t.key:
        t.left = insert(t.left, key, priority)
        if t.priority < t.left.priority:
            t = right_rotate(t)
    else:
        t.right = insert(t.right, key, priority)
        if t.priority < t.right.priority:
            t = left_rotate(t)
    return t            

def delete(t, key):
    if t == None:
        return None
    if key < t.key:
        t.left = delete(t.left, key)
    elif key > t.key:
        t.right = delete(t.right, key)
    else:
        return _delete(t, key)
    return t

def _delete(t, key):
    if t.left == None and t.right == None:
        return None
    elif t.left == None:
        t = left_rotate(t)
    elif t.right == None:
        t = right_rotate(t)
    else:
        if t.left.priority > t.right.priority:
            t = right_rotate(t)
        else:
            t = left_rotate(t)
    return delete(t, key)

def find(t, key):
    if t == None:
        return False
    if t.key == key:
        return True
    if key < t.key:
        return find(t.left, key)
    else:
        return find(t.right, key)

def inorder(t, inout):
    if t == None:
        return
    inorder(t.left, inout)
    inout.append(t.key)
    inorder(t.right, inout)

def preorder(t, preout):
    if t == None:
        return
    preout.append(t.key)
    preorder(t.left, preout)
    preorder(t.right, preout)

def main():
    m = int(input())
    treap = None
    for _ in range(m):
        query = input()
        if query[0] == 'i':
            _, key, priority = query.split()
            treap = insert(treap, int(key), int(priority))
        elif query[0] == 'd':
            _, key = query.split()
            treap = delete(treap, int(key))
        elif query[0] == 'f':
            _, key = query.split()
            if find(treap, int(key)):
                print('yes')
            else:
                print('no')
        elif query[0] == 'p':
            inout = []
            inorder(treap, inout)
            preout = []
            preorder(treap, preout)
            print('', *inout)
            print('', *preout)

if __name__ == '__main__':
    main()
"
8900798,ALDS1_8_D,"from dataclasses import dataclass
from typing import Optional


@dataclass()
class Node:
    key: Optional[int] = None
    priority: int = -1
    parent: Optional[""Node""] = None
    left: Optional[""Node""] = None
    right: Optional[""Node""] = None

    def __init__(self, key=None, priority=-1, parent=None):
        self.key = key
        self.priority = priority
        self.parent = parent
        if key is not None:
            self.left = Node(parent=self)
            self.right = Node(parent=self)
        else:
            self.left = None
            self.right = None

    def __bool__(self) -> bool:
        return self.key is not None

    def is_leaf(self) -> bool:
        return not self.left and not self.right


@dataclass()
class Tree:
    head: Node

    def __init__(self):
        self.head = Node()

    def find(self, key: int) -> Node:
        node = self.head

        while node:
            if key < node.key:
                node = node.left
            elif key == node.key:
                break
            else:
                node = node.right

        return node

    def insert(self, node) -> None:
        if not node:
            return

        replaced = self.find(node.key)
        parent = replaced.parent
        node.parent = parent

        if parent is None:
            self.head = node
            return
        elif parent.left is replaced:
            parent.left = node
        else:
            parent.right = node

        while parent is not None and parent.priority < node.priority:
            self.rotate(parent, node)
            parent = node.parent

        if parent is None:
            self.head = node

    def erase(self, key: int) -> None:
        node = self.find(key)
        if not node:
            return

        while not node.is_leaf():
            if node.left.priority < node.right.priority:
                self.rotate(node, node.right)
            else:
                self.rotate(node, node.left)

        if node.parent is None:
            self.head = Node()
        elif node.parent.left is node:
            node.parent.left = Node(parent=node.parent)
        else:
            node.parent.right = Node(parent=node.parent)

    def rotate(self, parent: Node, child: Node) -> None:
        child.parent = parent.parent
        parent.parent = child

        if parent.left is child:
            child.right, parent.left = parent, child.right
            parent.left.parent = parent
        else:
            child.left, parent.right = parent, child.left
            parent.right.parent = parent

        if child.parent is None:
            self.head = child
        elif child.parent.left is parent:
            child.parent.left = child
        else:
            child.parent.right = child

    def print_inorder(self) -> None:
        answer = [""""]
        breads = [self.head]

        while True:
            node = breads[-1]

            if not node:
                breads.pop()
                if not breads:
                    break
                else:
                    parent = breads[-1]
                    answer.append(str(parent.key))
                    breads[-1] = parent.right
            else:
                breads.append(node.left)

        print("" "".join(answer))

    def print_preorder(self) -> None:
        answer = [""""]
        breads = [self.head]

        while breads:
            node = breads.pop()
            if node:
                answer.append(str(node.key))
                breads.append(node.right)
                breads.append(node.left)

        print("" "".join(answer))


if __name__ == ""__main__"":
    M = int(input())
    tree = Tree()

    for _ in range(M):
        line = input().split()
        if line[0] == ""insert"":
            (k, p) = map(int, line[1:])
            tree.insert(Node(k, p))
        elif line[0] == ""find"":
            k = int(line[1])
            if tree.find(k):
                print(""yes"")
            else:
                print(""no"")
        elif line[0] == ""delete"":
            k = int(line[1])
            tree.erase(k)
        else:
            tree.print_inorder()
            tree.print_preorder()

"
3820345,ALDS1_8_D,"
class Node:
    def __init__(self, key, priority):
        self.key = key
        self.priority = priority
        self.parent = None
        self.left = None
        self.right = None


def rightRotate(t):
    s = t.left
    t.left = s.right
    s.right = t
    return s


def leftRotate(t):
    s = t.right
    t.right = s.left
    s.left = t
    return s


def insert(t, key, priority):
    if t is None:
        return Node(key, priority)
    if key == t.key:
        return t

    if key < t.key:
        t.left = insert(t.left, key, priority)
        if t.priority < t.left.priority:
            t = rightRotate(t)
    else:
        t.right = insert(t.right, key, priority)
        if t.priority < t.right.priority:
            t = leftRotate(t)

    return t


def delete(t, key):
    if t is None:
        return None
    if key < t.key:
        t.left = delete(t.left, key)
    elif key > t.key:
        t.right = delete(t.right, key)
    else:
        return _delete(t, key)
    return t


def _delete(t, key):
    if t.left is None and t.right is None:
        return None
    elif t.left is None:
        t = leftRotate(t)
    elif t.right is None:
        t = rightRotate(t)
    else:
        if t.left.priority > t.right.priority:
            t = rightRotate(t)
        else:
            t = leftRotate(t)
    return delete(t, key)


def find(t, key):
    if key == t.key:
        return t

    elif key < t.key:
        if t.left is not None:
            ret = find(t.left, key)
            if ret is not None:
                return ret
    else:
        if t.right is not None:
            ret = find(t.right, key)
            if ret is not None:
                return ret

    return None


def preorder(t, ret):
    ret.append(t.key)

    if t.left is not None:
        preorder(t.left, ret)

    if t.right is not None:
        preorder(t.right, ret)


def inorder(t, ret):
    if t.left is not None:
        inorder(t.left, ret)

    ret.append(t.key)

    if t.right is not None:
        inorder(t.right, ret)


def main():
    m = int(input())
    Treap = None
    for i in range(m):
        cmd, *v = input().split()
        if cmd == ""print"":
            print("" "", end="""")
            inans = []
            inorder(Treap, inans)
            print(*inans)
            print("" "", end="""")
            preans = []
            preorder(Treap, preans)
            print(*preans)
        elif cmd == ""insert"":
            k = int(v[0])
            p = int(v[1])
            Treap = insert(Treap, k, p)
        elif cmd == ""find"":
            z = int(v[0])
            if find(Treap, z) == None:
                print(""no"")
            else:
                print(""yes"")
        else:
            z = int(v[0])
            Treap = delete(Treap, z)


if __name__ == '__main__':
    main()

"
4567898,ALDS1_8_D,"import sys, collections
input = lambda: sys.stdin.readline().rstrip() 
sys.setrecursionlimit(10**7)
INF = 10**10
def I(): return int(input())
def F(): return float(input())
def SS(): return input()
def LI(): return [int(x) for x in input().split()]
def LI_(): return [int(x)-1 for x in input().split()]
def LF(): return [float(x) for x in input().split()]
def LSS(): return input().split()

class Node():
    key = None
    priority = None
    p = None
    left = None
    right = None

    def __init__(self, key, priority):
        self.key = key
        self.priority = priority

class BinarySearchTree():
    root = None

    def rightRotate(self, t):
        s = t.left
        t.left = s.right
        s.right = t
        return s

    def leftRotate(self, t):
        s = t.right
        t.right = s.left
        s.left = t
        return s

    def insert(self, t, key, priority):
        if t is None:
            return Node(key, priority)
        if key==t.key:
            return t

        if key < t.key:
            t.left = self.insert(t.left, key, priority)
            if t.priority < t.left.priority:
                t = self.rightRotate(t)
        else:
            t.right = self.insert(t.right, key, priority)
            if t.priority < t.right.priority:
                t = self.leftRotate(t)
        
        return t

    def find(self, k):
        x = self.root
        while x is not None:
            if x.key==k:
                return x
            elif x.key>k:
                x = x.left
            else:
                x = x.right
        return None

    def next_node(self, z):
        if z.right is None:
            x = z
            y = z.p
            while y is not None and y.left!=x:
                x = y
                y = y.p
            return y
        else:
            x = z.right
            while x is not None:
                y = x
                x = x.left
            return y

    def delete(self, t, key):
        if t is None:
            return None
        if key < t.key:
            t.left = self.delete(t.left, key)
        elif key > t.key:
            t.right = self.delete(t.right, key)
        else:
            return self._delete(t, key)
        return t

    def _delete(self, t, key):
        if t.left is None and t.right is None:
            return None
        elif t.left is None:
            t = self.leftRotate(t)
        elif t.right is None:
            t = self.rightRotate(t)
        else:
            if t.left.priority > t.right.priority:
                t = self.rightRotate(t)
            else:
                t = self.leftRotate(t)
        return self.delete(t, key)
            
    def print_nodes(self):
        inorder = []
        preorder = []

        def dfs(v):
            v_key = v.key
            preorder.append(v_key)
            if v.left is not None:
                dfs(v.left)
            inorder.append(v_key)
            if v.right is not None:
                dfs(v.right)

        dfs(self.root)

        print('', *inorder)
        print('', *preorder)

def resolve():
    m = I()
    T = BinarySearchTree()
    for _ in range(m):
        q = LSS()
        if q[0]=='insert':
            k = int(q[1])
            p = int(q[2])
            T.root = T.insert(T.root, k, p)
        elif q[0]=='find':
            k = int(q[1])
            if T.find(k):
                print('yes')
            else:
                print('no')
        elif q[0]=='delete':
            k = int(q[1])
            T.root = T.delete(T.root, k)
        else:
            T.print_nodes()

if __name__ == '__main__':
    resolve()

"
6836756,ALDS1_8_D,"class Node:
    def __init__(self,key,pri):
        self.left = None
        self.right = None
        self.key = key
        self.pri = pri

def rrotate(t):
    s = t.left
    t.left = s.right
    s.right = t
    return s 
    
def lrotate(t):
    s = t.right
    t.right = s.left
    s.left = t
    return s 

def insert(t, key, pri):
    if t == None:
        return Node(key, pri) 
    if key == t.key: 
        return t
    if key < t.key:
        t.left = insert(t.left, key, pri)

        if t.pri < t.left.pri:
            t = rrotate(t)
    else: 
        t.right = insert(t.right, key, pri)
        if t.pri < t.right.pri:
            t = lrotate(t)
    return t
    
def erase(t, key):
    if t == None:
        return None
    if key == t.key: 
    
        if t.left == None and t.right == None:
            return None
        
        elif t.left == None:
            t = lrotate(t)
        
        elif t.right == None:
            t = rrotate(t)
    
        else:
        
            if t.left.pri > t.right.pri:
                t = rrotate(t)
            else:
                t = lrotate(t)
            return erase(t, key)
    
    if ( key < t.key):
        t.left = erase(t.left, key)
    else:
        t.right = erase(t.right, key)
    return t

def find(t, key):
    if key == t.key:
        return t

    elif key < t.key:
        if t.left != None:
            _key = find(t.left, key)
            if _key != None:
                return _key
    else:
        if t.right != None:
            _key = find(t.right, key)
            if _key != None:
                return _key

    return None

def inorder(t, _key):
    if t.left != None:
        inorder(t.left, _key)

    _key.append(t.key)

    if t.right != None:
        inorder(t.right, _key)

def preorder(t, _key):
    _key.append(t.key)

    if t.left != None:
        preorder(t.left, _key)

    if t.right != None:
        preorder(t.right, _key)

def main():
    n = int(input())
    T = None
    for i in range(n):
        c, *v = input().split()
        if c == ""print"":
            print("" "", end="""")
            inans = []
            inorder(T, inans)
            print(*inans)
            print("" "", end="""")
            preans = []
            preorder(T, preans)
            print(*preans)
        elif c == ""insert"":
            key = int(v[0])
            pri = int(v[1])
            T = insert(T, key, pri)
        elif c == ""find"":
            key = int(v[0])
            if find(T, key) == None:
                print(""no"")
            else:
                print(""yes"")
        else:
            key = int(v[0])
            T = erase(T,key)

if __name__ == '__main__':
    main()
    
"
8034560,ALDS1_8_D,"class Node:
    def __init__(self,key,pri):
        self.left = None
        self.right = None
        self.key = key
        self.pri = pri

def rightRotate(t):
    s = t.left
    t.left = s.right
    s.right = t
    return s 

def leftRotate(t):
    s = t.right
    t.right = s.left
    s.left = t
    return s 
   
def insert(t, key, pri):           # 再帰的に探索
    if t == None:
        return Node(key, pri)               # 葉に到達したら新しい節点を生成して返す
    if key == t.key:
        return t                                 # 重複したkeyは無視

    if key < t.key:                               # 左の子へ移動
        t.left = insert(t.left, key, pri)   # 左の子へのポインタを更新
        if t.pri < t.left.pri:          # 左の子の方が優先度が高い場合右回転
            t = rightRotate(t)
    else:                                         # 右の子へ移動
        t.right = insert(t.right, key, pri) # 右の子へのポインタを更新
        if t.pri < t.right.pri:         # 右の子の方が優先度が高い場合左回転
            t = leftRotate(t)
    return t

def delete( t, key):
    if t == None:
        return None
    if key < t.key:              # 削除対象を検索
        t.left = delete(t.left, key)
    elif key > t.key:
        t.right = delete(t.right, key)
    else:
        return _delete(t, key)
    return t

def _delete( t, key): # 削除対象の節点の場合
    if t.left == None and t.right == None:           # 葉の場合
        return None
    elif t.left == None:                        # 右の子のみを持つ場合左回転
        t = leftRotate(t)
    elif t.right == None:                       # 左の子のみを持つ場合右回転
        t = rightRotate(t)
    else:                                         # 左の子と右の子を両方持つ場合
        if t.left.pri > t.right.pri:    # 優先度が高い方を持ち上げる
            t = rightRotate(t)
        else:
            t = leftRotate(t)
    return delete(t, key)

def find(t, key):
    if key == t.key:
        return t

    elif key < t.key:
        if t.left != None:
            _key = find(t.left, key)
            if _key != None:
                return _key
    else:
        if t.right != None:
            _key = find(t.right, key)
            if _key != None:
                return _key
    return None

def inorder(t, _key):
    if t.left != None:
        inorder(t.left, _key)

    _key.append(t.key)

    if t.right != None:
        inorder(t.right, _key)

def preorder(t, _key):
    _key.append(t.key)

    if t.left != None:
        preorder(t.left, _key)

    if t.right != None:
        preorder(t.right, _key)

def main():
    m = int(input())
    T = None
    for _ in range(m):
        older, *k = input().split()
        if older == ""print"":
            print("" "", end="""")
            inolder_result = []
            inorder(T, inolder_result)
            print(*inolder_result)
            print("" "", end="""")
            preolder_result = []
            preorder(T, preolder_result)
            print(*preolder_result)

        elif older == ""insert"":
            key = int(k[0])
            pri = int(k[1])
            T = insert(T, key, pri)
            
        elif older == ""find"":
            key = int(k[0])
            if find(T, key) == None:
                print(""no"")
            else:
                print(""yes"")
        else:
            key = int(k[0])
            T = delete(T,key)

if __name__ == '__main__':
    main() 
"
3942785,ALDS1_8_D,"import random
from collections import deque


class TreapNode():
    """"""節クラス: valは節の値, priorityは節の優先度を表す
    parent/left/rightはそれぞれ親/左側の子/右側の子へのポインタを表す
    """"""
    def __init__(self, val, priority):
        self.val = val
        self.priority = priority # random.random()
        self.parent = None
        self.right = None
        self.left = None


class Treap():
    """"""SSet(Sorted Set)をサポートする""""""
    def __init__(self):
        self.root = None

    def search(self, val: int) -> bool:
        """"""二分木に値valを持つ節が存在するかどうか判定する
        valと一致する節が存在する場合はTrue、存在しない場合はFalseを返す
        """"""
        ptr = self.root
        while ptr is not None:
            if ptr.val == val:
                return True
            if val < ptr.val:
                ptr = ptr.left
            else:
                ptr = ptr.right
        return False 

    def insert(self, val: int, priority):
        """"""二分木に値valを持つ節が存在しない場合、追加する""""""
        if self.root is None:
            self.root = TreapNode(val, priority)
            return

        ptr = self.root 
        while True:
            if val == ptr.val:
                return
            elif val < ptr.val:
                if ptr.left is None:
                    # ポインタの示す先に節が存在しない場合はNode(val)を追加する
                    ptr.left = TreapNode(val, priority)
                    ptr.left.parent = ptr
                    ptr = ptr.left
                    break
                ptr = ptr.left
            else:
                if ptr.right is None:
                    # ポインタの示す先に節が存在しない場合はNode(val)を追加する
                    ptr.right = TreapNode(val, priority)
                    ptr.right.parent = ptr
                    ptr = ptr.right
                    break
                ptr = ptr.right
       
        while (ptr.parent is not None) and (ptr.parent.priority < ptr.priority):
            if ptr.parent.right == ptr:
                self.rotate_left(ptr.parent)
            else:
                self.rotate_right(ptr.parent)
        if ptr.parent is None:
            self.root = ptr 
          
          
    def delete(self, val: int):
        """"""二分木から値valを持つ節を削除する""""""        
        ptr = self.root             
        while True: 
            if ptr is None:
                return
            elif val == ptr.val:
                break
            elif val < ptr.val:
                ptr = ptr.left
            else:
                ptr = ptr.right
       
        while (ptr.left is not None) or (ptr.right is not None):
            if ptr.left is None:
                self.rotate_left(ptr)
            elif ptr.right is None:
                self.rotate_right(ptr)
            elif ptr.left.priority > ptr.right.priority:
                self.rotate_right(ptr)
            else:
                self.rotate_left(ptr)
            if self.root == ptr:
                self.root = ptr.parent
       
        if ptr.parent.left == ptr:
            ptr.parent.left = None
        else:
            ptr.parent.right = None         
   
    def rotate_left(self, ptr):
        """"""木を左回転する""""""
        w = ptr.right
        w.parent = ptr.parent
        if w.parent is not None:
            if w.parent.left == ptr:
                w.parent.left = w
            else:
                w.parent.right = w
        ptr.right = w.left
        if ptr.right is not None:
            ptr.right.parent = ptr
        ptr.parent = w
        w.left = ptr
        if ptr == self.root:
            self.root = w
            self.root.parent = None
     
    def rotate_right(self, ptr):
        """"""木を右回転する""""""
        w = ptr.left
        w.parent = ptr.parent
        if w.parent is not None:
            if w.parent.right == ptr:
                w.parent.right = w
            else:
                w.parent.left = w
        ptr.left = w.right
        if ptr.left is not None:
            ptr.left.parent = ptr
        ptr.parent = w
        w.right = ptr
        if ptr == self.root:
            self.root = w
            self.root.parent = None

    def preorder_tree_walk(self):
        """"""先行順巡回(preorder tree walk)""""""
        res = []
        q = deque([])
        ptr = self.root
        while True:
            if ptr is not None:
                q.append(ptr) 
                res.append(ptr.val)
                ptr = ptr.left
            elif q: 
                ptr = q.pop() 
                ptr = ptr.right
            else:
                return res
 
    def inorder_tree_walk(self):
        """"""中間順巡回(inorder tree walk)""""""
        res = []
        q = deque([])
        ptr = self.root
        while True:
            if ptr is not None:
                q.append(ptr) 
                ptr = ptr.left
            elif q: 
                ptr = q.pop() 
                res.append(ptr.val)
                ptr = ptr.right
            else:
                return res
 
    def postorder_tree_walk(self):
        """"""後行順巡回(postorder tree walk)""""""
        res = []
        q = deque([self.root])
        ptr = self.root
        while q:
            ptr = q.pop()
            res.append(ptr.val)
            if ptr.left is not None:
                q.append(ptr.left)
            if ptr.right is not None:
                q.append(ptr.right)
        return reversed(res)

n = int(input())
info = [list(input().split()) for i in range(n)]
tp = Treap()

for i in range(n):
    if info[i][0] == ""insert"":
        tp.insert(int(info[i][1]), int(info[i][2]))
    elif info[i][0] == ""find"":
        if tp.search(int(info[i][1])):
            print(""yes"")
        else:
            print(""no"")
    elif info[i][0] == ""delete"":
        tp.delete(int(info[i][1]))
    else:
        print("" "", end="""")
        print(*tp.inorder_tree_walk())
        print("" "", end="""")
        print(*tp.preorder_tree_walk())
"
8212841,ALDS1_8_D,"class SortedSet():
    def __init__(self,default=[]):
        self.value=[]
        self.priority=[]
        self.child=[]
        self.left=[]
        self.right=[]
        self.parent=[]
        self.root=None
        self.length=0
        self.size=0
        self.seed=42
        for i in default:
            self.add(i)
    
    def add(self,val,pri=None):
        self.seed=(self.seed^(self.seed<<13))%pow(2,32)
        self.seed=(self.seed^(self.seed>>17))%pow(2,32)
        self.seed=(self.seed^(self.seed<<15))%pow(2,32)
        if pri==None:
            pri=self.seed
        par=None
        pos=self.root
        self.value.append(val)
        self.priority.append(pri)
        while pos!=None:
            self.child[pos]+=1
            par=pos
            if val<self.value[pos]:
                pos=self.left[pos]
            else:
                pos=self.right[pos]
        self.parent.append(par)
        self.left.append(None)
        self.right.append(None)
        self.child.append(0)
        self.length+=1
        self.size+=1
        if par==None:
            self.root=self.length-1
            return
        elif val<self.value[par]:
            self.left[par]=self.length-1
        else:
            self.right[par]=self.length-1
        pos=par
        while pos!=None:
            if self.left[pos]!=None and self.priority[pos]<self.priority[self.left[pos]]:
                self.right_rotate(pos)
                pos=self.parent[pos]
            elif self.right[pos]!=None and self.priority[pos]<self.priority[self.right[pos]]:
                self.left_rotate(pos)
                pos=self.parent[pos]
            else:
                break
            pos=self.parent[pos]

    def sort(self):
        self.in_order=[]
        self.pre_order=[]
        self.DFS(self.root)
        return self.in_order,self.pre_order

    def DFS(self,pos):
        if pos==None:
            return
        self.pre_order.append(self.value[pos])
        self.DFS(self.left[pos])
        self.in_order.append(self.value[pos])
        self.DFS(self.right[pos])

    def find(self,val):
        pos=self.root
        while pos!=None:
            if self.value[pos]==val:
                return True
            elif self.value[pos]<val:
                pos=self.right[pos]
            else:
                pos=self.left[pos]
        return False
    
    def or_less(self,val):
        pos=self.root
        ret=None
        while pos!=None:
            if self.value[pos]<=val:
                if ret==None:
                    ret=self.value[pos]
                ret=max(ret,self.value[pos])
                pos=self.right[pos]
            else:
                pos=self.left[pos]
        return ret

    def less_than(self,val):
        pos=self.root
        ret=None
        while pos!=None:
            if self.value[pos]<val:
                if ret==None:
                    ret=self.value[pos]
                ret=max(ret,self.value[pos])
                pos=self.right[pos]
            else:
                pos=self.left[pos]
        return ret

    def or_more(self,val):
        pos=self.root
        ret=None
        while pos!=None:
            if self.value[pos]>=val:
                if ret==None:
                    ret=self.value[pos]
                ret=min(ret,self.value[pos])
                pos=self.left[pos]
            else:
                pos=self.right[pos]
        return ret

    def more_than(self,val):
        pos=self.root
        ret=None
        while pos!=None:
            if self.value[pos]>val:
                if ret==None:
                    ret=self.value[pos]
                ret=min(ret,self.value[pos])
                pos=self.left[pos]
            else:
                pos=self.right[pos]
        return ret

    def discard(self,val):
        pos=self.root
        while pos!=None:
            if self.value[pos]==val:
                if self.right[pos]==None and self.left[pos]==None:
                    break
                if self.left[pos]==None:
                    self.left_rotate(pos)
                elif self.right[pos]==None:
                    self.right_rotate(pos)
                else:
                    if self.priority[self.left[pos]]<self.priority[self.right[pos]]:
                        self.left_rotate(pos)
                    else:
                        self.right_rotate(pos)
                pos=self.parent[pos]
            if self.value[pos]<val:
                pos=self.right[pos]
            else:
                pos=self.left[pos]
        if pos==None:
            return False
        par=self.parent[pos]
        self.size-=1
        if self.left[par]==pos:
            self.left[par]=None
        else:
            self.right[par]=None
        while par!=None:
            self.child[par]-=1
            par=self.parent[par]
        return True

    def right_rotate(self,root):
        child=self.left[root]
        par=self.parent[root]
        child_right=self.right[child]
        self.child[root],self.child[child]=self.child[root]-self.child[child]-1,self.child[root]
        if child_right!=None:
            self.child[root]+=self.child[child_right]+1
        self.left[root]=child_right
        if child_right!=None:
            self.parent[child_right]=root
        self.right[child]=root
        self.parent[root]=child
        self.parent[child]=par
        if par!=None:
            if self.left[par]==root:
                self.left[par]=child
            else:
                self.right[par]=child
        else:
            self.root=child

    def left_rotate(self,root):
        child=self.right[root]
        par=self.parent[root]
        child_left=self.left[child]
        self.child[root],self.child[child]=self.child[root]-self.child[child]-1,self.child[root]
        if child_left!=None:
            self.child[root]+=self.child[child_left]+1
        self.right[root]=child_left
        if child_left!=None:
            self.parent[child_left]=root
        self.left[child]=root
        self.parent[root]=child
        self.parent[child]=par
        if par!=None:
            if self.left[par]==root:
                self.left[par]=child
            else:
                self.right[par]=child
        else:
            self.root=child

m=int(input())
T=SortedSet()
for i in range(m):
    query=input().split()
    if query[0]==""insert"":
        T.add(int(query[1]),int(query[2]))
    elif query[0]==""find"":
        if T.find(int(query[1])):
            print(""yes"")
        else:
            print(""no"")
    elif query[0]==""delete"":
        T.discard(int(query[1]))
    else:
        order=T.sort()
        print("" "",end="""")
        print(*order[0])
        print("" "",end="""")
        print(*order[1])
"
8017867,ALDS1_8_D,"class TNode:
    def __init__(self, n, p):
        self.n = n
        self.p = p
        self.left = None
        self.right = None

def rightrotate(t):
    s = t.left
    t.left = s.right
    s.right = t
    
    return s

def leftrotate(t):
    s = t.right
    t.right = s.left
    s.left = t
    
    return s

def insert(root, m, p):
    if root is None:
        return TNode(m, p)
    
    if root.n > m:
        root.left = insert(root.left, m, p)
        if root.p < root.left.p:
            root = rightrotate(root)
    else:
        root.right = insert(root.right, m, p)
        if root.p < root.right.p:
            root = leftrotate(root)
    
    return root


def find(root, m):
    if root.n == m:
        return ""yes""
    
    if root.n > m:
        if root.left is None:
            return ""no""
        else:
            return find(root.left, m)
    else:
        if root.right is None:
            return ""no""
        else:
            return find(root.right, m)

def dodel(root, m):
    if root.left is None and root.right is None:
        return None
    
    if root.right is None:
        root = rightrotate(root)
    elif root.left is None:
        root = leftrotate(root)
    else:
        if root.left.p > root.right.p:
            root = rightrotate(root)
        else:
            root = leftrotate(root)
    
    return delete(root, m)

def delete(root, m):
    if root is None:
        return None
    
    if root.n == m:
        return dodel(root, m)
    
    if root.n > m:
        root.left = delete(root.left, m)
        return root
    else:
        root.right = delete(root.right, m) 
        return root

def preorder(root):
    tmp = [root.n]
    
    if root.left is not None:
        tmp += preorder(root.left)
    
    if root.right is not None:
        tmp += preorder(root.right)
    
    return tmp

def inorder(root):
    tmp = []
    
    if root.left is not None:
        tmp += inorder(root.left)
    
    tmp += [root.n]
    
    if root.right is not None:
        tmp += inorder(root.right)
    
    return tmp

n = int(input())
root = None

for _ in range(n):
    s = input()
    if s == ""print"":
        print("" "" + "" "".join(list(map(str, inorder(root)))))
        print("" "" + "" "".join(list(map(str, preorder(root)))))
    elif s.startswith(""insert""):
        s, m, p = s.split()
        m, p = int(m), int(p)
        root = insert(root, m, p)
    else:
        s, m = s.split()
        m = int(m)
        if s == ""find"":
            print(find(root, m))
        else:
            root = delete(root, m)
"
5286731,ALDS1_8_D,"from sys import stdin
import time
INFTY=1<<30
class node:
    def __init__(self,key,priority) -> None:
        self.key=key
        self.priority=priority
        self.left=None
        self.right=None
class treap:
    def __init__(self) -> None:
        self.root=None
    #右回転
    def rightRotate(self,p):
        c=p.left
        p.left=c.right
        c.right=p
        return c
    #左回転
    def leftRotate(self,t):
        s=t.right
        t.right=s.left
        s.left=t
        return s
    #挿入
    def insert(self,key,priority):
        new=node(key,priority)
        p=self.root;q=None;pl=[]
        #挿入する場所までpを移動
        while not p is None:
            pl.append(p)
            q=p
            #重複したkeyは無視
            if key==p.key:
                return
            elif key<p.key:
                p=p.left
            else:
                p=p.right
        #TEST
        if len(pl)>0 and pl[len(pl)-1]!=q:print(""エラー"")
        #挿入
        if q is None:
            self.root=new
        elif key<q.key:
            q.left=new
        else:
            q.right=new
        while len(pl):
            r=pl.pop()
            #回転する必要がなければ終了
            if priority<r.priority:break
            #右回転
            if r.left==new:
                self.rightRotate(r)
            #左回転
            elif r.right==new:
                self.leftRotate(r)
            #回転した部分は切れてしまうのでつなげる
            if len(pl)==0:
                self.root=new
            else:
                v=pl[len(pl)-1]
                if key<v.key:v.left=new
                else:v.right=new
    #検索
    def find(self,key):
        p=self.root;q=None
        while not p is None:
            if key==p.key:return [p,q]
            elif key<p.key:q=p;p=p.left
            else:q=p;p=p.right
        return [None,None]
    #削除
    def delete(self,key):
        p,q=self.find(key)
        #削除する値が存在しなければ何もしない
        if p is None:return
        #削除
        while True:
            #つけかえない点
            r=q
            #削除する点が葉の場合
            if p.left is None and p.right is None:
                if q is None:self.root=None
                elif q.left==p:q.left=None
                else:q.right=None
                return
            #削除する点が右子だけを持つ場合
            elif p.left is None:
                q=self.leftRotate(p)
            #削除する点が左子だけを持つ場合
            elif p.right is None:
                q=self.rightRotate(p)
            #削除する点が2つの子を持つ場合
            else:
                if p.left.priority>p.right.priority:
                    q=self.rightRotate(p)
                else:
                    q=self.leftRotate(p)
            #回転した部分は切れてしまうのでつなげる
            #削除する点が根の場合，根を変更する
            if r==None:self.root=q
            else:
                if q.key<r.key:r.left=q
                else:r.right=q

    def _delete(self,t,key):
        if t.left==None and t.right is None:
            return None
        elif t.left is None:
            t=self.leftRotate(t)
        elif t.right is None:
            t=self.rightRotate(t)
        else:
            if t.left.priority>t.right.priority:
                t=self.rightRotate(t)
            else:
                t=self.leftRotate(t)
        return self.delete(t,key)
    def print_pre(self,p):
        if p is None:return
        print(f' {p.key}',end='')
        self.print_pre(p.left)
        self.print_pre(p.right)
    def print_inn(self,p):
        if p is None:return
        self.print_inn(p.left)
        print(f' {p.key}',end='')
        self.print_inn(p.right)

    def print(self):
        self.print_inn(self.root)
        print()
        self.print_pre(self.root)
        print()


            
m=int(input())
T=treap()
for _ in range(m):
    order=stdin.readline().split()
    if ""insert"" in order[0]:
        T.insert(int(order[1]),int(order[2]))
    elif ""find"" in order[0]:
        print(""no"") if T.find(int(order[1]))[0] is None else print(""yes"")
    elif ""delete"" in order[0]:
        T.delete(int(order[1]))
    else:
        T.print()

"
4143244,ALDS1_8_D,"class Node:
    def __init__(self, key, priority):
        self.key = key
        self.priority = priority
        self.left = None
        self.right = None
class Treap:
    def __init__(self):
        self.root = None
        self.order_list = []
    def right_rotate(self, t):
        s = t.left
        t.left = s.right
        s.right = t
        return s
    def left_rotate(self, t):
        s = t.right
        t.right = s.left
        s.left = t
        return s
    def find(self, key):
        x = self.root
        while x != None:
            if key == x.key:
                return x
            elif key < x.key:
                x = x.left
            else:
                x = x.right
        return None
    def insert(self, t, key, priority):
        if t == None:
            return Node(key, priority)
        if key == t.key:
            return t
        if key < t.key:
            t.left = self.insert(t.left, key, priority)
            if priority > t.priority:
                t = self.right_rotate(t)
        else:
            t.right = self.insert(t.right, key, priority)
            if priority > t.priority:
                t = self.left_rotate(t)
        return t
    def delete(self, t, key):
        if t == None:
            return None
        if key < t.key:
            t.left = self.delete(t.left, key)
        elif key > t.key:
            t.right = self.delete(t.right, key)
        else:
            return self.__delete(t, key)
        return t
    def __delete(self, t, key):
        if t.left == None and t.right == None:
            return None
        elif t.left == None:
            t = self.left_rotate(t)
        elif t.right == None:
            t = self.right_rotate(t)
        else:
            if t.left.priority < t.right.priority:
                t = self.left_rotate(t)
            else:
                t = self.right_rotate(t)
        return self.delete(t, key)
    def walk_preorder(self, node):
        if node == None:
            return None
        self.order_list.append(node.key)
        self.walk_preorder(node.left)
        self.walk_preorder(node.right)
    def walk_inorder(self, node):
        if node == None:
            return None
        self.walk_inorder(node.left)
        self.order_list.append(node.key)
        self.walk_inorder(node.right)
    def print_nodes(self):
        self.order_list = []
        self.walk_inorder(self.root)
        inorder_str = ' '.join(map(str, self.order_list))
        print(' {}'.format(inorder_str))
        self.order_list = []
        self.walk_preorder(self.root)
        preorder_str = ' '.join(map(str, self.order_list))
        print(' {}'.format(preorder_str))
n = int(input())
tree = Treap()
for _ in range(n):
    command = input().split(' ')
    if len(command) == 1:
        tree.print_nodes()
    elif len(command) == 2:
        opecode, key = command[0], int(command[1])
        if opecode == 'delete':
            tree.root = tree.delete(tree.root, key)
        elif opecode == 'find':
            if tree.find(key) != None:
                print('yes')
            else:
                print('no')
    else:
        opecode, key, priority = command[0], int(command[1]), int(command[2])
        tree.root = tree.insert(tree.root, key, priority)
"
5850191,ALDS1_8_D,"class Node:
    def __init__(self, key, priority):
        self.key = key
        self.priority = priority
        self.left = None
        self.right = None

def insert(t, key, priority):
    if t==None:
        return  Node(key, priority)
    elif key==t.key:
        return t
    elif key<t.key:
        t.left = insert(t.left, key, priority)
        if t.priority<t.left.priority:
            t = rightRotate(t)
    else:
        t.right = insert(t.right, key, priority)
        if t.priority<t.right.priority:
            t = leftRotate(t)
    return t
            
def rightRotate(t):
    s = t.left
    t.left = s.right
    s.right = t
    return s

def leftRotate(t):
    s = t.right
    t.right = s.left
    s.left = t
    return s

def delete(t, key):
    if t==None:
        return None
    elif key<t.key:
        t.left = delete(t.left, key)
    elif key>t.key:
        t.right = delete(t.right, key)
    else:
        return _delete(t, key)
    return t

def _delete(t, key):
    if t.left==None and t.right==None:
        return None
    elif t.left==None:
        t = leftRotate(t)
    elif t.right==None:
        t = rightRotate(t)
    else:
        if t.left.priority>t.right.priority:
            t = rightRotate(t)
        else:
            t = leftRotate(t)
    return delete(t, key)

def find(t, key):
    if t==None:
        return False
    elif key<t.key:
        return find(t.left, key)
    elif key>t.key:
        return find(t.right, key)
    else:
        return True

def inorder(t):
    return inorder(t.left) + f' {t.key}' + inorder(t.right) if t else ''
def preorder(t):
    return f' {t.key}' + preorder(t.left) + preorder(t.right) if t else ''

node = None
m = int(input())
for i in range(m):
    command = input().split()
    if command[0]==""insert"":
        node = insert(node, int(command[1]), int(command[2]))
    elif command[0]==""delete"":
        node = delete(node, int(command[1]))
    elif command[0]==""find"":
        if find(node, int(command[1])):
            print(""yes"")
        else:
            print(""no"")
    else:
        print(inorder(node))
        print(preorder(node))


"
6809530,ALDS1_8_D,"class Node:
    def __init__(self,key,pri,l=None,r=None):
        self.key = key
        self.pri = pri
        self.l = l
        self.r = r

def r_rotate(t):
    s = t.l
    t.l = s.r
    s.r = t
    return s


def l_rotate(t):
    s = t.r
    t.r = s.l
    s.l = t
    return s

def insert(t,key,pri):
    if t == None:
        return Node(key,pri)
    if key == t.key:
        return t
    
    if key < t.key:
        t.l = insert(t.l,key,pri)
        if t.pri < t.l.pri:
            t = r_rotate(t)
    else:
        t.r = insert(t.r,key,pri)
        if t.pri < t.r.pri:
            t = l_rotate(t)
    return t

def preorder(t, ret):
    if t == None:
        return
    ret.append(t.key)
    preorder(t.l, ret)
    preorder(t.r, ret)


def inorder(t, ret):
    if t == None:
        return

    inorder(t.l, ret)
    ret.append(t.key)
    inorder(t.r, ret)

def erase(t,key):
    if t == None:
        return None
    
    if key == t.key:
        if t.l == None and t.r == None:
            return None
        elif t.l == None:
            t = l_rotate(t)
        elif t.r == None:
            t = r_rotate(t)
        else :
            if t.l.pri > t.r.pri:
                t = r_rotate(t)
            else:
                t = l_rotate(t)
        return erase(t,key)
    
    if key < t.key:
        t.l = erase(t.l,key)
    else:
        t.r = erase(t.r,key)
    
    return t

def find(t,key):
    if t == None:
        return ""no""

    if t.key == key:
        return ""yes""
    elif t.key < key:
        return find(t.r,key)
    else :
        return find(t.l,key)


m = int(input())
root = None

for _ in range(m):
    com = input()
    if com[0] == 'i':
        _,x,y = com.split()
        root = insert(root,int(x),int(y))


    elif com[0] == 'p':
        ans = []
        inorder(root, ans)
        print("" "", end="""")
        print(*ans)

        

        ans = []
        preorder(root, ans)
        print("" "", end="""")
        print(*ans)


    elif com[0] == 'f':
        _,x = com.split()
        print(find(root,int(x)))
    elif com[0] =='d':
        _,x = com.split()
        root = erase(root,int(x))


"
4267799,ALDS1_8_D,"# coding: utf-8

class TreapNode:
    def __init__(self, id, priority):
        self.id = id
        self.priority = priority
        self.left = None
        self.right = None
    
    def __str__(self):
        return 'id={}, priority={}'.format(self.id, self.priority)


    def _rotate_left(self):
        r = self.right
        self.right = r.left
        r.left = self
        return r
    
    def _rotate_right(self):
        l = self.left
        self.left = l.right
        l.right = self
        return l
    
    
    def _delete_node(self):
        if self.left is None and self.right is None:
            return None
        elif self.left is None:
            node = self._rotate_left()
        elif self.right is None:
            node = self._rotate_right()
        else:
            if self.left.priority < self.right.priority:
                node = self._rotate_left()
            else:
                node = self._rotate_right()
                
        return node.delete(self.id)

        
    def insert(self, id, priority):
        if self.id == id:
            return self
            
        if id < self.id:
            if self.left:
                self.left = self.left.insert(id, priority)
            else:
                self.left = TreapNode(id, priority)
            
            if self.priority < self.left.priority:
                return self._rotate_right()
        else:
            if self.right:
                self.right = self.right.insert(id, priority)
            else:
                self.right = TreapNode(id, priority)
                
            if self.priority < self.right.priority:
                return self._rotate_left()
                
        return self

    def delete(self, id):
        if id < self.id:
            if self.left:
                self.left = self.left.delete(id)
        elif id > self.id:
            if self.right:
                self.right = self.right.delete(id)
        else:
            return self._delete_node()
            
        return self
    
                
    def inorder(self, result):
        if self.left:
            self.left.inorder(result)
            
        result.append(self.id)
        
        if self.right:
            self.right.inorder(result)
    
    
    def preorder(self, result):
        result.append(self.id)
        
        if self.left:
            self.left.preorder(result)
            
        if self.right:
            self.right.preorder(result)

    def find(self, id):
        if self.id == id:
            return True
        if id < self.id:
            if self.left and self.left.find(id):
                return True
        else:
            if self.right and self.right.find(id):
                return True
        return False

class Treap:
    def __init__(self):
        self.root = None
    
    def insert_node(self, id, priority):
        if self.root:
            self.root = self.root.insert(id, priority)
        else:
            self.root = TreapNode(id, priority)
    
    def delete_node(self, id):
        if self.root:
            self.root = self.root.delete(id)
    
    def find_node(self, id):
        if self.root:
            return self.root.find(id)
        else:
            return False
            
    def walk_inorder(self):
        result = []
        if self.root:
            self.root.inorder(result)
        return result
    
    def walk_preorder(self):
        result = []
        if self.root:
            self.root.preorder(result)
        return result
    

def main():
    n = int(input())
    treap = Treap()
    
    for _ in range(n):
        cmd = input()
        if cmd[0] == 'p':
            result = treap.walk_inorder()
            print('', *result)
            
            result = treap.walk_preorder()
            print('', *result)

        elif cmd[0] == 'i':
            id, priority = [int(i) for i in cmd.split()[1:3]]
            treap.insert_node(id, priority)
            
        elif cmd[0] == 'd':
            id = int(cmd.split()[1])
            treap.delete_node(id)
            
        elif cmd[0] == 'f':
            id = int(cmd.split()[1])
            if treap.find_node(id):
                print('yes')
            else:
                print('no')

if __name__=='__main__':
    main()
"
7630386,ALDS1_8_D,"import sys
import os

class Node:
    def __init__(self, v,p):
        self.left = None
        self.right = None
        self.key = v
        self.priority=p

class Tree:
    def __init__(self):
        self.root = None
  
    def rightrotate(self,t):
        s = t.left
        t.left = s.right
        s.right = t
        return s
        
    def leftrotate(self,t):
        s = t.right
        t.right = s.left
        s.left = t
        return s
    
    def insert(self,t,key,priority):
        if t==None:
            return Node(key,priority)
        if key==t.key:
            return t
        if key<t.key:
            t.left=self.insert(t.left,key,priority)
            if t.priority < t.left.priority:          
                t = self.rightrotate(t)
        if key>t.key:
            t.right=self.insert(t.right,key,priority)
            if t.priority < t.right.priority:         
                t = self.leftrotate(t)
        return t
    
    def tree_walk2(self, node):
        preorder.append(node.key)
        if node.left != None:
            self.tree_walk2(node.left)
        inorder.append(node.key)
        if node.right != None:
            
            self.tree_walk2(node.right)
        # postorder.append(node.key)
    def find(self,node,t):
        if not node:
            return node
        if node.key==t:
            return node
        if node.key<t:
            return self.find(node.right,t)
        else:
            return self.find(node.left,t)
    
    
    def delete(self,t,key):
        if t==None:
            return None
        if key < t.key:                              
            t.left = self.delete(t.left, key)
        elif key > t.key:
            t.right = self.delete(t.right, key)
        else:
            return self.deletenode(t, key)
        return t
            
    def deletenode(self,t,key):    
        if t.left==None and t.right==None:
            return None
        elif t.left==None:
            t = self.leftrotate(t)
        elif t.right==None:
            t = self.rightrotate(t)
        else:
            if t.left.priority > t.right.priority:
                t = self.rightrotate(t)
            else:
                t = self.leftrotate(t)
        return self.delete(t,key)
                                      
fn = ""inputdata.txt""
if os.path.exists(fn):
    sys.stdin = open(fn)
n = int(sys.stdin.readline())


tree = Tree()
for _ in range(n):
    cmd = sys.stdin.readline().split()
    if cmd[0] == ""insert"":
        tree.root=tree.insert(tree.root,int(cmd[1]),int(cmd[2]))
    if cmd[0]==""find"":
        if tree.find(tree.root,int(cmd[1])):
            print(""yes"")
        else:
            print(""no"")
    if cmd[0]==""delete"":
        tree.root=tree.delete(tree.root,int(cmd[1]))
    if cmd[0] == ""print"":
        preorder = []
        inorder = []
        results = [
            (""Inorder"", inorder),
            (""Preorder"", preorder),
        ]
        tree.tree_walk2(tree.root)
        for name, result in results:
            print(end="" "")
            print(*result)
"
6830118,ALDS1_8_D,"class Node:
    def __init__(self,value,priority) -> None:
        self.left = None
        self.right = None
        self.value = value
        self.priority = priority

def Insert(t:Node,key,priority):
    if t == None:
        return Node(key,priority)
    if key == t.value:
        return t
    if key < t.value:
        t.left = Insert(t.left,key,priority)
        if t.priority < t.left.priority:
            t = rightRotate(t)
    else:
        t.right = Insert(t.right,key,priority)
        if t.priority < t.right.priority:
            t = leftRotate(t)
    return t
def rightRotate(t:Node):
    s = t.left
    t.left = s.right
    s.right = t
    return s
def leftRotate(t:Node):
    s = t.right
    t.right = s.left
    s.left = t
    return s

def Find(t:Node,key):
    if t.value > key:
        if t.left != None:
            return Find(t.left,key)
        else:
            return False
    if t.value < key:
        if t.right != None:
            return Find(t.right,key)
        else:
            return False
    return True

def Delete(t:Node,key):
    if t == None:
        return None
    if key < t.value:
        t.left = Delete(t.left,key)
    elif key > t.value:
        t.right = Delete(t.right,key)
    else:
        return _Delete(t,key)
    return t
def _Delete(t:Node,key):
    if t.left == None and t.right == None:
        return None
    elif t.left == None:
        t = leftRotate(t)
    elif t.right == None:
        t = rightRotate(t)
    else:
        if t.left.priority > t.right.priority:
            t = rightRotate(t)
        else:
            t= leftRotate(t)
    return Delete(t,key)

def print_preorder(node):
    out = ''
    if node.value == None:
        return out
    out += str(node.value) + ' '
    if node.left != None:
        out += print_preorder(node.left)
    if node.right != None:
        out += print_preorder(node.right)
    return out
def print_inorder(node):
    out = ''
    if node.value == None:
        return out
    if node.left != None:
        out += print_inorder(node.left)
    out += str(node.value) + ' '
    if node.right != None:
        out += print_inorder(node.right)
    return out

tree = None

N = int(input())

for i in range(N):
    ins = input().split()
    if ins[0] == 'insert':
        if tree == None:
            tree = Node(int(ins[1]), int(ins[2]))
        else:
            tree = Insert(tree,int(ins[1]),int(ins[2]))
    elif ins[0] == 'print':
        print(' ' + print_inorder(tree).strip())
        print(' ' + print_preorder(tree).strip())
    elif ins[0] == 'find':
        print('yes' if Find(tree,int(ins[1])) else 'no')
    elif ins[0] == 'delete':
        tree = Delete(tree,int(ins[1]))


"
2937782,ALDS1_8_D,"class Node:
    def __init__(self, key, priority):
        self.right = None
        self.left = None
        self.parent = None
        self.key = key
        self.priority = priority

    def preorder(self):
        ret = [self.key]
        if self.left:
            ret += self.left.preorder()
        if self.right:
            ret += self.right.preorder()
        return ret

    def inorder(self):
        ret = []
        if self.left:
            ret += self.left.inorder()
        ret += [self.key]
        if self.right:
            ret += self.right.inorder()
        return ret

    def find(self, k):
        if self.key == k:
            return self
        elif self.key < k:
            if self.right:
                return self.right.find(k)
            else:
                return None
        else:
            if self.left:
                return self.left.find(k)
            else:
                return None


class Treap:
    def __init__(self):
        self.root = None

    def right_rotate(self, t):
        s = t.left
        t.left = s.right
        s.right = t
        return s

    def left_rotate(self, t):
        s = t.right
        t.right = s.left
        s.left = t
        return s

    def insert(self, k, p):
        self.root = self._insert(self.root, k, p)

    def _insert(self, t, k, p):
        if t is None:
            return Node(k, p)
        if k == t.key:
            return t
        if k < t.key:
            t.left = self._insert(t.left, k, p)
            if t.priority < t.left.priority:
                t = self.right_rotate(t)
        else:
            t.right = self._insert(t.right, k, p)
            if t.priority < t.right.priority:
                t = self.left_rotate(t)
        return t

    def print(self):
        if self.root is None:
            print()
        else:
            print('', ' '.join(map(str, self.root.inorder())))
            print('', ' '.join(map(str, self.root.preorder())))

    def find(self, k):
        if self.root is None:
            return None
        else:
            return self.root.find(k)

    def delete(self, k):
        self.root = self._delete(self.root, k)

    def _delete(self, t, k):
        if t is None:
            return None
        if k < t.key:
            t.left = self._delete(t.left, k)
        elif k > t.key:
            t.right = self._delete(t.right, k)
        else:
            return self._else_delete(t, k)
        return t

    def _else_delete(self, t, k):
        if t.left is None and t.right is None:
            return None
        elif t.left is None:
            t = self.left_rotate(t)
        elif t.right is None:
            t = self.right_rotate(t)
        else:
            if t.left.priority > t.right.priority:
                t = self.right_rotate(t)
            else:
                t = self.left_rotate(t)
        return self._delete(t, k)


m = int(input())
treap = Treap()
for _ in range(m):
    s = input().split()
    if s[0] == ""insert"":
        treap.insert(int(s[1]), int(s[2]))
    elif s[0] == ""find"":
        if treap.find(int(s[1])):
            print(""yes"")
        else:
            print(""no"")
    elif s[0] == ""delete"":
        treap.delete(int(s[1]))
    else:
        treap.print()
"
4952498,ALDS1_8_D,"# coding: utf-8
#https:#onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/8/ALDS1_8_D
import sys

input=sys.stdin.readline
#ノードクラスの定義
class Node:
    def __init__(self, data,prio): #コンストラクタ
        self.data = data #ノードがもつ数値
        self.priority=prio
        self.parent=None
        self.left = None #左エッジ
        self.right = None #右エッジ

class BST:
    def __init__(self,num_list):
        self.root=None
        for node in num_list:
            self.insert(node)
    
    def insert(self,data):
        y=None
        x=self.root
        z=Node(data)
        while not x is None:
            y=x
            if data<x.data:
                x=x.left
            else:
                x=x.right
        z.parent=y
        if y==None:
            self.root=z
        elif z.data<y.data:
            y.left=z
        else:
            y.right=z
            
def find(node,k):
    while node!=None and k!=node.data:
        if k<node.data:
            node=node.left
        else:
            node=node.right
    return node

def rightRotate(node):
    s=node.left
    node.left=s.right
    s.right=node
    return s
    
def leftRotate(node):
    s = node.right
    node.right = s.left
    s.left = node
    return s # root of the subtree
    
def insert(t, data, priority):                   # 再帰的に探索
    if t is None:
        return Node(data, priority)               # 葉に到達したら新しい節点を生成して返す
    if data == t.data:
        return t                                 # 重複したkeyは無視

    if data < t.data:                              # 左の子へ移動
        t.left = insert(t.left, data, priority)  # 左の子へのポインタを更新
        if t.priority < t.left.priority:          # 左の子の方が優先度が高い場合右回転
            t = rightRotate(t)
    else:                                         # 右の子へ移動
        t.right = insert(t.right, data, priority)# 右の子へのポインタを更新
        if t.priority < t.right.priority:         # 右の子の方が優先度が高い場合左回転
            t = leftRotate(t)

    return t

def delete(t, key):
    if t is None:
        return None
    if key < t.data:                                # 削除対象を検索
        t.left = delete(t.left, key)
    elif key > t.data:
        t.right = delete(t.right, key)
    else:
        return _delete(t, key)
    return t

def _delete(t, key): # 削除対象の節点の場合
    if t.left is None and t.right is None:           # 葉の場合
        return None
    elif t.left is None:                        # 右の子のみを持つ場合左回転
        t = leftRotate(t)
    elif t.right is None:                       # 左の子のみを持つ場合右回転
        t = rightRotate(t)
    else:                                         # 左の子と右の子を両方持つ場合
        if t.left.priority > t.right.priority:    # 優先度が高い方を持ち上げる
            t = rightRotate(t)
        else:
            t = leftRotate(t)
    return delete(t, key)
    
def getSeccessor(node):
    if node.right!=None:
        return getMinimum(node.right)
    y=node.parent
    while y!=None and node==y.right:
        node=y
        y=y.parent
    return y

def getMinimum(node):
    while node.left!=None:
        node=node.left
    return node
    
def inOrder(node):
    if node is None:
        return
    inOrder(node.left)
    print("" %d"" % node.data,end="""")
    inOrder(node.right)
    
def preOrder(node):
    if node is None:
        return
    print("" %d"" % node.data,end="""")
    preOrder(node.left)
    preOrder(node.right)
    
if __name__==""__main__"":
    root=None
    n=int(input())
    for _ in range(n):
        tmp=input().split()
        if tmp[0]==""insert"":
            root=insert(root,int(tmp[1]),int(tmp[2]))
            #print(t.root.data)
        elif tmp[0]==""print"":
            inOrder(root)
            print()
            preOrder(root)
            print()
        elif tmp[0]==""find"":
            ans=find(root,int(tmp[1]))
            print(""yes"" if ans!=None else ""no"")
        elif tmp[0]==""delete"":
            root=delete(root,int(tmp[1]))


"
4634988,ALDS1_8_D,"class Node:
    def __init__(self, key, priority):
        self.key = key
        self.priority = priority
        self.parent = None
        self.left = self.right = None
    def preorder(self):
        L = [self.key]
        if self.left: L += self.left.preorder()
        if self.right: L += self.right.preorder()
        return L
    def inorder(self):
        L = []
        if self.left: L += self.left.inorder()
        L.append(self.key)
        if self.right: L += self.right.inorder()
        return L

def rightRotate(t):
    s = t.left
    t.left = s.right
    s.right = t
    return s # root of the subtree
def leftRotate(t):
    s = t.right
    t.right = s.left
    s.left = t
    return s # root of the subtree

def insert(t, key, priority):
    if not t:
        return Node(key, priority) # 葉に到達したら新しい節点を生成して返す
    if key == t.key:
        return t # 重複したkeyは無視
    if key < t.key: # 左の子に移動
        t.left = insert(t.left, key, priority) # 左の子へのポインタを更新
        if t.priority < t.left.priority: # 左の子の方が優先度が高い場合右回転
            t = rightRotate(t)
    else: # 右の子へ移動
        t.right = insert(t.right, key, priority) # 右の子へのポインタを更新
        if t.priority < t.right.priority: # 右の子の方が優先度が高い場合左回転
            t = leftRotate(t)
    return t

def delete(t, key):
    if not t:
        return None
    if key < t.key: # 削除対象を検索
        t.left = delete(t.left, key)
    elif key > t.key:
        t.right = delete(t.right, key)
    else:
        return _delete(t, key)
    return t
def _delete(t, key):
    if not t.left and not t.right: # 葉の場合
        return None
    if not t.left: # 右の子のみを持つ場合左回転
        t = leftRotate(t)
    elif not t.right: # 左の子のみを持つ場合右回転
        t = rightRotate(t)
    else: # 左の子と右の子を両方持つ場合、優先度が高い方を持ち上げる
        if t.left.priority > t.right.priority:
            t = rightRotate(t)
        else:
            t = leftRotate(t)
    return delete(t, key)

def find(t, k):
    x = t
    while x:
        if x.key == k:
            return x
        x = x.left if k < x.key else x.right
    return None

t = None
m = int(input())
for _ in range(m):
    cmd = list(input().split())
    if cmd[0] == 'insert':
        t = insert(t, int(cmd[1]), int(cmd[2]))
    if cmd[0] == 'find':
        print('yes' if find(t, int(cmd[1])) else 'no')
    if cmd[0] == 'delete':
        t = delete(t, int(cmd[1]))
    if cmd[0] == 'print':
        print('', *t.inorder())
        print('', *t.preorder())

"
5727054,ALDS1_8_D,"# 二分木

NOT_FOUND = 2000000001


# ノードクラス
class Node:
    def __init__(self, key_=0, priority_=0):
        self.key = key_
        self.priority = priority_
        self.left = None
        self.right = None


def right_rotate(node_):
    tmp = node_.left
    node_.left = tmp.right
    tmp.right = node_
    return tmp


def left_rotate(node_):
    tmp = node_.right
    node_.right = tmp.left
    tmp.left = node_
    return tmp


def insert(node_, key_, priority_):
    if node_ is None:
        node_ = Node(key_, priority_)
    elif key_ < node_.key:
        node_.left = insert(node_.left, key_, priority_)
        if node_.priority < node_.left.priority:
            node_ = right_rotate(node_)
    else:
        node_.right = insert(node_.right, key_, priority_)
        if node_.priority < node_.right.priority:
            node_ = left_rotate(node_)

    return node_


def _delete(node_, key_):
    if node_.left is None and node_.right is None:
        return None
    if node_.right is None:
        node_ = right_rotate(node_)
    elif node_.left is None:
        node_ = left_rotate(node_)
    else:
        if node_.left.priority > node_.right.priority:
            node_ = right_rotate(node_)
        else:
            node_ = left_rotate(node_)

    return delete(node_, key_)


def delete(node_, key_):
    if node_ is None:
        return None
    if key_ < node_.key:
        node_.left = delete(node_.left, key_)
    elif key_ > node_.key:
        node_.right = delete(node_.right, key_)
    else:
        return _delete(node_, key_)

    return node_


def find(node_, key_):
    if node_ is None:
        return NOT_FOUND
    if key_ == node_.key:
        return key_
    elif key_ < node_.key:
        return find(node_.left, key_)
    else:
        return find(node_.right, key_)


# 行きがけ順
def pre_order(node_):
    if node_ is None:
        return
    print(f' {node_.key}', end='')
    pre_order(node_.left)
    pre_order(node_.right)


# 通りがけ順
def in_order(node_):
    if node_ is None:
        return
    in_order(node_.left)
    print(f' {node_.key}', end='')
    in_order(node_.right)


# 帰りがけ順
def post_order(node_):
    if node_ is None:
        return
    post_order(node_.left)
    post_order(node_.right)
    print(f' {node_.key}', end='')


def print_node(node_):
    in_order(node_)
    print()
    pre_order(node_)
    print()


if __name__ == '__main__':
    n = int(input())
    command = [''] * n
    k = [0] * n
    p = [0] * n
    root = None

    for i in range(n):
        s = input()
        if s[0] == 'i':
            command[i], k[i], p[i] = s.split()
        elif s[0] != 'p':
            command[i], k[i] = s.split()
        else:
            command[i] = s

    for i in range(n):
        if command[i] == ""insert"":
            root = insert(root, int(k[i]), int(p[i]))
        elif command[i] == ""delete"":
            root = delete(root, int(k[i]))
        elif command[i] == ""find"":
            key = find(root, int(k[i]))
            if key == int(k[i]):
                print(""yes"")
            else:
                print(""no"")
        else:
            print_node(root)

"
7371877,ALDS1_8_D,"from typing import List


class Node:
    def __init__(self, id: int, priority: int) -> None:
        self.id = id
        self.priority = priority
        self.left = None
        self.right = None

    def __repr__(self) -> str:
        return (
            f""Node({self.id}, {self.priority}, ""
            f""l={self.left.id if self.left else self.left}, ""
            f""r={self.right.id if self.right else self.right})""
        )


class Treap:
    def __init__(self) -> None:
        self._nodes = {}

    def _rotate_right(self, top: Node) -> Node:
        new_top = top.left
        top.left = new_top.right
        new_top.right = top
        return new_top

    def _rotate_left(self, top: Node) -> Node:
        new_top = top.right
        top.right = new_top.left
        new_top.left = top
        return new_top

    def insert(self, root: Node, id: int, priority: int) -> Node:
        if root is None:
            root = Node(id, priority)
            self._nodes[id] = root
        elif id == root.id:
            pass
        elif id < root.id:
            root.left = self.insert(root.left, id, priority)
            if root.priority < root.left.priority:
                root = self._rotate_right(root)
        elif root.id < id:
            root.right = self.insert(root.right, id, priority)
            if root.priority < root.right.priority:
                root = self._rotate_left(root)
        return root

    def _inorder(self, node: Node = None) -> List[int]:
        order = []
        if node.left:
            order.extend(self._inorder(node.left))
        order.append(node.id)
        if node.right:
            order.extend(self._inorder(node.right))
        return order

    def _preorder(self, node: Node = None) -> List[int]:
        order = [node.id]
        if node.left:
            order.extend(self._preorder(node.left))
        if node.right:
            order.extend(self._preorder(node.right))
        return order

    def print(self, root: Node) -> None:
        print("" "" + "" "".join(map(str, self._inorder(root))))
        print("" "" + "" "".join(map(str, self._preorder(root))))

    def find(self, root: Node, target_id: int) -> bool:
        while root is not None:
            if target_id == root.id:
                return True
            elif target_id < root.id:
                root = root.left
            else:
                root = root.right
        return False

    def delete(self, root: Node, target_id: int) -> Node:
        if root is None:
            return None
        if target_id < root.id:
            root.left = self.delete(root.left, target_id)
        elif target_id > root.id:
            root.right = self.delete(root.right, target_id)
        else:
            return self._delete(root, target_id)
        return root

    def _delete(self, target: Node, target_id: int) -> Node:
        if target.left is None and target.right is None:
            return None
        elif target.left is None:
            target = self._rotate_left(target)
        elif target.right is None:
            target = self._rotate_right(target)
        else:
            if target.left.priority > target.right.priority:
                target = self._rotate_right(target)
            else:
                target = self._rotate_left(target)
        return self.delete(target, target_id)


if __name__ == ""__main__"":
    treap = Treap()
    root = None
    for _ in range(int(input())):
        line = input()
        if line == ""print"":
            treap.print(root)
        else:
            inst, *param = line.split()
            if inst == ""insert"":
                root = treap.insert(root, *map(int, param))
            elif inst == ""find"":
                if treap.find(root, *map(int, param)):
                    print(""yes"")
                else:
                    print(""no"")
            elif inst == ""delete"":
                root = treap.delete(root, *map(int, param))

"
5396708,ALDS1_8_D,"from sys import stdin

class Node:
  def __init__(self, val, priority):
    self.val = val
    self.priority = priority
    self.left = None
    self.right = None

class Treap:
  def __init__(self):
    self.root = None
  def right_rotate(self, t):
    s = t.left
    t.left = s.right
    s.right = t
    return s
  def left_rotate(self, t):
    s = t.right
    t.right = s.left
    s.left = t
    return s
  def insert(self, val, priority):
    self.root = self._insert(self.root, val, priority)
  def _insert(self, t, val, priority):
    if t==None: return Node(val, priority)
    if val==t.val: return t
    if val<t.val:
      t.left = self._insert(t.left, val, priority)
      if t.left!=None and t.priority < t.left.priority:
        t = self.right_rotate(t)
    else:
      t.right = self._insert(t.right, val, priority)
      if t.right!=None and t.priority < t.right.priority:
        t = self.left_rotate(t)
    return t
  def find(self, val):
    if self.root==None: print(""no""); return
    node = self._find(self.root, val)
    print(""no"" if node==None else ""yes"")
  def _find(self, node, val):
    while node!=None:
      if node.val == val: return node
      elif node.val > val: node = node.left
      else: node = node.right
    return None
  def delete(self, val):
    self.root = self._delete(self.root, val)
  def _delete(self, t, val):
    if t==None: return None
    if val<t.val: t.left = self._delete(t.left, val)
    elif val>t.val: t.right = self._delete(t.right, val)
    else: return self.__delete(t, val)
    return t
  def __delete(self, t, val):
    if t.left==None and t.right==None: return None
    elif t.left==None: t = self.left_rotate(t)
    elif t.right==None: t = self.right_rotate(t)
    else:
      if t.left.priority > t.right.priority: t = self.right_rotate(t)
      else: t = self.left_rotate(t)
    return self._delete(t, val)
  def print(self):
    self.remk_inorder()
    self.remk_preorder()
    print("" ""+"" "".join(list(map(lambda x:str(x.val), self.inorder))))
    print("" ""+"" "".join(list(map(lambda x:str(x.val), self.preorder))))
  def mk_preorder(self, node):
    self.preorder.append(node)
    if node.left!=None: self.mk_preorder(node.left)
    if node.right!=None: self.mk_preorder(node.right)
  def remk_preorder(self):
    self.preorder = []    # preorderの初期化
    self.mk_preorder(self.root)
  def mk_inorder(self, node):
    if node.left!=None: self.mk_inorder(node.left)
    self.inorder.append(node)
    if node.right!=None: self.mk_inorder(node.right)
  def remk_inorder(self):
    self.inorder = []    # preorderの初期化
    self.mk_inorder(self.root)

n, treap = int(stdin.readline()), Treap()
for _ in range(n):
  cmd = stdin.readline()
  if cmd[0]==""p"":
    treap.print()
  elif cmd[0]==""f"":
    treap.find(int(cmd.split()[1]))
  elif cmd[0]==""d"":
    treap.delete(int(cmd.split()[1]))
  else:
    v, p = map(int, cmd[7:].split())
    treap.insert(v, p)

"
7525508,ALDS1_8_D,"class Node:
    def __init__(self, k, priority):
        self.key = k
        self.priority = priority
        self.left = None
        self.right = None

def insert(t: Node, k: int, priority: int):
    if t is None:
        return Node(k, priority)
    if k == t.key:
        return t

    if k < t.key:
        t.left = insert(t.left, k, priority)
        if t.priority < t.left.priority:
            t = right_rotate(t)
    else:
        t.right = insert(t.right, k, priority)
        if t.priority < t.right.priority:
            t = left_rotate(t)
    return t

def find(t: Node, k: int):
    if t is None:
        return None

    while t is not None:
        if k == t.key:
            return t 
        elif k < t.key:
            t = t.left
        else:
            t = t.right
    return None

def delete(t: Node, k: int):
    if t is None:
        return None

    if k < t.key:
        t.left = delete(t.left, k)
    elif t.key < k:
        t.right = delete(t.right, k)
    else:
        return _delete(t, k)
    return t

def _delete(t: Node, k: int):
    if not(t.left or t.right):
        return None

    if t.left is None:
        t = left_rotate(t)
    elif t.right is None:
        t = right_rotate(t)
    else:
        if t.left.priority > t.right.priority:
            t = right_rotate(t)
        else:
            t = left_rotate(t)
    return delete(t, k)

def right_rotate(t: Node):
    s = t.left
    t.left = s.right
    s.right = t
    return s

def left_rotate(t: Node):
    s = t.right
    t.right = s.left
    s.left = t
    return s

def keys_inorder(t: Node):
    if t is None:
        return []

    l = []
    if t.left:
        l += keys_inorder(t.left)
    l += [t.key]
    if t.right:
        l += keys_inorder(t.right)
    return l

def keys_preorder(t: Node):
    if t is None:
        return []

    l = []
    l += [t.key]
    if t.left:
        l += keys_preorder(t.left)
    if t.right:
        l += keys_preorder(t.right)
    return l

m = int(input())
t = None

for _ in range(m):
    op,*v = [x for x in input().split()]
    if 'insert' == op:
        t = insert(t, int(v[0]), int(v[1]))
    elif 'find' == op:
        print('yes' if find(t, int(v[0])) else 'no')
    elif 'delete' == op:
        t = delete(t, int(v[0]))
    else:
        ki = keys_inorder(t)
        if ki:
            print(' ', end='')
            print(*ki)
        else:
            print()

        kp = keys_preorder(t)
        if kp:
            print(' ', end='')
            print(*kp)
        else:
            print()

"
8068697,ALDS1_8_D,"class Node:
    def __init__(self, key, pri):
        self.left = None
        self.right = None
        self.key = key
        self.pri = pri

class treap():

    def rrotate(self,t):
        s = t.left
        t.left = s.right
        s.right = t
        return s


    def lrotate(self,t):
        s = t.right
        t.right = s.left
        s.left = t
        return s


    def insert(self,t, key, pri):
        if t == None:
            return Node(key, pri)
        if key == t.key:
            return t
        if key < t.key:
            t.left = self.insert(t.left, key, pri)

            if t.pri < t.left.pri:
                t = self.rrotate(t)
        else:
            t.right = self.insert(t.right, key, pri)
            if t.pri < t.right.pri:
                t = self.lrotate(t)
        return t


    def delete(self,t, key):
        if t == None:
            return None
        if key == t.key:

            if t.left == None and t.right == None:
                return None

            elif t.left == None:
                t = self.lrotate(t)

            elif t.right == None:
                t = self.rrotate(t)

            else:

                if t.left.pri > t.right.pri:
                    t = self.rrotate(t)
                else:
                    t = self.lrotate(t)
                return self.delete(t, key)

        if (key < t.key):
            t.left = self.delete(t.left, key)
        else:
            t.right = self.delete(t.right, key)
        return t


    def find(self,t, key):
        if key == t.key:
            return t

        elif key < t.key:
            if t.left != None:
                _key = self.find(t.left, key)
                if _key != None:
                    return _key
        else:
            if t.right != None:
                _key = self.find(t.right, key)
                if _key != None:
                    return _key

        return None


    def inorder(self,t, _key):
        if t.left != None:
            self.inorder(t.left, _key)

        _key.append(t.key)

        if t.right != None:
            self.inorder(t.right, _key)


    def preorder(self,t, _key):
        _key.append(t.key)

        if t.left != None:
            self.preorder(t.left, _key)

        if t.right != None:
            self.preorder(t.right, _key)


if __name__==""__main__"":
    tree=treap()
    n = int(input())
    T = None
    for i in range(n):
        c, *v = input().split()
        if c == ""print"":
            print("" "", end="""")
            inans = []
            tree.inorder(T, inans)
            print(*inans)
            print("" "", end="""")
            preans = []
            tree.preorder(T, preans)
            print(*preans)
        elif c == ""insert"":
            key = int(v[0])
            pri = int(v[1])
            T = tree.insert(T, key, pri)
        elif c == ""find"":
            key = int(v[0])
            if tree.find(T, key) == None:
                print(""no"")
            else:
                print(""yes"")
        else:
            key = int(v[0])
            T = tree.delete(T, key)



"
8122575,ALDS1_8_D,"# -*- coding: utf-8 -*-
from sys import stdin
input = stdin.readline

n = int(input())

class Node():
    def __init__(self, data, priority):
        self.data = data
        self.left = None
        self.right = None
        self.p = None
        self.priority = priority

root = None

def rightRotate(t):
    s = t.left
    t.left = s.right
    s.right = t
    return s

def leftRotate(t):
    s = t.right
    t.right = s.left
    s.left = t
    return s

def insert(t, data, priority):
    if t is None:
        return Node(data, priority)
    if data == t.data:
        return t
    
    if data < t.data:
        t.left = insert(t.left, data, priority)
        if t.priority < t.left.priority:
            t = rightRotate(t)
    else:
        t.right = insert(t.right, data, priority)
        if t.priority < t.right.priority:
            t = leftRotate(t)
    return t

def delete(t, data):
    if t is None:
        return None
    if data < t.data:
        t.left = delete(t.left, data)
    elif data > t.data:
        t.right = delete(t.right, data)
    else:
        return _delete(t, data)
    return t

def _delete(t, data):
    if t.left is None and t.right is None:
        return None
    elif t.left is None:
        t = leftRotate(t)
    elif t.right is None:
        t = rightRotate(t)
    else:
        if t.left.priority > t.right.priority:
            t = rightRotate(t)
        else:
            t = leftRotate(t)
    return delete(t, data)

def pre_order(root):
    if root is None:
        return
    print(f"" {root.data}"", end="""")
    pre_order(root.left)
    pre_order(root.right)
    return

def in_order(root):
    if root is None:
        return
    in_order(root.left)
    print(f"" {root.data}"", end="""")
    in_order(root.right)

def find(target):
    if root is None:
        print(""no"")
        return
    nodes = root
    while nodes:
        if nodes.data == target:
            print(""yes"")
            return
        if target < nodes.data:
            nodes = nodes.left
        else:
            nodes = nodes.right
    else:
        print(""no"")
        return

for i in range(n):
    *x, = input().split()
    if 'insert' in x[0]:
        root = insert(root, int(x[1]), int(x[2]))
    elif 'find' in x[0]:
        find(int(x[1]))
    elif 'delete' in x[0]:
        root = delete(root, int(x[1]))
    else:
        in_order(root)
        print("""")
        pre_order(root)
        print("""")

"
6999458,ALDS1_8_D,"
from typing import Sequence, List, Deque, Optional, Tuple, Any, TypeVar, Union
from collections import deque
TREAP = TypeVar('TREAP', bound=""Treap"")


# class Node:
#     def __init__(self, id_: int, priority: int, treap: TREAP) -> None:
#         self.id = id_
#         self.priority = priority
#         self.treap = treap

#     def __eq__(self, __o: object) -> bool:
#         if isinstance(__o, Node):
#             return self.id == __o.id
#         super().__eq__(__o)

#     def __ne__(self, __o: object) -> bool:
#         if isinstance(__o, Node):
#             return not self.__eq__(__o)
#         super().__ne__(__o)

#     def __lt__(self, __o: object) -> bool:
#         if isinstance(__o, Node):
#             return self.id < __o.id
#         super().__lt__(__o)

#     def __le__(self, __o) -> bool:
#         if isinstance(__o, Node):
#             return self.__eq__(__o) or self.__lt__(__o)
#         super().__le__(__o)

#     def __gt__(self, __o) -> bool:
#         if isinstance(__o, Node):
#             return not self.__le__(__o)
#         super().__gt__(__o)

#     def __ge__(self, __o) -> bool:
#         if isinstance(__o, Node):
#             return not self.__lt__(__o)
#         super().__ge__(__o)


class Treap:
    def __init__(self, value: int = None, priority: int = None) -> None:
        self.id = value
        self.priority = priority
        self.left: Optional[TREAP] = None
        self.right: Optional[Treap] = None

    def find(self, value: int) -> Optional[TREAP]:
        if self.id is None and self.priority is None:
            return None

        if self.id == value:
            return self
        if self.id < value:
            try:
                return self.right.find(value)
            except AttributeError:
                return None
        if self.id > value:
            try:
                return self.left.find(value)
            except AttributeError:
                return None

    def is_exist(self, value: int) -> bool:
        return self.find(value) is not None

    def swap(self, other: TREAP):
        self.id, other.id = other.id, self.id
        self.priority, other.priority = other.priority, self.priority

    def left_rotate(self):
        self.swap(self.right)
        left_child = self.left
        right_child = self.right
        grand_child = self.right.right
        self.right.right = None
        self.right = grand_child

        left_child_of_right = right_child.left
        right_child.left = None
        right_child.right = left_child_of_right

        self.left = None
        right_child.left = left_child
        self.left = right_child

    def right_rotate(self):
        self.swap(self.left)
        left_child = self.left
        right_child = self.right
        grand_child = self.left.left
        self.left.left = None
        self.left = grand_child

        right_child_of_left = left_child.right
        left_child.right = None
        left_child.left = right_child_of_left

        self.right = None
        left_child.right = right_child
        self.right = left_child

    def delete(self, value: int) -> Optional[TREAP]:
        if self.id is None and self.priority is None:
            return self
        if value < self.id:
            if self.left is not None:
                self.left = self.left.delete(value)
            else:
                return self
        elif value > self.id:
            if self.right is not None:
                self.right = self.right.delete(value)
            else:
                return self
        else:
            return self.self_delete(value)
        return self

    def self_delete(self, value: int) -> Optional[TREAP]:
        if self.left is None and self.right is None:
            return

        if self.left is None:
            self.left_rotate()
        elif self.right is None:
            self.right_rotate()
        else:
            if self.left.priority < self.right.priority:
                self.left_rotate()
            else:
                self.right_rotate()
        return self.delete(value)

    def insert(self, key_: int, priority: int):
        if self.id is None and self.priority is None:
            self.id = key_
            self.priority = priority
            return

        if key_ == self.id:
            return

        if key_ < self.id:
            if self.left is not None:
                self.left.insert(key_, priority)
            else:
                self.left = Treap(key_, priority)
            if self.priority < self.left.priority:
                self.right_rotate()
        elif key_ > self.id:
            if self.right is not None:
                self.right.insert(key_, priority)
            else:
                self.right = Treap(key_, priority)
            if self.priority < self.right.priority:
                self.left_rotate()

    # def post_order(self) -> List[int]:
    #     def _post_order(root_node: Node) -> List[int]:
    #         left_ids = []
    #         if root_node.left is not None:
    #             left_ids = _post_order(root_node.left)
    #         right_ids = []
    #         if root_node.right is not None:
    #             right_ids = _post_order(root_node.right)

    #         left_ids.extend(right_ids)
    #         left_ids.append(root_node.id)
    #         return left_ids.copy()

    #     for node in self.nodes:
    #         if node.is_root:
    #             root = node
    #             break
    #     else:
    #         raise ValueError
    #     return _post_order(root)

    def pre_order(self) -> List[int]:
        stack: Deque[TREAP] = deque()
        ids = []
        stack.append(self)

        while stack:
            current_node = stack.pop()
            ids.append(current_node.id)
            if current_node.right is not None:
                stack.append(current_node.right)
            if current_node.left is not None:
                stack.append(current_node.left)
        return ids

    def in_order(self) -> List[int]:

        stack: Deque[TREAP] = deque()

        def add_left_nodes(node):
            left_leaf = node
            while left_leaf.left is not None:
                stack.append(left_leaf)
                left_leaf = left_leaf.left
            stack.append(left_leaf)

        ids = []

        add_left_nodes(self)
        while stack:
            current_node = stack.pop()
            ids.append(current_node.id)
            if current_node.right is not None:
                add_left_nodes(current_node.right)

        return ids

    # @property
    # def local_root(self) -> Optional[Node]:
    #     return self.__root

    # @local_root.setter
    # def local_root(self, node: Optional[Node]):
    #     self.__root = node
    #     self.__root.treap = self

    # @property
    # def global_treap(self) -> Optional[TREAP]:
    #     if self.parent is None:
    #         return self
    #     return self.parent.global_treap

    # @property
    # def id(self) -> Optional[int]:
    #     return self.local_root.id if self.local_root is not None else None

    # @property
    # def priority(self) -> Optional[int]:
    #     return (self.local_root.priority
    #             if self.local_root is not None else None)


def main():
    treap = Treap()
    N = int(input())
    for _ in range(N):
        query = input().split()
        if query[0] == ""insert"":
            treap.insert(int(query[1]), int(query[2]))
        if query[0] == ""find"":
            if treap.is_exist(int(query[1])):
                print(""yes"")
            else:
                print(""no"")
        if query[0] == ""delete"":
            treap.delete(int(query[1]))
        elif query[0] == ""print"":
            print("""".join(map(lambda elm: "" "" + str(elm), treap.in_order())))
            print("""".join(map(lambda elm: "" "" + str(elm), treap.pre_order())))


if __name__ == ""__main__"":
    main()

"
5440919,ALDS1_8_D,"import sys

class Node:
    parent = None
    left = None
    right = None
    
    def __init__(self, key, priority):
        self.key = key
        self.priority = priority

root = None

def preorder(u):
    if u is None:
        return
    print("" %d"" % u.key, end="""")
    preorder(u.left)
    preorder(u.right)
    
def inorder(u):
    if u is None:
        return
    inorder(u.left)
    print("" %d"" % u.key, end="""")
    inorder(u.right)

def right_rotate(t):
    s = t.left
    t.left = s.right
    s.right = t
    return s

def left_rotate(t):
    s = t.right
    t.right = s.left
    s.left = t
    return s

def insert(t, k, p):
    if t is None:
        return Node(k, p)
    if k < t.key:
        t.left = insert(t.left, k, p)
        if t.priority < t.left.priority:
            t = right_rotate(t)
    elif k > t.key:
        t.right = insert(t.right, k, p)
        if t.priority < t.right.priority:
            t = left_rotate(t)
    return t

def tree_delete(t, k):
    if t is None:
        return t
    if k == t.key:
        if t.left is None and t.right is None:
            return None
        elif t.left is None:
            t = left_rotate(t)
        elif t.right is None:
            t = right_rotate(t)
        else:
            if t.left.priority < t.right.priority:
                t = left_rotate(t)
            else:
                t = right_rotate(t)
        t = tree_delete(t, k)
    elif k < t.key:
        t.left = tree_delete(t.left, k)
    elif k > t.key:
        t.right = tree_delete(t.right, k)
    return t

def tree_search(u, k):
    if u == None:
        return None
    elif u.key == k:
        return u
    elif u.key > k:
        return tree_search(u.left, k)
    else:
        return tree_search(u.right, k)

n = int(input())
for _ in range(0, n):
    s = sys.stdin.readline().split()
    cmd = s[0]
    if cmd ==""find"":
        x = int(s[1])
        u = tree_search(root, x)
        if u == None:
            print(""no"")
        else:
            print(""yes"")
    elif cmd == ""insert"":
        x = int(s[1])
        p = int(s[2])
        root = insert(root, x, p)
    elif cmd == ""print"":
        inorder(root)
        print()
        preorder(root)
        print()
    elif cmd == ""delete"":
        x = int(s[1])
        root = tree_delete(root, x)

"
4026497,ALDS1_8_D,"class Treap:
    class TreapNode:
        def __init__(self, key, priority, leftchild=None, rightchild=None):
            self.key = key
            self.priority = priority
            self.leftchild = leftchild
            self.rightchild = rightchild

        def __repr__(self):
            return f'({self.key}, {self.priority})'

    def __init__(self):
        self.root = None
        self.inorder = []
        self.preorder = []

    def rotateR(self, t):
        s = t.leftchild
        t.leftchild = s.rightchild
        s.rightchild = t
        return s

    def rotateL(self, t):
        s = t.rightchild
        t.rightchild = s.leftchild
        s.leftchild = t
        return s

    def _insert(self, t, key, priority):
        if t is None:
            return self.TreapNode(key, priority)
        if key == t.key:
            return t
        if key < t.key:
            t.leftchild = self._insert(t.leftchild, key, priority)
            if t.priority < t.leftchild.priority:
                t = self.rotateR(t)
        else:
            t.rightchild = self._insert(t.rightchild, key, priority)
            if t.priority < t.rightchild.priority:
                t = self.rotateL(t)
        return t

    def insert(self, key, priority):
        self.root = self._insert(self.root, key, priority)

    def _delete_rotate(self, t, key):
        if t.leftchild is None and t.rightchild is None:
            return None
        elif t.leftchild is None:
            t = self.rotateL(t)
        elif t.rightchild is None:
            t = self.rotateR(t)
        else:
            if t.leftchild.priority > t.rightchild.priority:
                t = self.rotateR(t)
            else:
                t = self.rotateL(t)
        return self._delete(t, key)

    def _delete(self, t, key):
        if t is None:
            return None
        if key < t.key:
            t.leftchild = self._delete(t.leftchild, key)
        elif key > t.key:
            t.rightchild = self._delete(t.rightchild, key)
        else:
            return self._delete_rotate(t, key)
        return t

    def delete(self, key):
        self.root = self._delete(self.root, key)

    def _find(self, t, key):
        if t is None:
            return False
        elif key < t.key:
            return self._find(t.leftchild, key)
        elif key > t.key:
            return self._find(t.rightchild, key)
        else:
            return True

    def find(self, key):
        return self._find(self.root, key)

    def _walk(self, t):
        if t is None:
            return
        self.preorder.append(t.key)
        self._walk(t.leftchild)
        self.inorder.append(t.key)
        self._walk(t.rightchild)

    def walk(self):
        self.inorder.clear()
        self.preorder.clear()
        self._walk(self.root)

    def print(self):
        self.walk()
        print(' ' + ' '.join(map(str, self.inorder)))
        print(' ' + ' '.join(map(str, self.preorder)))


T = Treap()
N = int(input())
for _ in range(N):
    s = input().split()
    s[1:] = map(int, s[1:])
    if s[0] == 'insert':
        T.insert(s[1], s[2])
    if s[0] == 'find':
        print('yes' if T.find(s[1]) else 'no')
    if s[0] == 'delete':
        T.delete(s[1])
    if s[0] == 'print':
        T.print()

"
5488291,ALDS1_8_D,"class Treap:
    class TreapNode:
        def __init__(self, key, priority, leftchild=None, rightchild=None):
            self.key = key
            self.priority = priority
            self.leftchild = leftchild
            self.rightchild = rightchild

        def __repr__(self):
            return f'({self.key}, {self.priority})'

    def __init__(self):
        self.root = None
        self.inorder = []
        self.preorder = []

    def rotateR(self, t):
        s = t.leftchild
        t.leftchild = s.rightchild
        s.rightchild = t
        return s

    def rotateL(self, t):
        s = t.rightchild
        t.rightchild = s.leftchild
        s.leftchild = t
        return s

    def _insert(self, t, key, priority):
        if t is None:
            return self.TreapNode(key, priority)
        if key == t.key:
            return t
        if key < t.key:
            t.leftchild = self._insert(t.leftchild, key, priority)
            if t.priority < t.leftchild.priority:
                t = self.rotateR(t)
        else:
            t.rightchild = self._insert(t.rightchild, key, priority)
            if t.priority < t.rightchild.priority:
                t = self.rotateL(t)
        return t

    def insert(self, key, priority):
        self.root = self._insert(self.root, key, priority)

    def _delete_rotate(self, t, key):
        if t.leftchild is None and t.rightchild is None:
            return None
        elif t.leftchild is None:
            t = self.rotateL(t)
        elif t.rightchild is None:
            t = self.rotateR(t)
        else:
            if t.leftchild.priority > t.rightchild.priority:
                t = self.rotateR(t)
            else:
                t = self.rotateL(t)
        return self._delete(t, key)

    def _delete(self, t, key):
        if t is None:
            return None
        if key < t.key:
            t.leftchild = self._delete(t.leftchild, key)
        elif key > t.key:
            t.rightchild = self._delete(t.rightchild, key)
        else:
            return self._delete_rotate(t, key)
        return t

    def delete(self, key):
        self.root = self._delete(self.root, key)

    def _find(self, t, key):
        if t is None:
            return False
        elif key < t.key:
            return self._find(t.leftchild, key)
        elif key > t.key:
            return self._find(t.rightchild, key)
        else:
            return True

    def find(self, key):
        return self._find(self.root, key)

    def _walk(self, t):
        if t is None:
            return
        self.preorder.append(t.key)
        self._walk(t.leftchild)
        self.inorder.append(t.key)
        self._walk(t.rightchild)

    def walk(self):
        self.inorder.clear()
        self.preorder.clear()
        self._walk(self.root)

    def print(self):
        self.walk()
        print(' ' + ' '.join(map(str, self.inorder)))
        print(' ' + ' '.join(map(str, self.preorder)))


T = Treap()
N = int(input())
for _ in range(N):
    s = input().split()
    s[1:] = map(int, s[1:])
    if s[0] == 'insert':
        T.insert(s[1], s[2])
    if s[0] == 'find':
        print('yes' if T.find(s[1]) else 'no')
    if s[0] == 'delete':
        T.delete(s[1])
    if s[0] == 'print':
        T.print()


"
7093165,ALDS1_8_D,"class Node:
    def __init__(self, key, pri):
        self.key = key
        self.pri = pri
        self.left = None
        self.right = None


def rotate_left(t):
    s = t.right
    t.right = s.left
    s.left = t
    return s


def rotate_right(t):
    s = t.left
    t.left = s.right
    s.right = t
    return s


def insert(t, key, pri):
    if t is None:
        return Node(key, pri)
    if key < t.key:
        t.left = insert(t.left, key, pri)
        if t.left.pri > t.pri:
            t = rotate_right(t)
    else:
        t.right = insert(t.right, key, pri)
        if t.right.pri > t.pri:
            t = rotate_left(t)
    return t


def delete(t, key):
    if t is None:
        return None
    if t.key == key:
        if t.left is None and t.right is None:
            return None
        elif t.left is None:
            t = rotate_left(t)
        elif t.right is None:
            t = rotate_right(t)
        else:
            if t.right.pri > t.left.pri:
                t = rotate_left(t)
            else:
                t = rotate_right(t)
        t = delete(t, key)
    else:
        if key < t.key:
            t.left = delete(t.left, key)
        else:
            t.right = delete(t.right, key)
    return t


def find(t, key):
    if t is None:
        return False
    if t.key == key:
        return True
    if key < t.key:
        return find(t.left, key)
    else:
        return find(t.right, key)


def inorder(t):
    if t is None:
        return
    inorder(t.left)
    print('', t.key, end='')
    inorder(t.right)


def preorder(t):
    if t is None:
        return
    print('', t.key, end='')
    preorder(t.left)
    preorder(t.right)


M = int(input())
root = None
for _ in range(M):
    op = input().split()
    if op[0] == 'insert':
        root = insert(root, int(op[1]), int(op[2]))
    elif op[0] == 'find':
        print('yes' if find(root, int(op[1])) else 'no')
    elif op[0] == 'delete':
        root = delete(root, int(op[1]))
    else:
        inorder(root)
        print()
        preorder(root)
        print()

"
6807225,ALDS1_8_D,"import random

class Node:
    def __init__(self, key, priority):
        self.key = key
        self.priority = priority
        self.left = None
        self.right = None

def rotate_right(y):
    x = y.left
    y.left = x.right
    x.right = y

    return x

def rotate_left(x):
    y = x.right
    x.right = y.left
    y.left = x

    return y

def search(root, key):
    if root is None:
        return False
    
    if root.key == key:
        return True
    
    if root.key < key:
        return search(root.right, key)
    
    return search(root.left, key)

def insert(root, key, priority):
    if root is None:
        return Node(key, priority)
    
    if key == root.key:
        return root
    
    if key < root.key:
        root.left = insert(root.left, key, priority)
        if root.left.priority > root.priority:
            root = rotate_right(root)
    else:
        root.right = insert(root.right, key, priority)
        if root.right.priority > root.priority:
            root = rotate_left(root)
    
    return root

def delete(root, key):
    if root is None:
        return None

    if key < root.key:
        root.left = delete(root.left, key)
    elif key > root.key:
        root.right = delete(root.right, key)
    elif root.left is None and root.right is None:
        root = None
    elif root.left is None:
        temp = root.right
        del root
        root = temp
    elif root.right is None:
        temp = root.left
        del root
        root = temp
    elif root.left.priority < root.right.priority:
        root = rotate_left(root)
        root.left = delete(root.left, key)
    else:
        root = rotate_right(root)
        root.right = delete(root.right, key)
    
    return root

def traverse_inorder(root):
    if root is not None:
        traverse_inorder(root.left)
        print(f"" {root.key}"", end="""")
        traverse_inorder(root.right)

def traverse_preorder(root):
    if root is not None:
        print(f"" {root.key}"", end="""")
        traverse_preorder(root.left)
        traverse_preorder(root.right)

if __name__ == ""__main__"":
    n_queries = int(input())
    root = None
    queries = []
    for _ in range(n_queries):
        inputs = input().split()
        command = inputs[0]
        if command == ""insert"":
            k = int(inputs[1])
            p = int(inputs[2])
            root = insert(root, k, p)

        elif command == ""find"":
            k = int(inputs[1])
            n = search(root, k)
            if n:
                print(""yes"")
            else:
                print(""no"")

        elif command == ""delete"":
            k = int(inputs[1])
            root = delete(root, k)

        elif command == ""print"":
            traverse_inorder(root)
            print()
            traverse_preorder(root)
            print()


"
3587822,ALDS1_8_D,"import sys


class Node:
    def __init__(self, key=None, pri=None):
        self.left = None
        self.right = None
        self.key = key
        self.pri = pri


def right_rotate(t: Node):
    s = t.left
    t.left = s.right
    s.right = t
    return s


def left_rotate(t: Node):
    s = t.right
    t.right = s.left
    s.left = t
    return s


def insert(t: Node, key: int, pri: int):
    if t is None:
        return Node(key, pri)
    if key == t.key:
        return t
    if key < t.key:
        t.left = insert(t.left, key, pri)
        if t.pri < t.left.pri:
            t = right_rotate(t)
    else:
        t.right = insert(t.right, key, pri)
        if t.pri < t.right.pri:
            t = left_rotate(t)
    return t


def erase(t: Node, key: int):
    if t is None:
        return None
    if key == t.key:
        if t.left is None and t.right is None:
            return None
        elif t.left is None:
            t = left_rotate(t)
        elif t.right is None:
            t = right_rotate(t)
        else:
            if t.left.pri > t.right.pri:
                t = right_rotate(t)
            else:
                t = left_rotate(t)
        return erase(t, key)
    if key < t.key:
        t.left = erase(t.left, key)
    else:
        t.right = erase(t.right, key)
    return t


def find(t: Node, x: int):
    while t is not None:
        if t.key == x:
            return 1
        elif t.key > x:
            t = t.left
        else:
            t = t.right
    return 0


def inorder(t: Node):
    if t.left is not None:
        inorder(t.left)
    print("" {}"".format(t.key), end='')

    if t.right is not None:
        inorder(t.right)
    return


def preorder(t: Node):
    print("" {}"".format(t.key), end='')

    if t.left is not None:
        preorder(t.left)
    if t.right is not None:
        preorder(t.right)
    return


def print_key(t: Node):
    inorder(t)
    print(""\n"", end='')
    preorder(t)
    print(""\n"", end='')
    return


line = sys.stdin.readline()
n = int(line)
root = None
for i in range(n):
    line = sys.stdin.readline().split()
    if line[0] == 'insert':
        k, p = int(line[1]), int(line[2])
        root = insert(root, k, p)
    elif line[0] == 'delete':
        k = int(line[1])
        root = erase(root, k)
    elif line[0] == 'find':
        k = int(line[1])
        if find(root, k):
            print(""yes"")
        else:
            print(""no"")
    else:
        print_key(root)

"
6806693,ALDS1_8_D,"#テンプレート

def inputLine():
    return [x for x in input().split("" "")]



class Treap:
    def __init__(self):
        self.root = None

    @staticmethod
    def createNode(key, priority):
        return {""key"": key, ""priority"": priority, ""left"": None, ""right"": None}
    
    def getRoot(self):
        return self.root

    def setRoot(self, t):
        self.root = t


    def rightRotate(self, t):
        s = t[""left""]
        t[""left""] = s[""right""]
        s[""right""] = t
        return s# root of the subtree

    def leftRotate(self, t):
        s = t[""right""]
        t[""right""] = s[""left""]
        s[""left""] = t
        return s# root of the subtree


    def insert(self, t, key, priority):# 再帰的に探索
        if t == None:# 葉に到達したら新しい節点を生成して返す
            return Treap.createNode(key, priority)

        if t[""key""] == key:# 重複したkeyは無視
            return t

        if key < t[""key""]:# 左の子へ移動
            t[""left""] = self.insert(t[""left""], key, priority)#  左の子へのポインタを更新
            if t[""priority""] < t[""left""][""priority""]:# 左の子の方が優先度が高い場合右回転
                #print(t)
                t = self.rightRotate(t)
                #print(t)
    
        else:# 右の子へ移動
            t[""right""] = self.insert(t[""right""], key, priority)# 右の子へのポインタを更新
            if t[""priority""] < t[""right""][""priority""]:# 右の子の方が優先度が高い場合左回転
                #print(t)
                t = self.leftRotate(t)
                #print(t)

        return t


    def delete(self, t, key):
        if t == None:
            return None
        if key < t[""key""]:# 削除対象を検索
            t[""left""] = self.delete(t[""left""], key)
        elif key > t[""key""]:
            t[""right""] = self.delete(t[""right""], key)
        else:
            return self._delete(t, key)

        return t

    def _delete(self, t, key):# 削除対象の節点の場合
        if t[""left""] is None and t[""right""] is None:# 葉の場合
            return None

        elif t[""left""] is None:# 右の子のみを持つ場合左回転
            t = self.leftRotate(t)
        elif t[""right""] is None:# 左の子のみを持つ場合右回転
            t = self.rightRotate(t)
        else:# 左の子と右の子を両方持つ場合
            if t[""left""][""priority""] > t[""right""][""priority""]:# 優先度が高い方を持ち上げる
                t = self.rightRotate(t)
            else:
                t = self.leftRotate(t)

        return self.delete(t, key)# 回転処理後に再度実行
        

        
    def find(self, t, key):
        if t[""key""] == key:
            return True

        if key < t[""key""]:
            if t[""left""] is None:
                return False
            else:
                return self.find(t[""left""], key)

        else:
            if t[""right""] is None:
                return False
            else:
                return self.find(t[""right""], key)

    def preTraversal(self, t):
        if t is None:
            return

        print(f"" {t['key']}"", end="""")
        if t[""left""] is not None:
            self.preTraversal(t[""left""])
        if t[""right""] is not None:
            self.preTraversal(t[""right""])


    def inTraversal(self, t):
        if t is None:
            return

        if t[""left""] is not None:
            self.inTraversal(t[""left""])

        print(f"" {t['key']}"", end="""")

        if t[""right""] is not None:
            self.inTraversal(t[""right""])





if __name__ == ""__main__"":
    N = int(input())
    MyTreap = Treap()

    for _ in range(N):
        inputs = inputLine()

        if inputs[0] == ""insert"":
            [key, priority] = [int(v) for v in inputs[1:]]
            t = MyTreap.insert(MyTreap.getRoot(), key, priority)
            MyTreap.setRoot(t)

        elif inputs[0] == ""find"":
            key = int(inputs[1])
            result = MyTreap.find(MyTreap.getRoot(), key)
            if result:
                print(""yes"")
            else:
                print(""no"")

        elif inputs[0] == ""delete"":
            key = int(inputs[1])
            t = MyTreap.delete(MyTreap.getRoot(), key)
            MyTreap.setRoot(t)

        elif inputs[0] == ""print"":
            MyTreap.inTraversal(MyTreap.getRoot())
            print("""")
            MyTreap.preTraversal(MyTreap.getRoot())
            print("""")
            
        


    
"
8073214,ALDS1_8_D,"import random

class Node:
    def __init__(self, key, priority):
        self.key = key
        self.priority = priority
        self.left = None
        self.right = None

def rotate_right(y):
    x = y.left
    y.left = x.right
    x.right = y

    return x

def rotate_left(x):
    y = x.right
    x.right = y.left
    y.left = x

    return y

def search(root, key):
    if root is None:
        return False
    
    if root.key == key:
        return True
    
    if root.key < key:
        return search(root.right, key)
    
    return search(root.left, key)

def insert(root, key, priority):
    if root is None:
        return Node(key, priority)
    
    if key == root.key:
        return root
    
    if key < root.key:
        root.left = insert(root.left, key, priority)
        if root.left.priority > root.priority:
            root = rotate_right(root)
    else:
        root.right = insert(root.right, key, priority)
        if root.right.priority > root.priority:
            root = rotate_left(root)
    
    return root

def delete(root, key):
    if root is None:
        return None

    if key < root.key:
        root.left = delete(root.left, key)
    elif key > root.key:
        root.right = delete(root.right, key)
    elif root.left is None and root.right is None:
        root = None
    elif root.left is None:
        temp = root.right
        del root
        root = temp
    elif root.right is None:
        temp = root.left
        del root
        root = temp
    elif root.left.priority < root.right.priority:
        root = rotate_left(root)
        root.left = delete(root.left, key)
    else:
        root = rotate_right(root)
        root.right = delete(root.right, key)
    
    return root

def traverse_inorder(root):
    if root is not None:
        traverse_inorder(root.left)
        print(f"" {root.key}"", end="""")
        traverse_inorder(root.right)

def traverse_preorder(root):
    if root is not None:
        print(f"" {root.key}"", end="""")
        traverse_preorder(root.left)
        traverse_preorder(root.right)

if __name__ == ""__main__"":
    n_queries = int(input())
    root = None
    queries = []
    for _ in range(n_queries):
        inputs = input().split()
        command = inputs[0]
        if command == ""insert"":
            k = int(inputs[1])
            p = int(inputs[2])
            root = insert(root, k, p)

        elif command == ""find"":
            k = int(inputs[1])
            n = search(root, k)
            if n:
                print(""yes"")
            else:
                print(""no"")

        elif command == ""delete"":
            k = int(inputs[1])
            root = delete(root, k)

        elif command == ""print"":
            traverse_inorder(root)
            print()
            traverse_preorder(root)
            print()

"
3094278,ALDS1_8_D,"class Node:
    def __init__(self, key, priority):
        self.key = key
        self.pri = priority
        self.parent = None
        self.left = None
        self.right = None
        
    def insert(self, z):
        if z.key < self.key:
            if self.left:
                self.left.insert(z)
            else:
                self.left = z
                z.parent = self
            if self.pri < self.left.pri:
                self.rightR()
        elif self.key < z.key:
            if self.right:
                self.right.insert(z)
            else:
                self.right = z
                z.parent = self
            if self.pri < self.right.pri:
                self.leftR()
    
    def find(self, key):
        if self.key == key:
            return True
        elif not self.left and not self.right:
            return False
        else:
            if key < self.key:
                return self.left.find(key)
            else:
                return self.right.find(key)
            
    def delete(self, key):
        if key < self.key:
            self.left.delete(key)
        elif key > self.key:
            self.right.delete(key)
        else:
            self._delete()
    
    def _delete(self):
        if not self.left and not self.right:
            if self.parent.left == self:
                self.parent.left = None
            else:
                self.parent.right = None
            del self
            return None
        elif self.left and self.right:
            if self.left.pri > self.right.pri:
                self.rightR()
            else:
                self.leftR()
        elif self.right:
            self.leftR()
        else:
            self.rightR()
        self._delete()
        
    def rightR(self):
        tmp = self.left
        if self.parent:
            if self.key < self.parent.key:
                self.parent.left = tmp
            else:
                self.parent.right = tmp
        self.left = tmp.right
        if self.left:
            self.left.parent = self
        tmp.right = self
        tmp.parent = self.parent
        self.parent = tmp
        
    def leftR(self):
        tmp = self.right
        if self.parent:
            if self.key < self.parent.key:
                self.parent.left = tmp
            else:
                self.parent.right = tmp
        self.right = tmp.left
        if self.right:
            self.right.parent = self
        tmp.left = self
        tmp.parent = self.parent
        self.parent = tmp
    
    def preo(self):
        tmp = """"
        tmp += "" "" + str(self.key)
        if self.left:
            tmp += self.left.preo()
        if self.right:
            tmp += self.right.preo()
        return tmp
    
    def ino(self):
        tmp = """"
        if self.left:
            tmp += self.left.ino()
        tmp += "" "" + str(self.key)
        if self.right:
            tmp += self.right.ino()
        return tmp

m = int(input())
root = None
for i in range(m):
    com = input().split()
    if com[0] == ""insert"":
        node = Node(int(com[1]), int(com[2]))
        try:
            root.insert(node)
        except AttributeError :
            root = node
    elif com[0] == ""find"":
        try:
            if root.find(int(com[1])):
                print(""yes"")
            else:
                print(""no"")
        except AttributeError:
            print(""no"")
    elif com[0] == ""delete"":
        try:
            root.delete(int(com[1]))
        except AttributeError:
            pass
    else:
        try:
            print(root.ino())
            print(root.preo())
        except AttributeError:
            print(""None"")
    c = 0
    while(True):
        if root.parent:
            root = root.parent
        else:
            break
"
8022571,ALDS1_8_D,"from functools import lru_cache

NIL = -1

class Node:
    def __init__(self, key, priority) -> None:
        self.key = key
        self.priority = priority
        self.right = NIL
        self.left = NIL

def main():
    treap = NIL;
    m = int(input())

    for i in range(m):
        inputs = list(map(str, input().split()))
        if inputs[0] == ""insert"":
            key, priority = int(inputs[1]), int(inputs[2])
            treap = insert(treap, key, priority)
        elif inputs[0] == ""delete"":
            key = int(inputs[1])
            treap = delete(treap, key)
        elif inputs[0] == ""find"":
            key = int(inputs[1])
            find(treap, key)
        else:
            print_(treap)

def rightRotate(t):
    s = t.left
    t.left = s.right
    s.right = t
    return s # root of the subtree

def leftRotate(t):
    s = t.right
    t.right = s.left
    s.left = t
    return s # root of the subtree

def insert(t, key, priority):                        # 再帰的に探索
    if t == NIL:
        return Node(key, priority)               # 葉に到達したら新しい節点を生成して返す
    if key == t.key:
        return t                                 # 重複したkeyは無視

    if key < t.key:                               # 左の子へ移動
        t.left = insert(t.left, key, priority)   # 左の子へのポインタを更新
        if t.priority < t.left.priority:          # 左の子の方が優先度が高い場合右回転
            t = rightRotate(t)
    else:                                         # 右の子へ移動
        t.right = insert(t.right, key, priority) # 右の子へのポインタを更新
        if t.priority < t.right.priority:         # 右の子の方が優先度が高い場合左回転
            t = leftRotate(t)
    return t

def delete(t, key):
    if t == NIL:
        return NIL
    if key < t.key:                                # 削除対象を検索
        t.left = delete(t.left, key)
    elif key > t.key:
        t.right = delete(t.right, key)
    else:
        return _delete(t, key)
    return t

def _delete(t, key): # 削除対象の節点の場合
    if t.left == NIL and t.right == NIL:           # 葉の場合
        return NIL
    elif t.left == NIL:                        # 右の子のみを持つ場合左回転
        t = leftRotate(t)
    elif t.right == NIL:                       # 左の子のみを持つ場合右回転
        t = rightRotate(t)
    else:                                         # 左の子と右の子を両方持つ場合
        if t.left.priority > t.right.priority:    # 優先度が高い方を持ち上げる
            t = rightRotate(t)
        else:
            t = leftRotate(t)
    return delete(t, key)

def find(current_node, target_key):
    if current_node.key == target_key:
        print(""yes"")
        return
    elif target_key < current_node.key and current_node.left != NIL:
        return find(current_node.left, target_key)
    elif target_key > current_node.key and current_node.right != NIL:
        return find(current_node.right, target_key)
    else:
        print(""no"")
        return

def print_(t):
    # print('')
    inorder(t)
    print('')
    preorder(t)
    print('')

def inorder(t):
    if t == NIL:
        return
    inorder(t.left)
    print(f' {t.key}', end='')
    inorder(t.right)

def preorder(t):
    if t == NIL:
        return
    print(f' {t.key}', end='')
    preorder(t.left)
    preorder(t.right)

if __name__ == ""__main__"":
    main()

"
8033240,ALDS1_8_D,"class Node:
    def __init__(self, key, priority):
        self.key = key
        self.priority = priority
        self.left = None
        self.right = None

def right_rotate(t):
    s = t.left
    t.left = s.right
    s.right = t
    return s

def left_rotate(t):
    s = t.right
    t.right = s.left
    s.left = t
    return s

def insert(t, key, priority):
    if t is None:
        return Node(key, priority)
    if key == t.key:
        return t
    
    if key < t.key:
        t.left = insert(t.left, key, priority)
        if t.priority < t.left.priority:
            t = right_rotate(t)
    else:
        t.right = insert(t.right, key, priority)
        if t.priority < t.right.priority:
            t = left_rotate(t)
    return t

def delete(t, key):
    if t is None:
        return None
    if key < t.key:
        t.left = delete(t.left, key)
    elif key > t.key:
        t.right = delete(t.right, key)
    else:
        return delete2(t, key)
    return t

def delete2(t, key):
    if t.left is None and t.right is None:
        return None
    elif t.left is None:
        t = left_rotate(t)
    elif t.right is None:
        t = right_rotate(t)
    else:
        if t.left.priority > t.right.priority:
            t = right_rotate(t)
        else:
            t = left_rotate(t)
    return delete(t, key)

def find(t, key):
    if t is None:
        return False
    if t.key == key:
        return True
    if key < t.key:
        return find(t.left, key)
    if t.key < key:
        return find(t.right, key)


def inorder(t):
    if t is not None:
        inorder(t.left)
        print(f' {t.key}', end='')
        inorder(t.right)

def preorder(t):
    if t is not None:
        print(f' {t.key}', end='')
        preorder(t.left)
        preorder(t.right)

treap = None
n = int(input())
for _ in range(n):
    com = tuple(input().split())
    if com[0] == 'insert':
        treap = insert(treap, int(com[1]), int(com[2]))
    elif com[0] == 'find':
        if find(treap, int(com[1])):
            print('yes')
        else:
            print('no')
    elif com[0] == 'delete':
        treap = delete(treap, int(com[1]))
    else:
        inorder(treap)
        print()
        preorder(treap)
        print()

"
5124733,ALDS1_8_D,"def main() :
    global rootNode

    n = int(input())
    commandArray = [input() for _ in range(n)]

    for command in commandArray :
        splitCommand = command.split()

        if splitCommand[0] == ""insert"" :
            rootNode = insert(rootNode, int(splitCommand[1]), int(splitCommand[2]))
        elif splitCommand[0] == ""delete"" :
            deleteNodeId = int(splitCommand[1])
            rootNode = delete(rootNode, deleteNodeId)
        elif splitCommand[0] == ""find"" :
            targetNodeId = int(splitCommand[1])
            find(targetNodeId)
        else :
            printNodeByInOrder(rootNode)
            print()
            printNodeByPreOrder(rootNode)
            print()

def insert(node, id, priority) :
    if node is None :
        return Node(id, priority)
    
    if id == node.id :
        return node
    
    if id < node.id :
        node.leftChild = insert(node.leftChild, id, priority)
        if node.priority < node.leftChild.priority :
            node = rightRotate(node)
    else :
        node.rightChild = insert(node.rightChild, id, priority)
        if node.priority < node.rightChild.priority :
            node = leftRotate(node)
    
    return node

def delete(node, id) :
    if node is None :
        return None
    
    if id < node.id :
        node.leftChild = delete(node.leftChild, id)
    elif id > node.id :
        node.rightChild = delete(node.rightChild, id)
    else :
        return _delete(node, id)
    
    return node

def _delete(node, id) :
    if node.leftChild is None and node.rightChild is None :
        return None
    elif node.leftChild is None :
        node = leftRotate(node)
    elif node.rightChild is None :
        node = rightRotate(node)
    else :
        if node.leftChild.priority > node.rightChild.priority :
            node = rightRotate(node)
        else :
            node = leftRotate(node)
    
    return delete(node, id)

def find(targetNodeId) :
    global rootNode

    tempNode = rootNode

    while tempNode is not None :
        if targetNodeId == tempNode.id :
            print(""yes"")
            return
        elif targetNodeId < tempNode.id :
            tempNode = tempNode.leftChild
        else :
            tempNode = tempNode.rightChild
        
    print(""no"")
    return

def printNodeByPreOrder(targetNode) :
    if targetNode is None :
        return

    print("" "" + str(targetNode.id), end = """")

    printNodeByPreOrder(targetNode.leftChild)
    
    printNodeByPreOrder(targetNode.rightChild)

def printNodeByInOrder(targetNode) :
    if targetNode is None :
        return

    printNodeByInOrder(targetNode.leftChild)

    print("" "" + str(targetNode.id), end = """")

    printNodeByInOrder(targetNode.rightChild)

def rightRotate(node) :
    tempNode = node.leftChild
    node.leftChild = tempNode.rightChild
    tempNode.rightChild = node
    return tempNode

def leftRotate(node) :
    tempNode = node.rightChild
    node.rightChild = tempNode.leftChild
    tempNode.leftChild = node
    return tempNode

class Node :
    id = int()
    priority = int()
    parent = None
    leftChild = None
    rightChild = None

    def __init__(self, id, priority) :
        self.id = id
        self.priority = priority

rootNode = None
main()

"
8243927,ALDS1_9_A,"N = int(input())
L = list(map(int,input().split()))


for n in range(1,N+1):
    print('node ' + str(n) + (':'), end = ' ')
    key = L[n-1]
    print('key = ' + str(key),end = ', ' )
    if n > 1:
        parent = int(n/2)
        parentkey = L[parent - 1]
        print('parent key = ' + str(parentkey), end = ', ')
        
    if n*2 <= N:
        leftkey = L[n*2 - 1]
        print('left key = ' + str(leftkey), end = ', ')
        
        if n*2 + 1 <= N:
            rightkey = L[n*2]
            print('right key = ' + str(rightkey), end = ', ')
            
    print()
"
8394113,ALDS1_9_A,"def main():
    n = int(input())
    heap = [int(s) for s in input().split()]
    for i in range(1, n + 1):
        print(""node {}: key = {},"".format(i, heap[i-1]), end="" "")
        if 1 <= i // 2:
            print(""parent key = {},"".format(heap[i//2-1]), end="" "")
        if 2 * i <= n:
            print(""left key = {},"".format(heap[2*i-1]), end="" "")
        if 2 * i + 1 <= n:
            print(""right key = {},"".format(heap[2*i+1-1]), end="" "")
        print()


if __name__ == ""__main__"":
    main()
"
8439929,ALDS1_9_A,"def main():
    H = int(input())
    heap = [0] + list(map(int,input().split()))
    for i in range(1, 1+H):
        print_node_properties(i, heap)

def print_node_properties(ni, heap):
    # キー番号と値
    print(f'node {ni}: key = {heap[ni]}, ', end='')
    H = len(heap) - 1
    # 親ノードがある場合
    if ni != 1:
        print(f'parent key = {heap[ni//2]}, ', end='')
    # 左の子ノードがある場合
    if ni*2 <= H:
        print(f'left key = {heap[ni*2]}, ', end='')
    # 右の子ノードがある場合
    if (ni*2+1) <= H:
        print(f'right key = {heap[ni*2+1]}, ', end='')
    print()

if __name__ == '__main__':
    main()
"
8463004,ALDS1_9_A,"# Pythonでは、標準入力を扱うためにsysモジュールがよく使われます。
import sys

# 親ノードのインデックスを返す関数
def parent(i):
    return i // 2

# 左の子ノードのインデックスを返す関数
def left(i):
    return 2 * i

# 右の子ノードのインデックスを返す関数
def right(i):
    return 2 * i + 1

# メイン関数
def main():
    # ヒープのサイズを標準入力から読み込む
    H = int(input())
    
    # ヒープの各要素を標準入力から読み込む
    # Pythonでは、リスト内包表記を使ってこれを1行で行うことができます。
    heap = [int(x) for x in input().split()]
    
    # ヒープの要素を出力する
    for i in range(H):
        # 要素のインデックスは1から始まるため、オフセットとして1を加えます。
        print(f""node {i+1}: key = {heap[i]}, "", end='')
        
        # 親ノードがあれば出力する
        if parent(i+1) >= 1:
            print(f""parent key = {heap[parent(i+1)-1]}, "", end='')
        
        # 左の子ノードがあれば出力する
        if left(i+1) <= H:
            print(f""left key = {heap[left(i+1)-1]}, "", end='')
        
        # 右の子ノードがあれば出力する
        if right(i+1) <= H:
            print(f""right key = {heap[right(i+1)-1]}, "", end='')
        
        # 改行を出力
        print()

# メイン関数を呼び出す
if __name__ == ""__main__"":
    main()

"
8483132,ALDS1_9_A,"num_nodes = int(input())
keys = list(map(int, input().split()))
for i, key in enumerate(keys):
  attrs = [f'key = {key}']
  parent_i = int((i + 1) / 2)
  left_i = (i + 1) * 2
  right_i = (i + 1) * 2 + 1
  if 1 <= parent_i and parent_i <= num_nodes: attrs.append(f'parent key = {keys[parent_i - 1]}')
  if left_i <= num_nodes: attrs.append(f'left key = {keys[left_i - 1]}')
  if right_i <= num_nodes: attrs.append(f'right key = {keys[right_i - 1]}')
  print(f'node {i+1}: ' + ', '.join(attrs) + ', ')
"
8495992,ALDS1_9_A,"n = int(input()) + 1
h = [0] + [int(i) for i in input().split()]
for i in range(1, n):
    p = i >> 1
    l = i << 1
    r = l | 1
    print(f'node {i}: key = {h[i]}, ', end='')
    if p: print(f'parent key = {h[p]}, ', end='')
    if l < n: print(f'left key = {h[l]}, ', end='')
    if r < n: print(f'right key = {h[r]}, ', end='')
    print()
"
8527925,ALDS1_9_A,"N = int(input())
heap = input().split()
for i in range(N):
  print(f""node {i+1}: key = {heap[i]}, "", end="""")
  print(f""parent key = {heap[(i-1)//2]}, "" if i else """", end="""")
  print(f""left key = {heap[2*i+1]}, "" if 2*i+1 < N else """", end="""")
  print(f""right key = {heap[2*i+2]}, "" if 2*i+2 < N else """")

"
8561740,ALDS1_9_A,"debug_mode = False
if debug_mode:
    l = [10, 8, 5, 1, 2, 3]
else:
    n = int(input())
    l = list(map(int, input().split()))

for i, num in enumerate(l):
    node = i + 1
    key = num
    parent = None
    if node != 1:
        parent = l[node // 2 - 1]
    left_key, right_key = None, None
    if (2*node - 1) <= len(l)-1:
        left_key = l[2*node-1]
    if (2*node) <= len(l)-1:
        right_key = l[2*node]
    

    if left_key is None:
        print(f""node {node}: key = {key}, parent key = {parent},"")
    elif right_key is None:
        print(f""node {node}: key = {key}, parent key = {parent}, left key = {left_key},"")
    elif parent is None:
        print(f""node {node}: key = {key}, left key = {left_key}, right key = {right_key},"")
    else:
        print(f""node {node}: key = {key}, parent key = {parent}, left key = {left_key}, right key = {right_key},"")


"
8574969,ALDS1_9_A,"h = int(input())
key_list = list(map(int, input().split()))

for i, key in enumerate(key_list):
    parent = f""parent key = {key_list[(i + 1) // 2 - 1]}, "" if (i + 1) // 2 >= 1 else """"
    left = f""left key = {key_list[2 * (i + 1) - 1]}, "" if 2 * (i + 1) <= h else """"
    right = f""right key = {key_list[2 * (i + 1)]}, "" if 2 * (i + 1) + 1 <= h else """"
    print(f""node {i + 1}: "", f""key = {key}, "", parent, left, right)

"
8578914,ALDS1_9_A,"H = int(input())
heap = input().split(' ')

for i in range(H):
  print(f'node {i+1}: key = {heap[i]}, ', end='')
  print(f'parent key = {heap[(i - 1)//2]}, ' if i else '', end = '') # 1つ目のノードは親ノードを持たない。
  print(f'left key = {heap[2 * i + 1]}, ' if 2 * i + 1 < H else '', end = '')
  print(f'right key = {heap[2 * i + 2]}, ' if 2 * i + 2 < H else '')
"
8598851,ALDS1_9_A,"#Complete Binary Tree
H = int(input()) #heapsize
A = input().split(' ')
for i in range(H):
    A[i] = int(A[i])
for i in range(H):
    print(f'node {i+1}: key = {A[i]}, ', end = """")
    print(f'parent key = {A[(i-1)//2]}, 'if i else """", end = """")
    print(f'left key = {A[2*i+1]}, 'if 2*i+1<H else """", end = """")
    print(f'right key = {A[2*(i+1)]}, 'if 2*(i+1)<H else """")
    

"
8632788,ALDS1_9_A,"h = int(input())
A = [""x""] + list(map(int,input().split()))
for i in range(1, h+1):
    node = i
    key = A[i]
    parent_key = A[i//2] if i != 1 else ""x""
    left_key = A[i*2] if i*2 <= h else ""x""
    right_key = A[i*2+1] if i*2+1 <= h else ""x""
    print(f""node {node}: key = {key}, "", end="""")
    if parent_key != ""x"":
        print(f""parent key = {parent_key}, "", end="""")
    if left_key != ""x"":
        print(f""left key = {left_key}, "", end="""")
    if right_key != ""x"":
        print(f""right key = {right_key}, "", end="""")
    print("""")

"
8710986,ALDS1_9_A,"import sys
input = sys.stdin.readline

def parent(i):
    return i//2

def left(i):
    return 2*i

def right(i):
    return 2*i +1

H = int(input())

A = [None] + list(map(int, input().split()))

for i in range(1, H+1):
    print('node ' + str(i) + ': ',end = '')
    print('key = ' + str(A[i]) + ', ', end = '')
    if 1 <= parent(i):
        print('parent key = ' + str(A[parent(i)]) + ', ', end = '')
    if left(i) <= H:
        print('left key = ' + str(A[left(i)]) + ', ', end = '')
    if right(i) <= H:
        print('right key = ' + str(A[right(i)]) + ', ', end = '')
    print('')
"
8786662,ALDS1_9_A,"class Heap:
    def __init__(self,H,input_data):
        self.key = input_data
        self.parent = [-100 for i in range(H)]
        self.child = [[-100 for i in range(2)] for i in range(H)]

H = int(input())
input_data = list(map(int,input().split()))
heap = Heap(H,input_data)
for i in range(H//2):
    if 2*i+1 < H:
        heap.parent[2*i+1] = heap.key[i]
        heap.child[i][0] = heap.key[2*i+1]
    if 2*i+2 < H:
        heap.child[i][1] = heap.key[2*i+2]
        heap.parent[2*i+2] = heap.key[i]

for i in range(H):
    print(""node {}:"".format(i+1),end="" "")
    print(""key = {},"".format(heap.key[i]),end="" "")
    if heap.parent[i] != -100:
        print(""parent key = {},"".format(heap.parent[i]),end="" "")
    if heap.child[i][0] != -100:
        print(""left key = {},"".format(heap.child[i][0]),end="" "")
    if heap.child[i][1] != -100:
        print(""right key = {},"".format(heap.child[i][1]),end ="" "")
    print()
"
8787626,ALDS1_9_A,"# from icecream import ic

length = int(input())
Array = input()
a = list(map(int, Array.split()))

a.insert(0,None)

# ic(a)

for i in range(1, length+1):
    print(f""node {i}: key = {a[i]}, "", end="""")
    if i // 2 > 0:
        print(f""parent key = {a[i//2]}, "", end="""")
    if i * 2 <= length:
        print(f""left key = {a[i*2]}, "",end="""")
    if i * 2 + 1 <= length:
        print(f""right key = {a[i*2+1]}, "", end="""")
    print()
"
8795765,ALDS1_9_A,"def print_n(heap):
    n = len(heap)
    for i in range(n):
        node_info = f""node {i + 1}: key = {heap[i]}""
        parent_index = (i - 1) // 2
        left_index = 2 * i + 1
        right_index = 2 * i + 2

        if parent_index >= 0:
            node_info += f"", parent key = {heap[parent_index]}""
        if left_index < n:
            node_info += f"", left key = {heap[left_index]}""
        if right_index < n:
            node_info += f"", right key = {heap[right_index]}""

        print(node_info + "", "")
num111=input()
num = example_sequence = list(map(int, input().split()))
print_n(num)

"
8801895,ALDS1_9_A,"h = int(input())
key = [0] + list(map(int, input().split()))

for i in range(1, h+1):
    p = f""node {i}: key = {key[i]}, ""
    if 1 <= i//2:  p += f""parent key = {key[i//2]}, ""
    if 2*i <= h:   p += f""left key = {key[2*i]}, ""
    if 2*i+1 <= h: p += f""right key = {key[2*i+1]}, ""
    print(p)
"
8811568,ALDS1_9_A,"# aizu_ALDS1_9_A_CompleteBinaryTree.py  

class Node:
    def __init__(self): pass

H = int(input())
A = list(map(int,input().split()))
binary_heap = [ Node() for i in range(H+1)]

for i in range(1,H+1):
    h = binary_heap[i]
    h.id = i
    h.key = A[i-1]
    h.parent = i//2 if i//2 != 0 else -1
    h.left = i*2 if i*2 <= H else -1
    h.right = i*2 + 1 if i*2+1 <= H else -1

binary_heap[1].parent = -1
for i in range(1,H+1):
    h = binary_heap[i]
    ans = 'node ' + str(h.id) + ': key = '+ str(h.key) 
    if h.parent != -1: ans += ', parent key = ' + str(binary_heap[h.parent].key)
    if h.left != -1:
        ans += ', left key = ' + str(binary_heap[h.left].key) 
    if h.right != -1: 
        ans += ', right key = ' + str(binary_heap[h.right].key) 
    ans += ', '
    print(ans)
"
8817358,ALDS1_9_A,"H = int(input())
A = list(map(int, input().split()))

def print_node(i):
    print(f""node {i+1}: key = {A[i]},"", end="""")
    if i > 0:
        print(f"" parent key = {A[(i-1)//2]},"", end="""")
    if 2*i+1 < H:
        print(f"" left key = {A[2*i+1]},"", end="""")
    if 2*i+2 < H:
        print(f"" right key = {A[2*i+2]},"", end="""")
    print()

for i in range(H):
    print_node(i)
"
8826200,ALDS1_9_A,"class Node:
    def __init__(self):
        self.key = None
        self.leftkey = None
        self.rightkey = None
        self.parentkey = None

H = int(input())
binary_heap = [Node() for _ in range(H+1)]
output = []

input_line = list(map(int, input().split()))
for i in range(1, H+1):
    binary_heap[i].key = input_line[i-1]
    
for i in range(1, H+1):
    parent_index = i // 2
    left_index = 2 * i
    right_index = 2 * i + 1
    if i != 1:
        binary_heap[i].parentkey = binary_heap[parent_index].key
    if left_index <= H:
        binary_heap[i].leftkey = binary_heap[left_index].key
    if right_index <= H:
        binary_heap[i].rightkey = binary_heap[right_index].key

for i in range(1, H+1):
    nownode = binary_heap[i]
    if nownode.parentkey is None:
        output.append(""node {}: key = {}, left key = {}, right key = {},"".format(i, nownode.key, nownode.leftkey, nownode.rightkey))
    elif nownode.leftkey is not None and nownode.rightkey is not None:
        output.append(""node {}: key = {}, parent key = {}, left key = {}, right key = {},"".format(i, nownode.key, nownode.parentkey, nownode.leftkey, nownode.rightkey))
    elif nownode.leftkey is not None and nownode.rightkey is None:
        output.append(""node {}: key = {}, parent key = {}, left key = {},"".format(i, nownode.key, nownode.parentkey, nownode.leftkey))
    elif nownode.leftkey is None:
        output.append(""node {}: key = {}, parent key = {},"".format(i, nownode.key, nownode.parentkey))

print(""\n"".join(output))
"
9037216,ALDS1_9_A,"class Node:
    def __init__(self, key):
        self.key=key
        self.parent=None
        self.left=None
        self.right=None

H=int(input())
unit_list=list(map(int, input().split()))
nodes=[Node(i) for i in unit_list]
for i in range(H):
    if i >= 1:
        nodes[i].parent=nodes[(i+1)//2-1].key
    if 2*(i+1) <= H:
        nodes[i].left=nodes[2*(i+1)-1].key
    if 2*(i+1)+1 <= H:
        nodes[i].right=nodes[2*(i+1)].key
    print(""node {0}: key = {1}, "".format(i+1, nodes[i].key), end="""")
    if nodes[i].parent!=None:
        print(""parent key = {0}, "".format(nodes[i].parent), end="""")
    if nodes[i].left!=None:
        print(""left key = {0}, "".format(nodes[i].left), end="""")
    if nodes[i].right!=None:
        print(""right key = {0}, "".format(nodes[i].right), end="""")
    print()
"
9105306,ALDS1_9_A,"class Node:
    def __init__(self, key: int) -> None:
        self.key = key
        self.parent:Node = None
        self.left:Node = None
        self.right:Node = None
  
n = int(input())
nodes = [Node(i) for i in list(map(int, input().split()))]

for i in range(n):
    p = (i+1)//2 -1
    l = 2*(i+1) -1
    r = 2 * (i+1) + 1 -1 
    if p < n and p >= 0: nodes[i].parent = nodes[p]
    if l < n: nodes[i].left = nodes[l]
    if r < n: nodes[i].right = nodes[r]

for i, n in enumerate(nodes):
    print(f""node {i+1}: key = {n.key}, "", end = """")
    if n.parent != None: print(f""parent key = {n.parent.key}, "", end = """")
    if n.left != None: print(f""left key = {n.left.key}, "", end = """")
    if n.right != None: print(f""right key = {n.right.key}, "", end = """")
    print()
"
8902359,ALDS1_9_A,"from typing import Optional

def print_node(i: int, nodes: list[Optional[int]]):
    if i == 1:
        parent = """"
    else:
        parent = f"", parent key = {nodes[i//2]}""
    if i * 2 < len(nodes):
        left = f"", left key = {nodes[i*2]}""
    else:
        left = """"
    if i * 2 + 1 < len(nodes):
        right = f"", right key = {nodes[i*2+1]}""
    else:
        right = """"

    return f""node {i}: key = {nodes[i]}{parent}{left}{right}, ""


if __name__ == ""__main__"":
    N = int(input())

    NODES = [None]
    NODES.extend(map(int, input().split()))

    for i in range(1, N+1):
        print(print_node(i, NODES))
"
1572953,ALDS1_9_A,"H = int(input())
heap = list(map(int, input().split()))
heap.insert(0, 0)
for i in range(1, len(heap)):
    p = i // 2
    l = i * 2
    r = i * 2 + 1
    s = 'node ' + str(i) + ': key = ' + str(heap[i]) + ', '
    if 1 <= p <= H:
        s += 'parent key = ' + str(heap[p]) + ', '
    if l <= H:
        s += 'left key = ' + str(heap[l]) + ', '
    if r <= H:
        s += 'right key = ' + str(heap[r]) + ', '

    print(s)
"
1657157,ALDS1_9_A,"h = int(input())
heap = list(map(int, input().split()))

for i, key in enumerate(heap):
    i += 1
    pi, cli = i // 2, i * 2
    rel_nodes = ''
    if pi:
        rel_nodes += 'parent key = {}, '.format(heap[pi - 1])
    if cli <= h:
        rel_nodes += 'left key = {}, '.format(heap[cli - 1])
        if cli < h:
            rel_nodes += 'right key = {}, '.format(heap[cli])

    print('node {}: key = {}, '.format(i, key) + rel_nodes)
"
1714451,ALDS1_9_A,"H = int(input())

keys = [None] + input().split()

for i in range(1, H + 1):
    print('node {0}: '.format(i), end = '')
    print('key = {0}, '.format(keys[i]), end = '')
    if i != 1:
        print('parent key = {0}, '.format(keys[i // 2]), end = '')
    left_index = i * 2
    if left_index <= H:
        print('left key = {0}, '.format(keys[left_index]), end = '')
    right_index = left_index + 1
    if right_index <= H:
        print('right key = {0}, '.format(keys[right_index]), end = '')
    print('')
"
1952842,ALDS1_9_A,"n = int(input())
heap_keys = list(map(int, input().split()))
heap = []
for i,x in enumerate(heap_keys):
    node = i+1
    key = x
    parent_key = heap_keys[int(node/2)-1] if i > 0 else None
    left_key = heap_keys[2*node-1] if 2*node-1 <len(heap_keys) else None
    right_key = heap_keys[2*node] if 2*node <len(heap_keys) else None
    heap.append({""node"":node, ""key"":x, ""parent_key"":parent_key, ""left_key"":left_key, ""right_key"":right_key})

for h in heap:
    out_str = ""node %s: key = %s, "" % (h[""node""],h[""key""])
    if h[""parent_key""]:out_str += ""parent key = %s, "" % h[""parent_key""]
    if h[""left_key""]:out_str += ""left key = %s, "" % h[""left_key""]
    if h[""right_key""]:out_str += ""right key = %s, "" % h[""right_key""]
    print(out_str)
"
1959652,ALDS1_9_A,"n = int(input())
a = list(map(int, input().split()))
a = [-1] + a
for i, v in enumerate(a[1:], start=1):
    base = ""node {0}: key = {1}, "".format(i, v)
    parent = ""parent key = {0}, "".format(a[i//2]) if i != 1 else """"
    left = ""left key = {0}, "".format(a[i*2]) if i * 2 <= n else """"
    right = ""right key = {0}, "".format(a[i*2 + 1]) if i * 2 + 1 <= n else """"
    print(base + parent + left + right)
"
1982221,ALDS1_9_A,"index = int(input())
nodes = [int(n) for n in input().split(' ')]
for i in range(index):
    i += 1
    print(""node "" + str(i) + ': key = ' + str(nodes[i-1]) + ', ',end = """")
    if i // 2 > 0:
        print(""parent key = "" + str(nodes[i//2 - 1]) + "", "",end = """")
    if i * 2 < index + 1:
        print(""left key = "" + str(nodes[i*2 - 1]) + "", "",end = """")
    if i * 2 + 1 < index + 1:
        print(""right key = "" + str(nodes[i*2]) + "", "",end = """")
    print("""")
"
2074825,ALDS1_9_A,"#coding:UTF-8
class Node:
    def __init__(self,point):
        self.n=point
        self.p=None
        self.left=None
        self.right=None

def CBT(A,n):
    nlist=[]
    for i in range(n+1):
        if i==0:
            nlist.append(Node(0))
        else:
            nlist.append(Node(A[i-1]))
    for i in range(n+1):
        if i==0:
            continue
        if i/2>=1:
            nlist[i].p=nlist[int(i/2)].n
        if 2*i<=n:
            nlist[i].left=nlist[2*i].n
        if 2*i+1<=n:
            nlist[i].right=nlist[2*i+1].n
    for i in range(n+1):
        if i==0:
            continue
        ans=""node ""+str(i)+"": key = ""+nlist[i].n+"", ""
        if i != 1:
            ans+=""parent key = ""+nlist[i].p+"", ""
        if nlist[i].left!=None:
            ans+=""left key = ""+nlist[i].left+"", ""
        if nlist[i].right!=None:
            ans+=""right key = ""+nlist[i].right+"", ""
        print(ans)
        
        
            
if __name__==""__main__"":
    n=int(input())
    A=input().split("" "")
    CBT(A,n)
"
2108564,ALDS1_9_A,"def has_child(data, n):
    data_len = len(data) - 1  # [0]????????????????????§?????£?????????????????°???-1??????
    if data_len < n * 2:
        return 0
    else:
        if data_len >= (n * 2) + 1:
            return 2
        else:
            return 1


if __name__ == '__main__':
    # ??????????????\???
    num_of_data = int(input())
    data =  [int(x) for x in input().split(' ')]

    # ???????????????
    data.insert(0, None)  # ?????????????????????????????????[0]????????????????????\??????

    # ???????????????
    for i in range(1, num_of_data+1):
        print('node {0}: key = {1}, '.format(i, data[i]), end='')
        if i > 1:
            print('parent key = {0}, '.format(data[i//2]), end='')
        child = has_child(data, i)
        if child == 1:
            print('left key = {0}, '.format(data[i*2]), end='')
        if child == 2:
            print('left key = {0}, right key = {1}, '.format(data[i*2], data[i*2+1]), end='')
        print('')
"
2121325,ALDS1_9_A,"#http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_9_A
#????????????17:15~
def decode_heap(target_list):
    for i, key in enumerate(target_list):
        node_index = i + 1
        parent_index = int(node_index / 2) - 1
        parent = """"
        if not parent_index < 0:
            parent = "" parent key = "" + str(target_list[parent_index]) + "",""
            
        left_index = node_index * 2 - 1
        left = """"
        if left_index < len(target_list):
            left = "" left key = {},"".format(target_list[left_index])
            
        right_index = node_index * 2
        right = """"
        if right_index <  len(target_list):
            right = "" right key = {},"".format(target_list[right_index])

        print(""node {}: key = {},{}{}{} "".format(node_index, key, parent, left, right))

        
def main():
    n_nodes = int(input())
    target_list = [int(a) for a in input().split()]
    decode_heap(target_list)
    
if __name__ == ""__main__"":
    main()
"
2151751,ALDS1_9_A,"n = int(input())
heap = [-1] + list(map(int,input().split()))

for i in range(1,n+1):
    print(""node {}: key = {}, "" .format(i, heap[i]), end = '')
    if i!=1:
        print(""parent key = {}, "" .format(heap[i//2]), end = '')
    if i*2<=n:
        print(""left key = {}, "" .format(heap[i*2]), end ='')
    if i*2+1<=n:
        print(""right key = {}, "".format(heap[i*2+1]), end='')
    print()
"
2208304,ALDS1_9_A,"if __name__ == '__main__':
    N = input()
    heap_array = [int(i) for i in input().split()]

    for i in range(len(heap_array)):
        print(""node {}: key = {}, "".format(i+1, heap_array[i]), end='')
        if (i-1)//2 != -1 :
            print(""parent key = {}, "".format(heap_array[(i-1)//2]), end='')
        if 2*i+1 < len(heap_array):
            print(""left key = {}, "".format(heap_array[2*i+1]), end='')

        if 2*i+2 < len(heap_array):
            print(""right key = {}, "".format(heap_array[2*i+2]), end='')
        print('')
"
2252496,ALDS1_9_A,"#! -*- coding:utf-8 -*-
n = int(input())
data = list(input().split())
data = [int(i) for i in data]

for i in range(n):
    print('node ',i+1,':',sep = '',end = '')
    print(' key = ',data[i],',',sep = '',end = '')

    if i != 0:
        print(' parent key = ',data[(i-1)//2],',',sep = '',end = '')
    
    if 2*i + 1 >= 0 and 2*i + 1 < n:
        print(' left key = ',data[2*i+1],',',sep = '',end = '')
    if 2*(i+1) >= 0 and 2*(i+1) < n:
        print(' right key = ',data[2*(i+1)],',',sep = '',end = '')

    print(' ')
"
2312184,ALDS1_9_A,"class Heap:
    def __init__(self, L):
        self.H = len(L)
        self.heap = L
        self.heap.insert(0, 0)

    def parent(self, i):
        return self.heap[i // 2]

    def left(self, i):
        return self.heap[2 * i]

    def right(self, i):
        return self.heap[2 * i + 1]

H = int(input())
L = list(map(int, input().split()))
heap = Heap(L)
for i in range(1, H + 1):
    print(""node {}: key = {}, "".format(i, heap.heap[i]), end='')
    if i != 1:
        print(""parent key = {}, "".format(heap.parent(i)), end='')
    if i * 2 <= H:
        print(""left key = {}, "".format(heap.left(i)), end='')
    if i * 2 + 1 <= H:
        print(""right key = {}, "".format(heap.right(i)), end='')
    print()
"
2388113,ALDS1_9_A,"n = int(input())
xs = [int(i) for i in input().split()]
for i in range(n):
    ind = i + 1
    ret = ""node "" + str(ind) + "": key = "" + str(xs[ind - 1])
    if ind != 1:
        parent = ind // 2 - 1
        ret += "", parent key = "" + str(xs[parent])
    if n > 2 * i + 1:
        ret += "", left key = "" + str(xs[2 * i + 1])
    if n > 2 * i + 2:
        ret += "", right key = "" + str(xs[2*i + 2])
    ret += "", ""
    print(ret)
"
2397503,ALDS1_9_A,"#coding:utf-8
n = int(input())
l = list(map(int, input().split()))

for i in range(n):
    id = i + 1
    ans = ""node "" + str(id) + "": key = "" + str(l[id - 1])
    if id != 1:
        parent = id // 2 - 1
        ans += "", parent key = "" + str(l[parent])
    if n > 2 * i + 1:
        ans += "", left key = "" + str(l[2 * i + 1])
    if n > 2 * i + 2:
        ans += "", right key = "" + str(l[2*i + 2])
    ans += "", ""
    print(ans)
   
"
2436361,ALDS1_9_A,"def print_heap():
    for i in range(n):
        if (i-1)//2 in range(n):
            if 2*i+1 in range(n):
                if 2*i+2 in range(n):
                    print(""node {}: key = {}, parent key = {}, left key = {}, right key = {}, ""
                          .format(i+1, heap[i], heap[(i-1)//2], heap[2*i+1], heap[2*i+2]))
                else:
                    print(""node {}: key = {}, parent key = {}, left key = {}, ""
                          .format(i+1, heap[i], heap[(i-1)//2], heap[2*i+1]))
            else:
                print(""node {}: key = {}, parent key = {}, ""
                      .format(i+1, heap[i], heap[(i-1)//2]))
        else:
            if 2*i+1 in range(n):
                if 2*i+2 in range(n):
                    print(""node {}: key = {}, left key = {}, right key = {}, ""
                          .format(i+1, heap[i], heap[2*i+1], heap[2*i+2]))
                else:
                    print(""node {}: key = {}, left key = {}, ""
                          .format(i+1, heap[i], heap[2*i+1]))
            else:
                print(""node {}: key = {}, "".format(i+1, heap[i]))


if __name__ == ""__main__"":
    n = int(input())
    heap = list(map(int, input().split()))
    print_heap()
"
2459406,ALDS1_9_A,"# coding=utf-8
import math

class Tree():
    def __init__(self, key):
        self.root = key

class Node():
    def __init__(self, id, key):
        self.id = id
        self.key = key
        self.parent = None
        self.left = None
        self.right = None

    def set_status(self, id, key):
        global node_list
        parent_id = math.floor(id/2)
        odd = id % 2
        self.parent = node_list[parent_id]
        if odd == 0:
            self.parent.left = self
        else:
            self.parent.right = self

def print_nodes():
    global node_list
    node_list.pop(0)
    for node in node_list:
        print(""node {}: key = {}"".format(node.id, node.key), end = """")
        if node.parent:
            print("", parent key = {}"".format(node.parent.key), end = """")
        if node.left:
            print("", left key = {}"".format(node.left.key), end = """")
        if node.right:
            print("", right key = {}"".format(node.right.key), end = """")
        print("", "")

n = int(input())
input_num = list(map(int, input().split()))
node_list = [None]

for i, num in enumerate(input_num):
    i = i + 1 #suffix starts from 1
    node = Node(i, num)
    node_list.append(node)

    if i == 1:
        tree = Tree(num)
    else:
        node.set_status(i, num)

print_nodes()
"
2483585,ALDS1_9_A,"
def main():

    """""" ????????? """"""
    H = int(input().strip())
    hkeys = list(map(int,(input().split())))
    for i in range(H):
        txts = []
        id = i + 1
        txts.append(""node {}: key = {},"".format(id, hkeys[i]))
        parent = int(id / 2)
        if parent != 0:
            txts.append(""parent key = {},"".format(hkeys[parent-1]))
        left = id * 2
        if left > 0 and left <= H:
            txts.append(""left key = {},"".format(hkeys[left-1]))
        right = left + 1
        if right > 0 and right <= H:
            txts.append(""right key = {},"".format(hkeys[right-1]))
        print(""{} "".format("" "".join(txts)))

if __name__ == '__main__':
    main()
"
2653586,ALDS1_9_A,"# -*- coding:utf-8 -*-


def complete_binary_tree(tree, n):
    for i in range(1, n + 1):
        node = ""node {0}: "".format(i)
        key = ""key = {0}, "".format(tree[i-1])
        if i // 2 == 0:
            parent = """"
        else:
            parent = ""parent key = {0}, "".format(tree[(i // 2) - 1])

        if n >= (i * 2) + 1:
            left = ""left key = {0}, "".format(tree[(i * 2) - 1])
            right = ""right key = {0}, "".format(tree[(i * 2)])
        elif n >= (i * 2):
            left = ""left key = {0}, "".format(tree[(i * 2) - 1])
            right = """"
        else:
            left = """"
            right = """"

        print(node + key + parent + left + right)


if __name__ == ""__main__"":
    n = int(input())
    tree = [int(n) for n in input().split()]
    complete_binary_tree(tree, n)
"
2699415,ALDS1_9_A,"# -*- coding: utf-8 -*-


if __name__ == '__main__':

    H = int(input())
    A = [None] + [int(i) for i in input().split("" "")]

    def parent(i):
        return i // 2

    def left(i):
        return 2*i

    def right(i):
        return 2*i + 1

    for i in range(1, H+1):
        print(""node {}: key = {},"".format(i, A[i]), end="" "")
        if parent(i) >= 1:
            print(""parent key = {},"".format(A[parent(i)]), end="" "")
        if left(i) <= H:
            print(""left key = {},"".format(A[left(i)]), end="" "")
        if right(i) <= H:
            print(""right key = {},"".format(A[right(i)]), end="" "")
        print("""")

"
2706312,ALDS1_9_A,"H = int(input())
A = list(map(int, input().split()))
for i in range(H):
    s = f""node {i + 1}: key = {A[i]}, ""
    if i != 0:
        s += f""parent key = {A[(i - 1) // 2]}, ""
    if H > i * 2 + 1:
        s += f""left key = {A[i * 2 + 1]}, ""
    if H > i * 2 + 2:
        s += f""right key = {A[i * 2 + 2]}, ""
    print(s)

"
2722231,ALDS1_9_A,"input()
A=[0]+input().split()
H=len(A)
for i in range(1,H):
 print(f'node {i}: key = {A[i]}, {f""parent key = {A[i//2]}, ""if i>1 else""""}{f""left key = {A[2*i]}, ""if 2*i<H else""""}{f""right key = {A[2*i+1]}, ""if 2*i+1<H else""""}')
"
2724052,ALDS1_9_A,"if __name__ == '__main__':
    _ = input()
    hoge = [int(x) for x in input().split()]
    
    for index_num, elem in enumerate(hoge):
        output = list()
        parent = (index_num+1) // 2 
        left_c = (index_num+1) * 2 -1
        right_c = left_c +1
        if parent == 0:
            flag = True
        else:
            flag = False
        if left_c >= len(hoge):
            left_c = -1
        if right_c >= len(hoge):
            right_c = -1
        if flag:
            parent = -1
        else:
            parent -= 1
        hoge.append('')
        output.append('node {}:'.format(index_num+1))
        output.append('key = {},'.format(elem))
        if hoge[parent] != '':
            output.append('parent key = {},'.format(hoge[parent]))
        if hoge[left_c] != '':
            output.append('left key = {},'.format(hoge[left_c]))
        if hoge[right_c] != '':
            output.append('right key = {},'.format(hoge[right_c]))
        print(' '.join(output) + ' ')
        hoge.pop()
"
2751540,ALDS1_9_A,"n = int(input())

a = list(map(int, input().split()))

for i in range(n):
    node = i + 1
    key = a[i]
    out = ""node {}: key = {}, "".format(node, key)
    out += ""parent key = {}, "".format(a[(i - 1) // 2]) if (i-1)//2 >=0 else """"
    out += ""left key = {}, "".format(a[i * 2 + 1]) if i*2 + 1 < n else """"
    out += ""right key = {}, "".format(a[i * 2 + 2]) if i*2 + 2 < n else """"
    print(out)
"
2754719,ALDS1_9_A,"# Complete Binary Tree

n = int(input())
a = list(map(int, input().split())) # heap
# 接点の添字iが与えられた時、その親、左の子、右の子の添え字はそれぞれi//2, 2i, 2i+1
# ヒープの添字は1-indexed
for i in range(1, n+1):
    print(""node {0:}: key = {1:}, "".format(i, a[i-1]), end = """")
    if 0 < i // 2:
        print(""parent key = {0:}, "".format(a[i//2 - 1]), end = """")
    if 2 * i <= n:
        print(""left key = {0:}, "".format(a[2*i - 1]), end = """")
    if 2 * i + 1 <= n:
        print(""right key = {0:}, "".format(a[2*i]), end = """")
    print("""")
"
2831002,ALDS1_9_A,"
class Heap:
    def __init__(self):
        self._nodes = []

    @classmethod
    def create(cls, li):
        heap = cls()
        heap._nodes = li
        return heap

    def __iter__(self):
        self.cur = 0
        return self

    def __next__(self):
        if self.cur >= len(self._nodes):
            raise StopIteration
        self.cur += 1

        node = self._nodes[self.cur-1]
        if self.cur//2 - 1 >= 0:
            parent = self._nodes[self.cur//2 - 1]
        else:
            parent = None

        if self.cur*2 - 1 < len(self._nodes):
            left = self._nodes[self.cur*2 - 1]
        else:
            left = None

        if self.cur*2 < len(self._nodes):
            right = self._nodes[self.cur*2]
        else:
            right = None

        return (node, parent, left, right)


def run():
    _ = int(input())

    nodes = [int(i) for i in input().split()]
    heap = Heap.create(nodes)

    for (i, node) in enumerate(heap):
        n, p, nl, nr = node
        s = ""node {}: key = {}, "".format(i+1, n)
        if p is not None:
            s += ""parent key = {}, "".format(p)
        if nl is not None:
            s += ""left key = {}, "".format(nl)
        if nr is not None:
            s += ""right key = {}, "".format(nr)

        print(s)


if __name__ == '__main__':
    run()

"
2835328,ALDS1_9_A,"n = int(input())
a = [0] + list(map(int, input().split()))
def pi(i):
    global a, n
    s = f""node {i}: key = {a[i]}, ""
    if i != 1:
        s += f""parent key = {a[int(i / 2)]}, ""
    if i * 2 <= n:
        s += f""left key = {a[2 * i]}, ""
        if i * 2 + 1 <= n:
            s += f""right key = {a[2 * i + 1]}, ""
    print(s)

for i in range(1, n + 1):
    pi(i)
"
2847283,ALDS1_9_A,"n = int(input())
H = list(map(int, input().split(' ')))

for i in range(n):
    node = i+1
    key = H[i]
    parent = H[int(node/2)-1] if node != 1 else None
    left = H[node*2-1] if node*2 <= n else None
    right = H[node*2] if node*2+1 <= n else None
    print('node %d: key = %d, '%(node, key), end='')
    if parent != None: print('parent key = %d, '%parent, end='')
    if left != None: print('left key = %d, '%left, end='')
    if right != None: print('right key = %d, '%right, end='')
    print('')
"
2914871,ALDS1_9_A,"class NullNode():
    def __init__(self):
        self.id = None

null_node = NullNode()

class Node():
    def __init__(self, id):
        global null_node
        self.id = id
        self.parent = null_node
        self.left = null_node
        self.right = null_node

n = int(input())
node_list = [Node(id) for id in input().split()]

for i in range(n):
    node = node_list[i]
    node.left = node_list[2*i+1] if 2*i+1 < n else null_node
    node.right = node_list[2*i+2] if 2*i+2 < n else null_node
    if i != 0:
        node_list[i].parent = node_list[(i-1)//2]
    out_put = []
    out_put.append('node {}: '.format(i+1))
    out_put.append('key = {}, '.format(node.id))
    if node.parent.id is not None:
        out_put.append('parent key = {}, '.format(node.parent.id))
    if node.left.id is not None:
        out_put.append('left key = {}, '.format(node.left.id))
    if node.right.id is not None:
        out_put.append('right key = {}, '.format(node.right.id))
    print(''.join(out_put))


"
2916274,ALDS1_9_A,"# -*- coding: utf-8 -*-
class BinaryHeap:
    def __init__(self, ary):
        self.nodes = []
        for i, key in enumerate(ary):
            id = i + 1
            parent = id // 2
            if parent:
                parent_key = ary[parent - 1]
            else:
                parent_key = None
            left = 2 * id
            right = 2 * id + 1
            if left <= len(ary):
                left_key = ary[left - 1]
            else:
                left_key = None
            if right <= len(ary):
                right_key = ary[right - 1]
            else:
                right_key = None
            self.nodes.append(Node(id, key, parent_key, left_key, right_key))

    def print(self):
        for node in self.nodes:
            print('node {}: key = {}, '.format(node.id, node.key), end='')
            if type(node.parent_key) == int:
                print('parent key = {}, '.format(node.parent_key), end='')
            if type(node.left_key) == int:
                print('left key = {}, '.format(node.left_key), end='')
            if type(node.right_key) == int:
                print('right key = {}, '.format(node.right_key), end='')
            print()


class Node:
    def __init__(self, id, key, parent_key, left_key, right_key):
        self.id = id
        self.key = key
        self.parent_key = parent_key
        self.left_key = left_key
        self.right_key = right_key


if __name__ == '__main__':
    H = int(input())
    ary = [int(_) for _ in input().split()]
    bh = BinaryHeap(ary)
    bh.print()

"
2917173,ALDS1_9_A,"import math

h = int(input())
a = list(map(int,input().split()))

def parent(node):
    return math.floor(node/2)

def left(node):
    return 2*node

def right(node):
    return 2*node+1

for i in range(1,h+1):
    print('node {}: key = {}, '.format(i,a[i-1]),end='')
    if parent(i) > 0:
        print('parent key = {}, '.format(a[parent(i)-1]),end='')
    if left(i) <= h:
        print('left key = {}, '.format(a[left(i)-1]),end='')
    if right(i) <= h:
        print('right key = {}, '.format(a[right(i)-1]),end='')
    print()

"
2949038,ALDS1_9_A,"n = int(input())
a = [0] + list(map(int, input().split()))
def pi(i):
    global a, n
    s = f""node {i}: key = {a[i]}, ""
    if i != 1:
        s += f""parent key = {a[int(i / 2)]}, ""
    if i * 2 <= n:
        s += f""left key = {a[2 * i]}, ""
        if i * 2 + 1 <= n:
            s += f""right key = {a[2 * i + 1]}, ""
    print(s)
 
for i in range(1, n + 1):
    pi(i)

"
2949469,ALDS1_9_A,"import math


def make_row(id, heap):
    s = ""node "" + str(id) + "": key = "" + str(heap[id - 1]) + "", ""
    length = len(heap)
    if 0 <= math.floor(id // 2) - 1 < length:
        s += ""parent key = "" + str(heap[math.floor(id // 2) - 1]) + "", ""
    if 0 <= 2 * id - 1 < length:
        s += ""left key = "" + str(heap[2 * id - 1]) + "", ""
    if 0 <= 2 * id < length:
        s += ""right key = "" + str(heap[2 * id]) + "", ""
    return s


h = int(input())
heap = [int(x) for x in input().split()]

for id in range(1, h + 1):
    print(make_row(id, heap))
"
2965845,ALDS1_9_A,"#coding:utf-8
N = int(input())
nums = list(map(int,input().split()))

for ID,num in enumerate(nums,1):
    if 1 <= ID // 2 <= N:
        p = ""parent key = {}, "".format(nums[ID // 2 - 1])
    else:
        p = """"
    if 1 <= 2 * ID <= N:
        l = ""left key = {}, "".format(nums[2*ID - 1])
    else:
        l = """"
    if 1 <= 2 * ID + 1 <= N:
        r = ""right key = {}, "".format(nums[2*ID])
    else:
        r = """"

    print(""node {}: key = {}, "".format(ID,num) + p + l + r)
"
3022871,ALDS1_9_A,"n = int(input())
tree = list(map(int, input().split()))

for i in range(n) :
    s = 'node ' + str(i + 1) + ': key = ' + str(tree[i])
    if (i > 0) & (i % 2 == 0) :
        s += ', parent key = ' + str(tree[i // 2 - 1])
    elif (i > 0) & (i % 2 == 1):
        s += ', parent key = ' + str(tree[i // 2])

    if i * 2 + 2 < n :
        s += ', left key = ' + str(tree[i * 2 + 1]) + ', right key = ' + str(tree[i * 2 + 2])
    elif i * 2 + 1 < n :
        s += ', left key = ' + str(tree[i * 2 + 1])

    print(s, ', ', sep = '')

"
3035859,ALDS1_9_A,"import sys
import math


# 二分ヒープ数のサイズ
H = int(input())
# 二分ヒープを表す配列
A = list(map(int, input().split()))
# parent, left, right
parent, left, right = [], [], []


for i in range(H):
    count = i+1
    if count == 1:
        parent.append(0)
    else:
        parent.append(A[math.floor(count/2)-1])

    if 2*count <= len(A):
        left.append(A[2*count-1])
    else:
        left.append(0)

    if 2*count+1 <= len(A):
        right.append(A[2*count])
    else:
        right.append(0)

for i in range(H):

    sys.stdout.write('node %d: key = %d, ' % (i+1, A[i]))

    if parent[i] != 0:
        sys.stdout.write('parent key = %d, ' % parent[i])

    if left[i] != 0:
        sys.stdout.write('left key = %d, ' % left[i])

    if right[i] != 0:
        sys.stdout.write('right key = %d, ' % right[i])
    print()
# print('H: ', H)
# print('A: ', A)
# print('parent: ', parent)
# print('left: ', left)
# print('right: ', right)

"
3042966,ALDS1_9_A,"class Node():
    def __init__(self, id, key):
        self.id = id
        self.key = key

    def setKeys(self, data):
        length = len(data)
        if ( self.id // 2 ) != 0:
            self.pk = data[self.id // 2]
        else :
            self.pk = -1
        if self.id * 2 < length:
             self.lk = data[self.id * 2]
        else :
            self.lk = -1
        if self.id * 2 + 1 < length:
             self.rk = data[self.id * 2 + 1]
        else :
            self.rk = -1

    def printInfo(self):
        print( ""node "" + str(self.id) + "": key = "" + str(self.key), end="", "" )
        if self.pk != -1:
            print( ""parent key = "" + str(self.pk), end = "", "")
        if self.lk != -1:
            print( ""left key = "" + str(self.lk), end = "", "")
        if self.rk != -1:
            print( ""right key = "" + str(self.rk) , end="", "")
        print()

def main():
    n = int( input() )
    inputs = input().split()
    for tmp in inputs:
        tmp = int(tmp)
    data = [0]
    data.extend(inputs)
    Tree = []
    for i in range(1, n+1):
        Tree.append( Node(i, data[i]) )
    for node in Tree:
        node.setKeys( data )
        node.printInfo()

if __name__ == '__main__':
    main()

"
3043391,ALDS1_9_A,"n = int(input())
klist = list(map(int,input().split()))
plist = []
i = 0
k = 1
a = 2**i-1
while 1:
    if klist[a:a+2**i] != []:
        plist.append(klist[a:a + 2**i])
    else: break
    a += 2**i
    i += 1
for i in range(len(plist)):
    for j in range(len(plist[i])):
        try:
            if i==0:
                print(""node ""+str(k)+"": key = ""+str(plist[0][0])+
                      "", left key = ""+str(plist[1][0])+
                      "", right key = ""+str(plist[1][1])+"", "")
            else :
                l = int(j/2)
                print(""node ""+str(k)+"": key = ""+str(plist[i][j])+
                      "", parent key = ""+str(plist[i-1][l])+"", left key = ""+
                      str(plist[i+1][2*j]),end="""")
                try:
                    print("", right key = ""+str(plist[i+1][2*j+1])+"", "")
                except:
                    print("", "")
        except:
            l = int(j/2)
            print(""node ""+str(k)+"": key = ""+str(plist[i][j])+
                  "", parent key = ""+str(plist[i-1][l])+"", "")
        k += 1
"
3063230,ALDS1_9_A,"class Node:
	def __init__(self, i, k):
		self.i = i
		self.k = k
		self.p = self.l = self.r = None
		
	def __str__(self):
		ret = 'node ' + str(self.i) + ': '
		ret += 'key = ' + str(self.k) + ', '
		if self.p != None:
			ret += 'parent key = ' + str(self.p) + ', '
		if self.l != None:
			ret += 'left key = ' + str(self.l) + ', '
		if self.r != None:
			ret += 'right key = ' + str(self.r) + ', '
		return ret

n = int(input())
a = list(map(int, input().split()))
for i in range(n):
	id = i + 1
	node = Node(id, a[id-1])
	if i != 0:
		p = int(id/2) - 1
		node.p = a[p]
	l = id*2-1
	r = id*2
	if l < n:
		node.l = a[l]
	if r < n:
		node.r = a[r]		
	print(node)

"
3072002,ALDS1_9_A,"def parent(i):
    return i // 2


def left(i):
    return i * 2


def right(i):
    return i * 2 + 1


h = int(input())
a = [-1]
a.extend([int(v) for v in input().split()])

for i in range(1, h+1):
    result = 'node {0}: key = {1}, '.format(i, a[i])
    if parent(i) >= 1:
        result += 'parent key = {0}, '.format(a[parent(i)])
    if left(i) <= h:
        result += 'left key = {0}, '.format(a[left(i)])
    if right(i) <= h:
        result += 'right key = {0}, '.format(a[right(i)])
    print(result)
"
8795919,ALDS1_9_B,"def maxHeapify(A, i, H):
    l = 2 * i + 1
    r = 2 * i + 2
    largest = i

    if l < H and A[l] > A[i]:
        largest = l
    if r < H and A[r] > A[largest]:
        largest = r
    if largest != i:
        A[i], A[largest] = A[largest], A[i]
        maxHeapify(A, largest, H)

def buildMaxHeap(A):
    H = len(A)
    for i in range(H // 2 - 1, -1, -1):
        maxHeapify(A, i, H)

num111=input()

A = list(map(int, input().split()))


buildMaxHeap(A)

print("" "" + "" "".join(map(str, A)))



"
8754405,ALDS1_9_B,"H = int(input())
A = [None] + list(map(int, input().split()))

def maxheapify(i):
    l = 2 * i
    r = 2 * i + 1
    if l <= H and A[l] > A[i]:
        largest = l
    else:
        largest = i

    if r <= H and A[r] > A[largest]:
        largest = r

    if largest != i:
        A[i], A[largest] = A[largest], A[i]
        maxheapify(largest)

for i in range(H//2, 0, -1):
    maxheapify(i)

print(' ' + ' '.join(map(str, A[1:])))
"
8816845,ALDS1_9_B,"# aizu_ALDS1_9_B_MaxmumHeap.py  

H = int(input())
A = list(map(int,input().split()))

def max_heapify(A,i):
    l = 2*i+1
    r = 2*i+2
    if l < H and A[l] > A[i]:
        largest = l
    else: largest = i
    if r < H and A[r] > A[largest]:
        largest = r
    
    if largest != i:
        A[i],A[largest] = A[largest],A[i]
        max_heapify(A,largest)

def build_max_heap(A):
    for i in range(H//2,-1,-1):
        max_heapify(A,i)

build_max_heap(A)
print('',*A)
"
8632790,ALDS1_9_B,"H = int(input())
A = [""x""] + list(map(int,input().split()))

def max_heapify(A: list, i: int):
    """"""
    pep8 に基づく関数の命名
    """"""
    l = i*2
    r = i*2+1
    if 0 < l <= H and A[l] > A[i]:
        largest = l
    else:
        largest = i
    if 0 < r <= H and A[r] > A[largest]:
        largest = r
    
    if largest != i:
        A[i], A[largest] = A[largest], A[i]
        max_heapify(A, largest)

def build_max_heap(A):
    for i in range(H//2, 0, -1):
        max_heapify(A, i)

build_max_heap(A)

print("""", *A[1:])

"
8943873,ALDS1_9_B,"def left(i: int) -> int:
    return 2 * i + 1

def right(i: int) -> int:
    return 2 * i + 2

def max_heapify(heap: list[int], i: int, H: int) -> None:
    l = left(i)
    r = right(i)

    if l < H and heap[i] < heap[l]:
        largest = l
    else:
        largest = i
    if r < H and heap[largest] < heap[r]:
        largest = r

    if largest != i:
        heap[i], heap[largest] = heap[largest], heap[i]
        max_heapify(heap, largest, H)

def build_max_heap(heap: list[int], H: int) -> None:
    for i in range(H // 2 - 1, -1, -1):
        max_heapify(heap, i, H)

if __name__ == ""__main__"":
    H = int(input())    
    heap = [int(x) for x in input().split()]

    build_max_heap(heap, H)
    print("" "" + "" "".join(map(str, heap)))

"
9152155,ALDS1_9_B,"n = int(input())
arr = list(map(int, input().split()))

# ヒープ内の要素 i をルートとする部分木が max heap になるように要素を入れ替える
def max_heapify(arr, i):
    # 左右の子の内、より大きい方と交換する操作を再帰的に行う
    # ヒープ配列内の要素 i の左右の子

    # [0,1,2,3,4,5,6,7,8]

    # 0 indexed case
    # i*2+1, i*2+2
    # 1 -> 34
    # 2 -> 56
    # 3 -> 78
    # 4 -> 910
    child_l = i*2 + 1
    child_r = i*2 + 2

    max_idx = i
    if child_l < len(arr) and arr[child_l]  > arr[max_idx]:
        max_idx = child_l
    if child_r < len(arr) and arr[child_r]  > arr[max_idx]:
        max_idx = child_r
    
    tmp = arr[i]
    arr[i] = arr[max_idx]
    arr[max_idx] = tmp

    # 入れ替えが発生していた場合
    if max_idx != i:
        max_heapify(arr, max_idx)


# max heap化
# leafの２つ上のレベルのノードから順に max_heapify を適用していくことで
# max_heap化
# - 上のレベルの値は必ず下のレベルの値よりも大きくなっていることが保証されてる
for i in range(len(arr)//2, -1, -1):
    max_heapify(arr, i)

print("" "" + "" "".join(list(map(str,arr))))



"
8995247,ALDS1_9_B,"def left(i):
    return 2*i

def right(i):
    return 2*i + 1

def parent(i):
    return i // 2

def maxHeapify(A,i):
    l = left(i)
    r = right(i)
    largest = i
    if l <= H and A[l] > A[i]:
        largest = l
    if r <= H and A[r] > A[largest]:
        largest = r
    if largest != i:
        A[i],A[largest] = A[largest],A[i]
        maxHeapify(A, largest)

def buildMaxHeap(A):
    for i in range(H//2,0,-1):
        maxHeapify(A,i)

H = int(input())
A = [0] + list(map(int,input().split()))

buildMaxHeap(A)
print("""",*A[1:])    
    
"
8489471,ALDS1_9_B,"def max_heapify(i, H, A):
    """"""
    ヒープの最大値を保持するための関数です。
    最大ヒープは、すべてのノードにおいて、その値が子ノードの値以上である完全二分木です。

    パラメーター:
    i (int): ヒープまたはサブツリーの根を表す配列要素のインデックス。
    H (int): ヒープのサイズ。
    A (list): ヒープのリスト表現。
    """"""
    
    # print(A)
    
    # 左の子のインデックス
    l = 2 * i
    # 右の子のインデックス
    r = 2 * i + 1

    # 根と左の子、右の子の中で最大のものを選ぶ
    # 先に左の子と大きさ比べしているから、
    # 左の子と右の子では右の子のほうが大きくなる
    if l <= H and A[l] > A[i]:
        largest = l
    else:
        largest = i

    if r <= H and A[r] > A[largest]:
        largest = r

    # 上で子と交換した場合、下に下がった元親をlargestとして、 
    # largestが子よりも大きくなるか、子がいなくなるまで続ける
    if largest != i:
        # 値を交換、親子は交換する（兄弟は交換しない）
        A[i], A[largest] = A[largest], A[i]  
        
        # 下に移動した節点がさらに下にいくか確かめる。
        # 再帰処理で下へ下へと巡回する
        max_heapify(largest, H, A)  # ルートのヒープ化 

def main():
    """"""
    プログラムのメイン関数。要素の数を読み取り、最大ヒープを構築し、
    その後、要素を出力します。
    """"""
    H = int(input()) # ヒープのサイズを読み取る
    # A = [0] * (H + 1)  # ヒープのインデックスは1から始まるため、余分な要素を持つヒープを初期化

    # ヒープの要素を読み取る
    A = [0] + list(map(int, input().split()))

    # 最大ヒープを構築
    # 左半分だけのくり返しだが、
    # 前から半分番目というのはピラミッドの最下層の一つ手前になる
    # 最下層の親ノードになる（子が存在する親節点の最後の節点）
    # 最後の親節点から、左の親および上の親を巡回して回って、
    # 大きいキーの節点があれば、キーを交換して、大きいキーを上に上げていく
    for i in range(H // 2, 0, -1):
        max_heapify(i, H, A)

    # ヒープの要素を出力
    for i in range(1, H + 1):
        print(f' {A[i]}', end='')
    print()

# メイン関数を実行
if __name__ == ""__main__"":
    main()

"
8496589,ALDS1_9_B,"n = int(input())
h = [''] + [int(i) for i in input().split()]

for i in range(n // 2, 0, -1):
    while True:
        j = i
        l = i * 2
        r = l | 1
        if l == n and h[i] < h[l]: i = l
        if r <= n and (h[i] < h[l] or h[i] < h[r]):
            if h[l] > h[r]: i = l
            else: i = r
        if j == i: break
        h[i], h[j] = h[j], h[i]

print(*h)
"
8395376,ALDS1_9_B,"def max_heapify(data):
    n = len(data)
    def sub_func(i):
        # 1 スタート → 0 スタート.
        p, l, r = i - 1, 2 * i - 1, 2 * i + 1 - 1
        largest = p
        if l < n and data[largest] < data[l]:
            largest = l
        if r < n and data[largest] < data[r]:
            largest = r
        if largest != p:
            data[p], data[largest] = data[largest], data[p]
            # 0 スタート → 1 スタート.
            sub_func(largest + 1)
##    for i in range(n // 2, 0, -1):
##        sub_func(i)
    for i in range(1, n // 2 + 1):
        sub_func(n // 2 - i + 1)


def main():
    n = int(input())
    data = [int(s) for s in input().split()]
    max_heapify(data)
    print("" "", end="""")
    print(*data)


if __name__ == ""__main__"":
    main()
"
9046195,ALDS1_9_B,"def max_heapify(lista, i):
	obj = lista[i]

	while True:
		mayor = i*2 + 1

		if mayor >= len(lista):
			break

		hijo_der = mayor + 1
		if hijo_der < len(lista) and lista[hijo_der] > lista[mayor]:
			mayor = hijo_der

		if lista[mayor] <= obj:
			break

		lista[i] = lista[mayor]
		i = mayor

	lista[i] = obj

input()
lista = [int(i) for i in input().split()]

for i in range((len(lista) - 1) // 2, -1, -1):
	max_heapify(lista, i)

for i in lista:
	print(f"" {i}"", end = """")
print()

"
8787865,ALDS1_9_B,"H = int(input())
Array = input()
a = list(map(int, Array.split()))

a.insert(0,None)

def maxHeapify(A, i):
    l = i*2
    r = i*2+1
    # 左の子、自分、右の子で値が最大のノードを選ぶ
    if l <= H and A[l] > A[i]:
        largest = l
    else:
        largest = i
    if r <= H and A[r] > A[largest]:
        largest = r
    if largest != i: # i の子の方が値が大きい場合
        A[i], A[largest] = A[largest], A[i]
        maxHeapify(A, largest) # 再帰的に呼び出し

def buildMaxHeap(A):
   for i in range(H//2, 0, -1):
       maxHeapify(A, i)

buildMaxHeap(a)

for i in range(1,H+1):
    print(f"" {a[i]}"", end="""")
print()
"
8476412,ALDS1_9_B,"def sub_heapify(a, i):
    n = len(a)
    j = i
    if 2 * i + 1 < n and a[2 * i + 1] > a[j]:
        j = 2 * i + 1
    if 2 * i + 2 < n and a[2 * i + 2] > a[j]:
        j = 2 * i + 2
    if i != j:
        a[i], a[j] = a[j], a[i]
        sub_heapify(a, j)


def heapify(a):
    n = len(a)
    for i in range(n)[::-1]:
        sub_heapify(a, i)


n = int(input())
(*a,) = map(int, input().split())
heapify(a)
print("" "", end="""")
print(*a)

"
8489330,ALDS1_9_B,"def main():
    H = int(input())
    heap = [0] + list(map(int,input().split()))
    heap = build_max_heap(heap)
    for h in heap[1:]:
        print(f' {h}', end='')
    print()

# 要素iについて、max-ヒープ条件を満たすように値を入れ替え
def max_heapify(A, i):
    H = len(A) - 1
    l = 2 * i
    r = (2 * i) + 1
    # 親・左の子・右の子の中で、値が最大のものをlargestに保持
    if l <= H and A[l] > A[i]:
        largest = l
    else:
        largest = i
    if r <= H and A[r] > A[largest]:
        largest = r
    # 子の値の方が大きい場合、要素どうしを入れ替え
    if largest != i:
        A[i], A[largest] = A[largest], A[i]
        max_heapify(A, largest)
    return A

# 与えられた配列をmax-ヒープに変換
def build_max_heap(A):
    H = len(A) - 1
    # H/2より先の要素は葉ノードになるため、探索範囲は H/2 -> 1(根)
    # H/2より先の要素が葉ノードになるのは、ヒープを表現する配列の特性
    # 親 i/2, 左の子 2×i, 右の子 2×i+1 
    for i in reversed(range(1, (H//2 + 1))):
        A = max_heapify(A, i)
    return A


if __name__ == '__main__':
    main()
"
8787312,ALDS1_9_B,"def maxHeapify(index):
    l = index*2
    r = index*2 + 1
    if l <= H and heap[l] > heap[index]:
            largest = l
    else :
        largest = index
    
    if r <= H and heap[r] > heap[largest]:
                largest = r
    
    if largest != index:
        heap[largest],heap[index] = heap[index],heap[largest]
        maxHeapify(largest)
H = int(input())
heap =[-100]
input_data = list(map(int,input().split()))
heap = heap + input_data
for i in range(H//2,0,-1):
    maxHeapify(i)
print(end="" "")
for i in range(1,H+1):
    if i == H:
            print(heap[i])
    else :
      print(heap[i],end="" "")
"
8817536,ALDS1_9_B,"H = int(input())
A = list(map(int, input().split()))

def maxHeapify(A, i):
    l = 2 * i + 1
    r = 2 * i + 2 
    if l < H and A[l] > A[i]:
        largest = l
    else:
        largest = i
    if r < H and A[r] > A[largest]:
        largest = r

    if largest != i:
        A[i], A[largest] = A[largest], A[i]
        maxHeapify(A, largest)

def buildMaxHeap(A):
    for i in range(H // 2 - 1, -1, -1):  
        maxHeapify(A, i)

buildMaxHeap(A)
for i in range(len(A)):
    print("""",A[i], end="""")
print()
"
9105383,ALDS1_9_B,"import math
def left(i: int) -> int: return i * 2

def right(i: int) -> int: return i * 2 + 1

def maxHeapify(A:list[int], i:int):
    l = left(i)
    r = right(i)
    if l <= h and A[l] > A[i]:
        largest = l
    else: 
        largest = i
    if r <= h and A[r] > A[largest]:
        largest = r
    if largest != i:
        A[i], A[largest] = A[largest], A[i]
        maxHeapify(A, largest)

def buildMaxHeap(A:list):
    for i in range(h//2, 0, -1):
        maxHeapify(A, i)
        
h = int(input())
heap = [math.inf] + list(map(int, input().split()))
buildMaxHeap(heap)
for h in heap[1:]:
    print(f"" {h}"", end = """")
print()
"
8583222,ALDS1_9_B,"def left(i):
  if 2*i + 1 < H:
    return 2*i + 1
  else:
    return 2000000003

def right(i):
  if 2*i + 2 < H:
    return 2*i + 2
  else:
    return 2000000003



def maxHeapify(A, i):
  l = left(i)
  r = right(i)
  
  # 左の子、自分、右の子で値が最大のノードを選ぶ
  if l <= H and A[l] > A[i]:
    largest = l
  else:
    largest = i

  if r <= H and A[r] > A[largest]:
    largest = r
  
  if largest != i:
    A[i], A[largest] = A[largest], A[i]
    maxHeapify(A, largest)
    
  
def buildMaxHeap(A):
  for i in range((H//2)-1, -1, -1):
    maxHeapify(A, i)


H = int(input())  # ヒープサイズ
heap = input().split(' ') # ヒープの節点を表す配列

for i in range(H):
  heap[i] = int(heap[i])

buildMaxHeap(heap)

print('', end=' ')
print(*heap)
"
4646457,ALDS1_9_B,"from heapq import *
n = int(input())
H = [-x for x in map(int,input().split())]
heapify(H)
print("""","" "".join([str(-x) for x in H]))
"
4057139,ALDS1_9_B,"from heapq import heapify#, heappop, heappush, heappushpop
input() # N = int(input())
H = [-x for x in map(int, input().split())]

heapify(H)
print("""", *[-x for x in H])
"
4075760,ALDS1_9_B,"from heapq import heapify, heappop

n =int(input())
b = [-x for x in map(int, input().split())]

heapify(b)
print("""", *[-x for x in b])
"
4752930,ALDS1_9_B,"from heapq import heapify, heappop, heappush, heappushpop

N = int(input())
H = [-x for x in map(int,input().split())]

heapify(H)
print('', *[-x for x in H])

"
5009890,ALDS1_9_B,"from heapq import heapify, heappop, heappush, heappushpop
N = input()
H = [-x for x in map(int, input().split())]

heapify(H)
print('', *[-x for x in H])

"
5062818,ALDS1_9_B,"from heapq import heapify, heappop, heappush, heappushpop
N = input()
H = [-x for x in map(int, input().split())]

heapify(H)
print('', *[-x for x in H])
"
6438543,ALDS1_9_B,"from heapq import heapify

N = input()
H = [-x for x in map(int, input().split())]

heapify(H)
print('', *[-x for x in H])
"
3940456,ALDS1_9_B,"# https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/9/ALDS1_9_B
# heapの完全二分木としての表現は二分探索木のときとルールが違いのでこんがらがらないように注意
# 詳しくはP233と238の図
# 勉強にはなるが解くだけならpythonのライブラリでok
from heapq import heapify, heappop, heappush, heappushpop
N = input()
H = [-x for x in map(int, input().split())]

heapify(H)
print('', *[-x for x in H])

"
4600641,ALDS1_9_B,"from heapq import heapify, heappop, heappush, heappushpop
N = input()
H = [-x for x in map(int, input().split())]

heapify(H)
print('', *[-x for x in H])

"
4304471,ALDS1_9_B,"def resolve():
    '''
    code here
    '''
    import heapq
    N = int(input())
    input_list = [-1 * int(item) for item in input().split()]

    heapq.heapify(input_list)

    input_list = [-1 * item for item in input_list]
    print('', *input_list)


if __name__ == ""__main__"":
    resolve()

"
6146306,ALDS1_9_B,"from heapq import heapify, heappop, heappush, heappushpop
N = input()
H = [-x for x in map(int, input().split())]

heapify(H)
print('', *[-x for x in H])
"
4767860,ALDS1_9_B,"import heapq
N = input()
H = [-x for x in map(int, input().split())]

heapq.heapify(H)
print("""", *[-x for x in H])
"
8829706,ALDS1_9_B,"def left(i):
    return i * 2
    
def right(i):
    return i * 2 + 1

def max_heapify(A, i):
    l = left(i)
    r = right(i)
    #左の子、自分、右の子で値が最大のノードを選ぶ
    if l <= H and A[l] > A[i]:
        largest = l
    else:
        largest = i
    if r <= H and A[r] > A[largest]:
        largest = r
        
    #iの子の方が値が大きい場合
    if largest != i:
        A[i], A[largest] = A[largest], A[i]
        max_heapify(A, largest)
        
def build_maxheap(A):
    for i in range(H//2, 0, -1):
        max_heapify(A, i)
        
H = int(input())
input_line = list(map(int, input().split()))
A = [0 for _ in range(H+1)]
for i in range(1, H+1):
    A[i] = input_line[i-1]
build_maxheap(A)
for i in range(1, H+1):
    print("" {}"".format(A[i]), end="""")
    if i == H:
        print()
"
8598849,ALDS1_9_B,"#Maximum Heap
def left(i):
    if 2*i+1 < H:
        return 2*i+1
    else:
        return 200000000001

def right (i):
    if 2*i+2 < H:
        return 2*i+2
    else:
        return 200000000001

def maxHeapify(A, i):
    l = left(i)
    r = right(i)
    #select maximum node from the key, left and right
    if l <= H and A[l] > A[i]:
        largest = l
    else:
        largest = i
    if r <= H and A[r] > A[largest]:
        largest = r
    
    if largest != i:
        A[i], A[largest] = A[largest], A[i]
        maxHeapify(A, largest)

def buildMaxHeap(A):
    for i in range((H//2)-1, -1, -1):
        maxHeapify(A, i)

H = int(input()) #heapsize
A = input().split(' ')
for i in range(H):
    A[i] = int(A[i])        
        
buildMaxHeap(A)

for i in range(H):
    print(f' {A[i]}', end = """")
print()
    

"
8508345,ALDS1_9_B,"def max_heapify(arr, i):
  # Make max node top in it, its left and its right

  left_i = ((i + 1) * 2) - 1  # Do `+ 1` and `- 1` for computing heap tree idx
  right_i = ((i + 1) * 2) + 1 - 1

  val = arr[i]
  left = arr[left_i] if left_i < len(arr) else float('-inf')
  right = arr[right_i] if right_i < len(arr) else float('-inf')
  # Make `nodes` to get `maximum_i` from max val of it, its left and its right
  nodes = {
      val: i,
      left: left_i,
      right: right_i
  }

  maximum = max(nodes.keys())
  maximum_i = nodes[maximum]

  # Swap it and max and call `max_heapify` recursionaly if it != max
  if maximum_i != i:
    arr[i], arr[maximum_i] = arr[maximum_i], arr[i]
    max_heapify(arr, maximum_i)  # This is for make `arr[i]` down


def build_max_heap(arr):
  for i in reversed(range(len(arr) // 2 + 1)):  # `range(len(arr) // 2 + 1)` is
                                                # okay because half nodes of
                                                # `arr` are leafs
    max_heapify(arr, i)
  return arr

_ = input()
print(''.join(map(lambda x: ' ' + str(x), build_max_heap(list(map(int, input().split()))))))
"
5223512,ALDS1_9_B,"from heapq import heapify
input()
a = list(map(lambda x: -int(x), input().split()))
heapify(a)
print("""", *list(map(lambda x: -x, a)))

"
4284542,ALDS1_9_B,"class MaxHeap:

    @classmethod
    def heapify(cls, array):
        size = len(array)
        for i in reversed(range(size // 2)):
            cls.siftdown(array, i, size)

    @classmethod
    def push(cls, heap, x):
        heap.append(x)
        cls.siftup(heap, len(heap) - 1)

    @classmethod
    def pop(cls, heap):
        if heap:
            heap[0], heap[-1] = heap[-1], heap[0]
            res = heap.pop()
            cls.siftdown(heap, 0, len(heap) - 1)
            return res
        else:
            return None

    @staticmethod
    def peek(heap):
        return heap[0]

    @staticmethod
    def siftup(heap, i):
        parent = (i - 1) // 2
        while i > 0 and heap[i] >= heap[parent]:
            heap[i], heap[parent] = heap[parent], heap[i]
            i = parent
            parent = (i - 1) // 2

    @staticmethod
    def siftdown(heap, i, size):
        while True:
            left = 2 * i + 1
            right = 2 * i + 2
            largest = left
            if right < size and heap[right] > heap[left]:
                largest = right

            if left >= size or heap[i] > heap[largest]:
                break

            heap[i], heap[largest] = heap[largest], heap[i]
            i = largest


if __name__ == '__main__':
    input()
    array = list(map(int, input().split()))
    MaxHeap.heapify(array)
    print(' ' + ' '.join(map(str, array)))
"
2722406,ALDS1_9_B,"H=int(input())+1
A=[0]+list(map(int,input().split()))
def h(i):
 l=2*i;r=l+1
 if r<H:
  if A[i]<A[l]:
   if A[l]<A[r]:A[i],A[r]=A[r],A[i];h(r)
   else:A[i],A[l]=A[l],A[i];h(l)
  elif A[i]<A[r]:A[i],A[r]=A[r],A[i];h(r)
 elif l<H and A[i]<A[l]:A[i],A[l]=A[l],A[i];h(l)
for i in range(H//2,0,-1):h(i)
print(' '+' '.join(map(str,A[1:])))
"
5465191,ALDS1_9_B,"x=int(input())+1
y=[0]+list(map(int,input().split()))
def h(i):
 l=2*i;r=l+1
 if r<x:
  if y[i]<y[l]:
   if y[l]<y[r]:
    y[i],y[r]=y[r],y[i];h(r)
   else:
    y[i],y[l]=y[l],y[i];h(l)
  elif y[i]<y[r]:
    y[i],y[r]=y[r],y[i];h(r)
 elif l<x and y[i]<y[l]:
    y[i],y[l]=y[l],y[i];h(l)
for i in range(x//2,0,-1):
    h(i)
print(' '+' '.join(map(str,y[1:])))
"
5130705,ALDS1_9_B,"H=int(input())+1
A=[0]+list(map(int,input().split()))
def h(i):
 l=2*i;r=l+1
 if r<H:
  if A[i]<A[l]:
   if A[l]<A[r]:A[i],A[r]=A[r],A[i];h(r)
   else:A[i],A[l]=A[l],A[i];h(l)
  elif A[i]<A[r]:A[i],A[r]=A[r],A[i];h(r)
 elif l<H and A[i]<A[l]:A[i],A[l]=A[l],A[i];h(l)
for i in range(H//2,0,-1):h(i)
print(' '+' '.join(map(str,A[1:])))

"
5431006,ALDS1_9_B,"B=int(input())+1
A=[0]+list(map(int,input().split()))
def h(i):
 l=2*i;r=l+1
 if r<B:
  if A[i]<A[l]:
   if A[l]<A[r]:A[i],A[r]=A[r],A[i];h(r)
   else:A[i],A[l]=A[l],A[i];h(l)
  elif A[i]<A[r]:A[i],A[r]=A[r],A[i];h(r)
 elif l<B and A[i]<A[l]:A[i],A[l]=A[l],A[i];h(l)
for i in range(B//2,0,-1):h(i)
print(' '+' '.join(map(str,A[1:])))

"
8527958,ALDS1_9_B,"def max_heapify(A, i):
  triad = {j:A[j] if j < N else -float(""inf"") for j in [i, 2*i+1, 2*i+2]}
  i_max = max(triad, key=triad.get)
  if i != i_max:
    A[i], A[i_max] = A[i_max], A[i]
    max_heapify(A, i_max)

N = int(input())
heap = [*map(int, input().split())]
for i in reversed(range(N//2)):
  max_heapify(heap, i)
print("""", *heap)


"
3402215,ALDS1_9_B,"H=int(input())+1
A=[0]+list(map(int,input().split()))
def h(i):
 l=2*i;r=l+1
 if r<H and l<H:
  if A[i]<A[l]:
   if A[l]<A[r]:A[i],A[r]=A[r],A[i];h(r)
   else:A[i],A[l]=A[l],A[i];h(l)
  elif A[i]<A[r]:A[i],A[r]=A[r],A[i];h(r)
 elif l<H and A[i]<A[l]:A[i],A[l]=A[l],A[i];h(l)
for i in range(H//2,0,-1):h(i)
print(' '+' '.join(map(str,A[1:])))
"
3901373,ALDS1_9_B,"# ALDS1_9_B Maximum Heap
import sys

def maxheap(A, i):
    # i はリストの位置
    l = i * 2
    r = l + 1

    largest = i

    if l <= H:
        if A[l] > A[largest]:
            largest = l

    if r <= H:
        if A[r] > A[largest]:
            largest = r

    if largest != i:
        A[i], A[largest] = A[largest], A[i]
        maxheap(A, largest)


def buildmaxheap(A):
    for i in range(H // 2, 0, -1):
        maxheap(A, i)

H = int(input())

A = list(map(int, sys.stdin.readline().strip().split()))
A.insert(0, None)
buildmaxheap(A)
A.remove(None)
print('', ' '.join(map(str, A)))

"
2707449,ALDS1_9_B,"H = int(input())
L = list(map(int, input().split()))
def maxHeapify(A, i):
    l = i * 2 + 1
    r = i * 2 + 2
    if l < H and A[l] > A[i]:
        largest = l
    else:
        largest = i
    if r < H and A[r] > A[largest]:
        largest = r
    if largest != i:
        A[i], A[largest] = A[largest], A[i]
        maxHeapify(A, largest)
def buildMaxHeap(A):
    for i in range(H // 2, -1, -1):
        maxHeapify(A, i)
buildMaxHeap(L)
print("""", "" "".join(map(str, L)))

"
3442688,ALDS1_9_B,"H = int(input())
a = list(map(int, input().split()))
def maxHeapify(A, i):
    l = 2*i + 1
    r = 2*i + 2
    largest = i
    if l<H and A[largest] < A[l]:
        largest = l 
    if r<H and A[largest] < A[r]:
        largest = r
    if largest != i:
        A[i],A[largest] = A[largest],A[i]
        maxHeapify(A, largest)

def buildHeap(A):
    for i in range(H//2, -1,-1):
        maxHeapify(A, i)

buildHeap(a)

print(' '+' '.join(list(map(str, a))))

"
4299201,ALDS1_9_B,"import sys
sys.setrecursionlimit(15000)
n = int(input())
A = [0]+list(map(int,input().split()))

def maxHeapify(A, i):
  l = i*2
  r = i*2+1
  if l <= n and A[l] > A[i]:
    largest = l
  else:
    largest = i
  if r <= n and A[r] > A[largest]:
    largest = r
  if largest != i:
    A[i],A[largest]=A[largest],A[i]
    maxHeapify(A,largest)

def buildMaxHeap(A):
  for i in range(n//2,0,-1):
    maxHeapify(A,i)

buildMaxHeap(A)
print("" "",end="""")
print("" "".join(map(str,A[1:])))
"
5331438,ALDS1_9_B,"n = int(input())
a = [0] + list(map(int, input().split()))

def max_heapify(a, x):
    global n
    left = 2*x
    right = 2*x + 1
    
    if left <= n and a[left] > a[x]:
        largest = left
    else:
        largest = x
    
    if right <= n and a[right] > a[largest]:
        largest = right
    if largest != x:
        a[largest], a[x] = a[x], a[largest]
        max_heapify(a, largest)

for i in range(int(n / 2), 0, -1):
    max_heapify(a, i)
    
print("" "" + "" "".join(map(str, a[1:])))

"
5411648,ALDS1_9_B,"H = int(input())
tree = [None] + list(map(int, input().split()))


def max_heapify(tree, i):
    l = 2 * i
    r = 2 * i + 1
    if l <= H and tree[l] > tree[i]:
        largest = l
    else:
        largest = i
    if r <= H and tree[r] > tree[largest]:
        largest = r
    if largest != i:
        tree[i], tree[largest] = tree[largest], tree[i]
        max_heapify(tree, largest)


def build_max_heap(tree):
    for i in range(H // 2, 0, -1):
        max_heapify(tree, i)


build_max_heap(tree)
print("" "" + "" "".join(map(str, tree[1:])))

"
5428058,ALDS1_9_B,"H = int(input())
tree = [None] + list(map(int, input().split()))


def max_heapify(tree, i):
    l = 2 * i
    r = 2 * i + 1
    if l <= H and tree[l] > tree[i]:
        largest = l
    else:
        largest = i
    if r <= H and tree[r] > tree[largest]:
        largest = r
    if largest != i:
        tree[i], tree[largest] = tree[largest], tree[i]
        max_heapify(tree, largest)


def build_max_heap(tree):
    for i in range(H // 2, 0, -1):
        max_heapify(tree, i)


build_max_heap(tree)
print("" "" + "" "".join(map(str, tree[1:])))

"
3963895,ALDS1_9_B,"def maxHeapify(A, i):
    global H
    l = i * 2 + 1
    r = i * 2 + 2
    if l < H and A[l] > A[i]:
        largest = l
    else:
        largest = i
    if r < H and A[r] > A[largest]:
        largest = r
    
    if largest != i:
        A[i], A[largest] = A[largest], A[i]
        maxHeapify(A, largest)    

def buildMaxHeap(A):
    global H
    for i in reversed(range(int((H + 1) / 2))):
        maxHeapify(A, i)

H = int(input())
A = list(map(int, input().split("" "")))
buildMaxHeap(A)
print("" "", end = '')
print(' '.join(map(str, A)))
"
3114102,ALDS1_9_B,"#coding: utf-8

def maxHeapify(A, i):
    l = 2 * i
    r = 2 * i  + 1

    if l <= H and A[l] > A[i]:
        largest = l
    else:
        largest = i

    if r <= H and A[r] > A[largest]:
        largest = r

    if largest != i:
        A[i], A[largest] = A[largest], A[i]
        maxHeapify(A, largest)

def buildMaxHeap(A):
    for i in range(H//2, 0, -1):
        maxHeapify(A, i)

H = int(input())
A = [0] + list(map(int,input().split()))
buildMaxHeap(A)
A.pop(0)
print("" "" + "" "".join([str(num) for num in A]))

"
6823438,ALDS1_9_B,"def maxHeapify(A, i):
    global H
    l = 2 * i
    r = 2 * i + 1
    f = l if l <= H and A[l] > A[i] else i
    if r <= H and A[r] > A[f]:
        f = r
    if f != i:
        A[f], A[i] = A[i], A[f]
        maxHeapify(A, f)

H = int(input())


b = [0] + list(map(int, input().split()))
for i in range(int(H / 2), 0, -1):
    maxHeapify(b, i)
    
print("" "" + "" "".join(map(str, b[1:])))
"
2835891,ALDS1_9_B,"n = int(input())
a = [0] + list(map(int, input().split()))
def max_heapify(a, i):
    global n
    l = 2 * i
    r = 2 * i + 1
    largest = l if l <= n and a[l] > a[i] else i
    if r <= n and a[r] > a[largest]:
        largest = r
    if largest != i:
        a[largest], a[i] = a[i], a[largest]
        max_heapify(a, largest)

for i in range(int(n / 2), 0, -1):
    max_heapify(a, i)
    
print("" "" + "" "".join(map(str, a[1:])))
"
4992772,ALDS1_9_B,"def maxHeapfy(i):
    l = 2 * i 
    r = 2 * i + 1
    # 左の子、自分、右の子で値が最大のノードを選ぶ
    if l <= H and A[l] > A[i]:
        largest = l
    else:
        largest = i
    if r <= H and A[r] > A[largest]:
        largest = r
    if largest != i:
        A[i],A[largest] = A[largest],A[i]
        maxHeapfy(largest)


H = int(input())
A = [None] + list(map(int, input().split()))

for i in range(H//2, 0, -1):
   maxHeapfy(i)
A.pop(0)
print(' ' + ' '.join(map(str, A)))

"
6224094,ALDS1_9_B,"import sys
sys.setrecursionlimit(15000)
n = int(input())
A = [0]+list(map(int,input().split()))

def maxHeapify(A, i):
  l = i*2
  r = i*2+1
  if l <= n and A[l] > A[i]:
    largest = l
  else:
    largest = i
  if r <= n and A[r] > A[largest]:
    largest = r
  if largest != i:
    A[i],A[largest]=A[largest],A[i]
    maxHeapify(A,largest)

def buildMaxHeap(A):
  for i in range(n//2,0,-1):
    maxHeapify(A,i)

buildMaxHeap(A)
print("" "",end="""")
print("" "".join(map(str,A[1:])))

"
6822987,ALDS1_9_B,"def maxHeapify(A, i):
    global H
    l = 2 * i
    r = 2 * i + 1
    k = l if l <= H and A[l] > A[i] else i
    if r <= H and A[r] > A[k]:
        k = r
    if k != i:
        A[k], A[i] = A[i], A[k]
        maxHeapify(A, k)

H = int(input())
c = [0] + list(map(int, input().split()))

for i in range(int(H / 2), 0, -1):
    maxHeapify(c, i)
    
print("" "" + "" "".join(map(str, c[1:])))

"
3199908,ALDS1_9_B,"import sys

H = int(sys.stdin.readline())
A = list(map(int,sys.stdin.readline().split()))

def maxHeapify(A, i):
    l = (i+1)*2-1  
    r = (i+1)*2    
    
    if l < H and A[l] > A[i]:
        largest = l
    else:
        largest = i
    if r < H and A[r] > A[largest]:
        largest = r

    if largest != i: 
        A[i], A[largest] = A[largest], A[i]
        maxHeapify(A, largest) 

def buildMaxHeap(A):
    for i in range(H//2-1, -1, -1):
        maxHeapify(A, i)

buildMaxHeap(A)
print('',' '.join(map(str,A)))
"
5130283,ALDS1_9_B,"import sys
input=sys.stdin.readline
h=int(input())
key=list(map(int,input().split()))
def downheap(x):
    while (x+1)*2<=h:
        l=(x+1)*2-1
        r=(x+1)*2
        if r<h and key[r]>key[l]:
            l=r
        if key[l]>key[x]:
            work=key[l]
            key[l]=key[x]
            key[x]=work
            x=l
        else:
            break
for i in range(h//2-1,-1,-1):
    downheap(i)
print('',' '.join([str(s)for s in key]))
"
6227428,ALDS1_9_B,"H = int(input())
A = [0] + list(map(int, input().split()))
def maxHeapfy(i):
    l = 2*i
    r = 2*i +1
    if l<=H and A[l] > A[i]:
        largest = l
    else:
        largest = i
    if r <= H and A[r] > A[largest]:
        largest = r
    if largest != i:
        A[i],A[largest]=A[largest],A[i]
        
        maxHeapfy(largest)
        
for i in range(int(H/2),0,-1):
    maxHeapfy(i)
print("" "" + "" "".join(map(str, A[1:])))
    
"
5468163,ALDS1_9_B,"from sys import stdin

input = lambda: stdin.readline().rstrip()
H = int(input())
Tree = [0] + list(map(int, input().split()))

def maxHeapify(i):
    left = 2 * i
    right = 2 * i + 1

    if left <= H and Tree[left] > Tree[i]:
        largest = left
    else:
        largest = i

    if right <= H and Tree[right] > Tree[largest]:
        largest = right

    if largest != i:
        Tree[i], Tree[largest] = Tree[largest], Tree[i]
        maxHeapify(largest)


for i in range(1, H // 2 + 1 )[::-1]:
    maxHeapify(i)

# Treeの0番目の要素を削除
# del Tree[0]
print("" "" + "" "".join(map(str, Tree[1:])))
"
2296934,ALDS1_9_B,"def max_heapify(A, i):
  l = i * 2
  r = l + 1
  largest = i
  if l <= H and A[l] > A[i]: largest = l
  if r <= H and A[r] > A[largest]: largest = r
  if largest != i:
    A[i], A[largest] = A[largest], A[i]
    max_heapify(A, largest)

def build_max_heap(A):
  for i in range(H // 2, 0, -1):
    max_heapify(A, i)

H = int(input())
A = list(map(int, input().split()))
A.insert(0, 0)
build_max_heap(A)

print("" "" + "" "".join(map(str, A[1:])))
"
3072063,ALDS1_9_B,"def maxHeapfy(a, h, i):
    l = 2 * i
    r = 2 * i + 1

    if l <= h and a[l] > a[i]:
        largest = l
    else:
        largest = i
    if r <= h and a[r] > a[largest]:
        largest = r

    if largest != i:
        a[i], a[largest] = a[largest], a[i]
        maxHeapfy(a, h, largest)


h = int(input())
a = [-1]
a.extend([int(v) for v in input().split()])

for i in range(h//2, 0, -1):
    maxHeapfy(a, h, i)

print(' ' + ' '.join([str(v) for v in a[1:]]))
"
8707939,ALDS1_9_C,"import heapq

que = []
heapq.heapify(que)

ans = []
while 1:
    l = input().split()
    c = l[0]
    if c == ""insert"":
        v = l[1]
        heapq.heappush(que, -int(v))
    elif c == ""extract"":
        v = heapq.heappop(que)
        ans.append(-v)
    elif c == ""end"":
        break

print(*ans, sep=""\n"")

"
8829787,ALDS1_9_C,"""""""
def left(i):
    return i * 2
    
def right(i):
    return i * 2 + 1

def max_heapify(A, i):
    l = left(i)
    r = right(i)
    #左の子、自分、右の子で値が最大のノードを選ぶ
    if l <= H and A[l] > A[i]:
        largest = l
    else:
        largest = i
    if r <= H and A[r] > A[largest]:
        largest = r
        
    #iの子の方が値が大きい場合
    if largest != i:
        A[i], A[largest] = A[largest], A[i]
        max_heapify(A, largest)
        
def build_maxheap(A):
    for i in range(H//2, 0, -1):
        max_heapify(A, i)

def insert(A, elem):
    global H
    A.append(elem)
    H += 1
    build_maxheap(A)
    
def largest(A, i, l ,r):
    if A[l] > A[i]:
        largest = l
    else:
        largest = i
    if A[r] > A[largest]:
        largest = r
    return largest
    
def extract(A):
    global H
    print(A[1])
    A[1] = A.pop(-1)
    H -= 1
    build_maxheap(A)
    def _extract(A, i):
        l = left(i)
        r = right(i)
        if l > H:
            return
        if r > H:
            if A[l] > A[i]:
                A[l], A[i] = A[i], A[l]
                _extract(A, l)
            else:
                return
        else:
            large = largest(A, i, l, r)
            if large == i:
                return
            elif large == l:
                A[l], A[i] = A[i], A[l]
                i = l
                _extract(A, l)
            else:
                A[r], A[i] = A[i], A[r]
                i = r
                _extract(A, r)
    _extract(A, 1)
""""""
import heapq
A = []
heapq.heapify(A)
while True:
    command = input().split()
    if command[0] == ""insert"":
        heapq.heappush(A, -1*int(command[1]))
    elif command[0] == ""extract"":
        print(-1*heapq.heappop(A))
    elif command[0] == ""end"":
        break
"
8821923,ALDS1_9_C,"# aizu_ALDS1_9_C_PriorityQueue.py  

from heapq import heappop,heappush

S = []
while True:
    ope = input().split()
    if ope[0] == 'end': break
    if ope[0] == 'insert':
        k = int(ope[1])
        heappush(S,-k)
    if ope[0] =='extract':
        x = -heappop(S)
        print(x)
"
9044909,ALDS1_9_C,"from heapq import heapify, heappop, heappush

ans=[]
heapify(ans)
while True:
    order=list(input().split())
    if order[0]==""insert"":
        heappush(ans, -int(order[1]))
    elif order[0]==""extract"":
        print(-heappop(ans))
    else:
        break
"
6049297,ALDS1_9_C,"import sys
from collections import deque
from heapq import heappush, heappop

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines


def main():
    L = deque(read().rstrip().split())
    hq = []

    while L:
        order = L.popleft()

        if order == 'end':
            break

        if order == 'insert':
            heappush(hq, -int(L.popleft()))
        
        else:
            print(-heappop(hq))


if __name__ == '__main__':
    main()
"
8808384,ALDS1_9_C,"import heapq
q=[]
while(s:=input())!=""end"":
    p=s.split()
    if p[0]==""insert"":heapq.heappush(q,-int(p[1]))
    else:print(-heapq.heappop(q))
"
4103953,ALDS1_9_C,"import sys, heapq
def main():
    input = sys.stdin.readline
    que = []
    ans = []
    while True:
        a = input()
        if a[0] == ""i"":
            heapq.heappush(que, -int(a[7:]))
        elif a[2] == ""t"":
            ans.append(-heapq.heappop(que))
        else:
            break
    print(""\n"".join(map(str, ans)))

if __name__ == ""__main__"":
    main()
"
9047441,ALDS1_9_C,"import heapq
pq = []
while True:
    c = input().split()
    if c[0] == 'end':
        break
    if c[0] == 'extract':
        print(-heapq.heappop(pq))
    else:
        heapq.heappush(pq, -int(c[1]))
"
8574546,ALDS1_9_C,"import heapq

q = []
heapq.heapify(q)
while True:
    l = list(input().split())
    if l[0]==""insert"":
        heapq.heappush(q,-int(l[1]))
    elif l[0]==""extract"":
        print(-heapq.heappop(q))
    else:
        exit()
"
2708527,ALDS1_9_C,"import sys
from heapq import heapify, heappush, heappop
hq = []
S = []
for s in sys.stdin:
    if s[2] == ""s"":
        heappush(hq, -int(s[7:]))
    elif s[2] == ""t"":
        S.append(-heappop(hq))
    else:
        break
print(""\n"".join(map(str, S)))

"
5431008,ALDS1_9_C,"import sys
from heapq import*
B=[]
O=[]
for e in sys.stdin:
 if'i'==e[0]:heappush(B,-int(e[7:]))
 elif't'==e[2]:O+=[-heappop(B)]
 else:print('\n'.join(map(str,O)))

"
2722602,ALDS1_9_C,"import sys
from heapq import*
H=[]
O=[]
for e in sys.stdin:
 if'i'==e[0]:heappush(H,-int(e[7:]))
 elif't'==e[2]:O+=[-heappop(H)]
 else:print('\n'.join(map(str,O)))
"
8530563,ALDS1_9_C,"from heapq import heappop, heappush

heap = []
while True:
  op, *key = input().split()
  if op == ""end"":
    break
  if op == ""extract"":
    print(-heappop(heap))
  else:
    heappush(heap, -int(*key))

"
8872074,ALDS1_9_C,"import heapq

def insert(heap, k):
    heapq.heappush(heap, -k)

def extractMax(heap):
    return -heapq.heappop(heap)

heap = []
while True:
    command = input().split()
    if command[0] == 'end':
        break
    elif command[0] == 'insert':
        insert(heap, int(command[1]))
    elif command[0] == 'extract':
        print(extractMax(heap))
"
5965092,ALDS1_9_C,"import sys
from heapq import*
H=[]
O=[]
for e in sys.stdin:
 if'i'==e[0]:heappush(H,-int(e[7:]))
 elif't'==e[2]:O+=[-heappop(H)]
 else:print('\n'.join(map(str,O)))
"
8700749,ALDS1_9_C,"from heapq import heappop, heappush

def insert(S, k):
    # 負の数にして、heappopで扱えるようにする
    k *= -1
    heappush(S, k)

def extractMax(S):
    # 最小の要素を取得
    x = heappop(S)
    return x * -1

S = []
cnt = 0
while True:
    inp = (input())
    # end が入力されたら処理終了
    if inp == ""end"":
        break
    
    # insert xx が入力された場合
    elif inp.startswith(""insert""):
        k = int(inp.split()[-1])
        insert(S, k)
    
    # extract が入力された場合
    elif inp == ""extract"":
        print(extractMax(S))
    
    else:
        print(""insert xx または extract または end を入力してください"")
    
    cnt += 1
    if cnt > 2000000000:
        break
"
3152829,ALDS1_9_C,"from sys import stdin
from heapq import heappush, heappop


def main():
    Q = []

    for line in stdin.readlines():
        cmd = line.split()
        if cmd[0] == ""insert"":
            heappush(Q, -int(cmd[1]))
        elif cmd[0] == ""extract"":
            print(-heappop(Q))
        else:
            break


if __name__ == ""__main__"":
    main()
"
7347666,ALDS1_9_C,"""""""
class PriorityQueue:
    def __init__(self):
        self.plist = []
        self.priq = Heap(self.plist, len(self.plist))

    def insert_key(self, key):
        self.plist.append(key)
        self.priq.build_maxheap()

    def extract_max(self):
        max = self.plist.pop(0)
        return max

class Heap:
    def __init__(self, A, n):
        self.A = A
        self.n = n

    def left(self, i):
        return i * 2 + 1

    def right(self, i):
        return i * 2 + 2

    def max_heapify(self, i):
        l = self.left(i)
        r = self.right(i)

        if l < self.n and self.A[l] > self.A[i]:
            largest = l
        else:
            largest = i

        if r < self.n and self.A[r] > self.A[largest]:
            largest = r

        if largest != i:
            self.A[i], self.A[largest] = self.A[largest], self.A[i]
            self.max_heapify(largest)

    def build_maxheap(self):
        for i in range(self.n // 2, -1, -1):
            self.max_heapify(i)
""""""

import heapq
import sys

heap_list = []
for cmd in sys.stdin.readlines():
    if cmd[0] == ""i"":
        heapq.heappush(heap_list, -int(cmd[7:]))
    elif cmd[1] == ""x"":
        print(-heapq.heappop(heap_list))

"
1676219,ALDS1_9_C,"import heapq
import sys

h = []

for com in sys.stdin.readlines():
    if com[0] == ""i"":
        heapq.heappush(h, -int(com[7:]))
    elif com[1] == ""x"":
        print(-heapq.heappop(h))
"
5110473,ALDS1_9_C,"import sys, heapq
input = sys.stdin.readline


hq = []
ans = []
while True:
    a = input()
    if a[0] == ""i"":
        heapq.heappush(hq, -int(a[7:]))
    elif a[2] == ""t"":
        ans.append(-heapq.heappop(hq))
    else:
        break

print(""\n"".join(map(str, ans)))
"
5474297,ALDS1_9_C,"import heapq
from sys import stdin

r=[]
an=[]
ml=stdin.readlines()
for i in range(len(ml)):
    if ml[i][0]=='i':
        heapq.heappush(r,-int(ml[i][7:]))
    elif ml[i][1]=='x':
        an.append(-(heapq.heappop(r)))
    else:
        print(*an,sep='\n')
        exit()
"
4573753,ALDS1_9_C,"from heapq import heappop, heappush
import sys

q = []
ans = []
while True:
    s = sys.stdin.readline()
    if s[0] == 'i':
        heappush(q, -int(s[7:]))
    elif s[2] == 't':
        ans.append(-heappop(q))
    else:
        break
print('\n'.join(map(str, ans)))
"
7826303,ALDS1_9_C,"import sys
from heapq import heappush,heappop

heap=[]
result=[]

while True:
    try:
        oper=sys.stdin.readline()
        if oper[0]==""i"": # operName==""insert""
            heappush(heap,-int(oper[7:]))
        elif oper[2]==""t"": # operName==""extract""
            result.append(-heappop(heap))
        else: # operName==""end""
            break
    except EOFError:
        break

print(""\n"".join(map(str,result)))
"
4661887,ALDS1_9_C,"import heapq
L = []
heapq.heapify(L)

import sys
for a in sys.stdin:
    if a[0]=='i':
        heapq.heappush(L, -int(a[7:]))
    elif a[0:2]=='ex':
        e = heapq.heappop(L)
        print(-e)
    else:
        break
"
5411923,ALDS1_9_C,"import heapq

i = 0
A = []
Qeu = open(0).read().split()

while True:
    item = Qeu[i]
    if item == 'end':
        break
    elif item == 'insert':
        n = int(Qeu[i + 1])
        heapq.heappush(A, -n)
        i += 2
    elif item == 'extract':
        val = heapq.heappop(A)
        print(-val)
        i += 1

"
4779150,ALDS1_9_C,"import heapq
import sys
a = [0]
heapq.heapify(a)


for s in sys.stdin:
    if s[1] == 'x':
        print(heapq.heappop(a) * (-1))

    elif s[0] == 'i':
        num = int(s[7:]) * (-1)
        heapq.heappush(a, num)
"
4030144,ALDS1_9_C,"import heapq
S = []
Q = open(0).read().split()
i = 0
while True:
    it = Q[i]
    if it == 'end':
        break
    elif it == 'insert':
        num = int(Q[i + 1])
        heapq.heappush(S, -num)
        i += 2
    elif it == 'extract':
        ret = heapq.heappop(S)
        print(-ret)
        i += 1
    # print(S)
"
6349218,ALDS1_9_C,"
import heapq
import sys
a = [0]
heapq.heapify(a)


for s in sys.stdin:
    if s[1] == 'x':
        print(heapq.heappop(a) * (-1))

    elif s[0] == 'i':
        num = int(s[7:]) * (-1)
        heapq.heappush(a, num)
"
5130356,ALDS1_9_C,"import sys,heapq
input=sys.stdin.readline
def main():
    key=[]
    while True:
        cmd=input().split()
        if cmd[0]==""insert"":
            heapq.heappush(key,-int(cmd[1]))
        elif cmd[0]==""extract"":
            print(-heapq.heappop(key))
        else:
            break
main()
"
8755193,ALDS1_9_C,"if __name__ == '__main__':
    # 余計なものimportしないように、stdinだけimport
    from sys import stdin

    # 解説同様max_heapifyを再帰的に呼び出すと、リストAへのアクセス回数が増えてTLEするので、
    # whileを用いて実装する。
    def max_heapify(i):
        A_i = A[i]
        largest = i
        while True:
            l = 2*i
            r = 2*i+1
            # 左の子、自分、右の子で値が最大のノードを選ぶ
            A_largest = A_i

            if l <= H:
                A_l = A[l]
                if A_l > A_i:
                    largest, A_largest = l, A_l
                if r <= H:
                    A_r = A[r]
                    if A_r > A_largest:
                        largest, A_largest = r, A_r
            if largest != i: # 子の方が値が大きい場合
                A[i], A[largest] = A_largest, A_i
                i = largest
            else:
                return

    H = 0
    MAX = 2000000

    A = [-1]*(MAX+1)

    def extract():
        global H
        if H < 1:
            return
        maxv = A[1]
        A[1] = A[H]
        H -= 1
        max_heapify(1)
        return maxv

    def insert(key):
        global H
        H += 1
        A[H] = key
        i = H
        parent = i//2
        parent_key = A[parent]
        while i > 1 and parent_key < key:
            A[i], A[parent] = parent_key, key
            i = parent
            parent = i//2
            parent_key = A[parent]

    for line in stdin:
        if line.startswith('i'):
            key = int(line[7:])
            insert(key)
        elif line.startswith('ex'):
            print(extract())
        else:
            break
"
5488244,ALDS1_9_C,"from sys import stdin
from heapq import heappop, heappush
readline = stdin.readline


heap = []
while True:
    line = readline()
    if line[1] == 'x':print(-heappop(heap))
    elif line[0] == 'i':heappush(heap, -int(line.split()[1]))
    else:break

"
6993012,ALDS1_9_C,"from sys import stdin 
input = stdin.readline 
from heapq import heappop, heappush

H =[]
while True:
    query = input().strip()
    if query == 'end':
        break 
    elif query == 'extract':
        val = heappop(H)
        print(-val)
    else:
        k = int(query[7:])
        heappush(H, -k)
"
4755790,ALDS1_9_C,"import sys
import heapq

readline = sys.stdin.readline


def main():
    _, a = readline().strip().split()
    pq = [-int(a)]
    heapq.heapify(pq)
    flag = True

    while flag:
        op = readline().strip()
        if op[0] == ""i"":
            _, a = op.split()
            heapq.heappush(pq, -int(a))
        elif op[1] == ""x"":
            a = heapq.heappop(pq)
            print(-a)
        else:
            flag = False

    return


if __name__ == ""__main__"":
    main()

"
7538281,ALDS1_9_C,"from heapq import heappop,heappush
import sys

ans = []
h = []
for l in sys.stdin.readlines():
    if l.startswith('insert'):
        heappush(h, -int(l.split()[1]))
    elif l.startswith('extract'):
        ans.append(f'{(-heappop(h)):d}\n')
    else:
        break
sys.stdout.writelines(ans)

"
6290569,ALDS1_9_C,"import sys
from heapq import heappush, heappop
hp = []
for _ in range(2*10**9):
    op = sys.stdin.readline()
    if op[2] == 'd':
        break
    if op[0] == 'i':
        heappush(hp, -int(op[7:]))
    else:
        print(-heappop(hp))

"
2887008,ALDS1_9_C,"import sys
from heapq import heappush, heappop

# わからん
pq = []
lines = sys.stdin.readlines()
for line in lines:
    op = line.strip().split(' ')
    if op[0] == 'insert':
        heappush(pq, -int(op[1]))
    elif op[0] == 'extract':
        print(-heappop(pq))
    else:
        break

# import sys, time
#
# class PriorityQueue:
#     __slots__ = ['nodes', 'num']
#
#     def __init__(self):
#         self.nodes = []
#         self.num = 0
#
#     def max_heapify(self, i):
#         if i >= self.num: return
#         left, right = (i+1)*2-1, (i+1)*2
#
#         largest = i
#         if left < self.num and self.nodes[i] < self.nodes[left]: largest = left
#         if right < self.num and self.nodes[largest] < self.nodes[right]: largest = right
#
#         if largest != i:
#             self.nodes[i], self.nodes[largest] = self.nodes[largest], self.nodes[i]
#             self.max_heapify(largest)
#
#     def extract_max(self):
#         if self.num < 1: return
#         max = self.nodes[0]
#         self.nodes[0] = self.nodes[-1]
#         self.nodes.pop()
#         self.num -= 1
#         self.max_heapify(0)
#         return max
#
#     def insert(self, key):
#         self.nodes.append(key)
#         self.num += 1
#         i = self.num-1
#         par = lambda i: (i-1)//2
#         while i > 0 and self.nodes[par(i)] < self.nodes[i]:
#             self.nodes[i], self.nodes[par(i)] = self.nodes[par(i)], self.nodes[i]
#             i = par(i)
#
#     def print_element(self):
#         for node in self.nodes:
#             print('', node, end='')
#         print('')
#
# pq = PriorityQueue()
#
# start = time.time()
# lines = sys.stdin.readlines()
# for line in lines:
#     op = line.strip().split(' ')
#     if op[0] == 'insert':
#         pq.insert(int(op[1]))
#     elif op[0] == 'extract':
#         # print(pq.extract_max())
#         pq.extract_max()
#     else:
#         break
# print('elapsed:', time.time()-start)

"
2440618,ALDS1_9_C,"import sys
import heapq

if __name__ == ""__main__"":
    a = []
    for inp in sys.stdin.readlines():
        inp = inp.split()
        if inp[0] == ""insert"":
            heapq.heappush(a, -int(inp[1]))
        elif inp[0] == ""extract"":
            print(-heapq.heappop(a))
"
4304514,ALDS1_9_C,"def resolve():
    '''
    code here
    '''
    import sys
    import heapq
    queries = sys.stdin.readlines()
    
    heap = []

    for line in queries:
        query, *val = line.split()
        
        if query == 'insert':
            value = -1 * int(val[0])
            heapq.heappush(heap, value)
        if query == 'extract':
            print(-1 * heapq.heappop(heap))

    # print(heap)

if __name__ == ""__main__"":
    resolve()

"
5503114,ALDS1_9_C,"import heapq
push = heapq.heappush
pop = heapq.heappop
def solve(Query):
    HQ = []
    res = []
    for q in Query:
        if q == -1:
            res.append(-pop(HQ))
        else:
            push(HQ, -q)
    return res

import sys
def input():
    return sys.stdin.readline().rstrip()

def main():
    Query = []
    while True:
        s = input()
        if s == ""end"":
            break
        if s == ""extract"":
            Query.append(-1)
        else:
            _, k = s.split()
            Query.append(int(k))
    res = solve(Query)
    print(*res, sep = ""\n"")

if __name__ == ""__main__"":
    main()
"
2197496,ALDS1_9_C,"from sys import stdin
from heapq import heappop, heappush
readline = stdin.readline

heap = []
while True:
    line = readline()
    if line[1] == 'x':
        print(-heappop(heap))
    elif line[0] == 'i':
        heappush(heap, -int(line.split()[1]))
    else:
        break


'''
def insert(heap, key):
    heap.append(-1000000)
    heapIncreaseKey(heap, key)

def parent(i):
    return (i - 1) // 2

def heapIncreaseKey(heap, key):
    heap[len(heap) - 1] = key
    i = len(heap) - 1
    while i > 0 and heap[parent(i)] < heap[i]:
        heap[i], heap[parent(i)] = heap[parent(i)], heap[i]
        i = parent(i)

def heapExtractMax(heap):
    if len(heap) < 1:
        return None
    else:
        MAX = heap[0]
        heap[0] = heap.pop()
        maxHeapify(heap, 0)

        return MAX

def maxHeapify(heap, i):
    left = (i + 1) * 2 - 1
    right = (i + 1) * 2
    largest = left if left < len(heap) and heap[left] > heap[i] else i
    largest = right if right < len(heap) and heap[right] > heap[largest] else largest
    if largest != i:
        heap[i], heap[largest] = heap[largest], heap[i]
        maxHeapify(heap, largest)


heap = []
while True:
    line = sys.stdin.readline()
    if line[0] == 'i':
        insert(heap, int(line.split()[1]))
    elif line[0:2] == 'ex':
        print(str(heapExtractMax(heap)))
    else:
        break
'''
"
7644859,ALDS1_9_C,"import heapq
import sys

hq = heapq
command = []
a = []
for s in sys.stdin:
    command = s.split()
    if command[0] == ""end"":
        break
    elif command[0] == ""insert"":
        hq.heappush(a, int(command[1]) * (-1))
    else:
        print(hq.heappop(a) * (-1))


"
5471257,ALDS1_9_C,"import heapq
from sys import stdin

# input = lambda: stdin.readline().rstrip()
input = stdin.readline
S = []

while True:
    order = input()
    if order[0] == ""i"":
        order_insert, key = order.split()
        heapq.heappush(S, int(key) * (-1)) # pushする際に-1倍
    elif order[1] == ""x"":
        print(heapq.heappop(S) * (-1))
    else:
        break
"
1997612,ALDS1_9_C,"#!/usr/bin/env python3


import heapq
import sys


def main():
    pq = []
    for line in sys.stdin:
        args = line.split()
        if args[0] == ""insert"":
            heapq.heappush(pq, -int(args[1]))
        elif args[0] == ""extract"":
            print(-heapq.heappop(pq))
        else:
            return


if __name__ == '__main__':
    main()
"
7351149,ALDS1_9_C,"from heapq import heappush, heappop
import sys

que = []
ans = []
for line in sys.stdin.readlines():
    fte, *v = line.split()
    if fte == 'insert':
        heappush(que, -int(v[0]))
    elif fte == 'extract':
        ans.append(""%d\n"" % -heappop(que))
sys.stdout.writelines(ans)


"
5734999,ALDS1_9_C,"# 優先順位キュー
import heapq
import sys

hq = heapq
command = []
a = []
for s in sys.stdin:
    command = s.split()
    if command[0] == ""end"":
        break
    elif command[0] == ""insert"":
        hq.heappush(a, int(command[1]) * (-1))
    else:
        print(hq.heappop(a) * (-1))

"
7325651,ALDS1_9_C,"from heapq import heapify, heappop, heappush, heappushpop
import sys
inputs = sys.stdin.readline

heap = []
while True:
    # Input = input().split()
    Input = inputs().split()
    if Input[0] == 'end':
        break
    if Input[0] == 'insert':
        num = int(Input[1])
        heappush(heap, -num)
    elif Input[0] == 'extract':
        print(-heappop(heap))
"
3184990,ALDS1_9_C,"from heapq import heappush, heappop
import sys

que = []
ans = []
for line in sys.stdin.readlines():
    cmd, *v = line.split()
    if cmd == 'insert':
        heappush(que, -int(v[0]))
    elif cmd == 'extract':
        ans.append(""%d\n"" % -heappop(que))
sys.stdout.writelines(ans)

"
6336500,ALDS1_9_C,"from sys import stdin
import heapq

# 標準ライブラリのheapqはmin heapなので、符号を逆にして使う
heap_data = []
while True:
    query = stdin.readline().split()
    if query[0] == ""insert"":
        heapq.heappush(heap_data, -int(query[1]))
    elif query[0] == ""extract"":
        print(-heapq.heappop(heap_data))
    else:
        break
"
7825503,ALDS1_9_C,"from heapq import heappush, heappop
import sys

que = []
ans = []
for line in sys.stdin.readlines():
    cmd, *v = line.split()
    if cmd == 'insert':
        heappush(que, -int(v[0]))
    elif cmd == 'extract':
        ans.append(""%d\n"" % -heappop(que))
sys.stdout.writelines(ans)

"
2917279,ALDS1_9_C,"# -*- coding: utf-8 -*-
import sys
from heapq import *

q = []
while True:
    cmd = sys.stdin.readline().split()
    if cmd[0] == 'end':
        break
    elif cmd[0] == 'insert':
        heappush(q, -int(cmd[1]))
    else:
        print(-heappop(q))

"
6041819,ALDS1_9_C,"import heapq
import sys

A = []

while True:
    cmd = sys.stdin.readline().split()
    if cmd[0] == ""insert"":
        heapq.heappush(A, -int(cmd[1]))
    elif cmd[0] == ""end"":
        break
    else:
        print(-heapq.heappop(A))


"
7619156,ALDS1_9_C,"from heapq import heappush, heappop
import sys
que=[]
ans=[]
for line in sys.stdin.readlines():
    cmd,*v = line.split()
    if cmd ==""insert"":
        heappush(que,-int(v[0]))
    elif cmd == ""extract"":
        ans.append(""%d\n"" % -heappop(que))
sys.stdout.writelines(ans)
"
4018400,ALDS1_9_C,"from heapq import heappush, heappop
import sys

que = []
ans = []
for line in sys.stdin.readlines():
    cmd, *v = line.split()
    if cmd == 'insert':
        heappush(que, -int(v[0]))
    elif cmd == 'extract':
        ans.append(""%d\n"" % -heappop(que))
sys.stdout.writelines(ans)

"
4840935,ALDS1_9_C,"import bisect, collections, copy, heapq, itertools, math, string
import sys
def I(): return int(sys.stdin.readline().rstrip())
def MI(): return map(int, sys.stdin.readline().rstrip().split())
def LI(): return list(map(int, sys.stdin.readline().rstrip().split()))
def S(): return sys.stdin.readline().rstrip()
def LS(): return list(sys.stdin.readline().rstrip().split())


from heapq import heappop, heappush
def main():
    pri_que = []
    for _ in range(2 * 10 ** 6 + 1):
        ord = S()
        if ord[0] == 'i':
            num = -int(ord[7:])
            heappush(pri_que, num)
        elif ord[0:2] == 'ex':
            print(-heappop(pri_que))
        else:
            exit()



if __name__ == ""__main__"":
    main()
"
4246377,ALDS1_9_C,"from heapq import *
import sys

q = []
while True:
  # commands = list(map(str, input().split()))
  commands=sys.stdin.readline().split()

  if commands[0] == ""end"":
    break

  if commands[0] == ""insert"":
    heappush(q, -int(commands[1]))
  else:
    print(-heappop(q))
"
6411702,ALDS1_9_C,"import heapq
import sys
l=[]
for i in range(10000000):
    strings=sys.stdin.readline()[:-1]
    if strings[0]==""i"":
        heapq.heappush(l,-int(strings[7:]))
        continue
    if strings[1]==""x"":
        print(-heapq.heappop(l))
        continue
    break

"
7626730,ALDS1_9_C,"from heapq import *
import sys

q=[]

while True:
	a=sys.stdin.readline().split()
	if a[0]=='end': break
	if a[0]=='insert':
		heappush(q,-int(a[1]))
	else:
		print(-heappop(q))
"
6321083,ALDS1_9_C,"from heapq import heappush, heappop
import sys

que = []
ans = []
for line in sys.stdin.readlines():
    cmd, *v = line.split()
    if cmd == 'insert':
        heappush(que, -int(v[0]))
    elif cmd == 'extract':
        ans.append(""%d\n"" % -heappop(que))
sys.stdout.writelines(ans)
"
4263248,ALDS1_9_C,"from heapq import heappush, heappop
import sys

que = []
ans = []
for line in sys.stdin.readlines():
    cmd, *v = line.split()
    if cmd == 'insert':
        heappush(que, -int(v[0]))
    elif cmd == 'extract':
        ans.append(""%d\n"" % -heappop(que))
sys.stdout.writelines(ans)


"
6637548,ALDS1_9_C,"import sys
import heapq
from _heapq import heappush, heappop
from collections import deque


BIG_NUM = 2000000000

Q = []

while True:
    work = sys.stdin.readline().split()
    if work[0] == 'end':
        break

    if work[0] == 'insert':
        heappush(Q,-1*(int(work[1])))
    else: #extract
        print(-1 * heappop(Q))

"
6955804,ALDS1_9_C,"import sys
import heapq
from _heapq import heappush, heappop
from collections import deque


BIG_NUM = 2000000000

Q = []

while True:
    work = sys.stdin.readline().split()
    if work[0] == 'end':
        break

    if work[0] == 'insert':
        heappush(Q,-1*(int(work[1])))
    else: #extract
        print(-1 * heappop(Q))
"
7298563,ALDS1_9_C,"import sys
import heapq
from _heapq import heappush, heappop
from collections import deque


BIG_NUM = 2000000000

Q = []

while True:
    work = sys.stdin.readline().split()
    if work[0] == 'end':
        break

    if work[0] == 'insert':
        heappush(Q,-1*(int(work[1])))
    else: #extract
        print(-1 * heappop(Q))
"
8994867,ALDS1_9_D,"def unshift(a, i):
    while 1 < i:
        tmp = a[i]
        a[i] = a[i//2]
        a[i//2] = tmp
        i = i//2

def reverse_heap_sort(a):
    n = len(a)
    a = [None] + a
    hsize = 1
    while hsize < n:
        unshift(a, hsize)
        hsize += 1
        tmp = a[1]
        a[1] = a[hsize]
        a[hsize] = tmp
    return a[1:]

_ = input()
a = [int(x) for x in input().split()]
print(*reverse_heap_sort(sorted(a)))
"
8498866,ALDS1_9_D,"m = int(input())
a = [0] + [int(i) for i in input().split()]
a.sort()
x = a[1]

for i in range(2, m):
    a[1] = a[i]
    while (j := i //2): a[i], i = a[j], j

a[1], a[m] = a[m], x
print(*a[1:])
"
8948763,ALDS1_9_D,"if __name__ == ""__main__"":
    N = int(input())
    An = list(map(int, input().split()))
    An.sort()

    for i in range(N - 1):
        j = i
        while 0 < j:
            k = (j - 1) // 2
            An[j], An[k] = An[k], An[j]
            j = k
        An[0], An[i + 1] = An[i + 1], An[0]

    print("" "".join(map(str, An)))

"
8476923,ALDS1_9_D,"n = int(input())
(*a,) = map(int, input().split())
a.sort()
for i in range(1, n - 1):
    a[0], a[i] = a[i], a[0]
    while i > 0:
        j = (i - 1) // 2
        a[i], a[j] = a[j], a[i]
        i = j
a[0], a[-1] = a[-1], a[0]
print(*a)

"
8844231,ALDS1_9_D,"n = int(input())
a = list(map(int, input().split())) + [-1]
a.sort()

for i in range(2, n):
    a[1], a[i] = a[i], a[1]
    while i != 1:
        a[i], a[i//2] = a[i//2], a[i]
        i //= 2

a[1], a[n] = a[n], a[1]

print(*a[1:])
"
9049799,ALDS1_9_D,"N=int(input())
A=list(map(int, input().split()))

listed_A=sorted(A)
for i in range(N-1):
    j=i
    while j >= 1:
        k = (j-1)//2
        listed_A[j], listed_A[k] = listed_A[k], listed_A[j]
        j = k
    listed_A[0], listed_A[i+1] = listed_A[i+1], listed_A[0]
print(*listed_A)
"
5211881,ALDS1_9_D,"import sys
readline = sys.stdin.readline
write = sys.stdout.write
def solve():
    N = int(readline())
    *A, = map(int, readline().split())
    A.sort()
    for i in range(N-1):
        j = i
        while j > 0:
            k = (j - 1) // 2
            A[j], A[k] = A[k], A[j]
            j = k
        A[0], A[i+1] = A[i+1], A[0]
    write("" "".join(map(str, A)))
    write(""\n"")
solve()

"
6955807,ALDS1_9_D,"import sys
readline = sys.stdin.readline
write = sys.stdout.write
def solve():
    N = int(readline())
    *A, = map(int, readline().split())
    A.sort()
    for i in range(N-1):
        j = i
        while j > 0:
            k = (j - 1) // 2
            A[j], A[k] = A[k], A[j]
            j = k
        A[0], A[i+1] = A[i+1], A[0]
    write("" "".join(map(str, A)))
    write(""\n"")
solve()


"
7635467,ALDS1_9_D,"import sys
readline = sys.stdin.readline
write = sys.stdout.write
def solve():
    N = int(readline())
    *A, = map(int, readline().split())
    A.sort()
    for i in range(N-1):
        j = i
        while j > 0:
            k = (j - 1) // 2
            A[j], A[k] = A[k], A[j]
            j = k
        A[0], A[i+1] = A[i+1], A[0]
    write("" "".join(map(str, A)))
    write(""\n"")
solve()


"
6722956,ALDS1_9_D,"from sys import stdin

def solve(N,A):
    A.sort()
    for i in range(1, N):
        j = i-1
        while j>0:
            k = (j-1)//2
            A[j], A[k] = A[k], A[j]
            j = k
        A[0], A[i] = A[i], A[0]
    return A

def main():
    N = int(stdin.readline().rstrip())
    A = list(map(int, stdin.readline().rstrip().split()))
    print(*solve(N,A))
main()
"
7635327,ALDS1_9_D,"import sys
import os


fn = ""inputdata.txt""
if os.path.exists(fn):
    sys.stdin = open(fn)
num = int(sys.stdin.readline())

*A,=map(int,sys.stdin.readline().split())

def revert(A,num):
    rec=list(range(num))
    Ans=[A.pop()]+[None]*(num-2)+[A[0]]  
    t=num-2
    while 1:
        n=t
        temp=rec[n]
        while 1:
            m=(n-1)//2
            if m<0:
                break
            temp,rec[m]=rec[m],temp
            if m==0:
                maxnum=A.pop()
                Ans[rec[m]]=maxnum
            n=m
        t-=1
        if t==0:
            break
    return Ans

A.sort()
if num==1:
    Ans=A
elif num==2:
    Ans=[A[1],A[0]]
else:
    Ans=revert(A,num)
    
print(*Ans)   
"
5582218,ALDS1_9_D,"import sys

# READ_FROM_FILE = True
READ_FROM_FILE = False


def main():
    if READ_FROM_FILE:
        f = open('test0.txt', 'r')
    else:
        f = sys.stdin

    n = int(f.readline())
    a_list = list(map(int, f.readline().split()))
    a_list.sort()

    for i in range(n - 1):
        j = i
        while j > 0:
            k = (j - 1) // 2
            a_list[j], a_list[k] = a_list[k], a_list[j]
            j = k
        a_list[0], a_list[i + 1] = a_list[i + 1], a_list[0]

    print(*a_list)

    if READ_FROM_FILE:
        f.close()
    return


if __name__ == '__main__':
    main()

"
5114951,ALDS1_9_D,"def main():

    n = int(input())
    a = list(map(int, input().split())) + [-1]
    a.sort()

    for i in range(2, n):
        a[1], a[i] = a[i], a[1]
        while i != 1:
            a[i], a[i//2] = a[i//2], a[i]
            i //= 2

    a[1], a[n] = a[n], a[1]
    
    print(*a[1:])

main()

"
5333362,ALDS1_9_D,"def main():
    n = int(input())
    A = list(map(int, input().split()))
    A += [0]
    A.sort()
    for i in range(2, n):
        A[1], A[i] = A[i], A[1]
        while i != 1:
            A[i], A[i // 2] = A[i // 2], A[i]
            i //= 2
    A[1], A[n] = A[n], A[1]
    print(*A[1:])

if __name__ == '__main__':
    main()
"
5488246,ALDS1_9_D,"def main():

    n = int(input())
    a = list(map(int, input().split())) + [-1]
    a.sort()

    for i in range(2, n):
        a[1], a[i] = a[i], a[1]
        while i != 1:
            a[i], a[i//2] = a[i//2], a[i]
            i //= 2

    a[1], a[n] = a[n], a[1]
    
    print(*a[1:])

main()


"
6044247,ALDS1_9_D,"def main():

    n = int(input())
    a = list(map(int, input().split())) + [-1]
    a.sort()

    for i in range(2, n):
        a[1], a[i] = a[i], a[1]
        while i != 1:
            a[i], a[i//2] = a[i//2], a[i]
            i //= 2

    a[1], a[n] = a[n], a[1]
    
    print(*a[1:])

main()

"
5138882,ALDS1_9_D,"def main() :
    n = int(input())
    heapArray = list(map(int, input().split()))
    heapArray.sort()
    heapArray.insert(0, None)

    buildMaxCountHeap(heapArray)
    
    for i in range(1, len(heapArray) - 1) :
        print(heapArray[i], end = "" "")
    print(heapArray[-1])

def buildMaxCountHeap(heapArray) :
    for i in range(1, len(heapArray) - 1) :
        parent = i // 2
        child = i
        while parent >= 1 :
            heapArray[child], heapArray[parent] = heapArray[parent], heapArray[child]
            child = parent
            parent //= 2
            
        heapArray[1], heapArray[i + 1] = heapArray[i + 1], heapArray[1]


main()
"
5471199,ALDS1_9_D,"def main():
    x = int(input())
    P = list(map(int, input().split()))
    P += [0]
    P.sort()
    
    for i in range(2, x):
        P[1], P[i] = P[i], P[1]
        while i != 1:
            P[i], P[i // 2] = P[i // 2], P[i]
            i //= 2
            
    P[1], P[x] = P[x], P[1]
    print(*P[1:])

if __name__ == '__main__':
    main()
"
7538323,ALDS1_9_D,"def unshift(a, i):
    while 1 < i:
        tmp = a[i]
        a[i] = a[i//2]
        a[i//2] = tmp
        i = i//2

def reverse_heap_sort(a):
    n = len(a)
    a = [None] + a
    hsize = 1
    while hsize < n:
        unshift(a, hsize)
        hsize += 1
        tmp = a[1]
        a[1] = a[hsize]
        a[hsize] = tmp
    return a[1:]

_ = input()
a = [int(x) for x in input().split()]
print(*reverse_heap_sort(sorted(a)))

"
8571114,ALDS1_9_D,"def main():
    N = int(input())
    heap = [0] + list(map(int, input().split()))
    # ヒープソートにより昇順にソート
    heap = heap_sort(heap, N)
    # スワップ回数の総数が最大となる数列を求める
    max_swap_heap = solve_max_swap_heap(heap, N)
    print(*max_swap_heap[1:])


# 要素iについて、max-ヒープ条件を満たさせる
def max_heapify(A, i, heap_size):
    H = heap_size
    l = 2 * i
    r = (2 * i) + 1
    # 親・左の子・右の子の中で、値が最大のものをlargestに保持
    largest = i
    if l <= H and A[l] > A[largest]:
        largest = l
    if r <= H and A[r] > A[largest]:
        largest = r
    # 子の値の方が大きい場合、要素どうしを入れ替え
    if largest != i:
        A[i], A[largest] = A[largest], A[i]
        max_heapify(A, largest, H)
    return A

# ヒープソート
def heap_sort(A, N):
    # 与えられた配列をmax-ヒープに変換
    for i in reversed(range(1, (N//2 + 1))):
        A = max_heapify(A, i, N)
    # ソート
    # 1番目=根=最大値を末尾へ格納することを繰り返してソートする
    heap_size = N
    while heap_size >= 2:
        # *1
        A[1], A[heap_size] = A[heap_size], A[1]
        # 最大値はソート済みになるため、サイズを1ずつ減らす
        heap_size -= 1
        # 未ソート部がmax-ヒープ条件を満たすようにする
        A = max_heapify(A, 1, heap_size)
    return A

# ヒープソートを行う時に呼ぶmax_heapify内でのスワップ回数の総数が最大となる順列を求める
# 対象のスワップ処理が最大となるのは*1において、最小値が毎度heap_size(末尾)の位置にいる場合
# 最小値が未ソート部の最後尾に来るような数列を作成する
def solve_max_swap_heap(A, N):
    # 渡される配列Aはソート済み配列のため、
    # 1番目に最小値、i番目に 対象としているループ範囲の最大値が格納されている
    for i in range(2, N):
        # 最小値と最大値を入れ替え
        A[1], A[i] = A[i], A[1]
        # 最小値を根の位置(1)まで戻す：最小値と最大値を入れ替えることを繰り返したいため
        while i != 1:
            A[i], A[i//2] = A[i//2], A[i]
            i //= 2
    A[1], A[N] = A[N], A[1]
    return A


if __name__ == '__main__':
    main()
"
8734324,ALDS1_9_D,"def maxHeapify(A, n, i):
    """"""
    配列 A の指定されたノード i からヒープを再構築する関数
    :param A: ヒープとして扱う配列
    :param n: 配列の要素数
    :param i: ヒープを再構築するノードのインデックス
    """"""
    largest = i  # 最大の要素を根（i）として初期化
    l = 2 * i + 1  # 左の子ノードのインデックス
    r = 2 * i + 2  # 右の子ノードのインデックス

    # 左の子ノードが存在し、かつその値が現在の最大より大きい場合、更新
    if l < n and A[l] > A[largest]:
        largest = l

    # 右の子ノードが存在し、かつその値が現在の最大より大きい場合、更新
    if r < n and A[r] > A[largest]:
        largest = r

    # 根（i）が最大でない場合、根と最大の子ノードを交換
    if largest != i:
        A[i], A[largest] = A[largest], A[i]  # 交換
        # print("" "".join(map(str, A)))
        maxHeapify(A, n, largest)  # 交換した子ノードで再帰的にヒープを再構築


def heapSort(A, n):
    """"""
    ヒープソートを実行する関数
    先頭が最大だから、先頭を最後に持っていく
    先頭と交換された値（新しい先頭の値）をあるべき場所に移す（下げていく）
    下げることで交換されるものは上がっていく
    左にせばめていく（右端から確定していく）
    """"""
    # マックスヒープの構築
    for i in range(n // 2 - 1, -1, -1):
        maxHeapify(A, n, i)

    # 要素を一つずつ取り出して、ヒープを再構築しながらソート
    for i in range(n-1, 0, -1):
        A[i], A[0] = A[0], A[i]  # 根（最大値）と配列の最後を交換
        # print("" "".join(map(str, A)))
        maxHeapify(A, i, 0)  # ヒープサイズを減らして再構築
        
        
def heapMaxSwapSort(A, n):
    """"""
    ヒープソートでの交換回数を最大にするための並べ替え
    
    昇順にソートされているリストを前提とする
    先頭と末尾の要素を交換する（末尾は少しずつ後にずらしていく）
    末尾に下げられた交換相手をいけるところまで親と交換していく（上げていく）
    上げることで交換されるものは下がっていく
    元が昇順にソートされているリストだから、大きさ比べをせずに親の値と交換
    交換対象を上げていくときに一番長く動くように（交換回数が多くなるように）する
    
    基本的にはヒープソートの逆をする
    交換対象を上げるときに上げられるところまで上げる
    右にひろげていく
    """"""

    for i in range(n - 1):
        j = i
        while j > 0:
            k = (j - 1) // 2  # 親ノードのインデックスを計算
            A[j], A[k] = A[k], A[j]  # 現在のノードと親ノードを交換

            j = k  # 親ノードに移動
            
        # リストの先頭要素と次の要素を交換(末尾を１ずつ後に下げる)
        A[0], A[i + 1] = A[i + 1], A[0]

n = int(input())
A = list(map(int, input().split()))

# ヒープソート
heapSort(A, n)

# ヒープソートでの交換回数を最大にするための並べ替え
heapMaxSwapSort(A, n)

print("" "".join(map(str, A)))

"
8142373,ALDS1_9_D,"from typing import List

def heap_sort(arr: List[int]) -> List[int]:
    n = len(arr)
    arr.sort()
    arr.append(arr[0])
    for i in range(1, n):
        j = i
        p = j // 2
        while arr[p] < arr[j] and p > 0:
            arr[j], arr[p] = arr[p], arr[j]
            j = p
            p = j // 2
    return arr[1:]

if __name__ == '__main__':
    n = int(input())
    T = list(map(int, input().split()))
    result = heap_sort(T)
    print(*result)

"
5403730,ALDS1_9_D,"from sys import stdin

def parent(n):
  return (n-1)//2
def solve(s, n):
  for i in range(n-1):
    j = i
    while j>0:
      p = parent(j)
      s[j], s[p] = s[p], s[j]
      j = p
    s[0], s[i+1] = s[i+1], s[0]

n = int(stdin.readline())
s = list(map(int, stdin.readline().split()))
s.sort()
solve(s, n)
print("" "".join(map(str, s)))
"
7308814,ALDS1_9_D,"n = int(input())

A = list(map(int, input().split("" "")))
A.sort()
A.insert(0, -1)

def unshift(A, i, bound):
	parent = i // 2
	if parent >= bound:
		A[i], A[parent] = A[parent], A[i]
		unshift(A, parent, bound)

for i in range(1, n):
	unshift(A, i, 1)
	A[1], A[i+1] = A[i+1], A[1]
	
print("" "".join(map(str, A[1:])))
"
5485142,ALDS1_9_D,"N = int(input())
A = list(map(int, input().split())) + [-1]

def findPermutation():
    A.sort()

    for i in range(2, N):
        temp = A[1]
        A[1] = A[i]
        A[i] = temp
        
        while i != 1:
            temp = A[i]
            A[i] = A[i//2]
            A[i//2] = temp
            i //= 2
    
    temp = A[1]
    A[1] = A[N]
    A[N] = temp
    
    print(*A[1:])

findPermutation()
"
7391073,ALDS1_9_D,"N=int(input())
A=list(map(int,input().split()))
A.sort()
A.insert(0,-1)

def unshift(A, i, bound):
    parent = i//2
    if parent >= bound:
        A[i],A[parent] = A[parent],A[i]
        unshift(A, parent, bound)

for i in range(1,N):
    unshift(A, i, 1)
    A[1], A[i+1] = A[i+1], A[1]
print(*A[1:])
"
9106170,ALDS1_9_D,"def maxHeapify(A:list[int], i:int, heapSize:int):
    l = i * 2
    r = i * 2 + 1
    if l <= heapSize and A[l -1] > A[i -1]:
        largest = l
    else: 
        largest = i
    if r <= heapSize and A[r -1] > A[largest -1]:
        largest = r
    if largest != i:
        A[i -1], A[largest -1] = A[largest -1], A[i -1]
        maxHeapify(A, largest, heapSize)
        

def heapSort(A:list[int]):
    n = len(A)
    global mode
    mode = False
    # buildMaxHeap
    for i in range(n//2, 0, -1):
        maxHeapify(A, i, n)
    # sort
    mode = True
    heapSize = n
    while heapSize > 1:
        A[1 -1], A[heapSize -1] = A[heapSize -1], A[1 -1] # 右端から順に大きい数字を詰めていく
        heapSize -= 1 # 右側はSort済み
        maxHeapify(A, 1, heapSize) # 左端に持ってきた数字を改めてmaxHeapにする

def crateAns(ans:list[int], k:int):
    i = len(ans)
    p = i // 2
    while p > 0: # parentがいる限り続ける
        ans[p -1], ans[i -1] = ans[i -1], ans[p -1]
        i = p
        p = i//2
    ans.append(k) # 末尾に新しく数字を追加
    ans[0], ans[-1] = ans[-1], ans[0] # 最初（最小値）と末尾を交代
    
    
    
n = int(input())
S = list(map(int, input().split())) # 計算の都合上、Sを1-based index にしたいが、できないので配列の要素にアクセスする際に-1することで対応
heapSort(S)
ans = []
for s in S:
    crateAns(ans, s)
print("" "".join(map(str, ans)))
# cnt が最大になるのは常に右側に最小値がいるようなSortをするとき。
# そのような配列を作るには最小値のところに再帰的に親を入れていけばよい
"
8829840,ALDS1_9_D,"def left(i):
    return 2*i

def right(i):
    return 2*i + 1
    
def max_heapify(A, i):
    global heapsize
    l = left(i)
    r = right(i)
    if l <= heapsize and A[l] > A[i]:
        largest = l
    else:
        largest = i
    if r <= heapsize and A[r] > A[largest]:
        largest = r
        
    if largest != i:
        A[i], A[largest] = A[largest], A[i]
        max_heapify(A, largest)
        
def heap_sort(A):
    global heapsize
    for i in range(len(A)//2, 0, -1):
        max_heapify(A, i)
    while heapsize >= 2:
        A[1], A[heapsize] = A[heapsize], A[1]
        heapsize -= 1
        max_heapify(A, 1)

N = int(input())
heapsize = N
input_line = list(map(int, input().split()))
A = [-1 for _ in range(N+1)]
for i in range(1, N+1):
    A[i] = input_line[i-1]
heap_sort(A)

#max_heapifyの逆順操作をするイメージ？
for i in range(2, N):
    A[1], A[i] = A[i], A[1]
    
    while i != 1:
        A[i], A[i//2] = A[i//2], A[i]
        i //= 2
A[1], A[N] = A[N], A[1]
print(*A[1:])
"
5411609,ALDS1_9_D,"n = int(input())
A = list(map(int, input().split()))
A += [0]
A.sort()
for i in range(2, n):
    A[1], A[i] = A[i], A[1]
    while i != 1:
        A[i], A[i // 2] = A[i // 2], A[i]
        i //= 2
A[1], A[n] = A[n], A[1]
print(*A[1:])
"
5888428,ALDS1_9_D,"n = int(input())
A = list(map(int, input().split()))

A.sort()

for i in range(n - 1):
    x = i
    while x:
        p = (x - 1)//2
        A[x], A[p] = A[p], A[x]
        x = p
    A[0], A[i + 1] = A[i + 1], A[0]

print(*A)
"
6321091,ALDS1_9_D,"n = int(input())
A = list(map(int, input().split()))

A.sort()

for i in range(n - 1):
    x = i
    while x:
        p = (x - 1)//2
        A[x], A[p] = A[p], A[x]
        x = p
    A[0], A[i + 1] = A[i + 1], A[0]

print(*A)
"
7361668,ALDS1_9_D,"n = int(input())
A = list(map(int, input().split()))

A.sort()

for i in range(1, n):
    j = i - 1
    
    while j > 0:
        k = (j - 1) // 2
        A[j], A[k] = A[k], A[j]
        j = k

    A[0], A[i] = A[i], A[0]

print(*A)

"
7093350,ALDS1_9_D,"N = int(input())
ns = list(map(int, input().split()))
ns.sort()
ns.insert(0, -1)
heap_size = 1
while heap_size < N:
    idx = heap_size
    while idx > 1:
        p = idx // 2
        ns[p], ns[idx] = ns[idx], ns[p]
        idx = p
    heap_size += 1
    ns[1], ns[heap_size] = ns[heap_size], ns[1]
print(*ns[1:])

"
5411932,ALDS1_9_D,"n = int(input())
A = list(map(int, input().split()))
A += [0]
#sorting it
A.sort()

for i in range(2, n):
    #swap
    A[1], A[i] = A[i], A[1]
    while i != 1:
        #swap till i!=1
        A[i], A[i // 2] = A[i // 2], A[i]
        i //= 2
#swap 
A[1], A[n] = A[n], A[1]
A.pop(0)
print(*A)

"
6012723,ALDS1_9_D,"from sys import stdin

N = int(stdin.readline().rstrip())
A = list(map(int, stdin.readline().rstrip().split()))

A.sort()

for i in range(1, N):
    j = i - 1
    while j > 0:
        k = (j - 1) // 2
        A[j], A[k] = A[k], A[j]
        j = k
    
    A[0], A[i] = A[i], A[0]

print(*A)

"
8149044,ALDS1_9_D,"# -*- coding: utf-8 -*-
from sys import stdin
input = stdin.readline

n = int(input())
*keys, = map(int, input().split())

keys.sort()
for i in range(n-1):
    j = i
    while j > 0:
        k = (j-1)//2
        keys[k], keys[j] = keys[j], keys[k]
        j = k
    keys[0], keys[i+1] = keys[i+1], keys[0]

print(*keys)
"
5973263,ALDS1_9_D,"from sys import stdin

N = int(stdin.readline().rstrip())
A = list(map(int, stdin.readline().rstrip().split()))

A.sort()

for i in range(1, N):
    j = i - 1
    while j > 0:
        k = (j - 1) // 2
        A[j], A[k] = A[k], A[j]
        j = k
    
    A[0], A[i] = A[i], A[0]

print(*A)
"
7543497,ALDS1_9_D,"n = int(input())
a = list(map(int, input().split())) + [-1]
a.sort()
for i in range(2, n):
    a[1], a[i] = a[i], a[1]
    while i - 1:
        a[i], a[i >> 1] = a[i >> 1], a[i]
        i >>= 1
a[1], a[n] = a[n], a[1]
print(*a[1:])

"
7276869,ALDS1_9_D,"from sys import stdin
input = stdin.readline
n = int(input())
a = list(map(int, input().split())) + [-1]
a.sort()
for i in range(2, n):
    a[1], a[i] = a[i], a[1]
    while i - 1:
        a[i], a[i >> 1] = a[i >> 1], a[i]
        i >>= 1
a[1], a[n] = a[n], a[1]
print(*a[1:])
"
7384577,ALDS1_9_D,"from sys import stdin
input = stdin.readline
n = int(input())
a = list(map(int, input().split())) + [-1]
a.sort()
for i in range(2, n):
    a[1], a[i] = a[i], a[1]
    while i - 1:
        a[i], a[i >> 1] = a[i >> 1], a[i]
        i >>= 1
a[1], a[n] = a[n], a[1]
print(*a[1:])

"
5400180,ALDS1_9_D,"n = int(input())
A = list(map(int, input().split()))

A.sort()
B = [A[0]]*n

for i in range(1, n):
    B[i], B[i-1] = B[i-1], A[i]
    j = i-1
    while j>0:
        k = (j-1)//2
        if B[k] < B[j]:
            B[j], B[k] = B[k], B[j]
        j = k

print(' '.join(map(str, B)))

"
5417749,ALDS1_9_D,"import math
n = int(input())
A = list(map(int,input().split()))
#n = len(A)
#A = [1,2,3,5,9,12,15,23]
A.sort()
for i in range(n-1):
    j = i
    while j > 0:
        nl = math.floor((j - 1) / 2)
        A[j], A[nl] = A[nl], A[j]
        j = nl
    A[0], A[i+1] = A[i+1], A[0]
print(*A)
"
5500177,ALDS1_9_D,"from sys import stdin

def max_heapify(A,i,id_max):
    l = i*2
    r = i*2+1
    if l<=id_max and A[i]<A[l]:
        largest = l
    else:
        largest = i
    if r<=id_max and A[largest]<A[r]:
        largest = r

    if largest != i:
        A[i],A[largest] = A[largest],A[i]
        max_heapify(A,largest,id_max)

def build_max_heap(A,id_max):
    for i in reversed(range(1,id_max//2+1)):
        max_heapify(A,i,id_max)

def heap_sort(A,id_max):
    build_max_heap(A,id_max)

    heap_size = id_max
    while heap_size >= 2:
        A[1],A[heap_size] = A[heap_size],A[1]
        heap_size -= 1
        max_heapify(A,1,heap_size)

def make_max_swap_times(A,id_max):
    heap_sort(A, id_max)

    heap_size = 2
    while heap_size < id_max:
        A[1],A[heap_size] = A[heap_size],A[1]
        id_child = heap_size
        while id_child > 1:
            A[id_child],A[id_child//2]=A[id_child//2],A[id_child]
            id_child = id_child//2
        heap_size += 1
    A[1],A[id_max] = A[id_max],A[1]


n = int(stdin.readline().rstrip())
S = list(map(int, stdin.readline().rstrip().split()))
S = [-1, *S]

make_max_swap_times(S,n)

print("" "".join(str(item) for item in S[1:n+1]))
"
8149613,ALDS1_9_D,"# Heap Sort
# ネットの解答参照



from sys import stdin, maxsize
from typing import List

N = int(stdin.readline())
*A, = map(int, stdin.readline().split())
# 番兵の追加
A = [maxsize] + A

def max_heapify(A, index, heap_size):
    left_child_index = 2*index
    right_child_index = 2*index+1

    if left_child_index <= heap_size and A[left_child_index] > A[index]:
        largest = left_child_index
    else:
        largest = index
    if right_child_index <= heap_size and A[right_child_index] > A[largest]:
        largest = right_child_index

    # 子の方が値が小さい場合、swapする
    if largest != index:
        A[index], A[largest] = A[largest], A[index]
        # 再帰的に呼び出す(子nodeのindexがHより小さくなって終了する)
        max_heapify(A, largest, heap_size)

def heap_sort(A: List[int], N: int):
    heap_size = N

    # heapの構築
    for i in range(N//2, 0, -1):
        max_heapify(A, i, N)

    # sort
    while heap_size >= 2:
        # 1番目に格納されている最も大きい値を最後尾へ格納することを繰り返す
        A[1], A[heap_size] = A[heap_size], A[1]
        heap_size -= 1
        max_heapify(A, 1, heap_size)
                # 整列の状況を出力する
        # print(A)

heap_sort(A, N)

for i in range(2,N):
    A[1], A[i] = A[i], A[1]
    
    while i != 1:
        A[i], A[i//2] = A[i//2], A[i]
        i //= 2

A[1],A[N] = A[N], A[1]

print(*A[1:])

"
8226583,ALDS1_9_D,"from sys import stdin, maxsize
from typing import List

N = int(stdin.readline())
A = list(map(int, stdin.readline().split()))
A = [maxsize] + A

def max_heapify(A, index, heap_size):
    left_child_index = 2 * index
    right_child_index = 2 * index + 1

    if left_child_index <= heap_size and A[left_child_index] > A[index]:
        largest = left_child_index
    else:
        largest = index
    if right_child_index <= heap_size and A[right_child_index] > A[largest]:
        largest = right_child_index

    if largest != index:
        A[index], A[largest] = A[largest], A[index]
        max_heapify(A, largest, heap_size)

def heap_sort(A: List[int], N: int):
    heap_size = N

    for i in range(N // 2, 0, -1):
        max_heapify(A, i, N)

    while heap_size >= 2:
        A[1], A[heap_size] = A[heap_size], A[1]
        heap_size -= 1
        max_heapify(A, 1, heap_size)

heap_sort(A, N)

for i in range(2, N):
    A[1], A[i] = A[i], A[1]
    while i != 1:
        A[i], A[i // 2] = A[i // 2], A[i]
        i //= 2

A[1], A[N] = A[N], A[1]

# Print the sorted array (end result)
print(*A[1:])

"
5754732,ALDS1_9_D,"def maxHeapify(A, i, heap_size):
    left = 2 * i
    right = 2 * i + 1

    if left <= heap_size and A[i] < A[left]:
        largest = left
    else:
        largest = i

    if right <= heap_size and A[largest] < A[right]:
        largest = right

    if largest != i:
        A[i], A[largest] = A[largest], A[i]
        maxHeapify(A, largest, heap_size)

def heapSort(A, n):
    for i in range(n//2, 0, -1):
        maxHeapify(A, i, n)
    heap_size = n
    while heap_size >= 2:
        A[1], A[heap_size] = A[heap_size], A[1]
        heap_size -= 1
        maxHeapify(A, 1, heap_size)

n = int(input())
h_list = list(map(int, input().split()))
h_list = [-1, *h_list]
heapSort(h_list, n)

for i in range(2, n):
    h_list[1], h_list[i] = h_list[i], h_list[1]
    while i != 1:
        h_list[i], h_list[i // 2] = h_list[i // 2], h_list[i]
        i //= 2
h_list[1], h_list[n] = h_list[n], h_list[1]
print(*h_list[1:])
"
6336665,ALDS1_9_D,"from sys import stdin, maxsize
from typing import List

N = int(stdin.readline())
*A, = map(int, stdin.readline().split())
# 番兵の追加
A = [maxsize] + A


def max_heapify(A, index, heap_size):
    left_child_index = 2*index
    right_child_index = 2*index+1

    if left_child_index <= heap_size and A[left_child_index] > A[index]:
        largest = left_child_index
    else:
        largest = index
    if right_child_index <= heap_size and A[right_child_index] > A[largest]:
        largest = right_child_index

    # 子の方が値が小さい場合、swapする
    if largest != index:
        A[index], A[largest] = A[largest], A[index]
        # 再帰的に呼び出す(子nodeのindexがHより小さくなって終了する)
        max_heapify(A, largest, heap_size)


def heap_sort(A: List[int], N: int):
    heap_size = N

    # heapの構築
    for i in range(N//2, 0, -1):
        max_heapify(A, i, N)

    # sort
    while heap_size >= 2:
        # 1番目に格納されている最も大きい値を最後尾へ格納することを繰り返す
        A[1], A[heap_size] = A[heap_size], A[1]
        heap_size -= 1
        max_heapify(A, 1, heap_size)


heap_sort(A, N)

for i in range(2, N):
    A[1], A[i] = A[i], A[1]
    while i != 1:
        A[i], A[i//2] = A[i//2], A[i]
        i //= 2
A[1], A[N] = A[N], A[1]

print(*A[1:])

"
5850687,ALDS1_9_D,"h = int(input())
*A, = map(int, input().split())
A = [-1] + A

def maxHeapify(A, i, h):
    l = 2*i
    r = 2*i + 1
    if l<=h and A[l]>A[i]:
        largest = l
    else:
        largest = i
    if r<=h and A[r]>A[largest]:
        largest = r
    if largest!=i:
        A[i], A[largest] = A[largest], A[i]
        maxHeapify(A, largest, h)

def heapSort(A, h):
    for i in range(h//2, 0, -1):
        maxHeapify(A, i, h)
    heapsize = h
    while heapsize >= 2:
        A[1], A[heapsize] = A[heapsize], A[1]
        heapsize -= 1
        maxHeapify(A, 1, heapsize)
        
heapSort(A, h)
for i in range(2, h):
    A[1], A[i] = A[i], A[1]
    while i != 1:
        A[i], A[i // 2] = A[i // 2], A[i]
        i //= 2
A[1], A[h] = A[h], A[1]

print(*A[1:])
"
8140811,ALDS1_9_D,"from sys import stdin, maxsize
from typing import List

N = int(stdin.readline())
A = list(map(int, stdin.readline().split()))
A = [maxsize] + A

def max_heapify(A, index, heap_size):
    left_child_index = 2 * index
    right_child_index = 2 * index + 1

    if left_child_index <= heap_size and A[left_child_index] > A[index]:
        largest = left_child_index
    else:
        largest = index
    if right_child_index <= heap_size and A[right_child_index] > A[largest]:
        largest = right_child_index

    if largest != index:
        A[index], A[largest] = A[largest], A[index]
        max_heapify(A, largest, heap_size)

def heap_sort(A: List[int], N: int):
    heap_size = N

    for i in range(N // 2, 0, -1):
        max_heapify(A, i, N)

    while heap_size >= 2:
        A[1], A[heap_size] = A[heap_size], A[1]
        heap_size -= 1
        max_heapify(A, 1, heap_size)

heap_sort(A, N)

for i in range(2, N):
    A[1], A[i] = A[i], A[1]
    while i != 1:
        A[i], A[i // 2] = A[i // 2], A[i]
        i //= 2

A[1], A[N] = A[N], A[1]

# Print the sorted array (end result)
print(*A[1:])
"
8254018,ALDS1_10_A,"la = [1, 1]

n = int(input())
while len(la) <= n:
    la.append(la[-1] + la[-2])

print(la[n])

"
8257466,ALDS1_10_A,"def fibo(n):
    DP = [1]*(n+1) 
    for i in range(2,n+1):
        DP[i] = DP[i-1] + DP[i-2]
    return DP[n]

print(fibo(int(input())))

        
        
"
8262953,ALDS1_10_A,"n = int(input())
a = 0
b = 1
for i in range(n):
    a,b = b,(a+b)
    
print(b)
"
8283922,ALDS1_10_A,"from functools import lru_cache

@lru_cache(maxsize=1000)
def fib(n):
    if n == 0:
        return 1
    if n == 1:
        return 1
    else:
        return fib(n-1) + fib(n-2)
n = int(input())
print(fib(n))
"
8308621,ALDS1_10_A,"#あえてメモ化再帰
import sys
sys.setrecursionlimit(10**8)
n = int(input())
memo = [0 for _ in range(n+1)]
def fib(i):
  if i == 0:
    memo[i] = 1
    return 1
  if i == 1:
    memo[i] = 1
    return 1
  if memo[i] != 0:
    return memo[i]
  memo[i] = fib(i-1)+fib(i-2)
  return memo[i]

print(fib(n))
  
"
8341923,ALDS1_10_A,"import sys

N = int(sys.stdin.readline().rstrip())
INF = -1
dp = [INF] * 100


def f(N):
    if dp[N] != INF:
        return dp[N]

    if N == 0:
        return 1

    if N == 1:
        return 1

    dp[N] = f(N - 1) + f(N - 2)
    return dp[N]


print(f(N))

"
8347518,ALDS1_10_A,"N = int(input())

def fib(n):
  if n == 0 or n == 1:
    return 1
  DP = [0] * (n + 1)
  # 境界条件
  DP[0] = DP[1] = 1
  for i in range(2, n + 1):
    DP[i] = DP[i - 1] + DP[i - 2]
  return DP[n]

print(fib(N))
"
8358953,ALDS1_10_A,"n = int(input())
dp = [0]*(n+1)

for i in range(n+1):
    if i == 0 or i == 1:
        dp[i] = 1
    else:
        dp[i] = dp[i-1]+dp[i-2]

print(dp[-1])
"
8383502,ALDS1_10_A,"n = int(input())

dp = [1] * (n + 1)

for i in range(2, len(dp)):
    dp[i] = dp[i - 1] + dp[i - 2]

print(dp[n])

"
8397220,ALDS1_10_A,"n=int(input())

dp=[None]*(n+1)
dp[0]=1
dp[1]=1
for i in range(2,n+1):
  dp[i]=dp[i-1]+dp[i-2]

print(dp[n])
"
8405039,ALDS1_10_A,"# フィボナッチ数


def main():

    n = int(input())
    dp = [0]*(n+3)
    dp[0] = 1
    dp[1] = 1
    for i in range(2,n+3):
        dp[i] = dp[i-1] + dp[i-2]
    
    print(dp[n])


if __name__ == '__main__':
    main()
"
8417156,ALDS1_10_A,"# coding: utf-8

from functools import partial
try:
    dummy = src
    rl = partial(src.pop, 0)
except NameError:
    rl = input
def ints():
    return list(map(int, rl().strip().split()))
def int1():
    return int(rl().strip())

from functools import lru_cache

@lru_cache
def fib(n):
    f = [0] * (n+1)
    for i in range(n+1):
        if i == 0 or i == 1:
            f[i] = 1
        else:
            f[i] = f[i-2] + f[i-1]
    return f[n]

#@psecs
def main():
    n = int1()
    print(fib(n))
    
if __name__ == '__main__':
    main()
"
8419005,ALDS1_10_A,"n = int(input())
n_list = []

n_list.append(1)
n_list.append(1)

if n >= 2:
    for i in range(2,n+1):
        n_list.append(n_list[i-1] + n_list[i-2])
    print(n_list[n])
else:
    print(n_list[n])
"
8429347,ALDS1_10_A,"n = int(input())
DP = [None] * 1000

DP[0] = 1
DP[1] = 1
for i in range(2,100):
    DP[i] = DP[i-1] + DP[i-2]
print(DP[n])
"
8439323,ALDS1_10_A,"n = int(input())

if n==0 or n==1:
    print(1)
    exit()
    
prepre = 1
pre = 1
for _ in range(n-1):
    now = prepre + pre
    prepre = pre
    pre = now
    
print(pre)
"
8440749,ALDS1_10_A,"dp = [1,1]
n = int(input())
for i in range(2,n+1):
    dp.append(dp[i-1] + dp[i-2])
print(dp[-1])
"
8465168,ALDS1_10_A,"n = int(input())

dp = [-1]*(n+1)

dp[0] = 1
dp[1] = 1

for i in range(2, n+1):
    dp[i] = dp[i-1] + dp[i-2]
    
print(dp[n])
"
8465793,ALDS1_10_A,"def fibonacci(n):
    if n == 0 or n == 1:
        return 1  # 初項と2項目を1に修正
    fib = [1, 1] + [0] * (n - 1)  # 最初の2項を1に設定
    for i in range(2, n + 1):
        fib[i] = fib[i - 1] + fib[i - 2]
    return fib[n]

n = int(input().strip())
print(fibonacci(n))
"
8469287,ALDS1_10_A,"n = int(input())

if n==0 or n==1:
    print(1)
else:
    DP = [0]*(n+1)
    DP[0] = 1
    DP[1] = 1
    for i in range(2, n+1):
        DP[i] = DP[i-1] + DP[i-2]
    
    print(DP[n])
"
8485122,ALDS1_10_A,"n=int(input())

dp=[0]*(45)

dp[0]=1
dp[1]=1

for i in range(43):
    dp[i+2]=dp[i+1]+dp[i]
    
print(dp[n])
"
8497967,ALDS1_10_A,"a = [1, 0]
for i in range(int(input())): a[i & 1] = sum(a)
print(sum(a))
"
8499763,ALDS1_10_A,"n = int(input())
fib = [1]*(n+1)
for i in range(2,n+1):
	fib[i]=fib[i-1]+fib[i-2]
print(fib[n])
"
8530586,ALDS1_10_A,"from functools import lru_cache

@lru_cache(maxsize=None)
def fib(n):
  if n < 2:
    return 1
  return fib(n-1) + fib(n-2)

print(fib(int(input())))

"
8541136,ALDS1_10_A,"n = int(input())
dp = [0] * 45
dp[0] = 1
dp[1] = 1
for i in range(2,45):
    dp[i] = dp[i-1] + dp[i-2]
print(dp[n])
"
8572421,ALDS1_10_A,"def fibonacci(n):
    if n <= 1:
        return 1

    prev1, prev2 = 1, 1
    for _ in range(2, n + 1):
        current = prev1 + prev2
        prev2, prev1 = prev1, current

    return current


# フィボナッチ数列の10番目の項を計算する例
n = int(input())
ans = fibonacci(n)
print(ans)
"
8575976,ALDS1_10_A,"# 同じ計算を複数回しないように計算結果のテーブル用意
fibonacci_table = [-1] * 45

def main():
    n = int(input())
    print(solve_fibonacci(n))

def solve_fibonacci(n):
    # 終端条件
    if n == 0:
        fibonacci_table[0] = 1
        return 1
    if n == 1:
        fibonacci_table[1] = 1
        return 1
    # 再帰
    if fibonacci_table[n] == -1:
        fibonacci_table[n] = solve_fibonacci(n-1) + solve_fibonacci(n-2)
    return fibonacci_table[n]


if __name__ == '__main__':
    main()
"
8576806,ALDS1_10_A,"n = int(input())

dp = [0 for _ in range(50)]

dp[0] = 1
dp[1] = 1
for i in range(2, n + 1):
    dp[i] = dp[i - 2] + dp[i - 1]

print(dp[n])

"
8598936,ALDS1_10_A,"def fibonacci(n):
  dp = [1] * (n + 1)
  for i in range(2, n + 1):
    dp[i] = dp[i - 2] + dp[i - 1]
  return dp[n]

print(fibonacci(int(input())))
"
8603944,ALDS1_10_A,"a = int(input())
n1 = 1
n2 = 1
for i in range(a):
    rem = n1+ n2
    n1 = n2
    n2 = rem
print(n1)
"
8658083,ALDS1_10_A,"# ユーザーから整数nを入力してもらう
n = int(input())

# フィボナッチ数列を格納するためのリストを初期化
# 最初の2つの数は1
F = [0] * (n + 1)
F[0], F[1] = 1, 1

# n番目までのフィボナッチ数を計算
for i in range(2, n + 1):
    F[i] = F[i - 1] + F[i - 2]

# n番目のフィボナッチ数を出力
print(F[n])

"
8663261,ALDS1_10_A,"import sys
input = sys.stdin.readline

n = int(input())
F = [1]*50
for i in range(2, n+1):
    F[i] = F[i-1] + F[i-2]

print(F[n])
"
8723182,ALDS1_10_A,"N = int(input())
fib = [1, 1]
for _ in range(2, N+1):
    fib.append(fib[-1]+fib[-2])
print(fib[N])

"
8745251,ALDS1_10_A,"n=int(input())
fib=[0 for _ in range(n+1)]
for i in range(n+1):
    if i==0 or i==1:
        fib[i]=1
    else:
        fib[i]=fib[i-1]+fib[i-2]
print(fib[n])
"
8749668,ALDS1_10_A,"n = int(input())

memo = [-1 for _ in [0]*(n+1)]
def fib(n):
  if n==0:
    return 1
  if n==1:
    return 1
  if memo[n] != -1:
    return memo[n]
  memo[n] = fib(n-1) + fib(n-2)
  return memo[n]

print(fib(n))
"
8782709,ALDS1_10_A,"n = int(input())
if n <= 1:
    print(1)
else:
    dp = [0]*(n+1)
    dp[0] = 1
    dp[1] = 1
    for i in range(2,n+1):
        dp[i] = dp[i-1]+dp[i-2]
    print(dp[n])
"
8803988,ALDS1_10_A,"n = int(input())
F = []
F.append(int(1))
F.append(int(1))
for i in range(2,n+1):
    F.append(F[i-1]+F[i-2])
print(F[n])
"
8818712,ALDS1_10_A,"class SquareMatrix:

    def __init__(self, n, arr=None, T=int):
        self.n = n
        self.T = T
        self.arr = [[self.T(0)] * self.n for _ in range(self.n)]
        if arr is not None:
            for i in range(self.n):
                for j in range(self.n):
                    if isinstance(arr[i][i], T):
                        self.arr[i][j] = arr[i][j]
                    else:
                        self.arr[i][j] = T(arr[i][j])

    def add_identity(self):
        self.arr = [[self.T(0)] * self.n for _ in range(self.n)]

    def mul_identity(self):
        self.add_identity()
        for i in range(self.n):
            self.arr[i][i] = self.T(1)

    def __len__(self):
        return self.n

    def __getitem__(self, index):
        return self.arr[index]

    def __add__(self, other):
        buf = [self.arr[i][::] for i in range(self.n)]
        for i in range(self.n):
            for j in range(self.n):
               buf[i][j] += other[i][j]
        return self.__class__(self.n, buf, T = self.T)

    def __sub__(self, other):
        buf = [self.arr[i][::] for i in range(self.n)]
        for i in range(self.n):
            for j in range(self.n):
                buf[i][j] -= other[i][j]
        return self.__class__(self.n, buf, T = self.T)

    def __mul__(self, other):
        buf = self.__class__(self.n, T = self.T)
        for i in range(self.n):
            for j in range(self.n):
                for k in range(self.n):
                     buf[i][j] += (self.arr[i][k] * other[k][j])
        return buf

    __radd__ = __add__
    __rsub__ = __sub__
    __rmul__ = __mul__

    def _pow(self, power):
        buf = self.__class__(self.n, T = self.T)
        buf.mul_identity()
        if power == 0: return buf
        if power == 1: return self
        t = self._pow(power//2)
        return t * t * self if power%2 else t * t

    def show(self):
        for i in range(self.n):
            print(self.arr[i])

    def __pow__(self, power):
        return self._pow(power)

a1 = SquareMatrix(2, [
    [1, 1],
    [0, 0]
])

fib_mat = SquareMatrix(2, [
    [0, 1],
    [1, 1]
])

n = int(input())
ans = a1 * fib_mat**n
print(ans[0][0])


"
8818965,ALDS1_10_A,"def Fibonacci_dynamic(n):
    cal_result = {}
    
    cal_result[0] = 1
    cal_result[1] = 1
    
    if n == 0 or n == 1:
        return 1
    
    for i in range(2, n+1):
        cal_result[i] = cal_result[i-1] + cal_result[i-2]
        
    return cal_result[n]

n = int(input())
print(Fibonacci_dynamic(n))
"
8820965,ALDS1_10_A,"from functools import lru_cache

@lru_cache
def fib(n:int):
    if n < 2:
        return 1
    else:
        return fib(n-1) + fib(n-2)
    
n = int(input())
print(fib(n))
"
8827463,ALDS1_10_A,"n = int(input())
dp = [0] * 45
dp[0] = 1
dp[1] = 1
for i in range(2,n+1):
    dp[i] = dp[i-1] + dp[i-2]

print(dp[n])
"
8829847,ALDS1_10_A,"fib = [1] * 45
n = int(input())
for i in range(2, n+1):
    fib[i] = fib[i-1] + fib[i-2]
print(fib[n])
"
8832393,ALDS1_10_A,"# aizu_ALDS1_10_A_FibonacciNumber.py  

from functools import lru_cache

@lru_cache(maxsize=None)
def fib(n):
    if n == 0:return 1
    if n== 1:return 1
    return fib(n-1) + fib(n-2)

n = int(input())
print( fib(n))
"
8832432,ALDS1_10_A,"fb=[1,1]

for n in range(2,45):
    fb.append(fb[n-1]+fb[n-2])

print(fb[int(input())])

"
8843309,ALDS1_10_A,"fib=[1,1]
n=int(input())
for i in range(n-1):
    fib+=[fib[-1]+fib[-2]]
print(fib[-1])
"
8885672,ALDS1_10_A,"N = int(input())

dp = [0] * (50)
dp[0] = 1
dp[1] = 1

for i in range(2, 50):
    dp[i] = dp[i-1] + dp[i-2]

print(dp[N])
"
8891895,ALDS1_10_A,"def main() -> None:
    import sys

    input = sys.stdin.readline

    n = int(input())
    memo = [1, 1]
    for _ in range(n):
        memo[0], memo[1] = memo[1], memo[0] + memo[1]

    print(memo[0])


if __name__ == ""__main__"":
    main()

"
8896159,ALDS1_10_A,"def fibo(n):
    arr = [1, 1]
    for i in range(1, n):
        arr.append(arr[i-1]+arr[i])
    print(arr[n])


n = int(input())
fibo(n)

"
8898441,ALDS1_10_A,"x=[0]*45
x[0]=1
x[1]=1
n=int(input())
for i in range(2,n+1):
    x[i]=x[i-1]+x[i-2]
print(x[n])
"
8908720,ALDS1_10_A,"N = int(input())
dp =[]
for n in range(N+1):
  if n ==0:
    dp.append(1)
  elif n ==1:
    dp.append(1)
  else:
    dp.append(dp[n-1]+dp[n-2])
print(dp[-1])

"
8923484,ALDS1_10_A,"N = int(input())
dp = [0] * (N + 1)
dp[0] = 1
dp[1] = 1

for i in range(2, N + 1):
    dp[i] = dp[i - 1] + dp[i - 2]

print(dp[-1])

"
8925295,ALDS1_10_A,"#34
def fib(n):
    a, b = 0, 1
    for _ in range(n):
        a, b = b, a+b
    return b

n = int(input())
print(fib(n))
"
8933038,ALDS1_10_A,"from functools import cache
@cache
def f(n):
    return 1 if (n==1 or n==0)  else f(n-1)+f(n-2)
print(f(int(input())))
"
8945366,ALDS1_10_A,"N = int(input())

def fibonacci(N):
  
    fib = [0] * (N+1)##値0,長さN+1のリスト作成
    fib[0] = 1
    fib[1] = 1
    
    for i in range(2,N+1):
        fib[i] = fib[i-1]+fib[i-2]
    
    return fib[N]
    
result = fibonacci(N)
print(result)
"
8948814,ALDS1_10_A,"if __name__ == ""__main__"":
    N = int(input())

    fibs = [1, 1]
    while len(fibs) - 1 < N:
        fibs.append(fibs[-1] + fibs[-2])
    print(fibs[N])

"
8959367,ALDS1_10_A,"N=int(input())
l=[-1]*(N+2)
l[0]=1
l[1]=1
for i in range(2,N+2):
    l[i]=l[i-1]+l[i-2]

print(l[N])
"
8997315,ALDS1_10_A,"# import sys
# input = sys.stdin.readline
# N = float(input().rstrip('\n'))
import sys
input = sys.stdin.readline
N = int(input().rstrip('\n'))
a = [1,1]
for i in range(2,N+1):
    t = a[i-1]+a[i-2]
    a.append(t)

print(a[N])
"
9029457,ALDS1_10_A,"dp = [0] * 500
dp[0] = 1
dp[1] = 1

def fibonacci(n):
    if dp[n]:
        return dp[n]
    dp[n] = fibonacci(n - 1) + fibonacci(n - 2)
    return dp[n]

if __name__ == '__main__':
    n = int(input())
    print(fibonacci(n))

"
9036028,ALDS1_10_A,"
memo={}
def fib(n):
    # nが0または1の場合、1を返す
    if n <= 1:
        return 1
    # nの値がメモに既にある場合、その値を返す
    if n in memo:
        return memo[n]
    
    # fib(n-1) + fib(n-2)を計算し、結果をメモに保存する
    memo[n] = fib(n-1) + fib(n-2)
    # 計算結果を返す
    return memo[n]

# ユーザー入力を受け取る
N = int(input())

# 第N項のフィボナッチ数を出力
print(fib(N))

"
9047576,ALDS1_10_A,"n = int(input())
dp = [0]*(n+3)
dp[0] = 1
dp[1] = 1
for i in range(2,n+3):
    dp[i] = dp[i-1] + dp[i-2]
    
print(dp[n])
"
9059946,ALDS1_10_A,"def fibonacci(n):
    v1 = v2 = 1
    for i in range(2, n + 1):
        v1, v2 = v2, v1+v2
    return v2


n = int(input())
print(fibonacci(n))

"
9061033,ALDS1_10_A,"table=[0]*45
table[0]=1
table[1]=1
for i in range(2, 45):
    table[i]=table[i-1]+table[i-2]
n=int(input())
print(table[n])
"
9105293,ALDS1_10_A,"import sys

def check():
    input=lambda:sys.stdin.readline().rstrip()
    fib=[1,1]
    for i in range(44):
        fib.append(fib[-1]+fib[-2])
    print(fib[int(input())])
check()
"
9109159,ALDS1_10_A,"def fib(n:int) -> int:
    current = 1
    next = 1
    for _ in range(n):
        temp = current + next
        current = next
        next = temp
    return current    
print(fib(int(input())))
"
9114251,ALDS1_10_A,"dp=[0]*50
dp[0]=1
dp[1]=1

n=int(input())
for i in range(n):
  dp[i+2]=dp[i+1]+dp[i]
print(dp[n])

"
9117535,ALDS1_10_A,"fib = [0] * 45
fib[0] = fib[1] = 1
for i in range(2, 45):
    fib[i] = fib[i - 1] + fib[i - 2]

n = int(input())
print(fib[n])

"
3230413,ALDS1_10_B,"INF = 10**20
n = int(input())
nlist = []
all_mat = []
for i in range(n):
    a,b = map(int, input().split())
    all_mat.append((a,b))
    if (i == 0):
        nlist = [a,b]
    else:
        nlist.append(b)
        
def cost1(nlist):
    if len(nlist) == 0:
        return 0
    m = min(nlist)
    cost = 0
    mid = nlist.index(m)
    a = nlist[:mid]
    b = nlist[mid+1:]
    while (len(a)>1 and len(a) !=0):
        for i in range(len(a)-1):
            cost += a.pop()*a[-1]
            #print(a)
    while (len(b)>1 and len(b) !=0):
        b.reverse()
        for i in range(len(b)-1):
            cost += b.pop()*b[-1]
            #print(b)
    if (len(a) == 1 and len(b) == 1):
        cost += a.pop()*b.pop()
        #print(a,b)
    cost *= m
    return cost
#[34, 44, 13, 30]
def cost2(nlist, mm):
    if len(nlist) == 0:
        return 0
    m = min(nlist)
    cost = 0
    mid = nlist.index(m)
    a = nlist[:mid+1]
    #print(a)
    b = nlist[mid:]
    #print(b)
    while (len(a)>1 and len(a) !=0):
        a.reverse()
        for i in range(len(a)-1):
            cost += a.pop()*a[-1]
            #print(a)
    while (len(b)>1 and len(b) !=0):
        for i in range(len(b)-1):
            cost += b.pop()*b[-1]
            #print(b)
    if (len(a) == 1 and len(b) == 1):
        cost += m*mm
        #print(a,b)
    cost *= mm
    return cost

copy = nlist[:]
m = min(nlist)
#print(nlist)
c = nlist.count(m)
cost = 0
if (c == 1):
    cost = cost1(nlist)
elif (c >= 2):
    cc = 1
    cut_index = [0]
    mcount = nlist.count(m)
    for i in range(mcount):
        cut_index.append(nlist.index(m))
        nlist.remove(m)
    cut = []
    for i in range(mcount):
        cut.append(nlist[cut_index[i]:cut_index[i+1]])
    cut.append(nlist[cut_index[-1]:])
    #print(cut)
    co1 = cut[0] +[m]+ cut[-1]
    cost += cost1(co1)
    for co2 in cut[1:-1]:
        #print(co2)
        cost += cost2(co2,m)
    co3 = cut[0]+cut[-1]
    if (len(co3)>1):
        cost += (len(cut)-2)*m*min(co3)
print(cost)

"
9131220,ALDS1_10_B,"n = int(input())
s_list = list(map(int, input().split()))
for _ in range(1, n):
    r, c = map(int, input().split())
    s_list.append(c)
dp = [[0] * (n + 1) for _ in range(n)]

for start in range(n - 1, -1, -1):
    dpi = dp[start]
    for end in range(start + 2, n + 1):
        parameter = s_list[start] * s_list[end]
        dpi[end] = min(dpi[pos] + dp[pos][end] + parameter * s_list[pos] for pos in range(start + 1, end))
print(dp[0][-1])

"
8500295,ALDS1_10_B,"n = int(input()) - 1
a = [int(i) for _ in range(n + 1) for i in input().split()]
del a[2::2]
t = [[0] * (n + 1)] * 2 + [[] for _ in range(n)]

if n: t[2] = [a[i] * a[i + 1] * a[i + 2] for i in range(n)]

for r in range(3, n + 2):
    for i in range(n - r + 2):
        w = a[i] * a[i + r]
        t[r].append(min([t[m - i][i] + t[i + r - m][m] + w * a[m] for m in range(i + 1, i + r)]))

print(t[-1][0])
"
8609449,ALDS1_10_B,"n = int(input())
p = []

for i in range(n-1):
  p.append(int(input().split(' ')[0]))

p0 = input().split(' ')
p0 = list(map(int, p0))
# print(p0)
for a in range(2):
  p.append(p0[a])


m = [[0]*(n + 1) for i in range(n + 1)]

for l in range(2, n + 1):
  for i in range(n - l + 1):
    j = i + l
    m[i][j] = min(m[i][k] + m[k][j] + p[i]*p[k]*p[j] for k in range(i + 1, j))

print(m[0][n])
"
8829952,ALDS1_10_B,"#参考 : https://note.com/omotiti/n/n135fc83432a5
N = int(input())
R, C = [0]*N, [0]*N
for i in range(N):
    R[i], C[i] = map(int, input().split())
    
dp = [[0]*N for _ in range(N)]
for diff in range(1, N):
    for l in range(N-diff):
        r = l + diff
        dp[l][r] = min(dp[l][m] + dp[m+1][r] + R[l]*C[m]*C[r] for m in range(l, r))
        
print(dp[0][N-1])
"
8838972,ALDS1_10_B,"def matrix_chain_order(p):
    n = len(p) - 1
    m = [[0 for _ in range(n)] for _ in range(n)]
    s = [[0 for _ in range(n)] for _ in range(n)]

    for l in range(2, n + 1):
        for i in range(n - l + 1):
            j = i + l - 1
            m[i][j] = float('inf')
            for k in range(i, j):
                q = m[i][k] + m[k + 1][j] + p[i] * p[k + 1] * p[j + 1]
                if q < m[i][j]:
                    m[i][j] = q
                    s[i][j] = k
    return m, s

n = int(input())
M = []
for i in range(n):
    r, c = map(int, input().split())
    M.append(r)
    if i == n - 1:
        M.append(c)
m, s = matrix_chain_order(M)
print(m[0][n - 1])

"
8877963,ALDS1_10_B,"n = int(input())

row = [None]*n
col = [None]*n

for i in range(n):
  row[i], col[i] = map(int, input().split())
  
dp = [[10**18]*n for _ in range(n)]
for i in range(n):
  dp[i][i] = 0

for R in range(1,n):#右端
  for L in range(n-R):#左端
    r = row[L]
    c = col[L+R]
    dp[L][L+R] = min(r*col[i]*c + dp[L][i] + dp[i+1][L + R] for i in range(L, L+R))
print(dp[0][n-1])
      
"
9011136,ALDS1_10_B,"import sys
input = sys.stdin.readline

def main():
    N = int(input())
    
    M = [list(map(int, input().split())) for _ in range(N)]
    dp = [[0] * N for _ in range(N)]
    
    for i in range(1, N):
        for start_i in range(N - i):
            end_i = start_i + i
            dp[start_i][end_i] = min([dp[start_i][k] + dp[k+1][end_i] + M[start_i][0]*M[k][1]*M[end_i][1] for k in range(start_i, end_i)])
        # for a in dp:
        #     print(a)
    print(dp[0][-1])
    
    

if __name__ == ""__main__"":
    main()

"
8533250,ALDS1_10_B,"from functools import lru_cache

n = int(input())
p = [int(input().split()[0]) for _ in range(n-1)] + [*map(int, input().split())]

@lru_cache(maxsize=None)
def n_mul(i, j):
  if j - i == 1:
    return 0
  return min(n_mul(i,k) + n_mul(k,j) + p[i]*p[k]*p[j] for k in range(i+1,j))

print(n_mul(0, n))

"
8596073,ALDS1_10_B,"def main():
    n = int(input())
    M = [list(map(int, input().split())) for _ in range(n)]
    # スカラー乗算回数 = 左の行数 × 左の列数(=右の行数) × 右の列数
    # 必要なのは最初の行列の行数と各行列の列数のみ
    matrices = [M[0][0]] + [m[1] for m in M]

    # dp[si][ei]: 開始インデックスsiから終了インデックスeiまでのスカラー乗算回数の最小値
    # 最小値は十分大きな数で初期化
    # si=eiの場合、乗算は発生しないため、0にする
    dp = [[10**9]*(n + 1) for _ in range(n + 1)]
    for i in range(n+1):
        dp[i][i] = 0

    # 行列の計算範囲を2,3,...,nと段々大きくして最終的に全体の最小回数を求める
    # 行列2つ以上で乗算が発生するため、計算範囲は2～
    for sll in range(2, n + 1):
        # 計算開始位置、終了位置をずらして全パターンのスカラー乗算回数を計算
        # 計算範囲の開始位置: si, 終了位置: ei
        for si in range(1, (n + 1) - sll + 1):
            ei = si + sll - 1
            dp[si][ei] = calc_min_multi(si, ei, dp, matrices)
    print(dp[1][n])

# 指定範囲でのスカラー乗算回数の最小値を計算
def calc_min_multi(si, ei, dp, matrices):
    # 位置spiで行列を2つに区切り、2つそれぞれの計算量 + 2つの乗算の計算量 を求める
    for spi in range(si, ei):
        # 開始位置～区切り位置の計算量(X) + 区切り位置～終了位置の計算量(Z) + (Y=XZのスカラー乗算)
        # Yのスカラー乗算 = 左の行数(=si-1の列数) × 左の列数(=spi) × 右の列数(=ei)
        tmp_res = dp[si][spi] + dp[spi + 1][ei] + matrices[si - 1] * matrices[spi] * matrices[ei]
        dp[si][ei] = min(dp[si][ei], tmp_res)
    return dp[si][ei]


if __name__ == '__main__':
    main()
"
8821566,ALDS1_10_B,"from math import inf

def matrixChainOrder(p:list, m:list):
    n = len(p)-1
    for i in range(1,n+1):
        m[i][i] = 0
    for l in range(2, n+1): # length = the number of matrix
        for i in range(1, n-l+2):
            j = i+l-1
            m[i][j] = inf
            for k in range(i,j):
                q = m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j]
                m[i][j] = min(m[i][j], q)

p = []
matList = []

n = int(input())
for i in range(n):
    rc = input()
    a = list(map(int, rc.split()))
    matList.append(a)

for i, j in matList:
    if len(p) == 0:
        p.append(i)
        p.append(j)
    else:
        p.append(j)

m = [[0 for i in range(len(p))] for j in range(len(p))]
# from icecream import ic
# print(p)
# ic(m)

matrixChainOrder(p,m)

print(m[1][-1])
"
8999084,ALDS1_10_B,"import sys
input = lambda: sys.stdin.readline().rstrip()
ii = lambda: int(input())
mi = lambda: map(int, input().split())
li = lambda: list(mi())
inf = 2 ** 63 - 1
mod = 998244353
hash_mod = 2147483647
dpos4 = ((1, 0), (0, 1), (-1, 0), (0, -1))
dpos8 = ((0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1), (-1, 0), (-1, -1))
def main():
    N = ii()
    mtx = []
    for _ in range(N):
        r,c = mi()
        mtx.append(r)
    mtx.append(c)
    dp = [[inf] * (N) for _ in range(N)]
    
    for i in range(N):
        dp[i][i] = 0

    # 最初を幅にしないと累積みたいになってしまう。幅が一つずつつまりl,rの行列を一つずつかけて行った時
    for w in range(1,N):
        for i in range(N-w):
            j = i + w
            for k in range(i,j):
                dp[i][j] = min(dp[i][j],dp[i][k]+dp[k+1][j]+mtx[i]*mtx[k+1]*mtx[j+1])

    print(dp[0][-1])
if __name__ == '__main__':
    main()
"
9108746,ALDS1_10_B,"import sys

def check():
    input=lambda:sys.stdin.readline().rstrip()
    n=int(input())
    INF=10**10
    matrix=tuple(tuple(map(int,input().split())) for _ in range(n))
    dp=[[INF]*n for _ in range(n)]
    for i in range(n):
        dp[i][i]=0
    for extent in range(1,n):
        for start in range(n-extent):
            end=start+extent
            for sep in range(start,end):
                nx=dp[start][sep]+dp[sep+1][end]+matrix[start][0]*matrix[sep][1]*matrix[end][1]
                dp[start][end]=dp[start][end] if dp[start][end]<nx else nx
    print(dp[0][-1])
check()

"
9148547,ALDS1_10_B,"def print_array(array):
    for i in range(len(array)):
        print(*[str(x).rjust(7) for x in array[i]])
    print()

#メモ化再帰
from functools import lru_cache
@lru_cache(maxsize=None)
def solve(i, j):
    if i == j:
        return 0
    res = float('inf')
    for k in range(i, j):
        res = min(res, solve(i, k) + solve(k+1, j) + R[i]*C[k]*C[j])
    #print(i, j, res)
    return res


N = int(input())
R = [0]*N
C = [0]*N
for i in range(N):
    R[i], C[i] = map(int, input().split())

ans = solve(0, N-1)
print(ans)

"
8479038,ALDS1_10_B,"n = int(input())

rc = [list(map(int, input().split())) for _ in range(n)]

def calc(first,second,third):
    return dp[first][second] + dp[second][third] + rc[first][0]*rc[second][1]*rc[third][1]

dp = [[float(""inf"")]*n for _ in range(n)]
for i in range(n):
    dp[i][i] = 0


for W in range(n):
    for L in range(n-W):
        R = L+W
        for i in range(L,R):
            dp[L][R] = min(dp[L][R], dp[L][i]+dp[i+1][R]+rc[L][0]*rc[i][1]*rc[R][1])
print(dp[0][n-1])
"
8660788,ALDS1_10_B,"


def MI():return map(int,input().split())
def LM():return list(MI())
def LL(n):return [LM() for _ in range(n)]
def LS(n):return [list(input()) for _ in range(n)]

def MI_1():return map(lambda x:int(x)-1,input().split())
def LM_1():return list(MI_1())
def LL_1(n):return [LM_1() for _ in range(n)]




N=int(input())
Ms=LL(N)

dp = [[float(""inf"")]*N for _ in range(N)]
for i in range(N):
	dp[i][i] = 0

for width in range(2,N+1):
	for i in range(N-width+1):
		j = i+width-1
		for k in range(i,j):
			candidate = dp[i][k] + dp[k+1][j] + Ms[i][0]*Ms[k][1]*Ms[j][1]
			dp[i][j] = min(dp[i][j],candidate)

print(dp[0][-1]) 
"
8730525,ALDS1_10_B,"N = int(input())
size = [tuple(map(int, input().split())) for _ in range(N)]

# dp[i][j] = i個目からj個目までの積でのmin
dp = [[float('inf')]*N for _ in range(N)]
for i in range(N):
    dp[i][i] = 0

for d in range(1, N):
    for i in range(N-d):
        j = i+d
        for k in range(i, j):
            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + size[i][0]*size[k][1]*size[j][1])

print(dp[0][N-1])

"
8806207,ALDS1_10_B,"n = int(input())
p = []
m = [[None for i in range(100)] for j in range(100)]

for i in range(n):
    input_data = list(map(int,input().split()))
    if i ==0:
        p.append(input_data[0])
    p.append(input_data[1])
#print(p)

length = len(p)-1

for i in range(1,n+1):
    m[i][i] = 0
#for i in range(n+1):
 #print(m[i])
j = i
for l in range(2,n+1):
    for i in range(1,n-l+2):
        j = i+l-1
        m[i][j] = 100000000000
        for k in range(i,j):
            q = m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j]
            m[i][j] = min(m[i][j],q)
print(m[i][j])
"
8807296,ALDS1_10_B,"N = 100
p = [0]*(N+1)
m = [[0]*(N+1) for _ in range(N+1)]

n = int(input())

for i in range(n):
    p[i], p[i+1] = map(int, input().split())

for l in range(2, n+1):
    for i in range(1, n-l+2):
        j = i + l - 1
        m[i][j] = 10**9
        for k in range(i, j):
            m[i][j] = min(m[i][j], m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j])

print(m[1][n])
"
8832383,ALDS1_10_B,"# aizu_ALDS1_10_B_MatrixChainMultiplication.py  

n = int(input())
matrix_l = [ list(map(int,input().split())) for _ in range(n)]
min_mat_c = [ [0]*n for _ in range(n)]

def calc(i,j):
    if i == j: return 0
    if min_mat_c[i][j] != 0: return min_mat_c[i][j]
    temp = []
    for k in range(i,j):
        p = matrix_l[i][0]
        q = matrix_l[k][1]
        r = matrix_l[j][1]
        t = calc(i,k)+calc(k+1,j)+ p*q*r
        temp.append(t)
    min_mat_c[i][j] = min(temp)
    return min_mat_c[i][j]

ans = calc(0,n-1)
print(ans)
"
8941671,ALDS1_10_B,"import sys
# sys.setrecursionlimit(10**5+5)
input = sys.stdin.readline
from collections import defaultdict
from itertools import accumulate
import math

def inputa():
    return list(map(int, input().split()))

def inputs():
    return list(input().strip())

def solve(test):
    n = int(input())
    a = [inputa() for _ in range(n)]

    a = [a[0][0]] + [x for _,x in a]

    dp = [[0]*(n) for _ in range(n)]

    def dfs(i,j):
        if i == j:
            return 0
        if dp[i][j] != 0:
            return dp[i][j]

        min_ = math.inf
        for k in range(i,j):
            cost = dfs(i,k)+dfs(k+1,j)+a[i]*a[k+1]*a[j+1]
            min_ = min(cost, min_)

        dp[i][j] = min_
        return dp[i][j]

    print(dfs(0,n-1))

if __name__ == ""__main__"":
    test = 1
    # test = int(input())
    while(test):
        test-=1
        solve(test)
"
8961550,ALDS1_10_B,"import sys, re
from collections import deque, defaultdict, Counter
from math import ceil, floor, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, atan2, radians, degrees, log2, gcd
from cmath import phase
from itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby
from functools import cmp_to_key
from operator import itemgetter, mul
from copy import deepcopy
from string import ascii_lowercase, ascii_uppercase, digits
from bisect import bisect, bisect_left, insort, insort_left
from heapq import heappush, heappop
from functools import reduce, lru_cache
from random import randrange
import time
INF = float('inf')
sys.setrecursionlimit(10**9)
def input(): return sys.stdin.readline().strip()
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(): return list(map(int,  input().split()))
def TUPLE(): return tuple(map(int, input().split()))
def ZIP(n): return zip(*(MAP() for _ in range(n)))


n = INT()

R = []
for _ in range(n):
    r,c = MAP()
    R.append(r)
R.append(c)

dp = [[INF] * n for _ in range(n)]

for i in range(n):
    dp[i][i] = 0

for l in range(1,n):
    for i in range(n-l):
        j = i+l
        for k in range(i,j):
            # cost(左側行列積) + cost(右側行列積) + 行列計算のコスト
            dp[i][j] = min(dp[i][j], dp[i][k]+dp[k+1][j]+R[i]*R[k+1]*R[j+1]) # 初回はR[0]*R[1]*R[2]

print(dp[0][-1])
"
8964814,ALDS1_10_B,"n=int(input())
RC=[]
for _ in range(n):
    RC.append(list(map(int,input().split())))
dp=[[10**20]*(n) for _ in range(n)]
for i in range(n):
    dp[i][i]=0
for width in range(1,n):
    for left in range(n-width):
        right=left+width
        for mid in range(left,right):
            dp[left][right]=min(dp[left][right],dp[left][mid]+dp[mid+1][right]+RC[left][0]*RC[mid][1]*RC[right][1])
print(dp[0][-1])
"
8974814,ALDS1_10_B,"def function(l, r):
    if dp[l][r] != -1:
        return dp[l][r]
    if r - l == 0:
        res = 0
        dp[l][r] = res
        return res
    res = 10**10
    for mid in range(l, r):
        tmp = 0
        tmp += function(l, mid)
        tmp += function(mid + 1, r)
        tmp += L[l][0] * L[mid + 1][0] * L[r][1]
        res = min(tmp, res)
    dp[l][r] = res

    return res


N = int(input())
L = [list(map(int, input().split())) for _ in range(N)]
dp = [[-1] * N for _ in range(N)]
function(0, N - 1)
print(dp[0][-1])

"
9102911,ALDS1_10_B,"n=int(input())
matrix=[]
for _ in range(n):
    r, c=map(int, input().split())
    matrix.append(r)
matrix.append(c)

inf=float(""inf"")
dp=[[inf]*n for _ in range(n)]
for i in range(n):
    dp[i][i]=0
for dif in range(1,n):
    for i in range(n-dif):
        j = i + dif
        for k in range(i,j):
            dp[i][j] = min(dp[i][j], dp[i][k]+dp[k+1][j]+matrix[i]*matrix[k+1]*matrix[j+1])

print(dp[0][-1])
"
9115741,ALDS1_10_B,"import math
def minMCM(m: list[int], n: int) -> int:
    dp = [[0] * n for _ in range(n)]
    
    def dfs(i, j): # 再帰的に各セルに入る値を計算して返す
        if i == j:
            return 0
        if dp[i][j] != 0: # すでに数字が埋まっているなら計算不要 -> 動的計画法
            return dp[i][j]
        
        min_ = math.inf
        for k in range(i,j):
            cost = dfs(i,k) + dfs(k+1,j) + m[i] * m[k+1] * m[j+1]  # 上のリンクの考え方
            min_ = min(cost, min_)  # 最小値を更新
        
        dp[i][j] = min_
        return dp[i][j]
    
    return dfs(0, n-1)

n = int(input())
mtx = [list(map(int, input().split())) for _ in range(n)]
mtx = [mtx[0][0]] + [mtx[i][1] for i in range(n)]  # 必要な情報にまとめる(各行列の列番号と次の行番号は一致するはずだから、そこを圧縮する)
print(minMCM(mtx, n))
"
9128785,ALDS1_10_B,"l = int(input())
matrix = []

for _ in range(l):
    n,m = map(int,input().split())
    matrix.append((n,m))

DP = [[float('inf') for _ in range(l)] for _ in range(l)]
# DP[i][j] means that the minimum number scalar miltiplication Mi~Mj
for i in range(l):
    DP[i][i] = 0

for number_matrix in range(1,l+1):
    for start in range(l-number_matrix+1):
        end = start + number_matrix - 1
        for division in range(start, end):
            DP[start][end] = min(DP[start][end], DP[start][division]+DP[division+1][end] + matrix[start][0]*matrix[end][1]*matrix[division][1])

print(DP[0][l-1])

"
2725784,ALDS1_10_B,"def s():
 n=int(input())+1
 e=[input().split()for _  in[0]*~-n]
 p=[int(e[0][0])]+list(int(x[1])for x in e)
 m=[[0]*n for _ in[0]*n]
 for i in range(n):
  for r in range(n-i-1):
   c=r+i+1
   for j in range(r+1,c):
    x=m[r][j]+m[j][c]+p[r]*p[j]*p[c]
    if not 0<m[r][c]<=x:m[r][c]=x
 print(m[r][c])
if'__main__'==__name__:s()
"
3135274,ALDS1_10_B,"def s():
 n=int(input())+1
 e=[input().split()for _  in[0]*~-n]
 p=[int(e[0][0])]+list(int(x[1])for x in e)
 m=[[0]*n for _ in[0]*n]
 for i in range(n):
  for r in range(n-i-1):
   c=r+i+1
   for j in range(r+1,c):
    x=m[r][j]+m[j][c]+p[r]*p[j]*p[c]
    if not 0<m[r][c]<=x:m[r][c]=x
 print(m[r][c])
if'__main__'==__name__:s()

"
3939784,ALDS1_10_B,"def main():
    N = int(input())
    p = []
    for i in range(N):
        r, c = (int(i) for i in input().split())
        p.append(r)
        if i == N - 1:
            p.append(c)
    memo = [[float('inf') for j in range(N + 1)] for i in range(N + 1)]

    def matrix_chain_order():
        for i in range(1,N+1):
            memo[i][i] = 0

        for l in range(2,N+1):
            for i in range(1, N - l + 1 + 1):
                j = i + l - 1
                for k in range(i, j):
                    q = memo[i][k] + memo[k + 1][j] + p[i-1]*p[k]*p[j]
                    if q < memo[i][j]:
                        memo[i][j] = q

    matrix_chain_order()
    print(memo[1][N])

if __name__ == '__main__':
    main()
"
4263729,ALDS1_10_B,"def s():
 n=int(input())+1
 e=[input().split()for _  in[0]*~-n]
 p=[int(e[0][0])]+list(int(x[1])for x in e)
 m=[[0]*n for _ in[0]*n]
 for i in range(n):
  for r in range(n-i-1):
   c=r+i+1
   for j in range(r+1,c):
    x=m[r][j]+m[j][c]+p[r]*p[j]*p[c]
    if not 0<m[r][c]<=x:m[r][c]=x
 print(m[r][c])
if'__main__'==__name__:s()

"
5219928,ALDS1_10_B,"""""""
i < k < j
m[i][j] = m[i][k] + m[k+1][j] + Pi * Pk+1 * Pj+1
m[i][j] is  Pi, Pi+1, Pi+2, Pi+3
""""""


def printM(m):
    for a in m:
        print(a)


def matrixChainMultiplication(p):
    n = len(p) - 1
    m = [[0] * n for i in range(n)]

    for d in range(1, n):
        for i in range(0, n - d):
            j = i + d
            minimum = None
            for k in range(i, j):
                cost = m[i][k] + m[k + 1][j] + p[i] * p[k + 1] * p[j + 1]
                if minimum is None or minimum > cost:
                    minimum = cost
            m[i][j] = minimum
    # printM(m)
    print(m[0][-1])


def main():
    n = int(input())
    matrix = [tuple(map(int, input().split())) for i in range(n)]
    p = [matrix[i][0] for i in range(n)]
    p.append(matrix[-1][1])
    matrixChainMultiplication(p)


main()

"
5487284,ALDS1_10_B,"def multiply(p, n):
    m = [[0 for _ in range(n)] for _ in range(n)]
 
    for i in range(1, n):
        m[i][i] = 0
 
    for chain in range(2, n):
        for i in range(1, n-chain + 1):
            j = i + chain-1
            m[i][i + chain - 1] = 999999999999999999999
            
            for k in range(i, j): 
                q = m[i][k] + m[k + 1][j] + p[i-1]*p[k]*p[j]
                if q < m[i][j]:
                    m[i][j] = q
 
    return m[1][n-1]
 

M = int(input())
matrices = [list(map(int, input().split())) for _ in range(M)]
array = []
array.append(matrices[0][0])
[array.append(i[1]) for i in matrices]
print(multiply(array, M + 1))
"
8932775,ALDS1_10_B,"def main() -> None:
    import sys

    input = sys.stdin.readline

    n = int(input())
    mat_list = []
    for _ in range(n):
        r, c = map(int, input().split())
        mat_list.append((r, c))


    from collections import defaultdict
    import sys

    sys.setrecursionlimit(10**6)

    memo = defaultdict(int)

    def solve(i, j):
        if i == j:
            return 0
        if memo[(i, j)]:
            return memo[(i, j)]

        res = 1 << 60
        for k in range(i, j):
            p = mat_list[i][0]
            n = mat_list[k][1]
            q = mat_list[j][1]
            res = min(res, solve(i, k) + solve(k + 1, j) + p * n * q)
        memo[(i, j)] = res

        return res

    print(solve(0, n - 1))


if __name__ == ""__main__"":
    main()

"
8950211,ALDS1_10_B,"from typing import Optional


class Memo:
    __slots__ = [""memo""]
    memo: list[Optional[int]]

    def __init__(self):
        self.memo = [None for _ in range(105 * 105)]

    def get(self, i: int, j: int) -> Optional[int]:
        return self.memo[i * 105 + j]

    def set(self, i, j, value) -> None:
        self.memo[i * 105 + j] = value


def calc(rcs: list[tuple[int, int]], i: int, j: int, memo: Memo) -> int:
    if i == j:
        return 0

    ret = memo.get(i, j)
    if ret is not None:
        return ret

    ret = 200000000
    for k in range(i, j):
        r0, _ = rcs[i]
        _, c1 = rcs[k]
        _, c2 = rcs[j]

        s0 = calc(rcs, i, k, memo)
        s1 = calc(rcs, k + 1, j, memo)
        tmp = s0 + s1 + r0 * c1 * c2
        ret = min(ret, tmp)

    memo.set(i, j, ret)
    return ret


def run(rcs: list[tuple[int, int]]) -> int:
    memo = Memo()
    return calc(rcs, 0, len(rcs) - 1, memo)


if __name__ == ""__main__"":
    N = int(input())
    RCs = [tuple(map(int, input().split())) for _ in range(N)]
    print(run(RCs))

"
3927069,ALDS1_10_B,"def matrixChainMultiplication():
	INF = 100 * 100 * 100 + 1
	m = [[INF for _ in range(n + 1)] for _ in range(n + 1)]
	for i in range(1, n + 1):
		m[i][i] = 0
	for l in range(2, n + 1):
		for i in range(1, n - l + 2):
			j = i + l - 1
			for k in range(i, j):
				q = m[i][k] + m[k+1][j] + p[i-1] * p[k] * p[j]
				if q < m[i][j]:
					m[i][j] = q
	return m[1][n]

if __name__ == ""__main__"":
	n = int(input())
	p = list(map(int, input().split()))
	for i in range(1, n):
		p.append(list(map(int, input().split()))[1])
	print(matrixChainMultiplication())
"
4814647,ALDS1_10_B,"import sys


def main():
    input = sys.stdin.buffer.readline
    n = int(input())
    m = [tuple(map(int, input().split())) for _ in range(n)]
    dp = [[0] * 110 for _ in range(110)]
    for k in range(1, n):
        for i in range(n - k):
            dp[i][i + k] = min(
                [
                    dp[i][l] + dp[l + 1][i + k] + m[i][0] * m[l][1] * m[i + k][1]
                    for l in range(i, i + k)
                ]
            )

    print(dp[0][n - 1])


if __name__ == ""__main__"":
    main()

"
5169150,ALDS1_10_B,"import sys
input = sys.stdin.readline
def II(): return int(input())
def IS(): return input().rstrip()
def MI(): return map(int, input().split())
def LI(): return list(map(int, input().split()))
def MS(): return input().rstrip().split()
def LS(): return list(input().rstrip())


def main():
    N = II()
    R, C = [0]*N, [0]*N
    for i in range(N):
        R[i], C[i] = MI()
    dp = [[0]*N for _ in range(N)]
    for diff in range(1, N):
        for l in range(N-diff):
            r = l + diff
            dp[l][r] = min(dp[l][m]+dp[m+1][r] + R[l]*C[m]*C[r] for m in range(l, r))
    print(dp[0][N-1])

if __name__ == ""__main__"":
    main()

"
5312930,ALDS1_10_B,"def main():
    n = int(input())
    M = [list(map(int, input().split())) for _ in range(n)]

    dp = [[float('inf')] * n for _ in range(n)]
    for i in range(n):
        dp[i][i] = 0

    for w in range(1, n):
        for i in range(n - w):
            j = i + w
            dp[i][j] = min([dp[i][k] + dp[k + 1][j]
                            + M[i][0] * M[k][1] * M[j][1]
                            for k in range(i, j)])
    print(dp[0][n - 1])


if __name__ == '__main__':
    main()
"
5411834,ALDS1_10_B,"n = int(input()) #Accepting number of matrices to be considered where each line has number of rows and columns of a particular matrix

minfo = [None] * (n + 1)
minfo[0], minfo[1] = map(int, input().split())
for i in range(2, n + 1):
    _, minfo[i] = map(int, input().split()) #Building the sequence of dimensions

def MatrixChainOrder(p, n):
    m = [[0 for x in range(n)] for x in range(n)]
    for i in range(1, n):
        m[i][i] = 0
 
    for L in range(2, n):
        for i in range(1, n-L + 1):
            j = i + L-1
            m[i][j] = 1000000000
            for k in range(i, j):

                q = m[i][k] + m[k + 1][j] + p[i-1]*p[k]*p[j]
                if q < m[i][j]:
                    m[i][j] = q
 
    return m[1][n-1]
print(MatrixChainOrder(minfo, len(minfo)))
"
5437530,ALDS1_10_B,"def s():
 num=int(input())+1
 e=[input().split()for _  in[0]*~-num]
 p=[int(e[0][0])]+list(int(x[1])for x in e)
 m=[[0]*num for _ in[0]*num]
 for i in range(num):
  for r in range(num-i-1):
   c=r+i+1
   for j in range(r+1,c):
    x=m[r][j]+m[j][c]+p[r]*p[j]*p[c]
    if not 0<m[r][c]<=x:m[r][c]=x
 print(m[r][c])
if'__main__'==__name__:s()

"
6046350,ALDS1_10_B,"def cal_min_matrix_scala(mat_list):
    dp_list = [[10**10]*len(mat_list) for x in range(len(mat_list))]
    for i in range(len(mat_list)):
        dp_list[i][i] = 0
    
    for l in range(1, len(mat_list)):
        for i in range(len(mat_list) - l):
            j = i + l

            for k in range(i, j):
                p = mat_list[i][0]
                n = mat_list[k][1]
                q = mat_list[j][1]
                tmp = dp_list[i][k] + dp_list[k+1][j] + p*n*q 

                if dp_list[i][j] > tmp:
                    dp_list[i][j] = tmp

    return(dp_list[0][len(mat_list)-1])

N = int(input())
mat_list = []

for n in range(N):
    tmp = list(map(int, input().split()))
    mat_list.append(tmp)

ans = cal_min_matrix_scala(mat_list)
print(ans)
"
6826603,ALDS1_10_B,"def main():
    n = int(input())
    mat_dims = []
    for i in range(n):
        r, c = map(int, input().split())
        if i == 0:
            mat_dims.append(r)
            mat_dims.append(c)
        else:
            mat_dims.append(c)

    print(matrixChainOrder(mat_dims))

def matrixChainOrder(dims):
    import sys

    n = len(dims)
    dp = [[0 for _ in range(n)] for _ in range(n)]

    for i in range(n):
        dp[i][i] = 0

    for length in range(2, n):
        for i in range(1, n-length+1):
            j = i + length - 1
            dp[i][j] = sys.maxsize
            for k in range(i, j):
                cost = dp[i][k] + dp[k+1][j] + dims[i-1]*dims[k]*dims[j]
                if cost < dp[i][j]:
                    dp[i][j] = cost

    return dp[1][n-1]

if __name__ == '__main__':
    main()

"
6995054,ALDS1_10_B,"N = int(input())
r = [None] * N
c = [None] * N
for i in range(N):
    r[i], c[i] = map(int, input().split())

dp = [[0] * N for _ in range(N)]
for i in range(N):
    dp[i][i] = 0

for d in range(1, N):
    for i in range(N-d):
        L = r[i]
        R = c[i+d]
        dp[i][i+d] = min(dp[i][k] + dp[k+1][i+d] + L * R * c[k] for k in range(i, i+d))

ans = dp[0][-1]

print(ans)

"
7519259,ALDS1_10_B,"def mcmp(p):
    n = len(p)
    m = [[0 for _ in range(n)] for _ in range(n)] # 0段目を0で初期化
    for i in range(2, n):
        for j in range(n-i):
            tmp = float('inf')
            for k in range(1, i):
                if (m[k][j] + m[i-k][j+k] + p[j]*p[j+k]*p[j+i]) < tmp:
                    tmp = m[k][j] + m[i-k][j+k] + p[j]*p[j+k]*p[j+i]
                    m[i][j] = tmp 
    return m[n-1][0]

n = int(input())
p = list(map(int, input().split()))
for _ in range(n-1):
    p.append(int(input().split()[1]))
print(mcmp(p))
"
7550038,ALDS1_10_B,"# 10_B.py

from math import inf


def chain_matrix(M):

    n = len(M)
    T = [[inf] * n for _ in range(n)]

    for i in range(n):
        T[i][i] = 0

    for width in range(1, n):
        for l in range(0, n - width):
            r = l + width
            T[l][r] = min([
                T[l][m] + T[m + 1][r] + M[l][0] * M[m][1] * M[r][1]
                for m in range(l, r)
            ])

    return T[0][len(M) - 1]


n = int(input())

s = 0
M = []
for _ in range(n):
    M.append([int(e) for e in input().split()])

print(chain_matrix(M))

"
8057577,ALDS1_10_B,"INF = float('inf')
n = int(input())

r = []

for i in range(n):
    a, b = map(int, input().split())

    if i == 0:
        r.append(a)
        r.append(b)

    else:
        r.append(b)




def matrix_chain_order(r):
    n = len(r) - 1
    m = [ [INF for _ in range(n+1)] for __ in range(n+1) ]
    s = [ [ None for _ in range(n+1)] for __ in range(n+1) ]

    for i in range(1,n+1):
        m[i][i] = 0
    
    # l : length of sub matrix chain
    for l in range(2, n+1):
        for i in range(n-l+2):
            j = i+l-1
            # m[i][j] = INF

            for k in range(i, j):
                q = m[i][k] + m[k+1][j] + r[i-1]*r[k]*r[j]
                if m[i][j] > q:
                    m[i][j] = q
                    s[i][j] = k


    return (m, s)


m, s = matrix_chain_order(r)
print(m[1][n])





"
8073801,ALDS1_10_B,"import sys

infinity = sys.maxsize

n1 = int(input())
data = [0] * 101
output = [[0 for i in range(101)] for j in range(101)]

def matrixchainorder():
    for i in range(1, n1 + 1):
        output[i][i] = 0
    for j in range(2, n1 + 1):
        for k in range(1, n1 - j + 2):
            l = k + j - 1
            output[k][l] = infinity
            for m in range(k, l):
                n = output[k][m] + output[m + 1][l] + data[k - 1] * data[m] * data[l]
                if output[k][l] > n:
                    output[k][l] = n
    return output[1][n1]

for x in range(1, n1 + 1):
    data[x - 1], data[x] = map(int, input().split())

print(matrixchainorder())

"
3268935,ALDS1_10_B,"# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_10_B&lang=jp
#  Matrix Chain Multiplication : python3
#  2018.12.03 yonezawa

from collections import deque
import sys
input = sys.stdin.readline

def main():
    nmax = 1000000
    n = int(input())
    p = []
    calc = [[nmax for i in range(n + 1)] for i in range(n + 1)]

    for i in range(n):
        (a,b) = map(int,input().split())
        p.append(a)
    else:
        p.append(b)

    for i in range(n+1):
        calc[i][i] = 0

    for i in range(1,n):
        calc[i][i+1] = p[i-1] * p[i] * p[i +1] 
    
    for s in range(2,n):
        for i in range(1,n + 1 - s ):
#            print (i,i+s)
            for j in range(s):
                m = calc[i][i+j] + calc[i+j+1][i+s] + p[i-1]*p[i+j]* p[i+s]
#                print (""m="",m,""calc:"",i,i+j,""+calc"",i+j+1,i+s,""p:"",i-1,i+j,i+s)
                if calc[i][i+s] > m:
                    calc[i][i+s] = m
    print (calc[1][n])
if __name__ == '__main__':
    main()
"
4008825,ALDS1_10_B,"import sys


class Mat(object):

  def __init__(self, row, col):
    self.row = row
    self.col = col
    
def get_min_mult_cnt_dp(i, j, mat_list):

  multp = [[sys.maxsize for i in range(len(mat_list))] for i in range(len(mat_list))]

  

  # 長さ0連鎖の演算量
  for i in range(len(mat_list)):
    multp[i][i] = 0

  for le in range(1, len(mat_list)):
    for i in range(len(mat_list)-le):
      j = i + le

      tmp = sys.maxsize
      for k in range(i, j):
        p = mat_list[i].row
        n = mat_list[k].col
        q = mat_list[j].col
        tmp = multp[i][k] + multp[k+1][j] + p*n*q

        if (tmp < multp[i][j]):
          multp[i][j] = tmp
    
  
  return multp[i][j]
mat_list = []
num = int(input())
for i in range(num):
    a,b = map(int,input().split())
    mat_list.append(Mat(a,b))



print(int(get_min_mult_cnt_dp(0, num-1, mat_list)))
"
4058389,ALDS1_10_B,"def main():
    n = int(input())
    m1 = input().split()
    ps = [int(m1[0]), int(m1[1])]
    for _ in range(n - 1):
        ps.append(int(input().split()[1]))
    ms = [[float(""inf"") for _ in range(n)] for __ in range(n)]
    # 範囲 0 - n
    for i in range(n):
        ms[i][i] = 0

    for length in range(1, n):
        # 00 11 22 33 44 ...         nn
        # 01 12 23 34 45 ...      n-1,n
        # 02 13 24 35 46 ... n-2,n
        # ...
        # 0n
        for start in range(0, n - length):
            end = start + length
            # 仕切りpartition
            m_start_end = float(""inf"")
            for partition in range(start, end):
                m_start_end = min(m_start_end, ms[start][partition] + ms[partition + 1]
                                  [end] + ps[start] * ps[partition + 1] * ps[end + 1])
            ms[start][end] = m_start_end
    print(ms[0][n - 1])


if __name__ == ""__main__"":
    main()

"
4204650,ALDS1_10_B,"n = int(input())

M= [[] for i in range(n)]

for i in range(n):
  M[i] = list(map(int, input().split()))

p = [M[0][0]]

for i in range(n):
  p.append(M[i][1])

f_inf = float(""inf"")

m = [[f_inf for i in range(n)] for j in range(n)]

def matrixChainOrder(n):
  for i in range(n):
    m[i][i] = 0
  for l in range(2, n+1):
    for i in range(n-l+1):
      j = i + l - 1
      for k in range(i, j):
        q = m[i][k] + m[k+1][j] + p[i]*p[k+1]*p[j+1]
        if q < m[i][j]:
          m[i][j] = q

matrixChainOrder(n)

print(m[0][n-1])
"
4328769,ALDS1_10_B,"N = int(input())
matrices = [tuple(map(int, input().split())) for _ in range(N)]
R, C = zip(*matrices)
dp = [[float('inf')] * N for _ in range(N)]
for i in range(N): dp[i][i] = 0
for l in range(1, N):
    for i in range(N-l):
        r, c = R[i], C[i+l]
        dp[i][i+l] = min(r * C[j] * c + dp[i][j] + dp[j+1][i+l] for j in range(i, i+l))
print(dp[0][N-1])
"
4553086,ALDS1_10_B,"import sys

N = int(input())
R = [0]*N
C = [0]*N
for i in range(N):
    R[i], C[i] = map(int, input().split())

INF = 10**18
m = [[INF]*N for i in range(N)]
for i in range(N):
    m[i][i] = 0
for l in range(1, N):
    for i in range(N-l):
        a0 = R[i]
        c0 = C[i+l]
        m[i][i+l] = min(a0*C[j]*c0 + m[i][j] + m[j+1][i+l] for j in range(i, i+l))
print(m[0][N-1])
"
4574530,ALDS1_10_B,"def solve(n,mat):
    dp=[[0]*n for _ in range(n)]
    for kukan in range(1,n):
        for i in range(n-kukan):
            dp[i][i+kukan]=min([dp[i][mid]+dp[mid+1][i+kukan]+mat[i][0]*mat[mid+1][0]*mat[i+kukan][1] for mid in range(i,i+kukan)])
    return dp[0][n-1]

n=int(input())
mat=[tuple(map(int,input().split())) for _ in range(n)]
print(solve(n,mat))
"
5411889,ALDS1_10_B,"n = int(input()) #Accepting number of matrices to be considered where each line has number of rows and columns of a particular matrix

minfo = [None] * (n + 1)
minfo[0], minfo[1] = map(int, input().split())
for i in range(2, n + 1):
    _, minfo[i] = map(int, input().split()) #Building the sequence of dimensions

def MatrixChainOrder(minfo, n): #Based on pseudocode given in Cormen
    matrix = [[0 for num in range(n)] for num in range(n)]
    for i in range(1, n):
        matrix[i][i] = 0
 
    for c in range(2, n):
        for i in range(1, n - c + 1):
            j = i + c - 1
            matrix[i][j] = 1000000000 #Large number to be able to compare and update matrix
            for k in range(i, j):
                sum = matrix[i][k] + matrix[k + 1][j] + minfo[i - 1] * minfo[k] * minfo[j]
                if sum < matrix[i][j]:
                    matrix[i][j] = sum
 
    return matrix[1][n-1]
print(MatrixChainOrder(minfo, len(minfo))) #Printing the result
"
5426822,ALDS1_10_B,"def cost_calc():
	return min(a*c[k]*b + dp[j][k] + dp[k+1][j+i] for k in range(j, j+i))

n = int(input())
r = [None]*n
c = [None]*n

for i in range(n):
	buffer = [int(i) for i in input().split()][:2]  
	r[i] = buffer[0]
	c[i] = buffer[1]
# for i in range(len(buffer)):
# 	r[i] = buffer[i]
# 	c[i] = buffer[i+1]
dp = []
for i in range(n):
	dp.append([156498784654]*n)

for i in range(n):
	dp[i][i] = 0

for i in range(1, n):
    for j in range(n-i):
        a = r[j]
        b = c[j+i]
        dp[j][j+i] = cost_calc()

print(dp[0][n-1])
"
5465304,ALDS1_10_B,"def func(n,m):
    a=[[0]*n for _ in range(n)]
    for x in range(1,n):
        for i in range(n-x):
            a[i][i+x] = min([a[i][mid]+a[mid+1][i+x]+m[i][0]*m[mid+1][0]*m[i+x][1] for mid in range(i,i+x)])
    return a[0][n-1]

n=int(input())

m = [tuple(map(int,input().split())) for _ in range(n)]

print(func(n,m))

"
5485239,ALDS1_10_B,"n = int(input())
r= [0] * n
c = [0] * n

for i in range(n):
    r[i], c[i] = map(int, input().split())
dp = [[0]*n for _ in range(n)]
for diff in range(1, n):
    for l in range(n - diff):
        s = l + diff
        dp[l][s] = min(dp[l][m] + dp[m + 1][s] + r[l]*c[m]*c[s] for m in range(l, s))

print(dp[0][n - 1])
"
5487236,ALDS1_10_B,"# Algos (Ashoka Univ) - Assignment 10B

n = int(input())
arr = []

for _ in range(n):
    arr.append([int(num) for num in input().split()])

dyna = [[float('inf')] * n for _ in range(n)]

# Initializing to 0
for i in range(n): 
    dyna[i][i] = 0

for i in range(1, n):
    for j in range(n-i):
        row, column = arr[j][0], arr[j+i][1]
        dyna[j][j+i] = min(dyna[j][k] + dyna[k+1][j+i] + row * column * arr[k][1] for k in range(j, j+i))

print(dyna[0][n-1])
"
6245954,ALDS1_10_B,"n=int(input())
P=[[*map(int,input().split())] for i in range(n)]

p=[P[i][0] for i in range(n-1)]+P[n-1]
m=[[0]*(n+1) for i in range(n+1)]
for l in range(2,n+1):
    for i in range(n-l+1):
        j=i+l
        m[i][j] = min(m[i][k]+m[k][j]+p[i]*p[k]*p[j] for k in range(i+1,j))

print(m[0][n])

"
6321106,ALDS1_10_B,"n = int(input())
P = [[*map(int, input().split())] for i in range(n)]

p = [P[i][0] for i in range(n - 1)] + P[n - 1]
m = [[0] * (n + 1) for i in range(n + 1)]
for l in range(2, n + 1):
    for i in range(n-l + 1):
        j = i + l
        m[i][j] = min(m[i][k] + m[k][j] + p[i] * p[k] * p[j] for k in range(i + 1,j))

print(m[0][n])
"
6390102,ALDS1_10_B,"def matrix_chain(M):
    n = len(M)
    dp = [[float('inf')]*n for _ in range(n)]
    for i in range(n):
        dp[i][i] = 0
        
    for w in range(1, n): #区間の幅
        for l in range(n): #区間の左端
            r = l + w #区間の右端
            if r >= n:
                break 
            dp[l][r] = min(dp[l][i] + dp[i+1][r] + M[l][0]*M[i+1][0]*M[r][1] for i in range(l, r))
    return dp[0][n-1]


N = int(input())
M = [tuple(map(int, input().split())) for _ in range(N)]
ans = matrix_chain(M)
print(ans)
"
6797289,ALDS1_10_B,"N = int(input())
R, C = [0]*N, [0]*N
for i in range(N):
   R[i], C[i] = map(int, input().split())
   
dp = [[0]*N for _ in range(N)]
for diff in range(1, N):
   for l in range(N - diff):
       r = l + diff
       dp[l][r] = min(dp[l][m] + dp[m + 1][r] + R[l]*C[m]*C[r] for m in range(l, r))

print(dp[0][N - 1])
"
8954933,ALDS1_10_C,"def solve(x, y):
    pm = [0 for _ in range(ord('z') - ord('A') + 1)]
    for i, c in enumerate(x):
        pm[c] += 1 << i

    V = (1 << len(x)) - 1

    for c in y:
        V = ((V + (V & pm[c])) | (V & ~pm[c]))

    ans = bin(V)[-len(x):].count(""0"")

    return ans


if __name__ == ""__main__"":
    q = int(input())

    for _ in range(q):
        x = tuple(ord(c) - ord('A') for c in input())
        y = tuple(ord(c) - ord('A') for c in input())
        print(solve(x, y))

"
9086460,ALDS1_10_C,"q = int(input())
while q > 0:
    q -= 1
    x = input().rstrip()
    pm_dict = {}
    v = 1
    for c in x:
        if c in pm_dict:
            pm_dict[c] |= v
        else:
            pm_dict[c] = v
        v += v
    y = input().rstrip()
    mask = v = (1 << len(x)) - 1
    for c in y:
        u = v & pm_dict.get(c, 0)
        v = (v + u) | (v - u)
        v &= mask
    print(len(x) - bin(v).count('1'))

"
4759667,ALDS1_10_C,"# Longest Common Subsequence problem: LCS
# https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/10/ALDS1_10_C

import sys
input = sys.stdin.readline
ascii_letters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'


def get_LCS(x: str, y: str):
    lx = len(x)
    ly = len(y)
    dp = [[0] * (lx + 1) for _ in range(ly + 1)]  # 1-indexed

    for i in range(1, lx + 1):
        for j in range(1, ly + 1):
            if x[i - 1] == y[j - 1]:
                dp[j][i] = dp[j - 1][i - 1] + 1
            else:
                dp[j][i] = max(dp[j][i - 1], dp[j - 1][i])

    return dp[-1][-1]


def llcs(x, y):
    """"""solution author: bs5lNkJ""""""
    pm = dict((zip(ascii_letters, [0] * 52)))
    for c in pm:
        for i, xc in enumerate(x):
            if c == xc:
                pm[c] |= (1 << i)

    V = (1 << len(x)) - 1

    for yc in y:
        V = ((V + (V & pm[yc])) | (V & ~pm[yc]))

    ans = bin(V)[-len(x):].count('0')

    return ans


n = int(input())

for _ in range(n):
    X = input().strip()
    Y = input().strip()
    print(llcs(X, Y))

"
6664463,ALDS1_10_C,"ascii_letters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'

def llcs(x, y):
    pm = dict((zip(ascii_letters, [0] * 52)))
    for c in pm:
        for i, xc in enumerate(x):
            if c == xc:
                pm[c] |= (1 << i)
    
    V = (1 << len(x)) - 1
    
    for yc in y:
        V = ((V + (V & pm[yc])) | (V & ~pm[yc]))
    
    ans = bin(V)[-len(x):].count('0')
    
    return ans

from sys import stdin

def solve():
    file_input = stdin
    q = int(file_input.readline())
    for i in range(q):
        s1 = file_input.readline().rstrip()
        s2 = file_input.readline().rstrip()
        print(llcs(s1, s2))

solve()

"
6966530,ALDS1_10_C,"ascii_letters = ""abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ""


def LCS(x, y):
    pm = dict((zip(ascii_letters, [0] * 52)))
    for c in pm:
        for i, xc in enumerate(x):
            if c == xc:
                pm[c] |= 1 << i

    V = (1 << len(x)) - 1

    for yc in y:
        V = (V + (V & pm[yc])) | (V & ~pm[yc])

    ans = bin(V)[-len(x) :].count(""0"")

    return ans


q = int(input())


for i in range(q):
    x = input()
    y = input()
    print(LCS(x, y))

"
3007511,ALDS1_10_C,"ascii_letters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'

def llcs(x, y):
    pm = dict((zip(ascii_letters, [0] * 52)))
    for c in pm:
        for i, xc in enumerate(x):
            if c == xc:
                pm[c] |= (1 << i)
    
    V = (1 << len(x)) - 1
    
    for yc in y:
        V = ((V + (V & pm[yc])) | (V & ~pm[yc]))
    
    ans = bin(V)[-len(x):].count('0')
    
    return ans

from sys import stdin

def solve():
    file_input = stdin
    q = int(file_input.readline())
    for i in range(q):
        s1 = file_input.readline().rstrip()
        s2 = file_input.readline().rstrip()
        print(llcs(s1, s2))

solve()
"
5906759,ALDS1_10_C,"from collections import deque
from bisect import bisect_left
import sys
input = sys.stdin.readline

INF = 10**10
q = int(input())
for _ in range(q):
    X = list(input())
    X = X[:-1]
    Y = list(input())
    Y = Y[:-1]
    Y_info = [deque() for _ in range(50)]
    for i in range(len(Y)):
        Y_info[ord(Y[i]) - ord('a')].appendleft(i)
    ans = [INF for _ in range(max(len(X), len(Y)))]
    for s in X:
        for i in Y_info[ord(s) - ord('a')]:
            ans[bisect_left(ans, i)] = i
    print(bisect_left(ans, INF))
"
6955811,ALDS1_10_C,"from collections import deque
from bisect import bisect_left
import sys
input = sys.stdin.readline

INF = 10**10
q = int(input())
for _ in range(q):
    X = list(input())
    X = X[:-1]
    Y = list(input())
    Y = Y[:-1]
    Y_info = [deque() for _ in range(50)]
    for i in range(len(Y)):
        Y_info[ord(Y[i]) - ord('a')].appendleft(i)
    ans = [INF for _ in range(max(len(X), len(Y)))]
    for s in X:
        for i in Y_info[ord(s) - ord('a')]:
            ans[bisect_left(ans, i)] = i
    print(bisect_left(ans, INF))
"
7612469,ALDS1_10_C,"from collections import deque
from bisect import bisect_left
import sys
input = sys.stdin.readline

INF = 10**10
q = int(input())
for _ in range(q):
    X = list(input())
    X = X[:-1]
    Y = list(input())
    Y = Y[:-1]
    Y_info = [deque() for _ in range(50)]
    for i in range(len(Y)):
        Y_info[ord(Y[i]) - ord('a')].appendleft(i)
    ans = [INF for _ in range(max(len(X), len(Y)))]
    for s in X:
        for i in Y_info[ord(s) - ord('a')]:
            ans[bisect_left(ans, i)] = i
    print(bisect_left(ans, INF))

"
6361905,ALDS1_10_C,"from collections import deque
from bisect import bisect_left
import sys
input = sys.stdin.readline

INF = 10**10
q = int(input())
for _ in range(q):
    X = list(input())
    X = X[:-1]
    Y = list(input())
    Y = Y[:-1]
    Y_info = [deque() for _ in range(50)]
    for i in range(len(Y)):
        Y_info[ord(Y[i]) - ord('a')].appendleft(i)
    ans = [INF for _ in range(max(len(X), len(Y)))]
    for s in X:
        for i in Y_info[ord(s) - ord('a')]:
            ans[bisect_left(ans, i)] = i
    print(bisect_left(ans, INF))

"
6885567,ALDS1_10_C,"from bisect import bisect_left
from collections import defaultdict
from typing import List


def solve(X: str, Y: str) -> int:
    dp: List[int] = [-1]
    indice_Y_by_char = defaultdict(list)
    for i, c in enumerate(Y):
        indice_Y_by_char[c].append(i)
    for x in X:
        for idx in indice_Y_by_char[x][::-1]:
            tmp = bisect_left(dp, idx)
            if tmp == len(dp):
                dp.append(idx)
            elif tmp == 0:
                continue
            else:
                dp[tmp] = idx
    return len(dp) - 1


def main():
    q = int(input())
    for _ in range(q):
        X = input()
        Y = input()
        print(solve(X, Y))


if __name__ == ""__main__"":
    main()

"
7380934,ALDS1_10_C,"from collections import deque
from bisect import bisect_left
import sys
input = sys.stdin.readline

INF = 10**10
q = int(input())
for _ in range(q):
    z = list(input())
    z = z[:-1]
    Y = list(input())
    Y = Y[:-1]
    Y_info = [deque() for _ in range(50)]
    for i in range(len(Y)):
        Y_info[ord(Y[i]) - ord('a')].appendleft(i)
    ans = [INF for _ in range(max(len(z), len(Y)))]
    for s in z:
        for i in Y_info[ord(s) - ord('a')]:
            ans[bisect_left(ans, i)] = i
    print(bisect_left(ans, INF))
"
4274625,ALDS1_10_C,"import sys
import math
import string
import fractions
import random
from operator import itemgetter
import itertools
from collections import deque
import copy
import heapq
from bisect import bisect, bisect_left, bisect_right

MOD = 10 ** 9 + 7
INF = float('inf')
input = lambda: sys.stdin.readline().strip()

sys.setrecursionlimit(10 ** 8)


q = int(input())
for _ in range(q):
    s = input()
    t = input()

    info = deque(deque() for _ in range(100))
    check = []
    for i in range(len(s)):
        info[ord(s[i]) - 97].appendleft(i)
    ans = [INF] * (max(len(s), len(t)) + 10)
    link = [0] * (max(len(s), len(t)) + 10)
    for i in t:
        for l in info[ord(i) - 97]:
            ans[bisect_left(ans, l)] = l
    print(bisect_left(ans, INF))
"
3117828,ALDS1_10_C,"def lcs_hs(s1, s2):
    from bisect import bisect_left

    s2, lis, result = s2[::-1], [], 0
    find, append = s2.find, lis.append

    for c in s1:
        i = find(c)+1
        while i:
            j = bisect_left(lis, -i)
            if j >= result:
                append(-i)
                result += 1
            else:
                lis[j] = -i
            i = find(c, i)+1

    return result


print(*(lcs_hs(input(), input()) for _ in [0]*int(input())), sep=""\n"")
"
8152292,ALDS1_10_C,"# -*- coding: utf-8 -*-
from sys import stdin
input = stdin.readline

def lcs(a,b):
    n, m = len(a), len(b)
    dp = []
    for i in range(m):
        cur = 0
        for j in range(len(dp)):
            tmp = dp[j]
            if b[i] in a[cur:tmp]:
                dp[j] = cur + a[cur:tmp].index(b[i])
            cur = tmp+1
        if b[i] in a[cur:]:
            dp.append(cur + a[cur:].index(b[i]))
    return len(dp)

n = int(input())
for _ in range(n):
    a = input().strip()
    b = input().strip()
    print(lcs(a,b))
"
3405129,ALDS1_10_C,"def main():
    X=input()
    Y=input()
    dp=[]
    for y in range(len(Y)):
        now=0
        for i  in range(len(dp)):
            d=dp[i]
            if Y[y] in X[now:d]:
                dp[i]=now+X[now:d].index(Y[y])
            now=d+1
        if Y[y] in X[now:]:
            dp.append(now+X[now:].index(Y[y]))
    return len(dp)
for i in range(int(input())):
    print(main())
                 
"
3943640,ALDS1_10_C,"#
# 　　  ⋀_⋀　 
#　　  (･ω･)  
# .／ Ｕ ∽ Ｕ＼
#  │＊　合　＊│
#  │＊　格　＊│ 
#  │＊　祈　＊│ 
#  │＊　願　＊│ 
#  │＊　　　＊│ 
#      ￣
#
import sys
sys.setrecursionlimit(10**6)
input=sys.stdin.readline
from math import floor,ceil,sqrt,factorial,log #log2ないｙｐ
from heapq import heappop, heappush, heappushpop
from collections import Counter,defaultdict,deque
from itertools import accumulate,permutations,combinations,product,combinations_with_replacement
from bisect import bisect_left,bisect_right
from copy import deepcopy
inf=float('inf')
mod = 10**9+7
def pprint(*A): 
    for a in A:     print(*a,sep='\n')
def INT_(n): return int(n)-1
def MI(): return map(int,input().split())
def MF(): return map(float, input().split())
def MI_(): return map(INT_,input().split())
def LI(): return list(MI())
def LI_(): return [int(x) - 1 for x in input().split()]
def LF(): return list(MF())
def LIN(n:int): return [I() for _ in range(n)]
def LLIN(n: int): return [LI() for _ in range(n)]
def LLIN_(n: int): return [LI_() for _ in range(n)]
def LLI(): return [list(map(int, l.split() )) for l in input()]
def I(): return int(input())
def F(): return float(input())
def ST(): return input().replace('\n', '')
def main():
    Q=I()
    for _ in range(Q):
        S=ST()
        T=ST()[::-1]
        lis = []
        find, append = T.find, lis.append

        for c in S:
            i = find(c)+1
            while i:
                j = bisect_left(lis, -i)
                if j >= len(lis):
                    append(-i)
                else:
                    lis[j] = -i
                i = find(c, i)+1
        print(len(lis))
if __name__ == '__main__':
    main()
"
7257657,ALDS1_10_C,"import sys
from string import ascii_lowercase, ascii_uppercase
readline = sys.stdin.readline
write = sys.stdout.write

def calc(S, T):
    N = len(S)
    M = len(T)
    cA = ord('a')
    prv = [[None]*(M+1) for i in range(N+1)]

    cs = ascii_lowercase + ascii_uppercase

    it_g = [None]*(M+2)
    it_g[0] = []
    for i in range(1, M+2):
        it_g[i] = it_g[i - (i & -i)][:]
        it_g[i].append(i)

    it_u = [None]*(M+2)
    it_u[M+1] = [M+1]
    for i in range(M, 0, -1):
        if i + (i & -i) <= M+1:
            it_u[i] = it_u[i + (i & -i)][:]
            it_u[i].append(i)
        else:
            it_u[i] = [i]
    for i in range(1, M+2):
        it_u[i].reverse()

    data = [0]*(M+2)

    ds = [[] for i in range(len(cs))]
    for i in range(M):
        ds[cs.index(T[i])].append(i+1)
    for d in ds:
        d.reverse()

    for i in range(N):
        pi = prv[i+1]
        mi = (i+1)*(M+1)
        for j in ds[cs.index(S[i])]:
            s = 0
            for e in it_g[j-1]:
                if s < data[e]:
                    s = data[e]
            pi[j] = s

            x = s+1
            for e in it_u[j]:
                if x <= data[e]:
                    break
                data[e] = x
    s = 0
    for e in it_g[M+1]:
        if s < data[e]:
            s = data[e]
    return s

def solve():
    S = readline().strip()
    T = readline().strip()
    write(""%d\n"" % calc(S, T))

q = int(readline())
for _ in range(q):
    solve()
"
4400136,ALDS1_10_C,"import bisect


def LCS(S, T):
    N = len(S)
    M = len(T)
    dp = [[0] * (M + 1) for _ in range(N + 1)]

    for i, s in enumerate(S, start=1):
        for j, t in enumerate(T, start=1):
            if s == t:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[N][M]


def LCS_HTKB(S, T):
    T = T[::-1]
    memo = []

    for s in S:
        i = T.find(s) + 1
        while i:
            j = bisect.bisect_left(memo, -i)
            if j >= len(memo):
                memo.append(-i)
            else:
                memo[j] = -i
            i = T.find(s, i) + 1
    return len(memo)


if __name__ == ""__main__"":
    Q = int(input())
    ans = []
    for _ in range(Q):
        ans.append(LCS_HTKB(input(), input()))
    print(*ans, sep=""\n"")
"
2725736,ALDS1_10_C,"def m():
 e=input
 a=''
 for _ in[0]*int(e()):
  X,z=e(),[]
  for y in e():
   s=i=0
   for k in z:
    t=X.find(y,s)+1
    if t<1:break
    if t<k:z[i]=t
    s=k;i+=1
   else:
    t=X.find(y,s)+1
    if t:z+=[t]
  a+=f'\n{len(z)}'
 print(a[1:])
if'__main__'==__name__:m()
"
2919068,ALDS1_10_C,"def m():
 e=input
 a=''
 for _ in[0]*int(e()):
  X,z=e(),[]
  for y in e():
   s=i=0
   for k in z:
    t=X.find(y,s)+1
    if t<1:break
    if t<k:z[i]=t
    s=k;i+=1
   else:
    t=X.find(y,s)+1
    if t:z+=[t]
  a+=f'\n{len(z)}'
 print(a[1:])
if'__main__'==__name__:m()
"
4009696,ALDS1_10_C,"def lcs(str1, str2):
    lcslist = []
    for s in str2:
        m = n = 0
        for index in lcslist:
            t = str1.find(s, m) + 1
            if t <= 0:
                break
            elif t < index:
                lcslist[n] = t
            m = index
            n += 1
        else:
            t = str1.find(s, m) + 1
            if t > 0:
                lcslist.append(t)
    return len(lcslist)

if __name__ == '__main__':
    n = int(input())
    for i in range(n):
        str1 = input()
        str2 = input()
        print(lcs(str1, str2))
"
5086810,ALDS1_10_C,"def m():
 e=input
 a=''
 for _ in[0]*int(e()):
  X,z=e(),[]
  for y in e():
   s=i=0
   for k in z:
    t=X.find(y,s)+1
    if t<1:break
    if t<k:z[i]=t
    s=k;i+=1
   else:
    t=X.find(y,s)+1
    if t:z+=[t]
  a+=f'\n{len(z)}'
 print(a[1:])
if'__main__'==__name__:m()

"
5049046,ALDS1_10_C,"def m():
 e=input
 a=''
 for _ in[0]*int(e()):
  X,z=e(),[]
  for y in e():
   s=i=0
   for k in z:
    t=X.find(y,s)+1
    if t<1:break
    if t<k:z[i]=t
    s=k;i+=1
   else:
    t=X.find(y,s)+1
    if t:z+=[t]
  a+=f'\n{len(z)}'
 print(a[1:])
if'__main__'==__name__:m()
"
8237641,ALDS1_10_C,"import bisect


def LCS(S, T):
    N = len(S)
    M = len(T)
    dp = [[0] * (M + 1) for _ in range(N + 1)]

    for i, s in enumerate(S, start=1):
        for j, t in enumerate(T, start=1):
            if s == t:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[N][M]


def LCS_HTKB(S, T):
    T = T[::-1]
    memo = []

    for s in S:
        i = T.find(s) + 1
        while i:
            j = bisect.bisect_left(memo, -i)
            if j >= len(memo):
                memo.append(-i)
            else:
                memo[j] = -i
            i = T.find(s, i) + 1
    return len(memo)


if __name__ == ""__main__"":
    Q = int(input())
    ans = []
    for _ in range(Q):
        ans.append(LCS_HTKB(input(), input()))
    print(*ans, sep=""\n"")

"
8533226,ALDS1_10_C,"def lcs(s, t):
    n, m = len(s), len(t)
    dp = [0 for _ in range(m + 1)]
    for i in range(n):
        mem = dp[:]
        for j in range(m):
            if s[i] == t[j]:
                dp[j + 1] = mem[j] + 1
            elif dp[j + 1] < dp[j]:
                dp[j + 1] = dp[j]
    return dp[m]


if __name__ == '__main__':
    Q = int(input())
    for _ in range(Q):
        s = input().strip()
        t = input().strip()
        print(lcs(s, t))
"
3387819,ALDS1_10_C,"import bisect

INF = float('inf')
q = int(input())
for i in range(q):
    x = input()
    y = input()
    dic = {}
    for i,xx in enumerate(x):
        if xx in dic : dic[xx].append(i)
        else : dic[xx] = [i]
    inc = []
    size = -1
    for j,yy in enumerate(y):
        if not (yy in dic):continue
        inc.append([])
        size += 1
        for k in dic[yy]:
            inc[size].append(k)
    #incのLISを求めればよい
    n = len(inc)
    dp =  [INF for i in range(n)]
    temp = [INF for i in range(n)]

    for ii in inc:
        for i in ii:
            p = bisect.bisect_left(dp, i)
            temp[p] = min(i,temp[p])
        dp = temp[:]


    print(bisect.bisect_left(dp, INF))
"
4689731,ALDS1_10_C,"import sys
def input(): return sys.stdin.readline().strip()
def mapint(): return map(int, input().split())
sys.setrecursionlimit(10**9)

N = int(input())
from bisect import bisect_left
for _ in range(N):
    Xs = input()
    Ys = input()[::-1]
    lis = []
    for x in Xs:
        idx = Ys.find(x)+1
        while idx:
            j = bisect_left(lis, -idx)
            if j>=len(lis):
                lis.append(-idx)
            else:
                lis[j] = -idx
            idx = Ys.find(x, idx)+1
    print(len(lis))

"
2530536,ALDS1_10_C,"def lcs(s1, s2):
    dp = []
    for s2_k in s2:
        bgn_idx = 0
        for i, cur_idx in enumerate(dp):
            chr_idx = s1.find(s2_k, bgn_idx) + 1
            if not chr_idx:
                break
            dp[i] = min(cur_idx, chr_idx)
            bgn_idx = cur_idx
        else:
            chr_idx = s1.find(s2_k, bgn_idx) + 1
            if chr_idx:
                dp.append(chr_idx)
    return len(dp)

def solve():
    N = int(input())
    for _ in range(N):
        x = input()
        y = input()
        print(lcs(x, y))

if __name__ == '__main__':
    solve()
"
4154474,ALDS1_10_C,"def lcs(s1, s2):
    dp = []
    for s2_k in s2:
        bgn_idx = 0
        for i, cur_idx in enumerate(dp):
            chr_idx = s1.find(s2_k, bgn_idx) + 1
            if not chr_idx:
                break
            dp[i] = min(cur_idx, chr_idx)
            bgn_idx = cur_idx
        else:
            chr_idx = s1.find(s2_k, bgn_idx) + 1
            if chr_idx:
                dp.append(chr_idx)
    return len(dp)

n = int(input())
ans = []
for _ in range(n):
    x = input()
    y = input()
    ans.append(lcs(x, y))

for i in ans:
    print(i)
"
4774655,ALDS1_10_C,"# 38

import sys


def lcs(X, Y):
    l_x = len(X)
    l_y = len(Y)
    # dp[i][j] : Xのi文字目、Yのj文字目までから構成される最長部分列数
    dp = [[0] * (l_y+1) for _ in range(l_x+1)]
    for i in range(l_x):
        for j in range(l_y):
            if X[i] == Y[j]:
                dp[i+1][j+1] = dp[i][j]+1
            else:
                dp[i+1][j+1] = max(dp[i+1][j], dp[i][j+1])
    return dp[-1][-1]


def lcs_s(X, Y):
    L = []
    for yk in Y:
        bgn_idx = 0
        for i, cur_idx in enumerate(L):
            chr_idx = X.find(yk, bgn_idx) + 1
            if not chr_idx:
                break
            L[i] = min(cur_idx, chr_idx)
            bgn_idx = cur_idx
        else:
            chr_idx = X.find(yk, bgn_idx) + 1
            if chr_idx:
                L.append(chr_idx)
    return len(L)


Q = int(input())
for _ in range(Q):
    X = sys.stdin.readline().rstrip()
    Y = sys.stdin.readline().rstrip()
    print(lcs_s(X, Y))

"
3583816,ALDS1_10_C,"def lcs(s1_raw, s2_raw):
    dp = []
    for s2 in s2_raw:
        start = 0
        for i, cnt in enumerate(dp):
            index = s1_raw.find(s2, start) + 1
            if not index:
                break
            else:
                dp[i]  = min(cnt , index)
                start = cnt
        index = s1_raw.find(s2, start) + 1
        if index:
            dp.append(index)
    return len(dp)


if __name__ == ""__main__"":
    q = int(input())
    for _ in range(q):
        x = input()
        y = input()
        print(lcs(x, y))

"
3881306,ALDS1_10_C,"def lcs(X, Y):
    dp = []
    for y in Y:
        bgn_idx = 0
        for i, cur_idx in enumerate(dp):
            chr_idx = X.find(y, bgn_idx) + 1
            
            if not chr_idx:
                break
            dp[i] = min(cur_idx, chr_idx)
            bgn_idx = cur_idx
        else:
            chr_idx = X.find(y, bgn_idx) + 1
            if chr_idx:
                dp.append(chr_idx)
    return len(dp)

q = int(input())
for i in range(q):
    X = input()
    Y = input()
    print(lcs(X, Y))

"
4416173,ALDS1_10_C,"def lcs(s1, s2):
    dp = []
    for s2_k in s2:
        bgn_idx = 0
        for i, cur_idx in enumerate(dp):
            chr_idx = s1.find(s2_k, bgn_idx) + 1
            if not chr_idx:
                break
            dp[i] = min(cur_idx, chr_idx)
            bgn_idx = cur_idx
        else:
            chr_idx = s1.find(s2_k, bgn_idx) + 1
            if chr_idx:
                dp.append(chr_idx)
    return len(dp)

n = int(input())
for _ in range(n):
    x = input()
    y = input()
    print(lcs(x, y))

"
5266701,ALDS1_10_C,"#!/usr/bin/env python3
import sys

def getLengthOfLcs(a: str, b: str):
    L = []
    for bk in b:
        bgn_idx = 0  # 検索開始位置
        for i, cur_idx in enumerate(L):
            # ※1
            chr_idx = a.find(bk, bgn_idx) + 1
            if not chr_idx:
                break
            L[i] = min(cur_idx, chr_idx)
            bgn_idx = cur_idx
        else:
            # ※2
            chr_idx = a.find(bk, bgn_idx) + 1
            if chr_idx:
                L.append(chr_idx)
    return len(L)
 
def main():
    q = int(input())
    for _ in range(q):
        s = input()
        t = input()
        print(getLengthOfLcs(s, t))

if __name__ == '__main__':
    main()

"
5488284,ALDS1_10_C,"def lcs(s1, s2):
    dp = []
    for s2_k in s2:
        bgn_idx = 0
        for i, cur_idx in enumerate(dp):
            chr_idx = s1.find(s2_k, bgn_idx) + 1
            if not chr_idx:
                break
            dp[i] = min(cur_idx, chr_idx)
            bgn_idx = cur_idx
        else:
            chr_idx = s1.find(s2_k, bgn_idx) + 1
            if chr_idx:
                dp.append(chr_idx)
    return len(dp)


n = int(input())
for _ in range(n):
    x = input()
    y = input()
    print(lcs(x, y))


"
5947480,ALDS1_10_C,"import sys, re
from collections import deque, defaultdict, Counter
from math import ceil, floor, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2, gcd
from itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby
from operator import itemgetter, mul
from copy import deepcopy
from string import ascii_lowercase, ascii_uppercase, digits
from bisect import bisect, bisect_left, insort, insort_left
from heapq import heappush, heappop
from functools import reduce, lru_cache
def input(): return sys.stdin.readline().strip()
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(): return list(map(int, input().split()))
def TUPLE(): return tuple(map(int, input().split()))
def ZIP(n): return zip(*(MAP() for _ in range(n)))
sys.setrecursionlimit(10 ** 9)
INF = float('inf')
mod = 10 ** 9 + 7
#mod = 998244353
#from decimal import *
#import numpy as np
#decimal.getcontext().prec = 10

N = INT()


def lcs(s1, s2):
    dp = []
    for s2_k in s2:
        bgn_idx = 0
        for i, cur_idx in enumerate(dp):
            chr_idx = s1.find(s2_k, bgn_idx) + 1
            if not chr_idx:
                break
            dp[i] = min(cur_idx, chr_idx)
            bgn_idx = cur_idx
        else:
            chr_idx = s1.find(s2_k, bgn_idx) + 1
            if chr_idx:
                dp.append(chr_idx)
    return len(dp)


for _ in range(N):
    S = input()
    T = input()
    print(lcs(S, T))
"
6344087,ALDS1_10_C,"n=int(input())
INF=10**10

def test():
    A=input()
    B=input()
    l=len(A)
    m=len(B)
    L=[]
    for bk in B:
        b_i=0
        for i, c_i in enumerate(L):
            d_i = A.find(bk, b_i) + 1
            if not d_i:
                break
            L[i] = min(c_i, d_i)
            b_i = c_i
        else:
            d_i = A.find(bk, b_i) + 1
            if d_i:
                L.append(d_i)
    print(len(L))
    
for _ in range(n):
    test()
"
6388164,ALDS1_10_C,"#Longest Common Subsequence
#https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_10_C&lang=ja

def LCS(A,B):
    dp = []
    for a in A:
        idx = 0
        for i, dpidx in enumerate(dp):
            chidx = B.find(a,idx)+1
            if not chidx:
                break
            dp[i] = min(dpidx,chidx)
            idx = dpidx
        else:
            chidx = B.find(a,idx)+1
            if chidx:
                dp.append(chidx)
    return len(dp)

q = int(input())
for _ in range(q):
    X = input()
    Y = input()
    print(LCS(X,Y))
"
3988267,ALDS1_10_C,"def lcs(s1, s2):
    dp = []
    for s2_k in s2:
        bgn_idx = 0
        for i, cur_idx in enumerate(dp):
            chr_idx = s1.find(s2_k, bgn_idx) + 1
            if not chr_idx:
                break
            dp[i] = min(cur_idx, chr_idx)
            bgn_idx = cur_idx
        else:
            chr_idx = s1.find(s2_k, bgn_idx) + 1
            if chr_idx:
                dp.append(chr_idx)
    return len(dp)


n = int(input())
for _ in range(n):
    x = input()
    y = input()
    print(lcs(x, y))


"
4096942,ALDS1_10_C,"def lcs(s1, s2):

    dp = []

    for s2_k in s2:

        bgn_idx = 0

        for i, cur_idx in enumerate(dp):

            chr_idx = s1.find(s2_k, bgn_idx) + 1

            if not chr_idx:

                break

            dp[i] = min(cur_idx, chr_idx)

            bgn_idx = cur_idx

        else:

            chr_idx = s1.find(s2_k, bgn_idx) + 1

            if chr_idx:

                dp.append(chr_idx)

    return len(dp)



def solve():

    N = int(input())

    for _ in range(N):

        x = input()

        y = input()

        print(lcs(x, y))



if __name__ == '__main__':

    solve()
"
4130422,ALDS1_10_C,"# ライブラリのインポート
#import re #正規表現
import sys
#import heapq
#import collections
#import math

def main():
    q = int(input())
    STR = [str.strip(""\n"") for str in sys.stdin]
    for i in range(q):
        x = STR[2*i]
        y = STR[2*i+1]
        print(lcs(x,y))


def lcs(x, y):
    dp = []
    for y_k in y:
        ps = 0
        for i, pdp in enumerate(dp):
            p = x.find(y_k, ps) + 1 #.find method returns -1 if there is no element
            if not p: break
            dp[i] = min(p,pdp)
            ps = pdp
        else: #else block is executed when for block has done completedly
            p = x.find(y_k, ps) + 1
            if p: dp.append(p)
    return len(dp)


if __name__ == '__main__':
    main()

"
4296393,ALDS1_10_C,"
def resolve():
    def lcs(s1, s2):
        """"""
        文字列S, Tのlongest common subsequenceの長さを返す
        なお、longest common substringではない
        （要素同士がとなりあっていなくてもいい）ことに注意！
        """"""

        dp = []
        for s2_k in s2:
            bgn_idx = 0
            for i, cur_idx in enumerate(dp):
                # bgn_idx以降でs2_kを探す
                chr_idx = s1.find(s2_k, bgn_idx) + 1
                if not chr_idx:
                    break
                dp[i] = min(cur_idx, chr_idx)
                bgn_idx = cur_idx
            else:
                chr_idx = s1.find(s2_k, bgn_idx) + 1
                if chr_idx:
                    dp.append(chr_idx)
        return len(dp)

    q = int(input())
    for i in range(q):
        S = str(input())
        T = str(input())
        print(lcs(S, T))


resolve()
"
4469166,ALDS1_10_C,"# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_10_C&lang=ja
# 最長共通部分文字列
import sys
read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines

# dp[i][j] := Sのi番目までとTのj番目までのLCS
# アルゴリズム的には正しいがTLE
def LCS(S, T):
    n = len(S)
    m = len(T)

    dp = [[0] * (m+1) for _ in range(n+1)]

    for i in range(n):
        S_i = S[i]
        for j in range(m):
            if S_i == T[j]:
                dp[i+1][j+1] = dp[i][j] + 1
            else:
                dp[i+1][j+1] = max(dp[i+1][j], dp[i][j+1])
    
    return dp[n][m]


def LCS2(S, T):
    L = []
    for t in T:
        t_idx = 0  # 検索開始位置
        for i, cur_idx in enumerate(L):
            chr_idx = S.find(t, t_idx) + 1
            if not chr_idx:
                break
            L[i] = min(cur_idx, chr_idx)
            t_idx = cur_idx
        else:
            chr_idx = S.find(t, t_idx) + 1
            if chr_idx:
                L.append(chr_idx)
    
    return len(L)


def main():
    q = int(readline())
    xy = read().split()

    ans = []
    for X, Y in zip(*[iter(xy)]*2):
        ans.append(LCS2(X, Y))

    print(""\n"".join(map(str, ans)))


if __name__ == ""__main__"":
    main()
"
4569536,ALDS1_10_C,"def lcs(x, y):
    L = []
    for y_k in y:
        si = 0
        for i, cri in enumerate(L):
            chi = x.find(y_k, si) + 1
            if not chi:
                break
            L[i] = min(cri, chi)
            si = cri
        else:
            chi = x.find(y_k, si) + 1
            if chi:
                L.append(chi)
    return len(L)


if __name__ == ""__main__"":
    N = int(input())
    ans = []
    for _ in range(N):
        X = input()
        Y = input()
        print(lcs(X, Y))
"
4808326,ALDS1_10_C,"import sys


def lcs(X, Y):
    dp = [[0] * (len(Y) + 1) for _ in range(len(X) + 1)]

    for i in range(len(X)):
        for j in range(len(Y)):
            if X[i] == Y[j]:  # 同じ文字なら LCS が1文字伸びる
                dp[i + 1][j + 1] = dp[i][j] + 1
            else:  # 違う文字なら、LCS はそのままで、X,Yの部分列を伸ばす
                dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j])

    return dp[len(X)][len(Y)]


def lcs2(X, Y):
    dp = []

    for Y_k in Y:
        bgn_idx = 0
        for i, cur_idx in enumerate(dp):
            chr_idx = X.find(Y_k, bgn_idx) + 1
            if not chr_idx:
                break
            dp[i] = min(cur_idx, chr_idx)
            bgn_idx = cur_idx
        else:
            chr_idx = X.find(Y_k, bgn_idx) + 1
            if chr_idx:
                dp.append(chr_idx)

    return len(dp)


def main():
    q = int(sys.stdin.readline().rstrip())

    for _ in range(q):
        X = sys.stdin.readline().rstrip()
        Y = sys.stdin.readline().rstrip()
        print(lcs2(X, Y))


main()

"
5148569,ALDS1_10_C,"def lcs(a: str, b: str):
    L = []
#    r=1
    for bk in b:
#        print('ループ：'+str(r)+'回目')
        bgn_idx = 0  # 検索開始位置
        for i, cur_idx in enumerate(L):
            # ※1
            chr_idx = a.find(bk, bgn_idx) + 1
#            print('chr_idx：'+str(chr_idx))
#            print('bk：'+str(bk))
#            print('bgn_idx：'+str(bgn_idx))

            if not chr_idx:
#                print('chr_idxなしでbreak')
                break
            L[i] = min(cur_idx, chr_idx)
#            print('リストL：')
#            print(L)
            bgn_idx = cur_idx
#            print('bgn_idxをcur_idxに書き換え：'+str(bgn_idx))
        else:
            # ※2
            chr_idx = a.find(bk, bgn_idx) + 1
#            print('elseブロック chr_idx：'+str(chr_idx))
#            print('elseブロック bk：'+str(bk))
#            print('elseブロック bgn_idx：'+str(bgn_idx))
            if chr_idx:
                L.append(chr_idx)
#                print('elseブロック リストL(chr_idx追加後)：')
#                print(L)
#        r+=1
    return len(L)

N=int(input())
X=''
Y=''

for r in range(N):
  X=input()
  Y=input()

  print(lcs(X,Y))
"
5299088,ALDS1_10_C,"""""""
URL:https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_10_C&lang=ja
DATE:2021/03/18
""""""
import sys
# sys.setrecursionlimit(10**9)
# from copy import deepcopy
# from decimal import Decimal
# from math import ceil,floor
# from collections import deque,Counter
# from heapq import heapify,heappop,heappush
# from itertools import accumulate,product,permutations,combinations,combinations_with_replacement
# from bisect import bisect_left,bisect_right
# from functools import lru_cache#@lru_cache(maxsize=None)

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines

read_int = lambda: int(readline())
read_ints = lambda: map(int,readline().split())
read_str = lambda: readline().rstrip()
read_strs = lambda: readline().rstrip().split()
read_ints_list = lambda: list(map(int,readline().split()))
read_ints_array = lambda h:list(list(map(int,readline().split())) for _ in range(h))
read_strs_list = lambda: list(map(str,list(readline().rstrip())))
read_strs_array = lambda h:list(list(readline().rstrip()) for _ in range(h))

# solve
def LCS(s1, s2):
    dp = []
    for s2_k in s2:
        bgn_idx = 0
        for i, cur_idx in enumerate(dp):
            chr_idx = s1.find(s2_k, bgn_idx) + 1
            if not chr_idx:
                break
            dp[i] = min(cur_idx, chr_idx)
            bgn_idx = cur_idx
        else:
            chr_idx = s1.find(s2_k, bgn_idx) + 1
            if chr_idx:
                dp.append(chr_idx)
    return len(dp)

def main():
    N = read_int()
    
    ans = []
    for i in range(N):
        x = input()
        y = input()
        
        ans.append(LCS(x,y))
        
    print('\n'.join(map(str,ans)))
                           
    return 0

if __name__=='__main__':
    main()
"
5910155,ALDS1_10_C,"def lcs(a, b):
    L = []
    for bk in b:
        bgn_idx = 0
        for i, cur_idx in enumerate(L):
            chr_idx = a.find(bk, bgn_idx) + 1
            if not chr_idx:
                break
            L[i] = min(chr_idx, cur_idx)
            bgn_idx = cur_idx
        else:
            chr_idx = a.find(bk, bgn_idx) + 1
            if chr_idx:
                L.append(chr_idx)
    return len(L)

n = int(input())
for _ in range(n):
    x = input()
    y = input()
    print(lcs(x, y))
"
5954422,ALDS1_10_C,"def lcs(s1, s2):
    dp = []
    for s2_k in s2:
        bgn_idx = 0
        for i, cur_idx in enumerate(dp):
            chr_idx = s1.find(s2_k, bgn_idx) + 1
            if not chr_idx:
                break
            dp[i] = min(cur_idx, chr_idx)
            bgn_idx = cur_idx
        else:
            chr_idx = s1.find(s2_k, bgn_idx) + 1
            if chr_idx:
                dp.append(chr_idx)
    return len(dp)

def solve():
    N = int(input())
    for _ in range(N):
        x = input()
        y = input()
        print(lcs(x, y))

if __name__ == '__main__':
    solve()
"
6360529,ALDS1_10_C,"def lcs(s1, s2):
    dp = []
    for s2_k in s2:
        bgn_idx = 0
        for i, cur_idx in enumerate(dp):
            chr_idx = s1.find(s2_k, bgn_idx) + 1
            if not chr_idx:
                break
            dp[i] = min(cur_idx, chr_idx)
            bgn_idx = cur_idx
        else:
            chr_idx = s1.find(s2_k, bgn_idx) + 1
            if chr_idx:
                dp.append(chr_idx)
    return len(dp)

def solve():
    N = int(input())
    for _ in range(N):
        x = input()
        y = input()
        print(lcs(x, y))

solve()
"
6702693,ALDS1_10_C,"import sys
import math
from collections import defaultdict, deque

sys.setrecursionlimit(10 ** 6)
stdin = sys.stdin

INF = float('inf')

ni = lambda: int(ns())
na = lambda: list(map(int, stdin.readline().split()))
ns = lambda: stdin.readline().strip()

def lcs(a: str, b: str):
    L = []
    for bk in b:
        bgn_idx = 0  # 検索開始位置
        for i, cur_idx in enumerate(L):
            # ※1
            chr_idx = a.find(bk, bgn_idx) + 1
            if not chr_idx:
                break
            L[i] = min(cur_idx, chr_idx)
            bgn_idx = cur_idx
        else:
            # ※2
            chr_idx = a.find(bk, bgn_idx) + 1
            if chr_idx:
                L.append(chr_idx)
    return len(L)

T = ni()
for _ in range(T):
    X = ns()
    Y = ns()
    print(lcs(X, Y))

"
4166920,ALDS1_10_C,"import sys, re
from collections import deque, defaultdict, Counter
from math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians
from itertools import permutations, combinations, product
from operator import itemgetter, mul
from copy import deepcopy
from string import ascii_lowercase, ascii_uppercase, digits
from fractions import gcd
from bisect import bisect_left

def input(): return sys.stdin.readline().strip()
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(): return list(map(int, input().split()))
sys.setrecursionlimit(10 ** 9)
INF = float('inf')
mod = 10 ** 9 + 7

def lcs(s1, s2):
    dp = []
    for s2_k in s2:
        bgn_idx = 0
        for i, cur_idx in enumerate(dp):
            chr_idx = s1.find(s2_k, bgn_idx) + 1
            if not chr_idx:
                break
            dp[i] = min(cur_idx, chr_idx)
            bgn_idx = cur_idx
        else:
            chr_idx = s1.find(s2_k, bgn_idx) + 1
            if chr_idx:
                dp.append(chr_idx)
    return len(dp)

q = INT()

for _ in range(q):
	S = input()
	T = input()
	print(lcs(S, T))

"
4263768,ALDS1_10_C,"def lcs(s1, s2):
    dp = []
    for s2_k in s2:
        bgn_idx = 0
        for i, cur_idx in enumerate(dp):
            chr_idx = s1.find(s2_k, bgn_idx) + 1
            if not chr_idx:
                break
            dp[i] = min(cur_idx, chr_idx)
            bgn_idx = cur_idx
        else:
            chr_idx = s1.find(s2_k, bgn_idx) + 1
            if chr_idx:
                dp.append(chr_idx)
    return len(dp)


n = int(input())
for _ in range(n):
    x = input()
    y = input()
    print(lcs(x, y))


"
4572610,ALDS1_10_C,"def lcs(s1, s2):
    if len(s1) < len(s2):
      s1, s2 = s2, s1
    dp = []
    for s2_k in s2:
        #print(dp)
        bgn_idx = 0
        for i, cur_idx in enumerate(dp):#要素とそのindexを取得
            #s2_kをs1のbgn_idx番目以降から探す
            chr_idx = s1.find(s2_k, bgn_idx) + 1
            #print(s2_k, i, cur_idx, chr_idx, dp)
            if not chr_idx:#0だったらTrue#findは見つからないとき - 1を返す
                break
            dp[i] = min(cur_idx, chr_idx)
            #print(dp)
            bgn_idx = cur_idx
            
        else:#breakされなければ読み込まれる。
            chr_idx = s1.find(s2_k, bgn_idx) + 1
            if chr_idx:#0だったらfalse
                dp.append(chr_idx)
            #print(dp)    
             
    return len(dp)


n = int(input())
for _ in range(n):
    x = input()
    y = input()
    print(lcs(x, y))
"
4642258,ALDS1_10_C,"def lcs(x,y):
    L=[]
    for chk in y:
        bg_i=0
        for i,chr_i in enumerate(L):
            cur_i=x.find(chk,bg_i)+1
            if not cur_i:
                break
            L[i]=min(cur_i,chr_i)
            bg_i=chr_i
        else:
            cur_i=x.find(chk,bg_i)+1
            if cur_i:
                L.append(cur_i)
    return len(L)

n=int(input())
ans=[]
for i in range(n):
    x=input()
    y=input()
    ans.append(lcs(x,y))
for i in ans:
    print(i)
"
4902341,ALDS1_10_C,"def lcs(s1, s2):
    dp = []
    for s2_k in s2:
        bgn_idx = 0
        for i, cur_idx in enumerate(dp):
            chr_idx = s1.find(s2_k, bgn_idx) + 1
            if not chr_idx:
                break
            dp[i] = min(cur_idx, chr_idx)
            bgn_idx = cur_idx
        else:
            chr_idx = s1.find(s2_k, bgn_idx) + 1
            if chr_idx:
                dp.append(chr_idx)
    return len(dp)

def solve():
    N = int(input())
    for _ in range(N):
        x = input()
        y = input()
        print(lcs(x, y))

if __name__ == '__main__':
    solve()
"
6652003,ALDS1_10_C,"import sys

sys.setrecursionlimit(10**9)


def lcs(a: str, b: str):
    L = []
    for bk in b:
        bgn_idx = 0  # 検索開始位置
        for i, cur_idx in enumerate(L):
            # ※1
            chr_idx = a.find(bk, bgn_idx) + 1
            if not chr_idx:
                break
            L[i] = min(cur_idx, chr_idx)
            bgn_idx = cur_idx
        else:
            # ※2
            chr_idx = a.find(bk, bgn_idx) + 1
            if chr_idx:
                L.append(chr_idx)
    return len(L)
 


q = int(input())

for _ in range(q):
	S = input()
	T = input()
	print(lcs(S,T))


"
4547073,ALDS1_10_C,"# novel様のコードを借りて提出のテストです。失礼します
def lcs(s1, s2):
    dp = []
    for s2_k in s2:
        bgn_idx = 0
        for i, cur_idx in enumerate(dp):
            chr_idx = s1.find(s2_k, bgn_idx) + 1
            if not chr_idx:
                break
            dp[i] = min(cur_idx, chr_idx)
            bgn_idx = cur_idx
        else:
            chr_idx = s1.find(s2_k, bgn_idx) + 1
            if chr_idx:
                dp.append(chr_idx)
    return len(dp)


n = int(input())
for _ in range(n):
    x = input()
    y = input()
    print(lcs(x, y))
"
4730196,ALDS1_10_C,"import sys, os, math, bisect, itertools, collections, heapq, queue, copy, array

# from scipy.sparse.csgraph import csgraph_from_dense, floyd_warshall
# from decimal import Decimal
# from collections import defaultdict, deque

sys.setrecursionlimit(10000000)

ii = lambda: int(sys.stdin.buffer.readline().rstrip())
il = lambda: list(map(int, sys.stdin.buffer.readline().split()))
fl = lambda: list(map(float, sys.stdin.buffer.readline().split()))
iln = lambda n: [int(sys.stdin.buffer.readline().rstrip()) for _ in range(n)]

iss = lambda: sys.stdin.buffer.readline().decode().rstrip()
sl = lambda: list(map(str, sys.stdin.buffer.readline().decode().split()))
isn = lambda n: [sys.stdin.buffer.readline().decode().rstrip() for _ in range(n)]

lcm = lambda x, y: (x * y) // math.gcd(x, y)

MOD = 10 ** 9 + 7
MAX = float('inf')


def lcs(X, Y):
    dp = []
    for y in Y:
        bgn_idx = 0
        for i, cur_idx in enumerate(dp):
            # 既に探索済みの最長文字列を更新
            chr_idx = X.find(y, bgn_idx) + 1
            if not chr_idx:
                break
            dp[i] = min(chr_idx, cur_idx)
            bgn_idx = cur_idx
        else:
            chr_idx = X.find(y, bgn_idx) + 1
            if chr_idx:
                dp.append(chr_idx)
    return len(dp)


def main():
    if os.getenv(""LOCAL""):
        sys.stdin = open(""input.txt"", ""r"")

    N = ii()
    for _ in range(N):
        X, Y = iss(), iss()
        print(lcs(X, Y))


if __name__ == '__main__':
    main()

"
5411622,ALDS1_10_C,"def longest(s1, s2):
    dp = []
    for s2_k in s2:
        start = 0
        for i, current in enumerate(dp):
            charpos = s1.find(s2_k, start) + 1
            if not charpos:
                break
            dp[i] = min(current, charpos)
            start = current
        else:
            charpos = s1.find(s2_k, start) + 1
            if charpos:
                dp.append(charpos)
    return len(dp)


n = int(input())
for _ in range(n):
    x = input()
    y = input()
    print(longest(x, y))
"
5412646,ALDS1_10_C,"def lcs(a, b):
  dp = []
  for bc in b:
    bi = 0
    for i, curi in enumerate(dp):
      ci = a.find(bc, bi) + 1
      if not ci: break
      dp[i] = min(curi, ci)
      bi = curi
    else:
      ci = a.find(bc, bi) + 1
      if ci: dp.append(ci)
  print(len(dp))

n = int(input())
for _ in range(n):
  a = input()
  b = input()
  lcs(a, b)

"
5462086,ALDS1_10_C,"
def resolve():
    def lcs(s1, s2):
        dp = []
        for s2_k in s2:
            bgn_idx = 0
            for i, cur_idx in enumerate(dp):
                chr_idx = s1.find(s2_k, bgn_idx) + 1
                if not chr_idx:
                    break
                dp[i] = min(cur_idx, chr_idx)
                bgn_idx = cur_idx
            else:
                chr_idx = s1.find(s2_k, bgn_idx) + 1
                if chr_idx:
                    dp.append(chr_idx)
        return len(dp)
    q = int(input())
    for i in range(q):
        S = str(input())
        T = str(input())
        print(lcs(S, T))


resolve()

"
5509948,ALDS1_10_C,"def lcs(s1, s2):
    dp = []
    for s2_k in s2:
        bgn_idx = 0
        for i, cur_idx in enumerate(dp):
            chr_idx = s1.find(s2_k, bgn_idx) + 1
            if not chr_idx:
                break
            dp[i] = min(cur_idx, chr_idx)
            bgn_idx = cur_idx
        else:
            chr_idx = s1.find(s2_k, bgn_idx) + 1
            if chr_idx:
                dp.append(chr_idx)
    return len(dp)

N = int(input())
for _ in range(N):
    x = input()
    y = input()
    print(lcs(x, y))
"
4223796,ALDS1_10_C,"def lcs(s1_raw, s2_raw):
    dp = []
    for s2 in s2_raw:
        start = 0
        for i, cnt in enumerate(dp):
            index = s1_raw.find(s2, start) + 1
            if not index:
                break
            else:
                dp[i]  = min(cnt , index)
                start = cnt
        index = s1_raw.find(s2, start) + 1
        if index:
            dp.append(index)
    return len(dp)


if __name__ == ""__main__"":
    q = int(input())
    for _ in range(q):
        x = input()
        y = input()
        print(lcs(x, y))
"
4993813,ALDS1_10_C,"def lcs(s1, s2):
    dp = []
    for s2_k in s2:
        bgn_idx = 0
        for i, cur_idx in enumerate(dp):
            chr_idx = s1.find(s2_k, bgn_idx) + 1
            if not chr_idx:
                break
            dp[i] = min(cur_idx, chr_idx)
            bgn_idx = cur_idx
        else:
            chr_idx = s1.find(s2_k, bgn_idx) + 1
            if chr_idx:
                dp.append(chr_idx)
    return len(dp)

def solve():
    N = int(input())
    for _ in range(N):
        x = input()
        y = input()
        print(lcs(x, y))

if __name__ == '__main__':
    solve()
"
5013070,ALDS1_10_C,"def lcs(a: str, b: str):
    L = []
    for bk in b:
        bgn_idx = 0  # 検索開始位置
        for i, cur_idx in enumerate(L):
            chr_idx = a.find(bk, bgn_idx) + 1
            if not chr_idx:
                break
            L[i] = min(cur_idx, chr_idx)
            bgn_idx = cur_idx
        else:
            chr_idx = a.find(bk, bgn_idx) + 1
            if chr_idx:
                L.append(chr_idx)
    return len(L)

def main():
    q = int(input())
    for _ in range(q):
        X = input()
        Y = input()
        print(lcs(X, Y))

if __name__ == ""__main__"":
    main()

"
6216289,ALDS1_10_C,"def LCS(s1, s2):
    """"""文字列の長さを求めるだけならこれが最速 (s1,s2は文字列)""""""
    dp = []
    for s2_k in s2:
        bgn_idx = 0
        for i, cur_idx in enumerate(dp):
            chr_idx = s1.find(s2_k, bgn_idx) + 1
            if not chr_idx:
                break
            dp[i] = min(cur_idx, chr_idx)
            bgn_idx = cur_idx
        else:
            chr_idx = s1.find(s2_k, bgn_idx) + 1
            if chr_idx:
                dp.append(chr_idx)
    # dpの長さが共通文字列長さ
    return len(dp)


N = int(input())
for _ in range(N):
    x = input()
    y = input()
    print(LCS(x, y))

"
5459958,ALDS1_10_C,"
q = int(input())
if q <1 or q> 150:
    sys.exit()


def lcs_finder(x, y):
    updated_lcs = []
    for character_y in y:
        start = 0
        for i, current in enumerate(updated_lcs):
            x_index = x.find(character_y, start) + 1

            #if current character in y is not in  x
            if x_index:
                updated_lcs[i] = min(current, x_index)
                start = current
            else:
                break
            
            
        else:
            x_index = x.find(character_y, start) + 1
            if x_index:
                updated_lcs.append(x_index)

    print(len(updated_lcs))


for x in range(q):
    a = input()
    b = input()
    (lcs_finder(a, b))
"
6374551,ALDS1_10_C,"def lcs(s1, s2):
    dp = []
    for s2_k in s2:
        bgn_idx = 0
        for i, cur_idx in enumerate(dp):
            chr_idx = s1.find(s2_k, bgn_idx) + 1
            if not chr_idx:
                break
            dp[i] = min(cur_idx, chr_idx)
            bgn_idx = cur_idx
        else:
            chr_idx = s1.find(s2_k, bgn_idx) + 1
            if chr_idx:
                dp.append(chr_idx)
    return len(dp)

def solve():
    N = int(input())
    for _ in range(N):
        x = input()
        y = input()
        print(lcs(x, y))

if __name__ == '__main__':
    solve()
"
7115153,ALDS1_10_C,"import sys, os, math, bisect, itertools, collections, heapq, queue, copy, array

# from scipy.sparse.csgraph import csgraph_from_dense, floyd_warshall
# from decimal import Decimal
# from collections import defaultdict, deque

sys.setrecursionlimit(10000000)

ii = lambda: int(sys.stdin.buffer.readline().rstrip())
il = lambda: list(map(int, sys.stdin.buffer.readline().split()))
fl = lambda: list(map(float, sys.stdin.buffer.readline().split()))
iln = lambda n: [int(sys.stdin.buffer.readline().rstrip()) for _ in range(n)]

iss = lambda: sys.stdin.buffer.readline().decode().rstrip()
sl = lambda: list(map(str, sys.stdin.buffer.readline().decode().split()))
isn = lambda n: [sys.stdin.buffer.readline().decode().rstrip() for _ in range(n)]

lcm = lambda x, y: (x * y) // math.gcd(x, y)

MOD = 10 ** 9 + 7
MAX = float('inf')


def lcs(X, Y):
    dp = []
    for y in Y:
        bgn_idx = 0
        for i, cur_idx in enumerate(dp):
            # 既に探索済みの最長文字列を更新
            chr_idx = X.find(y, bgn_idx) + 1
            if not chr_idx:
                break
            dp[i] = min(chr_idx, cur_idx)
            bgn_idx = cur_idx
        else:
            chr_idx = X.find(y, bgn_idx) + 1
            if chr_idx:
                dp.append(chr_idx)
    return len(dp)


def main():
    if os.getenv(""LOCAL""):
        sys.stdin = open(""input.txt"", ""r"")

    N = ii()
    for _ in range(N):
        X, Y = iss(), iss()
        print(lcs(X, Y))


if __name__ == '__main__':
    main()
"
8831683,ALDS1_10_C,"from sys import stdin
input = stdin.readline

N = 1000

def lcs(X,Y):
    c=[[0]*(N+1) for _ in range(N+1)]
    maxl = 0
    X = ' ' + X
    Y = ' ' + Y
    pre_row = c[0]
    for i, x in enumerate(X):
        if i==0:
            continue
        row = c[i]
        for j, y in enumerate(Y):
            if j == 0:
                continue
            if x == y:
                value = pre_row[j-1] + 1
                row[j] = value
                if maxl < value:
                    maxl = value
            else:
                pre_row_j = pre_row[j]
                row_j_1 = row[j-1]
                value = row_j_1
                if pre_row_j > row_j_1:
                    value = pre_row_j
                row[j] = value
        pre_row = row
    return maxl

n = int(input())
for _ in range(n):
    s1 = input()[:-1]
    s2 = input()[:-1]
    print(lcs(s1,s2))
"
3247389,ALDS1_10_C,"def lcs(s1, s2):
    dp = []
    for s2_k in s2:
        bgn_idx = 0
        for i, cur_idx in enumerate(dp):
            chr_idx = s1.find(s2_k, bgn_idx) + 1
            if not chr_idx:
                break
            dp[i] = min(cur_idx, chr_idx)
            bgn_idx = cur_idx
        else:
            chr_idx = s1.find(s2_k, bgn_idx) + 1
            if chr_idx:
                dp.append(chr_idx)
    return len(dp)


n = int(input())
for _ in range(n):
    x = input()
    y = input()
    print(lcs(x, y))

"
8968256,ALDS1_10_D,"import math

def main():
    n = int(input())
    p = list(map(float, input().split()))
    q = list(map(float, input().split()))
    expect_cost = solve_optimal_cost(n, p, q)
    print(f'{expect_cost:.08f}')

# 最適二分探索木の1回の探索コストの期待値を求める
def solve_optimal_cost(n, p, q):
    # opt_e[i][j], opt_ki[i][j]: 探索範囲[i,j]の最適二分探索木の探索コストの期待値、根のインデックスを保持
    opt_e = [[0]*(n+1) for _ in range(n+1)]
    opt_ki = [[-1]*(n+1) for _ in range(n+1)]
    
    ## 方針: p,qにおいて探索範囲[si,ei]を広げながら、各探索範囲における最適な根のインデックスを探す
    ## 探索範囲[si,ei]の部分木は、pはsi~(ei-1)までの要素、qはsi~eiまでの要素で構成される
    # 1. p,qはソート済のため、先に累積確率を求めておく
    # 累積確率: q->p->q の順で与えられた確率を足す
    sum_prb = [0]*(2*(n+1))
    # i//2 は、奇数iの場合、その前の偶数の位置
    for i in range(2*n + 1):
        sum_prb[i+1] = sum_prb[i] + (q[i//2] if i%2 == 0 else p[i//2])

    # 2. 根のみの部分木の探索コストの期待値・根のインデックスを求める（一番小さな部分問題）
    # si = eiの時、この部分木を構成する要素はq[i]のみのため、根のみの部分木となる
    # 根のみのため深さの考慮は不要で、確率がそのまま期待値を表す
    for i in range(n+1):
        opt_e[i][i] = q[i]
        opt_ki[i][i] = i
        
    # 3. 探索範囲を1,2,...,nと広げ、各範囲での部分木の最適な根のインデックス・左右木の探索コストを求める
    for length in range(1, n+1):
        for si in range(n-length+1):
            ei = si + length
            # opt_lrには、探索範囲[si,ei]の左右木の探索コストの期待値が入る
            opt_lr, opt_ki[si][ei] = solve_subtree_optimal(si, ei, opt_e, opt_ki)

            # opt_lrは部分問題のため、探索範囲[si,ei]の全体の最適二分探索木の探索コストの期待値opt_seを加える
            # opt_seは、範囲[si,ei]に含まれる全要素の確率の合計に相当
            # sum_prbは累積確率のため、範囲[si,ei]に含まれる全要素の確率の合計は
            # (ei-1)番目までのp, ei番目までのqの累積確率 － 0~(si-1)番目までのp,qの累積確率
            ## 例えば、範囲[1,2]で考えた時、範囲内の要素はpの1番目、qの1,2番目
            ## (0->)q->p->q->p->q から 最初のq->p->を引くということ
            ## sum_prb[0]は0なので、実際に累積確率が入っているのはsum_prb[1]以降
            opt_se = sum_prb[2*ei+1] - sum_prb[2*si]
            opt_e[si][ei] = opt_lr + opt_se

    return opt_e[0][n]

# 探索範囲[si,ei]の部分木における最適な根のインデックス・左右木の探索コストを求める
def solve_subtree_optimal(si, ei, opt_e, opt_ki):
    # 範囲[si,ei]の部分木の最適な根のインデックスをrとすると、
    # 範囲[si,(ei-1)]の最適二分探索木の根srは、r以下
    # ∵範囲[si,(ei-1)]は、範囲[si,ei]の部分問題であるためその最適な根srは必ず、より大きな問題の最適な根rより大きくならない
    # 同様に範囲[si,ei]は、範囲[(si+1),ei]の部分問題であるため、範囲[(si+1),ei]の最適な根er >= r と言える

    # 範囲[si,ei]の部分木について、rを基準に分割して解く
    # rが取り得る範囲（ループの終端のためerは+1）
    sr = opt_ki[si][ei-1]
    er = min(opt_ki[si+1][ei]+1, ei)
    opt_er = math.inf
    opt_r = si
    for r in range(sr, er):
        expect_cost = opt_e[si][r] + opt_e[r+1][ei]
        if expect_cost < opt_er:
            opt_er = expect_cost
            opt_r = r
    return opt_er, opt_r


if __name__ == '__main__':
    main()
"
8819821,ALDS1_10_D,"n = int(input())
p = list(map(float, input().split()))
q = list(map(float, input().split()))
cp = [0]
cq = [0]

# Cumulative Sum
for i in range(n):
    cp.append(cp[i] + p[i])
for i in range(n + 1):
    cq.append(cq[i] + q[i])

inf = 1e9
dp = [[inf] * (n + 1) for _ in range(n + 1)]
pos = [[0] * (n + 1) for _ in range(n + 1)]

for i in range(n + 1):
    pos[i][i] = i
for i in range(n + 1):
    dp[i][i] = q[i]

for x in range(1, n + 1):
    for i in range(n + 1):
        if i + x >= n + 1: break
        j = i + x
        mx = inf
        pos[i][j] = pos[i][j - 1]
        left, right = pos[i][j - 1], min(n, pos[i + 1][j] + 1)

        for k in range(left, right):
            plus = (dp[i][k] + dp[k + 1][j]) + cp[j] - cp[i] + cq[j + 1] - cq[i]
            if plus < mx:
                mx = plus
                pos[i][j] = k

        dp[i][j] = mx

print(dp[0][n])

"
5477817,ALDS1_10_D,"# haven't submitted yet

def func():
    for i in range(0, (2 * n) + 1):
        if i % 2 == 0:
            S[i + 1] = S[i] + Q[i // 2]
        else:
            S[i + 1] = S[i] + P[i // 2]

    for left in range(1, n + 1):
        for i in range(n + 1 - left):
            tmp = 1e30
            j = left + i
            k0 = K[i][j - 1]
            k1 = K[i + 1][j]
            k2 = None
            for k in range(k0, min(k1 + 1, j)):
                v = C[i][k] + C[k + 1][j]
                if v < tmp:
                    k2 = k
                    tmp = v
            K[i][j] = k2
            C[i][j] = tmp + (S[(2 * j) + 1] - S[2 * i])

    return C


n = int(input())
*P, = map(float, input().split())
*Q, = map(float, input().split())

K = [[0] * (n + 1) for i in range(n + 1)]
C = [[0] * (n + 1) for j in range(n + 1)]
for j in range(0, n + 1):
    C[j][j] = Q[j]
    K[j][j] = j
S = [0] * ((2 * n) + 2)

ans_array = func()

print(""%.8f"" % ans_array[0][n])

"
5485160,ALDS1_10_D,"N = int(input())

K = [[None]*(N+1) for i in range(N+1)]
C = [[None]*(N+1) for i in range(N+1)]
S = [0]*(2*N+2)

*X, = map(float, input().split())
*Y, = map(float, input().split())

def modification():
    #modify values of S
    for i in range(2*N+1):
        if i % 2:
            S[i+1] = S[i] + X[i//2]
        else:
            S[i+1] = S[i] + Y[i//2]


    #modify values of C and K
    for i in range(N+1):
        C[i][i] = Y[i]
        K[i][i] = i

def calculation():
    for a in range(1, N+1):
        for b in range(N+1-a):
            c = a+b
            extra = 1e30
            first = K[b][c-1]
            second = K[b+1][c]
            third = None
            for d in range(first, min(second+1, c)):
                v = C[b][d] + C[d+1][c]
                if v < extra:
                    third = d
                    extra = v
            K[b][c] = third
            C[b][c] = extra + (S[2*c+1] - S[2*b])

modification()
calculation()
#print (C[0][n-1])
#print (C[0][N])
print(""%.10f\n"" % C[0][N])


"
5621993,ALDS1_10_D,"from sys import stdin

INF = float(""inf"")

def culc_search_cost(p_key,p_dummy):
    size = len(p_dummy)
    weight = [[0]*size for _ in range(size)]
    cost = [[0]*size for _ in range(size)]
    Knuth_Yao = [[0]*size for _ in range(size)]

    for i in range(size):
        weight[i][i] = p_dummy[i]
    for i in range(size-1):
        weight[i+1][i] = -p_key[i]

    for lc in range(1,size):
        for i in range(size-lc):
            weight[i][i+lc] = (weight[i][i+lc-1]
                               + weight[i+1][i+lc]
                               - weight[i+1][i+lc-1])

    for i in range(size):
        cost[i][i] = weight[i][i]
    for i in range(size-1):
        cost[i][i+1] = weight[i][i+1] + cost[i][i] + cost[i+1][i+1]
        Knuth_Yao[i][i+1] = i
    for lc in range(2,size):
        for i in range(size-lc):
            min_cost = INF
            for j in range(Knuth_Yao[i][i+lc-1],Knuth_Yao[i+1][i+lc]+1):
                current = cost[i][j] + cost[j+1][i+lc]
                if current <= min_cost:
                     min_cost = current
                     min_index = j
            cost[i][i+lc] = weight[i][i+lc] + min_cost
            Knuth_Yao[i][i+lc] = min_index
    return cost[0][size-1]

def main():
    n = int(stdin.readline().rstrip())
    lst_p = list(map(float, stdin.readline().rstrip().split()))
    lst_q = list(map(float, stdin.readline().rstrip().split()))

    print(culc_search_cost(lst_p,lst_q))


main()
"
7070560,ALDS1_10_D,"#!/usr/bin/env pypy3

"""""" c.durr - 2022 - CSES -
IITKESO207SPA3C - Optimal BST
https://www.spoj.com/problems/IITKESO207SPA3C/

Knuth, D. E. (1971). 
Optimum binary search trees. 
Acta Informatica, 1(1), 14–25. 
doi:10.1007/BF00264289 
https://doi.org/10.1007/BF00264289
""""""

import sys

def readint(): return int(sys.stdin.readline())
def readstr(): return sys.stdin.readline().strip()
def readints(): return list(map(int, readstr().split()))
def readfloats(): return list(map(float, readstr().split()))


def optimal_search_tree(alpha, beta):
    """""" Compute an optimal search tree

    :param alpha, beta: lists of probability weights index from 0 to n (included)
    :assumes: beta[0] = 0
    :returns: weighted path length of optimal tree and the actual tree. 
              A tree is either an empty list or a list of the form [left, root, right].
    :complexity: O(n^2)
    """"""
    n = len(alpha) - 1
    P = [[0 for j in range(n+1)] for i in range(n+1)] #
    W = [[0 for j in range(n+1)] for i in range(n+1)]
    R = [[0 for j in range(n+1)] for i in range(n+1)]

    for i in range(n + 1):
        # empty trees
        P[i][i] = W[i][i] = alpha[i]
        # weight of index range
        for j in range(i + 1, n + 1):
            W[i][j] = W[i][j - 1] + beta[j] + alpha[j]

    # single node trees
    for i in range(n):
        j = i + 1
        R[i][j] = j
        P[i][j] = P[i][i] + P[j][j] + W[i][j]  
    
    # recursion
    for j_i in range(2, n + 1): # difference between j and i
        for i in range(n - j_i + 1):
            j = i + j_i
            argmin = None
            valmin = float('+inf')
            for r in range(R[i][j - 1], R[i + 1][j] + 1):
                alt = P[i][r - 1] + P[r][j]
                if alt < valmin:
                    valmin = alt
                    argmin = r 
            P[i][j] = W[i][j] + valmin
            R[i][j] = argmin 
     
    # extract solution
    tree = extract_tree(R, 0, n)
    return P[0][n], tree 


def extract_tree(R, i, j):
    if i >= j:
        return []
    else:
        root = R[i][j]
        left = extract_tree(R, i, root - 1)
        right = extract_tree(R, root, j)
        return [left, root, right]


def print_tree(tree):
    print(""("", end="""")
    if tree:
        left, root, right = tree 
        print(root, end="""")
        if left or right:
            print_tree(left)
            print_tree(right)
    print("")"", end="""")


if  __name__ == ""__main__"":
        
    n = readint()
    beta = [0] + readfloats()
    alpha = readfloats()
    val, tree = optimal_search_tree(alpha, beta)
    print(val)
    
"
3998158,ALDS1_10_D,"import sys
readline = sys.stdin.readline
write = sys.stdout.write

N = int(readline())
*P, = map(float, readline().split())
*Q, = map(float, readline().split())

K = [[None]*(N+1) for i in range(N+1)]
C = [[None]*(N+1) for i in range(N+1)]
S = [0]*(2*N+2)
for i in range(2*N+1):
    S[i+1] = S[i] + (P[i//2] if i % 2 else Q[i//2])

for i in range(N+1):
    C[i][i] = Q[i]
    K[i][i] = i

for l in range(1, N+1):
    for i in range(N+1-l):
        j = i+l
        k0 = K[i][j-1]; k1 = K[i+1][j]
        tmp = 1e30
        k2 = None
        for k in range(k0, min(k1+1, j)):
            v = C[i][k] + C[k+1][j]
            if v < tmp:
                k2 = k
                tmp = v
        K[i][j] = k2
        C[i][j] = tmp + (S[2*j+1] - S[2*i])
write(""%.10f\n"" % C[0][N])

"
3199555,ALDS1_10_D,"import sys
readline = sys.stdin.readline
write = sys.stdout.write

N = int(readline())
*P, = map(float, readline().split())
*Q, = map(float, readline().split())

K = [[None]*(N+1) for i in range(N+1)]
C = [[None]*(N+1) for i in range(N+1)]
S = [0]*(2*N+2)
for i in range(2*N+1):
    S[i+1] = S[i] + (P[i//2] if i % 2 else Q[i//2])

for i in range(N+1):
    C[i][i] = Q[i]
    K[i][i] = i

for l in range(1, N+1):
    for i in range(N+1-l):
        j = i+l
        k0 = K[i][j-1]; k1 = K[i+1][j]
        tmp = 1e30
        k2 = None
        for k in range(k0, min(k1+1, j)):
            v = C[i][k] + C[k+1][j]
            if v < tmp:
                k2 = k
                tmp = v
        K[i][j] = k2
        C[i][j] = tmp + (S[2*j+1] - S[2*i])
write(""%.10f\n"" % C[0][N])
"
5415696,ALDS1_10_D,"from sys import stdin
import math

N = int(stdin.readline())
P = list(map(float, stdin.readline().split()))
Q = list(map(float, stdin.readline().split()))

K = [[None]*(N+1) for i in range(N+1)]
C = [[None]*(N+1) for i in range(N+1)]
S = [0]*(2*N+2)
for i in range(2*N+1):
  S[i+1] = S[i] + (P[i//2] if i % 2 else Q[i//2])

for i in range(N+1):
  C[i][i] = Q[i]
  K[i][i] = i

for l in range(1, N+1):
  for i in range(N+1-l):
    j = i+l
    k0 = K[i][j-1]; k1 = K[i+1][j]
    tmp = math.inf
    k2 = None
    for k in range(k0, min(k1+1, j)):
      v = C[i][k] + C[k+1][j]
      if v < tmp:
        k2 = k
        tmp = v
    K[i][j] = k2
    C[i][j] = tmp + (S[2*j+1] - S[2*i])
print(C[0][N])

"
3791054,ALDS1_10_D,"if __name__ == ""__main__"":
    num_nodes = int(input())
    P = list(map(lambda x: float(x), input().split()))
    Q = list(map(lambda x: float(x), input().split()))

    Depth = [[0] * (num_nodes + 1) for i in range(num_nodes + 1)]
    Exp = [[0.0] * (num_nodes + 1) for i in range(num_nodes + 1)]
    Cum_prob = [0.0] * (2 * num_nodes + 2)

    for i in range(2 * num_nodes + 1):
        Cum_prob[i + 1] = Cum_prob[i] + (P[i // 2] if i % 2 else Q[i // 2])

    for i in range(num_nodes + 1):
        Exp[i][i] = Q[i]
        Depth[i][i] = i

    for l in range(1, num_nodes + 1):
        for i in range(num_nodes + 1 - l):
            j = i + l
            d0 = Depth[i][j - 1]
            d1 = Depth[i + 1][j]
            d2 = -1
            cost = 1e30
            for k in range(d0, min(d1 + 1, j)):
                v = Exp[i][k] + Exp[k + 1][j]
                if v < cost:
                    d2 = k
                    cost = v
            Depth[i][j] = d2
            Exp[i][j] = cost + Cum_prob[2 * j + 1] - Cum_prob[2 * i]

    print(f""{Exp[0][num_nodes]:.5f}"")

"
4263769,ALDS1_10_D,"import sys
readline = sys.stdin.readline
write = sys.stdout.write

N = int(readline())
*P, = map(float, readline().split())
*Q, = map(float, readline().split())

K = [[None]*(N+1) for i in range(N+1)]
C = [[None]*(N+1) for i in range(N+1)]
S = [0]*(2*N+2)
for i in range(2*N+1):
    S[i+1] = S[i] + (P[i//2] if i % 2 else Q[i//2])

for i in range(N+1):
    C[i][i] = Q[i]
    K[i][i] = i

for l in range(1, N+1):
    for i in range(N+1-l):
        j = i+l
        k0 = K[i][j-1]; k1 = K[i+1][j]
        tmp = 1e30
        k2 = None
        for k in range(k0, min(k1+1, j)):
            v = C[i][k] + C[k+1][j]
            if v < tmp:
                k2 = k
                tmp = v
        K[i][j] = k2
        C[i][j] = tmp + (S[2*j+1] - S[2*i])
write(""%.10f\n"" % C[0][N])

"
5011757,ALDS1_10_D,"import sys
readline = sys.stdin.readline
write = sys.stdout.write

N = int(readline())
*P, = map(float, readline().split())
*Q, = map(float, readline().split())

K = [[None]*(N+1) for i in range(N+1)]
C = [[None]*(N+1) for i in range(N+1)]
S = [0]*(2*N+2)
for i in range(2*N+1):
    S[i+1] = S[i] + (P[i//2] if i % 2 else Q[i//2])

for i in range(N+1):
    C[i][i] = Q[i]
    K[i][i] = i

for l in range(1, N+1):
    for i in range(N+1-l):
        j = i+l
        k0 = K[i][j-1]; k1 = K[i+1][j]
        tmp = 1e30
        k2 = None
        for k in range(k0, min(k1+1, j)):
            v = C[i][k] + C[k+1][j]
            if v < tmp:
                k2 = k
                tmp = v
        K[i][j] = k2
        C[i][j] = tmp + (S[2*j+1] - S[2*i])
write(""%.10f\n"" % C[0][N])
"
5411649,ALDS1_10_D,"N = int(input())
*P, = map(float, input().split())
*Q, = map(float, input().split())

K = [[None]*(N+1) for i in range(N+1)]
C = [[None]*(N+1) for i in range(N+1)]
S = [0]*(2*N+2)
for i in range(2*N+1):
    S[i+1] = S[i] + (P[i//2] if i % 2 else Q[i//2])

for i in range(N+1):
    C[i][i] = Q[i]
    K[i][i] = i

for l in range(1, N+1):
    for i in range(N+1-l):
        j = i+l
        k0 = K[i][j-1]; k1 = K[i+1][j]
        tmp = 1e30
        k2 = None
        for k in range(k0, min(k1+1, j)):
            v = C[i][k] + C[k+1][j]
            if v < tmp:
                k2 = k
                tmp = v
        K[i][j] = k2
        C[i][j] = tmp + (S[2*j+1] - S[2*i])
print(C[0][N])


"
6525050,ALDS1_10_D,"import sys
readline = sys.stdin.readline
write = sys.stdout.write

N = int(readline())
*P, = map(float, readline().split())
*Q, = map(float, readline().split())

K = [[None]*(N+1) for i in range(N+1)]
C = [[None]*(N+1) for i in range(N+1)]
S = [0]*(2*N+2)
for i in range(2*N+1):
    S[i+1] = S[i] + (P[i//2] if i % 2 else Q[i//2])

for i in range(N+1):
    C[i][i] = Q[i]
    K[i][i] = i

for l in range(1, N+1):
    for i in range(N+1-l):
        j = i+l
        k0 = K[i][j-1]; k1 = K[i+1][j]
        tmp = 1e30
        k2 = None
        for k in range(k0, min(k1+1, j)):
            v = C[i][k] + C[k+1][j]
            if v < tmp:
                k2 = k
                tmp = v
        K[i][j] = k2
        C[i][j] = tmp + (S[2*j+1] - S[2*i])
write(""%.10f\n"" % C[0][N])

"
8152320,ALDS1_10_D,"# -*- coding: utf-8 -*-
from sys import stdin
input = stdin.readline

n = int(input())
*P, = map(float, input().split())
*Q, = map(float, input().split())

S = [0]*(2*n+2)
for i in range(2*n+1):
    S[i+1] = S[i] + (P[i//2] if i % 2 else Q[i//2])

K = [[None]*(n+1) for i in range(n+1)]
C = [[None]*(n+1) for i in range(n+1)]
for i in range(n+1):
    C[i][i] = Q[i]
    K[i][i] = i

for l in range(1, n+1):
    for i in range(n+1-l):
        j = i+l
        k0 = K[i][j-1]; k1 = K[i+1][j]
        tmp = 100000000
        k2 = None
        for k in range(k0, min(k1+1, j)):
            v = C[i][k] + C[k+1][j]
            if v < tmp:
                k2 = k
                tmp = v
        K[i][j] = k2
        C[i][j] = tmp + (S[2*j+1] - S[2*i])

print(f""{C[0][n]:.5f}"")
"
5488286,ALDS1_10_D,"n=int(input())
A=[0.0]+[float(i) for i in input().split()]
B=[float(i) for i in input().split()]
W={}
E={}
for i in range(1,n+2):
    W[i,i-1] = B[i-1]
    E[i,i-1] = B[i-1],i
for i in range(1,n+1):
    for j in range(i,n+1):
        W[i,j] = W[i,j-1]+A[j]+B[j]
for i in range(1,n+1):
    E[i,i] = E[i,i-1][0] + E[i+1,i][0] + W[i,i],i
for h in range(1,n):
    for i in range(1,n-h+1):
        e = 1001,None
        j = i + h
        k0 = E[i,j-1][1]
        k1 = E[i+1,j][1]
        for r in range(k0,k1+1):
            tmp = E[i,r-1][0] + E[r+1,j][0] + W[i,j]
            if tmp < e[0]:
                e = tmp,r
        E[i,j] = e
print(E[1,n][0])

"
3223197,ALDS1_10_D,"n=int(input())
A=[0.0]+[float(i) for i in input().split()]
B=[float(i) for i in input().split()]
W={}
E={}
for i in range(1,n+2):
    W[i,i-1] = B[i-1]
    E[i,i-1] = B[i-1],i
for i in range(1,n+1):
    for j in range(i,n+1):
        W[i,j] = W[i,j-1]+A[j]+B[j]
for i in range(1,n+1):
    E[i,i] = E[i,i-1][0] + E[i+1,i][0] + W[i,i],i
for h in range(1,n):
    for i in range(1,n-h+1):
        e = 1001,None
        j = i + h
        k0 = E[i,j-1][1]
        k1 = E[i+1,j][1]
        for r in range(k0,k1+1):
            tmp = E[i,r-1][0] + E[r+1,j][0] + W[i,j]
            if tmp < e[0]:
                e = tmp,r
        E[i,j] = e
print(E[1,n][0])
"
5462853,ALDS1_10_D,"n=int(input())
A=[0.0]+[float(i) for i in input().split()]
B=[float(i) for i in input().split()]
P={}
Q={}
for i in range(1,n+2):
    P[i,i-1] = B[i-1]
    Q[i,i-1] = B[i-1],i
for i in range(1,n+1):
    for j in range(i,n+1):
        P[i,j] = P[i,j-1]+A[j]+B[j]
for i in range(1,n+1):
    Q[i,i] = Q[i,i-1][0] + Q[i+1,i][0] + P[i,i],i
for h in range(1,n):
    for i in range(1,n-h+1):
        e = 1001,None
        j = i + h
        k0 = Q[i,j-1][1]
        k1 = Q[i+1,j][1]
        for r in range(k0,k1+1):
            temp = Q[i,r-1][0] + Q[r+1,j][0] + P[i,j]
            if temp < e[0]:
                e = temp,r
        Q[i,j] = e
print(Q[1,n][0])
"
9128543,ALDS1_10_D,"import math
def OBST():
    n = int(input())
    p = list(map(float, input().split()))  # n 個
    q = list(map(float, input().split()))  # n + 1 個
    dp = [[0]*(n+1) for _ in range(n+1)]
    dp2 = [[math.inf]*(n+1) for _ in range(n+1)]
    
    def OBST2(i: int, j:int) -> float:
        if i == j: return q[i]
        if dp[i][j] != 0: return dp[i][j]
        min_ = math.inf
        q_sum = sum(q[i:j+1])
        p_sum = sum(p[i:j])
        for k in range(i,j):
            if (k < dp2[i][j-1] and dp2[i][j-1] != math.inf) or k > dp2[i+1][j]: continue
            cost = OBST2(i, k) + OBST2(k + 1, j) + p_sum + q_sum
            if cost < min_:
                dp2[i][j] = k
                min_ = cost
        
        dp[i][j] = min_
        return dp[i][j]
    
    print(OBST2(0, n))
OBST()
"
6321112,ALDS1_10_D,"n = int(input())
A = [0.0] + [float(i) for i in input().split()]
B = [float(i) for i in input().split()]
W = {}
E = {}
for i in range(1, n+2):
    W[i, i-1] = B[i-1]
    E[i, i-1] = B[i-1], i
    
for i in range(1, n+1):
    for j in range(i, n+1):
        W[i, j] = W[i, j-1] + A[j] + B[j]
        
for i in range(1, n+1):
    E[i, i] = E[i, i-1][0] + E[i+1, i][0] + W[i, i], i
    
for h in range(1, n):
    for i in range(1, n-h+1):
        e = 1001, None
        j = i + h
        k0 = E[i, j-1][1]
        k1 = E[i+1, j][1]
        for r in range(k0, k1+1):
            tmp = E[i,r-1][0] + E[r+1, j][0] + W[i, j]
            if tmp < e[0]:
                e = tmp, r
        E[i, j] = e
print(E[1, n][0])
"
8966775,ALDS1_10_D,"from itertools import accumulate


def run(pn, qn):
    rn = []
    for i in range(len(pn)):
        rn.append(qn[i])
        rn.append(pn[i])
    rn.append(qn[-1])

    sn = tuple(accumulate(rn, initial=0.0))

    memo = [0.0] * (1010 * 1010)
    for i in range(len(rn)):
        memo[i * 1011 + 1] = rn[i]

    for length in range(3, len(rn) + 1, 2):
        for left in range(0, len(rn) - length + 1, 2):
            right = left + length
            value = min(memo[left * 1010 + i] + memo[(i + 1) * 1010 + right] for i in range(left + 1, right, 2))
            memo[left * 1010 + right] = value + sn[right] - sn[left]

    return memo[len(rn)]


if __name__ == ""__main__"":
    N = int(input())
    PN = tuple(map(float, input().split()))
    QN = tuple(map(float, input().split()))
    print(run(PN, QN))

"
8519829,ALDS1_10_D,"def g(): return [int(f.replace('.', '')) for f in input().split()]
def t(a, t = 0): return [0] + [(t := t + i) for i in a]

n = int(input()) + 1
a = t(g())
b = [[] for _ in range(n)]
b[0] = g()
bt = t(b[0])

for r in range(1, n):
     for i in range(n - r):
         ir = i + r
         b[r].append(min([b[m - i][i] + b[ir - m - 1][m + 1] for m in range(i, ir)]) + a[ir] - a[i] + bt[ir + 1] - bt[i])

print(b[-1][0] / 10000)

"
8244265,ALDS1_10_D,"def OptimalBST(p, q, n):
    e = [[0] * (n+1) for _ in range(n+1)]
    w = [[0] * (n+1) for _ in range(n+1)]
    for i in range(n+1):
        e[i][i] = q[i]
        w[i][i] = q[i]
    for l in range(1, n+1):
        for i in range(n-l+1):
            j = i + l
            e[i][j] = float(""inf"")
            w[i][j] = w[i][j-1] + p[j] + q[j]
            for r in range(i+1, j+1):
                t = e[i][r-1] + e[r][j] + w[i][j]
                if t < e[i][j]:
                    e[i][j] = t
    return e

def main():
    n = int(input())
    P = list(map(float, input().split())) # n:   1 to n
    P.insert(0, 0.00)
    Q = list(map(float, input().split())) # n+1: 0 to n


    print(""{:.5f}"".format(OptimalBST(P, Q, n)[0][n]))


if __name__ == '__main__':
    main()
"
5255960,ALDS1_10_D,"def main():
    n = int(input())
    _p = list(map(float, input().split()))
    _q = list(map(float, input().split()))
    p = []
    q = []
    for e in _p:
        p.append(int(round(e * 10000)))
    for e in _q:
        q.append(int(round(e * 10000)))
    acc = [0, q[0]]
    tmp = q[0]

    for i in range(n):
        tmp += p[i]
        acc.append(tmp)
        tmp += q[i + 1]
        acc.append(tmp)
    
    inf = 10 ** 10

    dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]

    for i in range(n + 1):
        dp[i][i + 1] = q[i]
        dp[i + 1][i] = dp[i][i + 1]

    for d in range(2, n + 2):
        for l in range(0, n - d + 2):
            r = l + d
            val = inf
            dpl = dp[l]
            dpr = dp[r]
            for i in range(l + 1, r):
                t = dpl[i] + dpr[i]
                if val > t:
                    val = t
            dp[l][r] = val + acc[2 * r - 1] - acc[2 * l]
            dp[r][l] = dp[l][r]

    print(dp[0][n + 1] / 10000)

if __name__ == ""__main__"":
    main()
"
5422351,ALDS1_10_D,"def func():

    n = int(input())
    p = [0.00] + list(map(float, input().split()))
    q = list(map(float, input().split()))

    arrW =[[None] * (n + 1) for i in range(n + 1)]
    arrC =[[0.00] * (n + 1) for i in range(n + 1)]

    for x in range(n + 1):
        arrW[0][x] = q[x]

    for row in range(1, n + 1):
        for i in range(n + 1 - row):
            
            j = row + i
            arrW[row][i] = arrW[row - 1][i] + p[j] + q[j]

            temp = float('inf')

            for k in range(i + 1, j + 1):
                curr = arrC[k - 1 - i][i] + arrC[j - k][k]
                if temp > curr:
                    temp = curr

            arrC[row][i] = temp + arrW[row][i]

    print(arrC[n][0] + sum(q))
    return

func()
"
5853513,ALDS1_10_D,"def main():

    n = int(input())
    p = list(map(float, input().split()))
    q = list(map(float, input().split()))
    dp = [[0] * (n + 1) for _ in range(n + 1)]
    sump = [0, q[0], ]
    temp = q[0]

    for i in range(n):
        temp += p[i]
        sump.append(temp)
        temp += q[i + 1]
        sump.append(temp)
    
    for i in range(n + 1):
        dpi = dp[i]
        dpi[i] = q[i]
        for j in range(i - 1, -1, -1):
            ma = dp[j][j] + dpi[j+1]
            for k in range(1, i - j):
                mak = dp[j+k][j] + dpi[j+k+1]
                if ma > mak:
                    ma = mak
            dpi[j] = ma + sump[2 * i + 1] - sump[2 * j]
            
    print(dp[n][0])

main()


"
5068391,ALDS1_10_D,"def main():

    n = int(input())
    p = list(map(float, input().split()))
    q = list(map(float, input().split()))
    dp = [[0] * (n + 1) for _ in range(n + 1)]
    sump = [0, q[0], ]
    temp = q[0]

    for i in range(n):
        temp += p[i]
        sump.append(temp)
        temp += q[i + 1]
        sump.append(temp)
    
    for i in range(n + 1):
        dpi = dp[i]
        dpi[i] = q[i]
        for j in range(i - 1, -1, -1):
            ma = dp[j][j] + dpi[j+1]
            for k in range(1, i - j):
                mak = dp[j+k][j] + dpi[j+k+1]
                if ma > mak:
                    ma = mak
            dpi[j] = ma + sump[2 * i + 1] - sump[2 * j]
            
    print(dp[n][0])

main()

"
5586173,ALDS1_10_D,"import sys

# READ_FROM_FILE = True
READ_FROM_FILE = False


def main():
    if READ_FROM_FILE:
        f = open('test0.txt', 'r')
    else:
        f = sys.stdin

    n = int(f.readline())
    p = list(map(float, f.readline().split()))
    q = list(map(float, f.readline().split()))
    dp = [[0] * (n + 1) for _ in range(n + 1)]
    sum_p = [0, q[0], ]
    tmp = q[0]

    for i in range(n):
        tmp += p[i]
        sum_p.append(tmp)
        tmp += q[i + 1]
        sum_p.append(tmp)

    for i in range(n + 1):
        dpi = dp[i]
        dpi[i] = q[i]
        for j in range(i - 1, -1, -1):
            ma = dp[j][j] + dpi[j + 1]
            for k in range(1, i - j):
                mak = dp[j + k][j] + dpi[j + k + 1]
                if ma > mak:
                    ma = mak
            dpi[j] = ma + sum_p[2 * i + 1] - sum_p[2 * j]

    print(dp[n][0])
    if READ_FROM_FILE:
        f.close()
    return


if __name__ == '__main__':
    main()

"
5071573,ALDS1_10_D,"
def optimal_cost(n, kp, dp):
    sums = [sum(kp[0:i]) + sum(dp[0:i+1]) for i in range(n+1)]
    expects = [[kp[i] + (dp[i] + dp[i+1])*2 for i in range(n)]]

    for w in range(2, n+1):
        exps = []
        for i in range(n-w+1):
            j = i + w
            exp = min(dp[i] + expects[j-i-2][i+1], expects[j-i-2][i] + dp[j])
            for k in range(i+1, j-1):
                _exp = expects[k-i-1][i] + expects[j-k-2][k+1]
                if exp > _exp:
                    exp = _exp
            exps.append(exp + sums[j] - sums[i] + dp[i])
        expects.append(exps)

    return expects[-1][0]


def run():
    n = int(input())
    ps = [float(x) for x in input().split()]
    qs = [float(x) for x in input().split()]

    print(""{:.8f}"".format(optimal_cost(n, ps, qs)))


if __name__ == '__main__':
    run()
"
3190826,ALDS1_10_D,"#!/usr/bin/env python3
# ALDS_10_D: Dynamic Programming - Optimal Binary Search Tree


def optimal_cost(n, kp, dp):
    sums = [sum(kp[0:i]) + sum(dp[0:i+1]) for i in range(n+1)]
    expects = [[kp[i] + (dp[i] + dp[i+1])*2 for i in range(n)]]

    for w in range(2, n+1):
        exps = []
        for i in range(n-w+1):
            j = i + w
            exp = min(dp[i] + expects[j-i-2][i+1], expects[j-i-2][i] + dp[j])
            for k in range(i+1, j-1):
                _exp = expects[k-i-1][i] + expects[j-k-2][k+1]
                if exp > _exp:
                    exp = _exp
            exps.append(exp + sums[j] - sums[i] + dp[i])
        expects.append(exps)

    return expects[-1][0]


def run():
    n = int(input())
    ps = [float(x) for x in input().split()]
    qs = [float(x) for x in input().split()]

    print(""{:.8f}"".format(optimal_cost(n, ps, qs)))


if __name__ == '__main__':
    run()

"
4194120,ALDS1_10_D,"def main():
    """"""最適二分探索木での探索一回あたりの期待値の最小値を求める
    """"""
    inf = 10*6
    n = int(input())
    # 内包よりはやい
    P = [0.0] + list(map(float, input().split()))
    Q = list(map(float, input().split()))
    E = [[0.0]*(n+1) for _ in range(n+1)]
    W = [[0.0]*(n+1) for _ in range(n+1)]
    for i in range(1, n+1):
        W[i][i] = Q[i-1] + P[i] + Q[i]
        E[i][i] = P[i] + (Q[i-1] + Q[i])*2
    for i in range(1, n+1):
        for j in range(i+1, n+1):
            W[i][j] = W[i][j-1] + P[j] + Q[j]
    for d in range(1, n):
        for i in range(1, n-d+1):
            j = i + d
            e = Q[i-1] + E[i+1][j] + W[i][j] 
            for k in range(i+1, j):
                ne =  E[i][k-1] + E[k+1][j] + W[i][j]
                if ne < e:
                    e = ne
            ne = E[i][j-1] + Q[j] + W[i][j]
            if ne < e:
                e = ne
            E[i][j] = e
    print(E[1][-1])

if __name__ == ""__main__"":
    main()
"
7764500,ALDS1_10_D,"n = int(input())
p = [0] + list(map(float, input().split()))
q = list(map(float, input().split()))

e = [[0]*(n+1) for _ in range(n+1)]
w = [[0]*(n+1) for _ in range(n+1)]
for i in range(n+1):
    e[i][i] = q[i]
    w[i][i] = q[i]
    
for k in range(1, n+1):
    for i in range(n-k+1):
        j = i+k
        w[i][j] = w[i][j-1] + p[j] + q[j]
        e[i][j] = min(e[i][r] + e[r+1][j] for r in range(i, j))
        e[i][j] += w[i][j]

print(e[0][n])
"
7592381,ALDS1_10_D,"n = int(input())
_p = list(map(float, input().split()))
_q = list(map(float, input().split()))
p = []
q = []
for e in _p:
    p.append(int(round(e * 10000)))
for e in _q:
    q.append(int(round(e * 10000)))
acc = [0, q[0]]
tmp = q[0]

for i in range(n):
    tmp += p[i]
    acc.append(tmp)
    tmp += q[i + 1]
    acc.append(tmp)

inf = 10 ** 10

dp = [[0 for _ in range(n + 2)] for _ in range(n + 2)]

for i in range(n + 1):
    dp[i][i + 1] = q[i]
    dp[i + 1][i] = dp[i][i + 1]

for d in range(2, n + 2):
    for l in range(0, n - d + 2):
        r = l + d
        val = inf
        dpl = dp[l]
        dpr = dp[r]
        for i in range(l + 1, r):
            t = dpl[i] + dpr[i]
            if val > t:
                val = t
        dp[l][r] = val + acc[2 * r - 1] - acc[2 * l]
        dp[r][l] = dp[l][r]

print(dp[0][n + 1] / 10000)

"
5462130,ALDS1_10_D,"def main():
    n = int(input())
    P = [0.0] + list(map(float, input().split()))
    Q = list(map(float, input().split()))
    E = [[0.0]*(n+1) for _ in range(n+1)]
    W = [[0.0]*(n+1) for _ in range(n+1)]
    for i in range(1, n+1):
        W[i][i] = Q[i-1] + P[i] + Q[i]
        E[i][i] = P[i] + (Q[i-1] + Q[i])*2
    for i in range(1, n+1):
        for j in range(i+1, n+1):
            W[i][j] = W[i][j-1] + P[j] + Q[j]
    for d in range(1, n):
        for i in range(1, n-d+1):
            j = i + d
            e = Q[i-1] + E[i+1][j] + W[i][j] 
            for k in range(i+1, j):
                ne =  E[i][k-1] + E[k+1][j] + W[i][j]
                if ne < e:
                    e = ne
            ne = E[i][j-1] + Q[j] + W[i][j]
            if ne < e:
                e = ne
            E[i][j] = e
    print(E[1][-1])

if __name__ == ""__main__"":
    main()

"
7651591,ALDS1_10_D,"import sys
import os
from math import inf

fn = ""inputdata.txt""
if os.path.exists(fn):
    sys.stdin = open(fn)


def optimizebinary(n):
    for d in range(1,n+1):
        for i in range(n+1-d):
            f=i+d
            for k in range(i,f):
                temp=mem[i][k]+mem[k+1][f]
                if temp<mem[i][f]:
                    mem[i][f]=temp
            suml[i][f]=suml[i][f-1]+K[f-1]+D[f]
            mem[i][f]+=suml[i][f]

n= int(sys.stdin.readline())
*K,=  map(float,sys.stdin.readline().split()) 
*D,=  map(float,sys.stdin.readline().split())

mem=[[inf]*(n+1) for _ in range(n+1)]
suml=[[inf]*(n+1) for _ in range(n+1)]

for i in range(n+1):
    mem[i][i]=D[i]
    suml[i][i]=D[i]

optimizebinary(n)
print(mem[0][n])
"
7612922,ALDS1_10_D,"def OptimalBST(p, q, n):
	e = [[0] * (n+1) for _ in range(n+1)]
	w = [[0] * (n+1) for _ in range(n+1)]
	for i in range(n+1):
		e[i][i] = q[i]
		w[i][i] = q[i]
	for l in range(1, n+1):
		for i in range(n-l+1):
			j = i + l
			e[i][j] = float(""inf"")
			w[i][j] = w[i][j-1] + p[j] + q[j]
			for r in range(i+1, j+1):
				t = e[i][r-1] + e[r][j] + w[i][j]
				if t < e[i][j]:
					e[i][j] = t
	return e
	
n = int(input())
p = list(map(float, input().split("" "")))
p.insert(0, 0.0)
q = list(map(float, input().split("" "")))

print(""{:.5f}"".format(OptimalBST(p, q, n)[0][n]))

"
7293278,ALDS1_10_D,"def OptimalBST(p, q, n):
	e = [[0] * (n+1) for _ in range(n+1)]
	w = [[0] * (n+1) for _ in range(n+1)]
	for i in range(n+1):
		e[i][i] = q[i]
		w[i][i] = q[i]
	for l in range(1, n+1):
		for i in range(n-l+1):
			j = i + l
			e[i][j] = float(""inf"")
			w[i][j] = w[i][j-1] + p[j] + q[j]
			for r in range(i+1, j+1):
				t = e[i][r-1] + e[r][j] + w[i][j]
				if t < e[i][j]:
					e[i][j] = t
	return e
	
n = int(input())
p = list(map(float, input().split("" "")))
p.insert(0, 0.0)
q = list(map(float, input().split("" "")))

print(""{:.5f}"".format(OptimalBST(p, q, n)[0][n]))
"
4702270,ALDS1_10_D,"import sys
def input():
    return sys.stdin.readline()[:-1]
    
n = int(input())
p = [None] + list(map(float, input().split()))
q = list(map(float, input().split()))
T = [[500 for i in range(n+1)] for j in range(n+1)]

psum = [0] * (n+1)
qsum = [0] * (n+1)
qsum[0] = q[0]
for i in range(1,n+1):
    psum[i] = psum[i-1] + p[i]
    qsum[i] = qsum[i-1] + q[i]
    
for i in range(1,n+1):
    T[i][i] = p[i] + (q[i-1] + q[i])*2
    
for l in range(2,n+1):
    for i in range(1,n-l+1+1):
        val_list = [T[i][j] + T[j+2][i+l-1] for j in range(i,i+l-2)]
        val_list.append(T[i][i+l-2] + q[i+l-1])
        val_list.append(T[i+1][i+l-1] + q[i-1])
        if i-2>=0:
            w = psum[i+l-1]-psum[i-1] + qsum[i+l-1]-qsum[i-2]
        else:
            w = psum[i+l-1]-psum[i-1] + qsum[i+l-1]
        T[i][i+l-1] = min(val_list) + w
        
print(T[1][n])
"
8247670,ALDS1_11_A,"def main():
    n = int(input())
    adj = [[0]*n for _ in range(n)] # adj[row][column]
    for _ in range(n):
        table = list(map(int, input().split()))
        row = table[0]-1
        num = table[1]
        if num == 0:
            continue
        for i in range(2, num+2):
            column = table[i]-1
            adj[row][column] = 1
    for i in range(n):
        print(*adj[i])

if __name__ == '__main__':
    main()
"
8524063,ALDS1_11_A,"for _ in range(n := int(input())): print(*format(sum([1 << (int(i) - 1) for i in input().split()[2:]]), f'0{n}b')[::-1])
"
8535641,ALDS1_11_A,"n = int(input())
A = [[0] * n for _ in range(n)]
for _ in range(n):
  u, _, *V = map(int, input().split())
  for v in V:
    A[u-1][v-1] = 1

for a in A:
  print(*a)

"
8576953,ALDS1_11_A,"n = int(input())

for _ in range(n):
    n_list = list(map(int, input().split()))
    row = [0 for _ in range(n)]
    for i in range(n_list[1]):
        row[n_list[2 + i] - 1] = 1
    print(*row)

"
8634573,ALDS1_11_A,"def main():
    n = int(input())
    adjacency_matrices = [[0]*n for _ in range(n)]

    for _ in range(n):
        # u: ノード番号
        # k: ノードから出ていくエッジの数
        # vs: ノードから出たエッジの行先
        u, k, *vs = map(int,input().split())
        for v in vs:
            adjacency_matrices[u-1][v-1] = 1
    for amr in adjacency_matrices:
        print(*amr)

if __name__ == '__main__':
    main()
"
8644288,ALDS1_11_A,"n = int(input())

# 行列を0で初期化
A = [[0] * n for i in range(n)]

for i in range(n):
  u, k, *V = map(int, input().split(' '))
  # print(u)
  # print(k)
  # print(V)
  for v in V:
    A[u - 1][v - 1] = 1

for i in A:
  print(*i)
"
8664112,ALDS1_11_A,"from sys import stdin
input = stdin.readline

n = int(input())
M = [['0']*n for _ in range(n)] # 0オリジンの隣接行列、0で初期化しておく

for _ in range(n):
    u, k, *vv = input().split()
    u = int(u) - 1
    k = int(k)
    for v in vv:
        v = int(v) - 1
        M[u][v] = '1'

for m in M:
    print(' '.join(m))
"
8673801,ALDS1_11_A,"n = int(input())
Adj = [[]for _ in range(n)]
for i in range(n):
    Adj[i] = list(map(int,input().split()))[2:]
#print(Adj)
ans = [[0]*n for _ in range(n)]

for i in range(n):
    for j in range(n):
        if j+1 in Adj[i]:
            ans[i][j] = 1

for a in ans:
    print(*a)
"
8716896,ALDS1_11_A,"n = int(input())
g = [[0] * n for _ in range(n)]
for _ in range(n):
    u, k, *vl = list(map(int, input().split()))
    for v in vl:
        g[u - 1][v - 1] = 1

for h in g:
    print(*h)

"
8815571,ALDS1_11_A,"n = int(input())
g = [[0] * n for _ in range(n)]

for i in range(n):
    u, l, *vs = list(map(int, input().split()))

    for v in vs:
        g[u-1][v-1] = 1

for l in g:
    print(*l)

"
8822491,ALDS1_11_A,"n = int(input())

m = [[0 for i in range(n)] for j in range(n)]

for i in range(n):
    Array = input()
    a = list(map(int, Array.split()))
    for j in a[2:]:
        m[i][j-1] = 1

for i in m:
    print(*i,sep="" "")
"
8822540,ALDS1_11_A,"n = int(input())
input_data = []
G = [[0 for i in range(n)]for j in range(n)]

for i in range(n):
    input_data = list(map(int,input().split()))
    for j in range(2,input_data[1]+2):
        G[input_data[0]-1][input_data[j]-1] = 1

for i in range(len(G)):
    for j in range(len(G[i])):
        if j != n-1:
           print(G[i][j],end="" "")
        else :
           print(G[i][j])

"
8843957,ALDS1_11_A,"# aizu_ALDS1_11_A_Graph.py  

n = int(input())
adj = [ [0]*n for _ in range(n)]

for _ in range(n):
    u,k,*v = map(int,input().split())
    for e in v:
        adj[u-1][e-1] = 1

for i in range(n):
    print(*adj[i])
"
8846413,ALDS1_11_A,"def adjacency_matrix(n, adj_list):
    matrix = [[0] * n for _ in range(n)] # n x nのゼロ行列を初期化
    for row in adj_list:
        u = row[0]# 隣接リストの最初の要素は頂点 u
        for vi in row[2:]:
            matrix[u - 1][vi - 1] = 1 # 隣接リストから取り出した頂点 vi に対応する行列の要素を 1 に設定
    return matrix

n = int(input())
adj_list = []
for _ in range(n):
    adj_list.append(list(map(int, input().split())))
# 隣接行列を計算
matrix = adjacency_matrix(n, adj_list)

for row in matrix:
    print(' '.join(map(str, row)))

"
8967434,ALDS1_11_A,"def to_matrix(edges):
    N = len(edges)
    matrix = [[0] * N for _ in range(N)]
    for i, e in enumerate(edges):
        for j in e:
            matrix[i][j] = 1
    return matrix


if __name__ == ""__main__"":
    N = int(input())
    edges = [None for _ in range(N)]
    for _ in range(N):
        u, k, *v = map(int, input().split())
        edges[u - 1] = [x - 1 for x in v]

    matrix = to_matrix(edges)
    for row in matrix:
        print("" "".join(map(str, row)))

"
8996036,ALDS1_11_A,"V = int(input())
G = [[] for _ in range(V+1)]

for _ in range(V):
    tmp = list(map(int,input().split()))
    v = tmp[0]
    G[v] = set(tmp[2:])

adjancy_graph = [[0]*V for _ in range(V)]
for i in range(V):
    for j in range(V):
        if j+1 in G[i+1]:
            adjancy_graph[i][j] = 1

for i in range(V):
    print(*adjancy_graph[i])
            
        


"
9128619,ALDS1_11_A,"def adj():
    n = int(input())
    adj_li = [list(map(int, input().split())) for _ in range(n)]
    adj_mtx = [[0] * n for _ in range(n)]
    for a in adj_li:
        for k in range(2, 2 + a[1]):
            adj_mtx[a[0]-1][a[k]-1] = 1
        
    for a in adj_mtx:
        print("" "".join(map(str, a)))
adj()

"
9130376,ALDS1_11_A,"N = int(input())
for i in range(N):
    u, k, *vs = map(int, input().split())
    E = [0]*N
    for v in vs:
        E[v-1] = 1
    print(*E)
"
9142916,ALDS1_11_A,"n = int(input())
ulist = []
for i in range(n):
    ulist.append(list(map(int, input().split())))

for i in range(n):
    output = [0 for i in range(n)]
    n_adj = ulist[i][1]

    for j in range(n_adj):
        output[ulist[i][j+2] - 1] = 1
    print(*output) 
    
"
9148633,ALDS1_11_A,"V = int(input())                                # the number of vertices
A = [[0 for j in range(V)] for i in range(V)]   # adjacency-matrix 
for i in range (V):
  u, k, *vs = map(int, input().split())
  for j in range(k):
    A[u-1][vs[j]-1] = 1

for i in range(V):
  print(*A[i])
"
9154727,ALDS1_11_A,"N = int(input())
G = [[0]*N for i in range(N)]

for i in range(N):
    u, k, *vs = list(map(int, input().split()))
    for v in vs:
        G[u-1][v-1] = 1
        
for row in G:
    print(*row)

"
9155599,ALDS1_11_A,"N = int(input())
G = [None for i in range(N)]
for i in range(N):
    u, k, *v = map(int, input().split())
    G[u-1] = [e for e in v]

Adj = [[0]*N for i in range(N)]

for  x in range(N):
    for y in G[x]:
        Adj[x][y-1] = 1
    print(*Adj[x])

"
9156224,ALDS1_11_A,"N = int(input())

for i in range(N):
    u,k,*vs=map(int,input().split())
    E=[0]*N
    for v in vs:
        E[v-1]=1
    print(*E)
"
9159311,ALDS1_11_A,"# n:頂点数
n = int(input())
# u:隣接する頂点の番号のリスト
u = [[] for i in range(n)]
# g:隣接行列
g =[[0] * n for i in range(n)]
for i in range(n):
  u_1 = list(map(int, input().split()))
  u[u_1[0]-1] = u_1[2:]
for i in range(n):
  for j in range(len(u[i])):
    g[i][u[i][j]-1] = 1

for row in g:
  print(' '.join(map(str, row)))
"
9169865,ALDS1_11_A,"N = int(input())
V = [[0]*N for i in range(N)]


for i in range(N):
    u,num,*v = map(int,input().split())
    for vi in v:
        V[i][vi-1] = 1


for i in range(N):
    x=V[:][i]
    print(*x)

"
9173069,ALDS1_11_A,"n = int(input())

# 入力を受け取って2次元リストAを作成
A = [[0] * n for _ in range(n)]
for _ in range(n):
    u, k, *neighbors = map(int, input().split())
    u -= 1
    for v in neighbors:
        A[u][v - 1] = 1

# 行ごとにAを出力
for row in A:
    print(*row)


"
9182361,ALDS1_11_A,"n = int(input())
for i in range(n):
    u, k, *vs = map(int, input().split())
    A = [0] * n
    for v in vs:
        A[v-1] = 1
    print(*A)

"
9182789,ALDS1_11_A,"n = int(input())
for _ in range(n):
    v = list(map(int, input().split()))[2:]
    line = [0] * n
    for i in v:
        line[i - 1] = 1
    print(*line)


"
9185164,ALDS1_11_A,"def main():
    n = int(input()) 

    adj_matrix = [[0] * n for _ in range(n)]

    for _ in range(n):
        v, deg, *neighbers = map(int, input().split())
        for i in neighbers:
            adj_matrix[v - 1][i - 1] = 1

    for i in adj_matrix:
        print(*i)

if __name__ == ""__main__"":
    main()
"
9187519,ALDS1_11_A,"S = int(input())

G = [[0] * S for _ in range(S)]
for i in range(S):
    array = list(map(int, input().split()))
    for j in range(array[1]):
        G[i][array[j+2]-1] = 1

for i in G:
    print(*i)
"
9188293,ALDS1_11_A,"n = int(input())  # 頂点数

# 隣接リスト表現を受け取る
adj_list = []
for _ in range(n):
    vertex, out_degree, *neighbors = map(int, input().split())
    adj_list.append(neighbors)

# 隣接行列を初期化
adj_matrix = [[0] * n for _ in range(n)]

# 隣接リストから隣接行列を構築
for u in range(n):
    for v in adj_list[u]:
        adj_matrix[u][v - 1] = 1  # 隣接リストの頂点番号は1-indexedなので調整

# 隣接行列を出力
for row in adj_matrix:
    print(*row)

"
9193883,ALDS1_11_A,"N = int(input())              # the number of nodes
G = [None for i in range(N)]
table=[]

for i in range(N):
    u, k, *vs = map(int, input().split())
    G[u-1] = [e for e in vs]
    table.append( [1 if j+1 in G[u-1] else 0 for j in range(N)])
    
for row in table:
    print("" "".join(map(str, row)))
"
9199305,ALDS1_11_A,"n = int(input())
ans = [[0]*n for _ in range(n)]   #二次元リスト作成

for i in range(n):      #ループ処理
    A = list(map(int, input().split()))
    if A[1] > 0:
        for j in range(A[1]):
            ans[i][A[2+j]-1] = 1   #`ans` の `i` 行目の `A[2+j]-1` 列目に `1` を代入

for i in ans:   # 行の要素をスペース区切りで表示
    print(*i)
"
9200102,ALDS1_11_A,"n = int(input())
G = [[0]*n for _ in range(n)]

for _ in range(n):
    u,k,*v = [int(x) for x in input().split()]
    for vi in v:
        G[u-1][vi-1] = 1
        
for Gi in G:
    print(*Gi)
"
5636570,ALDS1_11_A,"n = int(input())
adj = [[str(0)] * n for _ in range(n)]
for _ in range(n):
    inp = list(map(int, input().split()))
    for i in range(inp[1]):
        adj[inp[0] - 1][inp[2 + i] - 1] = str(1)

for i in range(n):
    print("" "".join(adj[i]))
"
1658029,ALDS1_11_A,"n = int(input())
g = [[0] * n for _ in range(n)]

while n:
    l = list(map(int, input().split()))
    cg = g[l[0] - 1]
    for i in l[2:]:
        cg[i - 1] = 1
    n -= 1

for v in g:
    print(*v)
"
1711982,ALDS1_11_A,"n = int(input())
for i in range(n):
    node = list(map(int,input().split()))
    node_list = node[2:]
    matrix = [""0""]* n

    for j in node_list:
        matrix[j -1] = ""1""
    print("" "".join(matrix))
"
1903612,ALDS1_11_A,"n = int(input())
for _ in range(n):
    u = list(map(int,input().split()))
    out = [0]*n
    for i in u[2:]: out[i-1] = 1
    print(*out)
"
2109494,ALDS1_11_A,"if __name__ == '__main__':
    # ??????????????\???
    num = int(input())
    data = []
    for _ in range(num):
        data.append(list(map(int, input().split(' '))))

    # ???????????????
    graph_table = [[0]*num for _ in range(num)]
    for d in data:
        node_id = d[0]
        num_of_e = d[1]
        for e in d[2:]:
            graph_table[node_id-1][e-1] = 1

    # ???????????????
    for row in graph_table:
        print(*row)
"
2164794,ALDS1_11_A,"if __name__ == '__main__':
    N = int(input())
    matrix = [['0'] * N for _ in range(N)]
    for i in matrix:
        node_info = [int(i) for i in input().split()]
        node_i = node_info[0] - 1
        if not node_info[1] == 0:
            for i in node_info[2:]:
                matrix[node_i][i - 1] = '1'
    [print(' '.join(line)) for line in matrix]
"
2176227,ALDS1_11_A,"import sys

def debug(x, table):
    for name, val in table.items():
        if x is val:
            print('DEBUG:{} -> {}'.format(name, val), file=sys.stderr)
            return None

def solve():
    n = int(input())
    edge = [[0]*n for i in range(n)]

    for i in range(n):
        u, k, *vs = [int(j) - 1 for j in input().split()]
        # debug(vs, locals())
        for v in vs:
            edge[u][v] = 1

    for i in range(n):
        print(*edge[i])

    pass

if __name__ == '__main__':
    solve()
"
2185710,ALDS1_11_A,"n=int(input())
for _ in [0]*n:
    a=[0]*n
    for i in list(map(int,input().split()))[2:]:a[i-1]=1
    print(*a)
"
2220755,ALDS1_11_A,"n = int(input())
g = [[0] * n for _ in range(n)]

while n:
    l = list(map(int, input().split()))
    column_g = g[l[0] - 1]
    for i in l[2:]:
        column_g[i-1] = 1
    n -= 1
for v in g:
    print(*v)
"
2352332,ALDS1_11_A,"n = int(input())
Adj = [[0 for i in range(n)] for i in range(n)]

for i in range(n):
    u = list(map(int, input().split()))
    if u[1] > 0:
        for i in u[2: 2 + u[1]]:
            Adj[u[0] - 1][i - 1] = 1

for i in range(n):
    print("" "".join(map(str, Adj[i])))
"
2362643,ALDS1_11_A,"def convertList(G):
    n = len(G)
    GL = [ [0 for _ in range(n)] for _ in range(n)]
    for key, values in G.items():
        GL[key - 1][key - 1] = 0
        for v in values:
            GL[key - 1][v - 1] = 1

    return GL


if __name__ == '__main__':
    G = {}
    n = int(input())
    for _ in range(n):
        tmp = list(map(int, input().split()))
        u = tmp.pop(0)
        k = tmp.pop(0)
        G[u] = tmp
    GL = convertList(G)
    for i in range(n):
        print(*GL[i])
"
2400643,ALDS1_11_A,"n = int(input())
adj = [[0 for i in range(n)] for j in range(n)]

for i in range(n):
    tmp = list(map(int, input().split()))
    u = tmp[0]
    u = u -1
    k = tmp[1]
    v = tmp[2:]
    for j in range(k):
        adj[u][v[j]-1] = 1
        
for i in range(n):
        print("" "".join(list(map(str, adj[i]))))
"
2446094,ALDS1_11_A,"import sys


if __name__ == ""__main__"":
    n = int(sys.stdin.readline())
    ANS = [[0] * n for i in range(n)]
    for inp in sys.stdin.readlines():
        inp = list(map(int, inp.split()))
        for i in inp[2:]:
            ANS[inp[0]-1][i-1] = 1
    for row in ANS:
        print("" "".join(map(str, row)))
"
2459927,ALDS1_11_A,"# coding=utf-8

n = int(input())
M = [[0 for _ in range(n)] for _ in range(n)]
for _ in range(n):
    u, k, *v = map(int, input().split())
    u = u-1 #for index
    if k == 0:
        continue
    for num in v:
        num = num-1 #for index
        M[u][num] = 1
for row in M:
    print(*row)
"
2494468,ALDS1_11_A,"N = int(input())
dp = [[0 for i in range(N)] for j in range(N)] 

for _ in range(N):
    inputs = list(map(int, input().split()))
    u = inputs[0]
    k = inputs[1]
    v = inputs[2:]
    #print(u, k, v)
    for each in v:
        dp[u-1][each-1] = 1

for i in range(N):
    print(*dp[i][:])
"
2495768,ALDS1_11_A,"def adjmatrices():
    n = int(input())
    for i in range(n):
        node_list = list(map(int, input().split()))
        matrix = [0]*n
        for j in node_list[2:]:
            matrix[j-1] = 1
        print(*matrix)

if __name__ == '__main__':
    adjmatrices()
"
2496409,ALDS1_11_A,"# -*- coding: utf-8 -*-

N = int(input())
adj = [[""0""]*N for _ in range(N)]

for _ in range(N):
    inp = list(map(int, input().split()))
    for i in inp[2:]:
        adj[inp[0]-1][i-1] = ""1""

for a in adj:
    print("" "".join(a))
"
2515862,ALDS1_11_A,"n = int(input())
M = [[0] * n for i in range(n)]
for i in range(n):
    t = list(map(int, input().split()))
    v = t[0]
    k = t[1]
    for j in range(k):
        M[v - 1][t[2+j] - 1] = 1

for r in M:
    r = map(str, r)
    print(' '.join(r))
"
2517459,ALDS1_11_A,"# Aizu Problem ALDS_1_10_B: Graph
#
import sys, math, os

# read input:
PYDEV = os.environ.get('PYDEV')
if PYDEV==""True"":
    sys.stdin = open(""sample-input.txt"", ""rt"")


n = int(input())
G = [[0 for _ in range(n)] for __ in range(n)]
for row in range(n):
    inp = [int(_) for _ in input().split()]
    a = inp[0]
    if inp[1] > 0:
        for b in inp[2:]:
            G[a-1][b-1] = 1

for row in G:
    print(' '.join([str(_) for _ in row]))
"
2521627,ALDS1_11_A,"# your code goes here
#graph
#????????????????¨?????????¨
n=int(input())
L=[]
for i in range(n):
    L.append([])
    for j in range(n):
        L[i].append(""0"")
#rint(L)
for i in range(n):
    v=[int(i) for i in input().split()]
#    print(v)
    for j in range(2,2+v[1]):
        L[v[0]-1][v[j]-1]=""1""#??????????????????1????????????i???i-1
#        print(L)
     #   L[v[j]-1][v[0]-1]=""1""
for i in range(n):
    print("" "".join(L[i]))
"
2523783,ALDS1_11_A,"def main():
    num = int(input())
    T = [[0] * num for i in range(num)]
    for n in range(num):
        a = list(map(int,input().split()))
        u = a[0] - 1
        if a[1] > 0:
            for i in a[2:]:
                T[u][i-1] = 1

    for i in range(num):
        print("" "".join(map(str,T[i])))

if __name__ == '__main__':
    main()
"
2552398,ALDS1_11_A,"n = int(input())
for i in range(n):
    u, k, *v = map(int, input().split())
    row = """"
    for j in range(1, n + 1):
        if j in v:
            row += ""1""
        else:
            row += ""0""
        if j != n:
            row += "" ""
    print(row)
"
2590815,ALDS1_11_A,"v_num = int(input())
adjacent = [[0 for n in range(v_num)] for m in range(v_num)]
for _ in range(v_num):
    inp = [int(n) for n in input().split("" "")]
    for i in inp[2:]:
        adjacent[inp[0] - 1][i - 1] = 1
for i in range(v_num):
    print(*adjacent[i])
"
2599581,ALDS1_11_A,"n = int(input())
a = [[0 for i in range(n)] for j in range(n)]

for i in range(n):
    inp = list(map(int, input().split()))
    u = inp[0]
    k = inp[1]
    for j in range(k):
        a[u - 1][inp[2 + j] - 1] = 1
    print(*a[u - 1])
"
2625387,ALDS1_11_A,"n = int(input())
a = [[0 for i in range(n)] for j in range(n)]

for i in range(n):
    v = list(map(int, input().split()))
    u = v[0]
    k = v[1]
    for j in range(k):
        a[u - 1][v[2 + j] - 1] = 1
    print(*a[u - 1])
"
2625578,ALDS1_11_A,"n = int(input())
M = [[0] * n for i in range (n)]
for i in range(n):
    u = list(map(int, input().split()))
    v = u[0]
    for j in u[2:]:
        M[v - 1][j - 1] = 1

for i in M:
    print(*i)
"
2630135,ALDS1_11_A,"n = int(input())
a = [[0]*n for i in range(n)]
    
for i in range(n):
    v = list(map(int, input().split()))
    u = v[0] - 1
    for j in v[2:]:
        a[u][j - 1] = 1
    print(*a[i])
"
2664920,ALDS1_11_A,"n=int(input())
for _ in range(n):
    u=list(map(int,input().split()))
    out=[0]*n
    for i in u[2:]: out[i-1] = 1
    print(*out)
"
2696691,ALDS1_11_A,"# coding: UTF-8
n = int(input())
Ans =[ [0 for i in range(n)] for j in range(n)]
for l in range(n):
  raw = list(map(int,input().split()))
  i = raw[0]
  d = raw[1]
  for m in range(2,d+2):
    Ans[i-1][raw[m]-1] = 1

for i in range(n):
  print("" "".join(map(str,Ans[i])))
"
2714293,ALDS1_11_A,"n = int(input())
MAP = [[0] * n for _ in range(n)]
for i in range(n):
    u, k, *v = map(int, input().split())
    for j in v:
        MAP[u - 1][j - 1] = 1
for m in MAP:
    print(*m)

"
2718569,ALDS1_11_A,"n = int(input())
Adj = [0 for i in range(n)]

for i in range(n):
    row = list(map(int, input().split(' ')))
    Adj[row[0] - 1] = row

for adj in Adj:
    row = [0 for i in range(n)]
    for i in adj[2:2+adj[1]]:
        row[i - 1] = 1
    print(' '.join(map(str, row)))

"
2721846,ALDS1_11_A,"import sys
data_list = []
for line in sys.stdin:
	data_list.append(line.split())

class Node():
    def __init__(self, name, transaction_list = None):
        self.transaction_list = transaction_list or []

    def add_node(self, node):
        self.transaction_list.append(node)

def convert_adjencentList_to_adjencentMatrix(adjencentList):
    adjencent_matrix = [[0 for i in range(len(adjencentList))] for j in range(len(adjencentList))]
    count = 0
    for targetList in adjencentList:
        targetList.transaction_list.sort()
        for target_index in targetList.transaction_list :
            adjencent_matrix[count][int(target_index) - 1] = 1
        count = count + 1

    for i in adjencent_matrix:
        print(*i)

if __name__ == ""__main__"":
        node_data_list = []

        for node_data in data_list[1:]:
            node = Node(node_data[1])
            for transaction_node in node_data[2:]:
                node.add_node(transaction_node)

            node_data_list.append(node)

        convert_adjencentList_to_adjencentMatrix(node_data_list)

"
2726592,ALDS1_11_A,"N=int(input())
for _ in[0]*N:
 r=[0]*N
 for i in input().split()[2:]:r[int(i)-1]=1
 print(*r)
"
8242125,ALDS1_11_B,"from collections import deque

n = int(input())

la = [[] for i in range(n)]


for _ in range(n):
    lb = list(map(int, input().split()))
    i = lb[0]
    if lb[1] != 0:
        lb = list(map(lambda x: x - 1, lb[2:]))
        la[i - 1] = lb.copy()


lc = [[-1, -1] for j in range(n)]
cnt = 0


def dfs(p):
    global cnt
    cnt += 1
    lc[p][0] = cnt
    for a in la[p]:
        if lc[a][0] == -1:
            dfs(a)
    cnt += 1
    lc[p][1] = cnt


for i in range(n):
    if lc[i][0] == -1:
        dfs(i)

for i in range(n):
    print(i + 1, lc[i][0], lc[i][1])

"
8252485,ALDS1_11_B,"n = int(input()) # number of vertices
G = []
checked = [False for _ in range(n)]
d = [0 for _ in range(n)]
f = [0 for _ in range(n)]
timestamp = 1

def dfs(id):
    global timestamp
    checked[id] = True
    d[id] = timestamp
    timestamp += 1
    for v in G[id]:
        if not checked[v-1]:
            dfs(v-1)
    f[id] = timestamp
    timestamp += 1

def main():
    for _ in range(n):
        table = list(map(int, input().split()))
        G.append(table[2:])
    for id in range(n):
        if not checked[id]:
            dfs(id)
    for i in range(n):
        print('{0} {1} {2}'.format(i+1, d[i], f[i]))

if __name__ == '__main__':
    main()
"
8298027,ALDS1_11_B,"n = int(input())
G = [[] for _ in range(n)]
for _ in range(n):
    l = list(map(int, input().split()))
    for i in range(l[1]):
        G[l[0] - 1].append(l[i + 2] - 1)

d = [-1 for _ in range(n)]
f = [-1 for _ in range(n)]


def dfs(G, node):
    global timestamp
    timestamp += 1
    d[node] = timestamp
    for next in G[node]:
        if d[next] == -1:
            dfs(G, next)
    timestamp += 1
    f[node] = timestamp


timestamp = 0

for i in range(n):
    if d[i] == -1:
        dfs(G, i)

for i in range(n):
    print(i + 1, d[i], f[i])

"
8395200,ALDS1_11_B,"n = int(input())
graph = [[] for _ in range(n + 1)]
for _ in range(n):
    x, _, *lst = map(int, input().split())
    for y in lst:
        graph[x].append(y)

stack = [x for x in range(1, n + 1)[::-1]]
count = [0] * (n + 1)
time = 0
discover = [0] * (n + 1)
finished = [0] * (n + 1)
while stack:
    time += 1
    x = stack.pop()
    count[x] += 1
    if count[x] == 1:
        discover[x] = time
    elif count[x] == 2:
        finished[x] = time
        continue
    else:
        time -= 1
        continue
    stack.append(x)
    for y in graph[x][::-1]:
        if count[y] > 0:
            continue
        stack.append(y)
for i in range(1, n + 1):
    print(i, discover[i], finished[i])

"
8396814,ALDS1_11_B,"import sys
sys.setrecursionlimit(120000)

n=int(input())
#隣接リスト
G=[[None]]
for i in range(n):
  top=list(map(int,input().split()))
  G.append(top[2:])

#出力する答え
ans=[[None,None,None] for i in range(n+1)]
for i in range(1,n+1):
  ans[i][0]=i
  
#タイムスタンプ:d,f
d=[None]*(n+1)
f=[None]*(n+1)
visited=[False]*(n+1)
global cnt


#深さ優先探索
def dfs(G,pos,d,f,visited):
  global cnt
  d[pos] = cnt
  cnt+=1
  for next in G[pos]:
    if visited[next]==True:
      continue
    visited[next]=True
    dfs(G,next,d,f,visited)
  f[pos]=cnt
  cnt+=1


cnt=1

for i in range(1,n+1):
  if visited[i]==True:
    continue
  visited[i]=True
  dfs(G,i,d,f,visited)

for i in range(1,n+1):
  ans[i][1]=d[i]
  ans[i][2]=f[i]

for i in range(1,n+1):
  print(*ans[i])
  
"
8396898,ALDS1_11_B,"N = int(input())
adj = [[] for i in range(N)]
for n in range(N):
    V = list(map(int, input().split()))
    for v in V[2:]: # u,k,v1,v2,...
        adj[n].append(v-1)
d = [0] * N # 発見時刻
f = [0] * N # 完了時刻

def dfs(v, t):
    t+=1 # 発見したらインクリメント
    d[v] = t
    for next in adj[v]:
        if d[next] == 0: # 未発見なら
            t = dfs(next, t)
    t+=1 # 完了してもインクリメント
    f[v] = t
    return t

t = 0
for n in range(N):
    if d[n]==0: # 未発見なら
        t = dfs(n,t)
    print (n+1,d[n],f[n])
"
8399007,ALDS1_11_B,"# 深さ優先探索

import sys

sys.setrecursionlimit(100000)

time = 0
def dfs(v,d,f,G,check):
    global time
    if check[v] == True:
        return
    time += 1
    d[v] = time
    check[v] = True
    for to in sorted(G[v]):
        if check[to] == False:
            dfs(to, d,f,G,check)
    
    time += 1
    f[v] = time
    return 


def main():
    n = int(input())
    d = [0]*n
    f = [0]*n
    G = [[] for _ in range(n)]  
    check = [False]*n
    for i in range(n):
        pt = list(map(int, input().split()))
        for j in range(pt[1]):
            G[pt[0]-1].append(pt[2+j]-1)
    
    for i in range(n):
        if check[i] == True:
            continue
        dfs(i,d,f,G,check)
    
    for i in range(n):
        print(i+1,d[i],f[i])

    

if __name__ == '__main__':
    main()

"
8413217,ALDS1_11_B,"# coding: utf-8

from functools import partial
try:
    dummy = src
    rl = partial(src.pop, 0)
except NameError:
    rl = input
def ints():
    return list(map(int, rl().strip().split()))
def int1():
    return int(rl().strip())

def dfs(p, nodes, ans, visited, step):
    step[0] += 1
#    pr('p, step[0]')
    ans[p].append(step[0])
    for p2 in sorted(nodes[p]):
        if visited[p2] == 0:
            visited[p2] = 1
            dfs(p2, nodes, ans, visited, step)
    step[0] += 1
#    pr('p, step[0]')
    ans[p].append(step[0])

#@psecs
def main():
    n = int1()
    nodes = [[] for _ in range(n+1)]
    for _ in range(n):
        i, k, *rest = ints()
        if k > 0:
            nodes[i] = rest
#    pr(nodes)
    
    ans = [[] for _ in range(n+1)]
    visited = [0] * (n+1)
    step = [0]
    for i in range(1, n+1):
        if visited[i] == 0:
            visited[i] = 1
            dfs(i, nodes, ans, visited, step)
    
    for i in range(1, n+1):
        print(i, *ans[i])
    
if __name__ == '__main__':
    main()
"
8431923,ALDS1_11_B,"n = int(input())

G = {}
for _ in range(n):
  u, k, *V = map(int, input().split())
  G[u] = V

found=[-1]*(n+1)
end=[-1]*(n+1)

def dfs(G, node_i, clock, f, e):
  f[node_i]=clock
  clock+=1
  for node_j in G[node_i]:
    if f[node_j]!=-1:
      continue
    clock, f, e = dfs(G, node_j, clock, f, e)
    
  e[node_i]=clock
  clock+=1
  return clock, f, e

clock=1
while True:
  node = -1
  for i, f in enumerate(found):
    if i==0:
      continue
    if f==-1:
      node=i
      break
  if node==-1:
    break
  clock, found, end = dfs(G, node, clock, found, end)
    
for i, (f, e) in enumerate(zip(found, end)):
  if i==0:
    continue
  print(i, f, e)
"
8466198,ALDS1_11_B,"#AOJ ALDS1_11_B

#再帰回数の上限を緩める.
import sys
sys.setrecursionlimit(10**7)

#dfsの定義.
def dfs(node_ind):
	global time
	#訪問済みの場合 d に値が入っている.
	if d[node_ind]:
		return
	#訪問した時間を記録し、時間を進める.
	d[node_ind] = time
	time += 1

	#隣接リストの頂点を順次訪問.
	#出自数0 なら [2:] で空リストなのでforスルー.
	for node in prox[node_ind][2:]:
		node -= 1 # リストで扱いやすいよう、0始まりに
		dfs(node)

	#子の訪問を終えたら時間を記録し、時間を進め、return.
	f[node_ind] = time
	time += 1
	return

#input
n = int(input())
prox = [ list(map(int,input().split())) for _ in range(n) ]

#define
d = [0] * n 
f = [0] * n
time = 1

#run
#未訪問の独立した島とかがあった場合、それも若い順から訪問したい.
#訪問済みの場合、何も起きずにreturnなので、0~n-1全部dfsすれば良い.
for i in range(n):
	dfs(i)

#display
for i in range(n):
	print(f""{i+1} {d[i]} {f[i]}"")




"
8524309,ALDS1_11_B,"#21D8102009G Miyagawa Kai
#Depth First Search

n=int(input()) #vertices

path=list() #list of vertices
path.append([]) #don't use index:0

for i in range(n):
    tmp=list(map(int, input().split()))
    path.append(tmp[2:])

d=[0]*(n+1) #find_time
f=[0]*(n+1) #finish_time

time=0

def dfs(id,d,f): #id is index
    global time
    
    time+=1

    d[id]=time

    for i in path[id]:
        if d[i]==0: #if d[i] have not search yet
            dfs(i,d,f) #to next vertice

    #when returning
    time+=1
    f[id]=time

    return

for start in range(1,n+1):
    if d[start]==0:
        dfs(start,d,f)

for i in range(1,n+1):
    print(i,d[i],f[i])
"
8524753,ALDS1_11_B,"n = int(input()) + 1
a = [0] + [[int(j) for j in input().split()][: 1: -1] for _ in range(n - 1)]
b = [[] for _ in range(n)]
c = 0

for m in range(1, n):
    if not b[m]:
        l = [m]
        c += 1
        while l:
            i = l[-1]
            if not b[i]: b[i].append(c)
            c += 1
            while a[i]:
                j = a[i].pop()
                if not b[j]:
                    l.append(j)
                    break
            else: b[l.pop()].append(c)

for i in range(1, n): print(i, *b[i])
"
8535658,ALDS1_11_B,"n = int(input())
G = [None] * n
for _ in range(n):
  u, _, *V = map(int, input().split())
  G[u-1] = [v-1 for v in V]

d, f = [None] * n, [None] * n
time = 0

def visit(u):
  global time
  time += 1
  d[u] = time
  for v in G[u]:
    if not d[v]:
      visit(v)
  time += 1
  f[u] = time

for u in range(n):
  if not d[u]:
    visit(u)
  print(u+1, d[u], f[u])

"
8539550,ALDS1_11_B,"n = int(input())
A = [[] for _ in range(n+1)]
for _ in range(n):
    t = [*map(int,input().split())]
    v = t[0]
    if (t[1] != 0):
        A[v] = t[2:]
seen = [0] * (n+1)
done = [0] * (n+1)
time = 1
def dfs(v,t):
    global time
    seen[v] = time
    time += 1
    NP = A[v]
    for np in NP:
        if (seen[np] == 0):
            dfs(np,time)
    done[v] = time
    time += 1
for i in range(1,n+1):
    if (seen[i] == 0):
        dfs(i,time)
for i in range(1,n+1):
    print(i,seen[i],done[i])
"
8571476,ALDS1_11_B,"def dfs(graph, vertex, visited, start_time, end_time, time):
    visited[vertex] = True
    start_time[vertex] = time
    time += 1
    
    for neighbor in graph[vertex]: # 頂点の隣接頂点を探索
        if not visited[neighbor]:
            time = dfs(graph, neighbor, visited, start_time, end_time, time)
    
    end_time[vertex] = time
    time += 1
    
    return time

def depth_first_search(graph, n):
    visited = [False] * (n + 1) # 始めは全て未探索
    d = [0] * (n + 1) # 最初に発見した発見時刻
    f = [0] * (n + 1) # 隣接リストを調べ終えた完了時刻
    time = 1
    
    for vertex in range(1, n + 1):
        if not visited[vertex]:
            time = dfs(graph, vertex, visited, d, f, time)
    
    for i in range(1, n + 1):
        print(i, d[i], f[i])

# 入力処理
n = int(input())  # 頂点数
G = {} # グラフ
for i in range(n):
    data = list(map(int, input().split()))
    u = data[0] # 頂点番号
    v = data[2:] # 隣接頂点
    G[u] = v

# 深さ優先探索を実行
depth_first_search(G, n)

"
8572977,ALDS1_11_B,"def dfs(graph, u, visited, discovery_time, finish_time, current_time):
    visited[u] = True
    current_time += 1
    discovery_time[u] = current_time
    
    for v in graph[u]:
        if not visited[v]:
            current_time = dfs(graph, v, visited, discovery_time, finish_time, current_time)
    
    current_time += 1
    finish_time[u] = current_time
    return current_time

def depth_first_search(graph, n):
    visited = [False] * (n + 1)
    discovery_time = [0] * (n + 1)
    finish_time = [0] * (n + 1)
    current_time = 0
    
    for u in range(1, n + 1):
        if not visited[u]:
            current_time = dfs(graph, u, visited, discovery_time, finish_time, current_time)
    
    return discovery_time, finish_time

# 入力の読み込み
n = int(input())
graph = {i: [] for i in range(1, n + 1)}

for _ in range(n):
    data = list(map(int, input().split()))
    u, k, *neighbors = data
    graph[u] = neighbors

# 深さ優先探索の実行
discovery_time, finish_time = depth_first_search(graph, n)

# 結果の出力
for u in range(1, n + 1):
    print(f""{u} {discovery_time[u]} {finish_time[u]}"")

"
8577205,ALDS1_11_B,"from enum import Enum


class Color(Enum):
    WHITE = 0
    GRAY = 1
    BLACK = 2


class Node:
    def __init__(self, id: int, neighbors_list: list) -> None:
        self.id = id
        self.neighbor_list = neighbors_list
        self.color = Color.WHITE
        self.t_visited = 0
        self.t_complete = 0


def dfs(node: Node):
    global t
    global node_list
    node.color = Color.GRAY
    node.t_visited = t
    t = t + 1
    for neighbor in node_list:
        if neighbor.id in node.neighbor_list and neighbor.color == Color.WHITE:
            dfs(neighbor)
    node.color = Color.BLACK
    node.t_complete = t
    t = t + 1


n = int(input())
node_list = []
for _ in range(n):
    n_list = list(map(int, input().split()))
    n_neighbors = n_list[1]
    neighbors_list = []
    for i in range(n_neighbors):
        neighbors_list.append(n_list[2 + i])
    node_list.append(Node(n_list[0], neighbors_list))
t = 1
for i in range(n):
    if node_list[i].color == Color.WHITE:
        dfs(node_list[i])
for i in range(n):
    node = node_list[i]
    print(f""{node.id} {node.t_visited} {node.t_complete}"")

"
8577743,ALDS1_11_B,"n=(int)(input())
g=[]
d=[0]*n
f=[0]*n
for i in range(n):
    line=input()
    line_int=list(map(int,line.split()))
    line_int.pop(0)
    g.append(line_int)

#探索済みならcheck=1、未探索ならcheck=0
#check→[頂点,辺1,辺2,...]
check=[]
for i in range(n):
    list=[]
    for j in range(len(g[i])):
        list.append(0)
    check.append(list)

cnt=0
for v in range(n):
    if(check[v][0]==0):
        check[v][0]=1
        cnt+=1
        d[v]=cnt
        stuck=[]
        stuck.append(v) 
        while len(stuck)!=0:
            u=stuck[len(stuck)-1]
            judge=-1
            for i in range(1,len(check[u])):
                if check[u][i]==0:
                    judge=1
                    check[u][i]=1
                    if check[(g[u][i]-1)][0]==0:
                        stuck.append(g[u][i]-1)
                        check[(g[u][i]-1)][0]=1
                        cnt+=1
                        d[stuck[len(stuck)-1]]=cnt
                    break
            if judge<0:
                cnt+=1
                f[stuck[len(stuck)-1]]=cnt
                stuck.pop(len(stuck)-1)

for i in range(n):
    print(i+1,d[i],f[i])
"
8596050,ALDS1_11_B,"n = int(input())
visited = [0 for _ in range(n)]
finished = [0 for _ in range(n)]
clock = 0

def dfs(s,nb):
    global clock
    if visited[s] > 0:
        return clock
    # visited process
    clock += 1
    record_v(s,clock)
    # neighbouring process
    for x in nb[s]:
        clock = dfs(x - 1,nb)
    # returning process
    clock += 1
    record_f(s,clock)

    return clock

def record_v(i ,t):
    global visited
    visited[i] = t

def record_f(i, t):
    global finished
    finished[i] = t

# initialization and input
nb = []
import copy
for _ in range(n):
    u, k, *v = map(int, input().split())
    nb.append(copy.copy(v))
# DFS
for i in range(n):
    dfs(i, nb)
# output
for i in range(n):
    print(i+1, visited[i], finished[i])
"
8612017,ALDS1_11_B,"n = int(input())
a=[]
for i in range(n):
    u, k, *b = map(int, input().split())
    a.append(b)

time = 1
d = [-1]*n
f = [-1]*n

def dfs(v):
    global time
    d[v] = time
    time += 1
    for i in a[v]:
        if d[i-1] == -1: #未探索なら進む
            dfs(i-1)
    f[v] = time
    time += 1

for i in range(n):
    if d[i] == -1:
        dfs(i)
for i in range(n):
    print(i+1, d[i], f[i])
"
8615002,ALDS1_11_B,"n = int(input())
u = []
for i in range(n):
    a,b,*tmp = [int(i)-1 for i in input().split()]
    u.append(tmp)
#　uの中身　(頂点番号　辺数　隣接点*)
q = [0]*(n) # 探索済み辺数

time_s = [-1]*(n) #発見時刻
time_f = [-1]*(n) #完了時刻

cnt = 1

def df(cur):
    global cnt
    #print(""u"",u)
    #print(""cur"",cur)
    #print(""u[cur]"",u[cur])
    time_s[cur]=cnt
    cnt+=1
    for next in u[cur]:
        #print(""next"",next)
        if time_s[next]==-1:
            df(next)
    time_f[cur] = cnt
    cnt+=1

for i in range(n):
    if time_s[i]==-1:
        df(i)

for i in range(n):
    print(i+1,time_s[i],time_f[i])
"
8616046,ALDS1_11_B,"G=[]
n=int(input())
for i in range(n):
    T=[int(t) for t in input().split()]
    G.append(T)
from operator import itemgetter
g=sorted(G,key=itemgetter(0))

t=1
d=[-1]*n
f=[-1]*n
d[0]=t
t+=1
v=[1]
j=1
while j==1:
    while len(v) > 0:
        u=v[len(v)-1]
        if len(g[u-1]) > 2:
            if d[g[u-1][2]-1] < 0:
                v.append(g[u-1][2])
                d[g[u-1][2]-1]=t
                t+=1
            del g[u-1][2]
        else:
            f[v[len(v)-1]-1]=t
            t+=1
            del v[len(v)-1]
    j=0
    for i in range(n):
        if d[i] < 0:
            v.append(i+1)
            d[i]=t
            t+=1
            j=1
            break
for i in range(n):
    print(g[i][0],d[i],f[i])
"
8616124,ALDS1_11_B,"# 頂点数 n, 有向グラフ G の入力
n = int(input())
G = [[int(i) - 1 for i in input().split()[2:]] for _ in range(n)]

# タイムスタンプ d, f の初期化
d = [0] * n
f = [0] * n

# seen[i]: 頂点 i が探索済みかどうか(T/F)
seen = [False] * n

# 時刻のカウンター, 開始時刻は 1
cnt = 1


# 頂点 u を始点とした深さ優先探索
def dfs(u):
    global cnt
    seen[u] = True

    # 頂点 u を最初に発見した時刻を記録する
    d[u] = cnt

    # u に隣接する頂点 v について再帰的に dfs する
    for v in G[u]:
        if seen[v]:
            continue
        cnt += 1
        dfs(v)

    cnt += 1

    # 頂点 u の隣接リストを調べ終えた時刻を記録する
    f[u] = cnt


# 未発見の頂点 u を始点として繰り返し dfs する
for u in range(n):
    if not seen[u]:
        dfs(u)
        cnt += 1

# 解
ans = zip(range(1, n + 1), d, f)

for a in ans:
    print(*a)

"
8616744,ALDS1_11_B,"def dfs(graph, v, visited, discovery_time, finish_time, time):
    visited[v] = True
    time[0] += 1
    discovery_time[v] = time[0]

    for neighbor in graph[v]:
        if not visited[neighbor]:
            dfs(graph, neighbor, visited, discovery_time, finish_time, time)

    time[0] += 1
    finish_time[v] = time[0]

def depth_first_search(graph, n):
    visited = [False] * (n + 1)
    discovery_time = [0] * (n + 1)
    finish_time = [0] * (n + 1)
    time = [0]

    for vertex in range(1, n + 1):
        if not visited[vertex]:
            dfs(graph, vertex, visited, discovery_time, finish_time, time)

    for vertex in range(1, n + 1):
        print(f""{vertex} {discovery_time[vertex]} {finish_time[vertex]}"")

# 入力処理
n = int(input())
graph = {i: [] for i in range(1, n + 1)}

for _ in range(n):
    line = list(map(int, input().split()))
    vertex = line[0]
    neighbors = line[2:]
    graph[vertex] = neighbors

# 深さ優先探索の実行
depth_first_search(graph, n)

"
8617615,ALDS1_11_B,"def main():
    n = int(input())
    g = Graph(n)

    for u in range(n):
        data = input().split()
        k = int(data[1])
        for v in map(int, data[2:]):
            g.add_edge(u, v - 1)  

    g.dfs()
    g.print()

class DFSResult:
    def __init__(self):
        self.id = -1
        self.discovery_time = -1
        self.finish_time = -1


class Graph:
    def __init__(self, vert):
        self.vert = vert
        self.adjacency_list = [[] for _ in range(vert)]
        self.results = [DFSResult() for _ in range(vert)]

    def add_edge(self, from_ver, to_ver):
        self.adjacency_list[from_ver].append(to_ver)

    def dfs(self):
        time = [1] 

        def dfs_visit(ver):
            nonlocal time
            self.results[ver].id = ver + 1
            self.results[ver].discovery_time = time[0]
            time[0] += 1

            for adjacent_ver in self.adjacency_list[ver]:
                if self.results[adjacent_ver].discovery_time == -1:
                    dfs_visit(adjacent_ver)

            self.results[ver].finish_time = time[0]
            time[0] += 1

        for start_ver in range(self.vert):
            if self.results[start_ver].discovery_time == -1:
                dfs_visit(start_ver)

    def print(self):
        for ver in range(self.vert):
            print(f""{self.results[ver].id} {self.results[ver].discovery_time} {self.results[ver].finish_time}"")

if __name__ == ""__main__"":
    main()
"
8618018,ALDS1_11_B,"n = int(input())
v = []
k = []
v_adj = []
for i in range(n):
    L = [int(x) for x in input().split()]
    v.append(L[0])
    k.append(L[1])
    v_adj.append(L[2:])

d = [0]*n
f = [0]*n
stack = [v[0]]
go = 1
d[0] = go
while len(stack) > 0:
    u = stack[-1]
    if len(v_adj[u-1]) > 0:
        if d[v_adj[u-1][0]-1] == 0:
            go += 1
            d[v_adj[u-1][0]-1] = go
            stack.append(v_adj[u-1][0])
        v_adj[u-1].pop(0)
    else:
        go += 1
        stack.pop()
        f[u-1] = go
        if len(stack) == 0:
            i = 0
            while i < n and d[i] > 0:
                i += 1
            if i < n:
                stack.append(v[i])
                go += 1
                d[i] = go

for i in range(n):
    print(v[i], d[i], f[i])
"
8656967,ALDS1_11_B,"class Node:
    def __init__(self):
        self.uid = -1
        self.visited = False
        self.start = 0
        self.end = 0
        self.adj = []

def main():
    n = int(input())
    # グラフ要素
    graph = [Node() for _ in range(n)]
    for node in graph:
        node.uid, k, *node.adj = map(int, input().split())
    # 隣接リストの中身をノード番号からノードそのものに変える
    for node in graph:
        node.adj = [graph[uid-1] for uid in node.adj]
    # 時間の記録
    # グローバル変数を使わずにカウントしやすい
    t = iter(range(1, 2*n+1)).__next__
    # 深さ優先探索
    for node in graph:
        if node.visited:
            continue
        depth_first_search(node, t)
    # 出力
    for node in graph:
        print(node.uid, node.start, node.end)

# 深さ優先探索
def depth_first_search(node, t):
    visit(node, t)
    for v in node.adj:
        if not v.visited:
            depth_first_search(v, t)
    node.end = t()
# ノード訪問記録
def visit(node, t):
    if not node.visited:
        node.visited = True
        node.start = t()


if __name__ == '__main__':
    main()
"
8661542,ALDS1_11_B,"n=int(input())
connect=[[] for i in range(n)]

for i in range(n):
    t=list(map(int,input().split()))
    for j in range(t[1]):
        connect[t[0]-1].append(t[j+2]-1)

for i in range(n):
    connect[i].sort()

d=[0]*n
f=[0]*n
time=0

def dfs(now,time):
        global d,f
        time+=1
        d[now]=time
        for to in connect[now]:
            if d[to]==0:
                time=dfs(to,time)
        time+=1
        f[now]=time
        return time

for i in range(n):
    if d[i]==0:
        time=dfs(i,time)
for i in range(n):
    print(i+1,d[i],f[i])
"
8676596,ALDS1_11_B,"from collections import defaultdict
n = int(input())
g = defaultdict(list)
st = [0 for _ in range(n)]
et = [0 for _ in range(n)]
strt_pt = 0
for i in range(n):
    u, k, *v = map(int, input().split())
    g[u].extend(v)


def bdf(s=1):
    global strt_pt
    strt_pt += 1
    st[s-1] += strt_pt
    for i in g[s]:
        if st[i-1] != 0:
            continue
        bdf(i)
    strt_pt += 1
    et[s-1] += strt_pt

    return


pt = set(range(n))

while pt != set():
    in_bdf = min(pt)
    bdf(in_bdf+1)
    pt -= set([i for i, v in enumerate(et) if v != 0])

for i in range(n):
    print(i+1, st[i], et[i])

"
8722338,ALDS1_11_B,"N = int(input())
adj = [[] for _ in range(N+1)]
for _ in range(N):
    line = tuple(map(int, input().split()))
    u, k, vs = line[0], line[1], list(line[2:])
    adj[u] = vs

d = [0]*(N+1)
f = [0]*(N+1)

def dfs(u, t):
    t += 1
    d[u] = t
    for v in adj[u]:
        if d[v] > 0:
            continue
        t = dfs(v, t)
    t += 1
    f[u] = t
    return t

t = 0
for i in range(1, N+1):
    if d[i] == 0:
        t = dfs(i, t)
for i in range(1, N+1):
    print(i, d[i], f[i])

"
8751854,ALDS1_11_B,"import sys
sys.setrecursionlimit(100000)


def printe(*args, end=""\n"", **kwargs):
    print(*args, end=end, file=sys.stderr, **kwargs)


def main():
    n = int(input())
    graph = [[] for _ in range(n)]
    for _ in range(n):
        num, k, *nodes = map(int, input().split())
        if not nodes:
            continue
        graph[num - 1].extend(map(lambda n: n - 1, nodes))

    visited = [False for _ in range(n)]
    nodes_time = [[-1, -1] for _ in range(n)]

    def dfs(start_node: int, c_time: int) -> int:
        if visited[start_node]:
            return c_time
        visited[start_node] = True
        c_time += 1
        nodes_time[start_node][0] = c_time

        for neighbor in graph[start_node]:
            if visited[neighbor]:
                continue
            c_time = dfs(neighbor, c_time)
        nodes_time[start_node][1] = c_time + 1
        return c_time + 1

    current_time = 0
    for node_idx in range(n):
        current_time = dfs(node_idx, current_time)
    for node_idx, node_time in enumerate(nodes_time, 1):
        print(node_idx, *node_time)


if __name__ == ""__main__"":
    main()

"
8756532,ALDS1_11_B,"def dfs(v,t,G,d,f): #時刻tにvに着いた時
    d[v] = t[0]
    for nxtv in sorted(G[v]):
        if d[nxtv] == -1:
            t[0] += 1
            dfs(nxtv,t,G,d,f)
    t[0] += 1
    f[v] = t[0]

n = int(input())
G = []
for i in range(n):
    qry = list(map(int, input().split()))
    u, k = qry[:2]
    u -= 1
    g = []
    for v in qry[2:]:
        v -= 1
        g.append(v)
    G.append(g)

d = [-1]*n
f = [-1]*n
t = [0]

for i in range(n):
    if d[i] == -1:
        t[0] += 1
        dfs(i,t,G,d,f)
for i in range(n):
    print(i+1,d[i],f[i])
"
8815671,ALDS1_11_B,"n = int(input())
g = [[] for _ in range(n)]

for i in range(n):
    u, k, *vs = list(map(int, input().split()))
    g[u-1] = list(map(lambda x: int(x) - 1, vs))

for i in range(n):
    g[i].sort()

vis = [0] * n

s = [0] * n
e = [0] * n
t = [0]
def dfs(node):
    t[0] += 1
    s[node] = t[0]
    vis[node] = 1
    for i in g[node]:
        if vis[i]: continue
        dfs(i)
    
    t[0] += 1
    e[node] = t[0]

for i in range(n):
    if not vis[i]:
        dfs(i)
for i in range(n):
    print(i+1, s[i], e[i])

"
8824041,ALDS1_11_B,"class Node:
    def __init__(self,index):
        self.index = index
        self.nears = []
        self.color = ""white""

def dfs():
    for u in V:
        if G[u-1].color == ""white"":
            visit(u-1)

def visit(number):
    global time_now
    G[number].color = ""gray""
    time_now += 1
    time[G[number].index-1][0] = time_now
    for u in G[number].nears:
        if G[u-1].color == ""white"":
            visit(u-1)
    G[number].color = ""black""
    time_now += 1
    time[G[number].index-1][1] = time_now
    


n = int(input())
G = []
time_now = 0
time = [[0,0]for i in range(n)]
V = []
for i in range(n):
    input_data = list(map(int,input().split()))
    V.append(int(input_data[0]))
    box = Node(input_data[0])
    box.nears = input_data[2:]
    G.append(box)

dfs()

for i in range(n):
    print(G[i].index,time[G[i].index-1][0],time[G[i].index-1][1])
"
8827443,ALDS1_11_B,"n = int(input())
G = [None] * n
for _ in range(n):
    u, _, *V = map(int,input().split())
    G[u-1] = [v-1 for v in V]

d,f = [None] * n, [None] * n
time = 0

def visit(u):
    global time
    time += 1
    d[u] = time
    for v in G[u]:
        if not d[v]:
            visit(v)
    time += 1
    f[u] = time

for u in range(n):
    if not d[u]:
        visit(u)
    print(u+1,d[u],f[u])
"
8842781,ALDS1_11_B,"from sys import stdin
input = stdin.readline

N = 100
WHITE = 0
GRAY = 1
BLACK = 2

M = [[0]*N for _ in range(N)]
color = [WHITE]*N  # colorの初期化は最初に行っておく。
d = [0]*N
f = [0]*N

def dfs_visit(u):
    global tt
    color[u] = GRAY
    tt += 1
    d[u] = tt # 最初の訪問
    for v in range(n):
        if M[u][v] == 0:
            continue
        if color[v] == WHITE:
            dfs_visit(v)
    color[u] = BLACK
    tt += 1
    f[u] = tt # 訪問の完了

def dfs():
    global tt
    tt = 0

    for u in range(n):
        if color[u] == WHITE:
            # 未訪問のuを始点として深さ優先探索
            dfs_visit(u)
    for u in range(n):
        print(str(u+1) + ' ' + str(d[u]) + ' ' + str(f[u]))

n = int(input())
for _ in range(n):
    u, k, *vv = input().split()
    u = int(u)-1  # 0オリジンにする
    k = int(k)    # kは使わない
    for v in vv:
        v = int(v)-1
        M[u][v] = 1
dfs()
"
8844775,ALDS1_11_B,"# aizu_ALDS1_11_B_DepthFirstSearch.py  

import sys
sys.setrecursionlimit(10**7)

n = int(input())
adj = [ ]

for _ in range(n):
    u,k,*v = map(int,input().split())
    adj.append(v)

d = [0]*n
f = [0]*n

def dfs(s):
    global time
    for n_s in adj[s]:
        if d[n_s-1] !=0: continue 
        d[n_s-1] = time
        time += 1
        dfs(n_s-1)
        if f[n_s-1]!= 0: continue 
        f[n_s-1] = time
        time += 1

time = 1
for s in range(n):
    if d[s] == 0:
        d[s] = time;time += 1
        dfs(s)
        if f[s] == 0:
            f[s] = time;time +=1

for i in range(n):
    print(i+1,d[i],f[i])
"
8851369,ALDS1_11_B,"def dfs():
    global time #各頂点の訪問開始時刻と訪問終了時刻を記録するための変数
    for u in range(n):
        color[u] = 0
        d[u] = 0
        f[u] = 0
    time = 0

    for u in range(n):
        if color[u] == 0:
            visit(u)

def visit(u):
    global time
    color[u] = 1
    time += 1
    d[u] = time
    for v in G[u]:
        if color[v] == 0:
            visit(v)
    color[u] = 2
    time += 1
    f[u] = time

n = int(input())
G = [[] for i in range(n)]
color = [0]*n #各頂点の訪問状態を追跡するための配列
d = [0]*n #各頂点の訪問開始時刻
f = [0]*n #各頂点の訪問終了時刻

for i in range(n):
    u, k, *v = map(int, input().split())#頂点の番号,出次数,隣接する頂点のリスト
    G[u-1] = v
    for j in range(k):
        G[u-1][j] -= 1

dfs()

for i in range(n):
    print(i+1, d[i], f[i])

"
8855185,ALDS1_11_B,"#24
n = int(input())
g = [None for _ in range(n)]
for _ in range(n):
    u, k, *v = map(lambda x: int(x)-1, input().split())
    g[u] = v

time_found = [0]*n
time_finished = [0]*n
time = 0
def dfs(u):
    global time
    if time_found[u] > 0:
        return
    time += 1
    time_found[u] = time
    for v in g[u]:
        dfs(v)
    time += 1
    time_finished[u] = time

for i in range(n):
    if time_found[i] == 0:
        dfs(i)

for i in range(n):
    print(i+1, time_found[i], time_finished[i])
"
8878774,ALDS1_11_B,"def main() -> None:
    import sys

    input = sys.stdin.readline

    n = int(input())
    G = [[]]
    for _ in range(n):
        _, _, *v = map(int, input().split())
        G.append(v)

    seen = [False] * (n + 1)
    d, f = [0] * (n + 1), [0] * (n + 1)

    def dfs(now, t):
        d[now] = t
        seen[now] = True
        for nv in G[now]:
            if seen[nv]:
                continue
            t = dfs(nv, t + 1)
        f[now] = t + 1
        return t + 1

    t = 1
    for i in range(1, n + 1):
        if seen[i]:
            continue
        t = dfs(i, t) + 1
    for i in range(1, n + 1):
        print(f""{i} {d[i]} {f[i]}"")


if __name__ == ""__main__"":
    main()

"
8880677,ALDS1_11_B,"# code 
import sys
sys.setrecursionlimit(10**9)
n = int(input())
g = [[] for _ in range(n+1)]
for i in range(n):
    u,k,*v = map(int, input().split())
    g[u] = v

start = 1
cntr = 0
visited = [False] * (n+1)
ans = [[] for _ in range(n+1)]
def dfs(v):
    global cntr
    cntr += 1
    ans[v].append(cntr)
    visited[v] = True
    for next_v in g[v]:
        if not visited[next_v]:
            dfs(next_v)
    cntr += 1
    ans[v].append(cntr)

for i in range(1,n+1):
    if not visited[i]:
        dfs(i)
for i in range(1,n+1):
    print(i, *ans[i])
"
8905029,ALDS1_11_B,"n=int(input())
graph=dict()
for i in range(n):
    temp=list(map(int,input().split()))
    if temp[1]==0:
        graph[i+1]=[]
    else:
        graph[i+1]=temp[2:]


visited = [0] * (len(graph) + 1)

# 各頂点の発見時刻と完了時刻を保存するリスト
d = [0] * (len(graph) + 1)
f = [0] * (len(graph) + 1)

# 時刻を管理する変数
time = 0

def dfs(v):
    global time
    # 頂点vを訪問中にする
    visited[v] = 1
    # 発見時刻を記録
    time += 1
    d[v] = time

    # 頂点vから行ける各頂点について
    for u in graph[v]:
        if visited[u] == 0:
            dfs(u)

    # 頂点vを訪問済みにする
    visited[v] = 2
    # 完了時刻を記録
    time += 1
    f[v] = time

# すべての頂点について深さ優先探索を実行
for v in range(1, len(graph) + 1):
    if visited[v] == 0:
        dfs(v)

for v in range(1, len(graph) + 1):
    print(v,d[v],f[v])

"
8930151,ALDS1_11_B,"import sys

sys.setrecursionlimit(10 ** 6)

n = int(input())

edges = [[] for i in range(n)]
for i in range(n):
    a = list(map(int, input().split()))
    edges[i] = sorted(a[2:])

pInfo = [[-1, -1] for i in range(n)]

def dfs (num, i):
    nextNode = edges[num]
    pInfo[num][0] = i+1
    arrive = i+1
    for k in nextNode:
        if pInfo[k-1][0] != -1:
            continue
        arrive = dfs(k-1, arrive)
    pInfo[num][1] = arrive + 1
    return arrive + 1

a = 0
for i in range(n):
    if pInfo[i][0] != -1:
        continue
    a = dfs(i, a)

for i in range(n):
    print(i+1, pInfo[i][0], pInfo[i][1])


"
8944330,ALDS1_11_B,"V = int(input())

adj_list = [[] for v in range(V)]

for i in range(V):
    l = list(map(int, input().split()))
    u,k = l[0]-1,l[1]
    for j in range(k):
        v = l[2+j]-1
        adj_list[u].append(v)

color = [""WHITE""]*V
time = 0
d = [-1]*V
f = [-1]*V

def dfs_visit(u):
    global time
    time += 1
    d[u] = time
    color[u] = ""GRAY""
    for v in adj_list[u]:
        if color[v] == ""WHITE"":
            dfs_visit(v)
    time += 1
    f[u] = time
    color[u] = ""BLACK""
    
for u in range(V):
    if color[u] == ""WHITE"":
        dfs_visit(u)

for v in range(V):
    print(v+1, d[v], f[v])


"
8964455,ALDS1_11_B,"import sys
sys.setrecursionlimit(10000)

V = int(input())
adj_list = [[] for v in range(V)]

for i in range (V):
    alist = list(map(int, input().split()))
    alist[0] -= 1
    for j in range (alist[1]):
        alist[j+2] -= 1
        adj_list[alist[0]].append(alist[j+2])
time = 0        
visited = [0]*V
discovered = [0]*V
finished = [0]*V
def Visit(u):
    global time
    time += 1
    discovered[u] = time
    visited[u]=1
    for i in adj_list[u]:
        if visited[i] == 0:
            Visit(i)
    time += 1
    finished[u] = time
    visited[u] = 2
    
for i in range(V):
    if(visited[i]==0):
        Visit(i)

for i in range (V):
    print(i+1, discovered[i], finished[i])

"
8966413,ALDS1_11_B,"V = int(input())
adj_list = [[] for v in range(V)]

for i in range(V):
    temp = [int(num) for num in input().split()]
    u = temp[0] -1
    d = temp[1]
    if d != 0:
        for v in range(d):
            adj_list[u].append(temp[v+2] - 1)
    


color = [""WHITE""]*V
p = [None]*V
time = 0
d = [-1]*V
f = [-1]*V

def dfs_visit(u):
    global time
    time = time + 1
    d[u] = time
    color[u] = ""GRAY""

    for v in adj_list[u]:
        if color[v] == ""WHITE"":
            p[v] = u
            dfs_visit(v)

    color[u] = ""BLACK""
    time = time + 1
    f[u] = time

for u in range(V):
    if color[u] == ""WHITE"":
        dfs_visit(u)

for v in range(V):
    if d[v] == -1:
        dv = ""undiscovered""
    else:
        dv = d[v]
    if f[v] == -1:
        fv = """"
    else:
        fv = f[v]
    if p[v] != None:
        pv = p[v]+1
    else:
        pv = ""None""

    print(v+1,dv,fv)

"
8967463,ALDS1_11_B,"class Ts:
    __slots__ = [""d"", ""f""]
    d: int
    f: int

    def __init__(self):
        self.d = 0
        self.f = 0


def dp(u: int, edges: list[list[int]], t: int, ts: list[Ts]) -> int:
    ts[u].d = t
    t += 1

    for v in edges[u]:
        if ts[v].d == 0:
            t = dp(v, edges, t, ts)

    ts[u].f = t
    return t + 1


def solve(edges: list[list[int]]):
    N = len(edges) - 1
    ts = [Ts() for _ in range(N + 1)]
    breads = [i for i in range(N, 0, -1)]

    t = 1
    while breads:
        u = breads.pop()
        if ts[u].d == 0:
            t = dp(u, edges, t, ts)

    for i in range(1, N + 1):
        print(f""{i} {ts[i].d} {ts[i].f}"")


if __name__ == ""__main__"":
    N = int(input())
    edges = [None] * (N + 1)

    for _ in range(N):
        u, _, *v = map(int, input().split())
        edges[u] = v

    solve(edges)

"
8972009,ALDS1_11_B,"from collections import defaultdict
import sys

sys.setrecursionlimit(10**6)

def dfs(curr):
    global t
    S[curr] = t
    visited.add(curr)
    for np in nei_dict[curr]:
        if np in visited:
            continue
        t += 1
        dfs(np)
    t += 1
    F[curr] = t

n = int(input())
nei_dict = defaultdict(list)
for i in range(n):
    lst = list(map(int, input().split()))
    k = lst[1]
    lst = lst[2:]
    for j in range(k):
        nei_dict[i].append(lst[j] - 1)

S = [0 for _ in range(n)]
F = [0 for _ in range(n)]
visited = set()
t = 1
for i in range(n):
    if i not in visited:
        dfs(i)
        t += 1
for i in range(n):
    print(i + 1, S[i], F[i])
"
8973690,ALDS1_11_B,"from collections import deque
import sys

time = 0

def dfs(g, s, visited, discovery_time, finish_time):
    global time
    stack = deque([s])

    while stack:
        v = stack[-1]
        if v not in visited:
            time += 1
            discovery_time[v] = time
            visited.add(v)
        remove_from_stack = True
        for neighbor in sorted(g[v]):
            if neighbor not in visited:
                stack.append(neighbor)
                remove_from_stack = False
                break
        if remove_from_stack:
            stack.pop()
            time += 1
            finish_time[v] = time


n = int(input().strip())


g = {i: [] for i in range(1, n+1)}


for _ in range(n):
    line = list(map(int, input().strip().split()))
    v = line[0]
    for adjacent_v in line[2:]:
        g[v].append(adjacent_v)

visited = set()
discovery_time = {}
finish_time = {}


for v in range(1, n+1):
    if v not in visited:
        dfs(g, v, visited, discovery_time, finish_time)


for v in range(1, n+1):
    print(v, discovery_time.get(v, 0), finish_time.get(v, 0))
"
8974979,ALDS1_11_B,"n = int(input())
adj_list = [[] for _ in range(n)]
for i in range(n):
    line = input().split()
    u = int(line[0]) - 1
    k = int(line[1])
    for j in range(k):
        v = int(line[j + 2]) - 1
        adj_list[u].append(v)


color = [""WHITE""] * n
d = [-1] * n
f = [-1] * n
time = 0

def DFS(u):
    global time
    color[u] = ""GRAY""
    time += 1
    d[u] = time
    for v in adj_list[u]:
        if color[v] == ""WHITE"":
            DFS(v)
    color[u] = ""BLACK""
    time += 1
    f[u] = time

for u in range(n):
    if color[u] == ""WHITE"":
        DFS(u)

for u in range(n):
    print(u + 1, d[u], f[u])

"
8975254,ALDS1_11_B,"def dfs_visit(u, graph, visited, d, f, time):
    time[0] += 1
    d[u] = time[0] 
    visited.add(u)
    
    for v in graph[u]:
        if v not in visited:
            dfs_visit(v, graph, visited, d, f, time) 
    time[0] += 1
    f[u] = time[0] 

def dfs(graph, n):
    visited = set()
    d = [0] * (n + 1)  # Discovery times, 1-indexed
    f = [0] * (n + 1)  # Finish times, 1-indexed
    time = [0]  # Global time counter
    
    for u in range(1, n + 1):
        if u not in visited:
            dfs_visit(u, graph, visited, d, f, time)
    
    return d, f

n = int(input())  # Number of vertices
graph = {i: [] for i in range(1, n + 1)}

for _ in range(n):
    input_line = list(map(int, input().split()))
    u = input_line[0]
    k = input_line[1]
    for v in input_line[2:2+k]:
        graph[u].append(v)

d, f = dfs(graph, n)

for i in range(1, n + 1):
    print(f""{i} {d[i]} {f[i]}"")
"
8975410,ALDS1_11_B,"# graph_type = input()
# # 
# # if graph_type != ""Directed Graph"":
# #     print(""DFS only works on Directed Graph"")
# #     exit()

V = int(input())
adj_list = [[] for v in range(V)]
for i in range(V):
    ver = list(map(lambda x:int(x)-1, input().split()))
    id = ver[0]
    adj_list[id]= ver[2:]

color = [""WHITE""]*V
p = [None]*V
time = 0
d = [-1]*V
f = [-1]*V
# print(adj_list)
# print(
# ""-----------------------------""
# )
# Write your Depth-First Search code below
# Don't forget to make the initial dfs call! :)

def dfs_visit(G,s):
    global time
    time += 1
    d[s] = time
    color[s] = ""GRAY""
    # print(""Before"")
    # print(G[s],s,color,d,f)
    for v in G[s]:
        # print(v)
        if color[v] == ""WHITE"":
            p[v] = s
            dfs_visit(G,v)
   
    color[s] = ""BLACK""
    time += 1
    f[s] = time
    # print(""After"")
    # print(G[s],s,color,d,f)
 
for v in range(V):
    # print(v,'t')
    if color[v] == ""WHITE"":
        dfs_visit(adj_list,v)

# The code below is for printing output

for v in range(V):
    if d[v] == -1:
        dv = ""undiscovered""
    else:
        dv = d[v]
    if f[v] == -1:
        fv = """"
    else:
        fv = f[v]
    if p[v] != None:
        pv = p[v]+1
    else:
        pv = ""None""

    print(v+1, dv, fv)



"
8975470,ALDS1_11_B,"def dfs(adj_list, n):
    visited = [False] * (n + 1)
    discover_time = [0] * (n + 1)
    finish_time = [0] * (n + 1)
    time = 1

    def dfs_visit(vertex):
        nonlocal time
        visited[vertex] = True
        discover_time[vertex] = time
        time += 1

        for neighbor in adj_list[vertex]:
            if not visited[neighbor]:
                dfs_visit(neighbor)

        finish_time[vertex] = time
        time += 1

    for i in range(1, n + 1):
        if not visited[i]:
            dfs_visit(i)

    return discover_time, finish_time


def main():
    n = int(input().strip())
    adj_list = {}
    for i in range(1, n + 1):
        data = list(map(int, input().split()))
        u = data[0]
        neighbors = data[2:]
        adj_list[u] = neighbors

    discover_time, finish_time = dfs(adj_list, n)

    for i in range(1, n + 1):
        print(i, discover_time[i], finish_time[i])


if __name__ == ""__main__"":
    main()

"
8975571,ALDS1_11_B,"def dfs(graph, vertex, visited, time, discover, finish):
    # Mark the current vertex as visited
    visited[vertex] = True
    
    # Increment the time
    time[0] += 1
    discover[vertex] = time[0]
    
    # Explore adjacent vertices
    for neighbor in graph[vertex]:
        if not visited[neighbor]:
            dfs(graph, neighbor, visited, time, discover, finish)
    
    # Update finish time
    time[0] += 1
    finish[vertex] = time[0]

def main():
    # Read input
    n = int(input())
    graph = {}
    for i in range(1, n + 1):
        line = input().split()
        vertex = int(line[0])
        neighbors = list(map(int, line[2:]))
        graph[vertex] = neighbors

    # Initialize data structures
    visited = [False] * (n + 1)
    discover = [0] * (n + 1)
    finish = [0] * (n + 1)
    time = [0]

    # Perform DFS on each vertex if it hasn't been visited
    for vertex in range(1, n + 1):
        if not visited[vertex]:
            dfs(graph, vertex, visited, time, discover, finish)

    # Print the result
    for vertex in range(1, n + 1):
        print(vertex, discover[vertex], finish[vertex])

if __name__ == ""__main__"":
    main()

"
8976165,ALDS1_11_B,"n = int(input())  
graph = {i: [] for i in range(1, n + 1)}

for i in range(n):
    user_in = list(map(int, input().split()))
    u = user_in[0]
    k = user_in[1]
    for v in user_in[2:2+k]:
        graph[u].append(v)

def dfs_visit(u, graph, visited, d, f, time):
    time[0] += 1
    d[u] = time[0] 
    visited.add(u)
    
    for v in graph[u]:
        if v not in visited:
            dfs_visit(v, graph, visited, d, f, time)
    
    time[0] += 1
    f[u] = time[0]  

def dfs(graph, n):
    visited = set()
    discover = [0] * (n + 1)  
    finish = [0] * (n + 1)  
    time = [0]  
    
    for u in range(1, n + 1):
        if u not in visited:
            dfs_visit(u, graph, visited, discover, finish, time)
    
    return discover, finish


d, f = dfs(graph, n)


for i in range(1, n + 1):
    print(f""{i} {d[i]} {f[i]}"")

"
8976204,ALDS1_11_B,"#6520054 Myo Myat Min
V = int(input())
adj_list = [[] for _ in range(V)]

for i in range(V):
    row = list(map(lambda x: int(x) - 1, input().split()))
    if row[1] != -1:
        adj_list[i] = row[2:]

color = [""WHITE""] * V
p = [None] * V
time = 0
d = [-1] * V
f = [-1] * V

def dfs_visit(G, s):
    global time
    time += 1
    d[s] = time
    color[s] = ""GRAY""
    for v in G[s]:
        if color[v] == ""WHITE"":
            p[v] = s
            dfs_visit(G, v)

    color[s] = ""BLACK""
    time += 1
    f[s] = time

for v in range(V):
    if color[v] == ""WHITE"":
        dfs_visit(adj_list, v)

for v in range(V):
    print(v + 1, d[v], f[v])

"
8976364,ALDS1_11_B,"def dfs(graph, vertex, visited, time, discover, finish):
    # Mark the current vertex as visited
    visited[vertex] = True
    
    # Increment the time
    time[0] += 1
    discover[vertex] = time[0]
    
    # Explore adjacent vertices
    for neighbor in graph[vertex]:
        if not visited[neighbor]:
            dfs(graph, neighbor, visited, time, discover, finish)
    
    # Update finish time
    time[0] += 1
    finish[vertex] = time[0]

def main():
    # Read input
    n = int(input())
    graph = {}
    for i in range(1, n + 1):
        line = input().split()
        vertex = int(line[0])
        neighbors = list(map(int, line[2:]))
        graph[vertex] = neighbors

    # Initialize data structures
    visited = [False] * (n + 1)
    discover = [0] * (n + 1)
    finish = [0] * (n + 1)
    time = [0]

    # Perform DFS on each vertex if it hasn't been visited
    for vertex in range(1, n + 1):
        if not visited[vertex]:
            dfs(graph, vertex, visited, time, discover, finish)

    # Print the result
    for vertex in range(1, n + 1):
        print(vertex, discover[vertex], finish[vertex])

if __name__ == ""__main__"":
    main()
"
8976529,ALDS1_11_B,"def dfs(graph, v, visited, discover, finish, time):
    time += 1
    discover[v] = time
    visited[v] = True
    for neighbor in graph[v]:
        if not visited[neighbor]:
            time = dfs(graph, neighbor, visited, discover, finish, time)
    time += 1
    finish[v] = time
    return time

def main():
    n=int(input())
    graph = [[] for _ in range(n + 1)]
    for _ in range(n):
        u, k, *adj_list = map(int, input().split())
        graph[u] = adj_list

    visited = [False] * (n + 1)
    discover = [0] * (n + 1)
    finish = [0] * (n + 1)
    time = 0

    for v in range(1, n + 1):
        if not visited[v]:
            time = dfs(graph, v, visited, discover, finish, time)

    for v in range(1, n + 1):
        print(v, discover[v], finish[v])

if __name__ == ""__main__"":
    main()

"
8976692,ALDS1_11_B,"def dfs(node_id):
    global current_time, visited, go_time, back_time, G
    go_time[node_id] = current_time
    current_time += 1

    for next_node in G[node_id]:
        if visited[next_node]:
            continue
        visited[next_node] = True
        dfs(next_node)

    back_time[node_id] = current_time
    current_time += 1


V = int(input())
G = [[] for _ in range(V)]
visited = [False] * V
go_time = [0] * V
back_time = [0] * V

for loop in range(V):
    tmp_list = list(map(int, input().split()))
    node_id, num = tmp_list[0] - 1, tmp_list[1]
    for i in range(2, num + 2):
        G[node_id].append(tmp_list[i] - 1)

current_time = 1

for i in range(V):
    if not visited[i]:
        visited[i] = True
        dfs(i)

for i in range(V):
    print(f""{i+1} {go_time[i]} {back_time[i]}"")

"
8977102,ALDS1_11_B,"n = int(input())  
graph = {i: [] for i in range(1, n + 1)}

# print(graph)

for i in range(n):
    user_in = list(map(int, input().split()))
    u = user_in[0]
    k = user_in[1]
    for v in user_in[2:2+k]:
        graph[u].append(v)

# print(graph)

def dfs_visit(u, graph, visited, d, f, time):
    time[0] += 1
    d[u] = time[0] 
    visited.add(u)
    
    for v in graph[u]:
        if v not in visited:
            dfs_visit(v, graph, visited, d, f, time)
    
    time[0] += 1
    f[u] = time[0]  

def dfs(graph, n):
    visited = set()
    discover = [0] * (n + 1)  
    finish = [0] * (n + 1)  
    time = [0]  
    
    for u in range(1, n + 1):
        if u not in visited:
            dfs_visit(u, graph, visited, discover, finish, time)
    
    return discover, finish


d, f = dfs(graph, n)


for i in range(1, n + 1):
    print(f""{i} {d[i]} {f[i]}"")

"
8977401,ALDS1_11_B,"V = int(input())
adj_list = [[] for v in range(V)]
for i in range(V):
    lInput = list(map(int, input().split()))
    u = lInput[0] - 1
    for neighbor in lInput[2:]:
        adj_list[u].append(neighbor - 1)
    
color = [""WHITE""]*V
p = [None]*V
time = 0
d = [-1]*V
f = [-1]*V

def dfs():
    global time
    for i in range(V):
        color[i] = ""WHITE""
        p[i] = None
    time = 0
    for i in range(V):
        if(color[i]==""WHITE""):
            dfs_visit(i)

def dfs_visit(i):
    global time
    time += 1
    d[i]=time
    color[i] = ""GRAY""
    for o in adj_list[i]:
        if color[o]==""WHITE"":
            p[o]=i
            dfs_visit(o)
    time+=1
    f[i]=time
    color[i]=""BLACK""

dfs()

for v in range(V):
    if d[v] == -1:
        dv = ""undiscovered""
    else:
        dv = d[v]
    if f[v] == -1:
        fv = """"
    else:
        fv = f[v]
    if p[v] is not None:
        pv = p[v]+1
    else:
        pv = ""None""
    print(v+1,dv,fv)
   

"
8977416,ALDS1_11_B,"def dfs_visit(u):
    global time
    time += 1
    d[u] = time
    color[u] = ""GRAY""
    for v in adj_list[u]: 
        if color[v] == ""WHITE"":
            p[v] = u
            dfs_visit(v)
    time += 1
    f[u] = time

def dfs():
    global time
    for u in range(1, V + 1):
        if color[u] == ""WHITE"":
            dfs_visit(u)
            
V = int(input())
adj_list = {}
for i in range(V):
    u, k, *neighbors = map(int, input().split()) #*neighbours to get everything after k
    adj_list[u] = neighbors
#print(adj_list)
    
# Initialize variables with [0] + .... (since constraint started from 1)
color = [0] + [""WHITE""] * V 
p = [0]+ [None] * V 
time = 0
d = [0] + [-1] * V 
f = [0] + [-1] * V 


dfs()


for v in range(1, V + 1):
    print(v, d[v], f[v])

"
9000429,ALDS1_11_B,"import sys
sys.setrecursionlimit(10**7) 
n = int(input())

G = [[] for _ in range(n+1)]

for _ in range(n):
    l = list(map(int,input().split()))
    u = l[0]
    G[u] = l[2:]

d = [0]*(n+1)
f = [0]*(n+1)
color = [""White""]*(n+1)
time = 0
def dfs(u):
    global time
    time += 1
    d[u] = time
    color[u] = ""Gray""
    
    for v in G[u]:
        if color[v] == ""White"":
            dfs(v)
    
    time += 1
    f[u] = time
    color[u] = ""Black""

for i in range(1,n+1):
    if color[i] == ""White"":
        dfs(i)

for i in range(1,n+1):
    print(i, d[i], f[i])
"
9029646,ALDS1_11_B,"global current_time


def dfs(adjacent_list, d, f, pos: int):
    global current_time

    adjacent = sorted(adjacent_list[pos - 1])
    current_time += 1
    d[pos - 1] = current_time

    for v in adjacent:
        if d[v - 1] == 0:
            dfs(adjacent_list, d, f, v)
        else:
            pass

    current_time += 1
    f[pos - 1] = current_time


def main():
    global current_time
    current_time = 0

    n = int(input())
    adjacent_list = []
    for i in range(n):
        line = list(map(int, input().split("" "")))
        adjacent_list.append(line[2:])

    # タイムスタンプ d[v]: v を最初に発見した発見時刻を記録します。
    # タイムスタンプ f[v]: v の隣接リストを調べ終えた完了時刻を記録します。
    d = [0] * n
    f = [0] * n

    while True:
        not_traversed = sorted([v for (v, found_time) in enumerate(d, 1) if found_time == 0])
        # until all nodes are traversed.
        if not not_traversed:
            break

        next_pos = not_traversed[0]
        dfs(adjacent_list, d, f, pos=next_pos)

    for i in range(n):
        print(f""{i + 1} {d[i]} {f[i]}"")


# 深さ優先探索: https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_11_B&lang=ja
if __name__ == '__main__':
    main()

"
9032715,ALDS1_11_B,"def counter(t=0):
    while True:
        yield t
        t += 1


def depth_first_search(node):
    d[node] = next(clock)
    for adjacent_node in connections[node]:
        d[adjacent_node] or depth_first_search(adjacent_node)
    f[node] = next(clock)


n = int(input())
connections = [range(1, n + 1)] + [list(map(int, input().split()))[2:] for _ in range(n)]
d, f = [0] * (n + 1), [0] * (n + 1)
clock = counter(0)
depth_first_search(0)
for number, (start, end) in list(enumerate(zip(d, f)))[1:]:
    print(f'{number} {start} {end}')

"
8241652,ALDS1_11_C,"from collections import deque

def bfs(graph, start):
    n = len(graph)
    distances = [-1] * n
    distances[start - 1] = 0
    queue = deque([start])

    while queue:
        current_vertex = queue.popleft()
        for neighbor in graph[current_vertex - 1]:
            if distances[neighbor - 1] == -1:
                distances[neighbor - 1] = distances[current_vertex - 1] + 1
                queue.append(neighbor)

    return distances

# Read input
n = int(input())
graph = [[] for _ in range(n)]

for i in range(n):
    data = input().split()
    u = int(data[0])
    k = int(data[1])
    v = [int(x) for x in data[2:]]
    graph[u - 1] = v

# Perform BFS starting from vertex 1
distances = bfs(graph, 1)  # Start from vertex 1

# Print the results
for vertex_id, distance in enumerate(distances):
    print(f""{vertex_id + 1} {distance}"")

"
8246324,ALDS1_11_C,"N = int(input())
G = [None for i in range(N)]
for i in range(N):
    u, k, *vs = map(int, input().split())
    G[u-1] = [e-1 for e in vs]


from collections import deque
dist = [-1]*N
que = deque([0])
dist[0] = 0
while que:
    v = que.popleft()
    d = dist[v]
    for w in G[v]:
        if dist[w] > -1:
            continue
        dist[w] = d + 1
        que.append(w)

for i in range(N):
    print(i+1, dist[i])
"
8246516,ALDS1_11_C,"vertex = int(input())
adj_list = [[] for v in range(vertex)]

for i in range(vertex):
    list_of_adj_list = list(map(int, input().split()))
    node = list_of_adj_list[0] - 1
    edge = list_of_adj_list[1] - 1
    edge_list = list_of_adj_list[2:]
    for j in edge_list:
        adj_list[node].append(j)

a = [[] for v in range(len(adj_list))]
for x in range(len(adj_list)):
    for i in adj_list[x]:
        a[x].append(i - 1)



color = [""WHITE""] * vertex
d = [-1] * vertex

node = 0
if color[node] == ""WHITE"":
    color[node] = ""GRAY""
    d[node] = 0

queue = [node]

while len(queue) > 0:
    parent = queue.pop(0)
    for neighbor in a[parent]:
        if color[neighbor] == ""WHITE"":
            color[neighbor] = ""GRAY""
            d[neighbor] = d[parent] + 1
            queue.append(neighbor)

    color[parent] = ""BLACK""

def debug():
    for v in range(vertex):
        if d[v] == -1:
            dv = -1
        else:
            dv = d[v]
        print(""%d %d"" % (v + 1, dv))

debug()

"
8246986,ALDS1_11_C,"from collections import deque

def shortest_distance(graph, n):
    distances = [-1] * (n + 1)
    visited = [False] * (n + 1)

    distances[1] = 0
    visited[1] = True

    queue = deque([1])

    while queue:
        current_vertex = queue.popleft()
        for neighbor in graph[current_vertex]:
            if not visited[neighbor]:
                visited[neighbor] = True
                distances[neighbor] = distances[current_vertex] + 1
                queue.append(neighbor)

    return distances

# Read input                                  
n = int(input())
graph = [[] for _ in range(n + 1)]

for i in range(1, n + 1):
    data = list(map(int, input().split()))
    u = data[0]
    neighbors = data[2:]
    graph[u] = neighbors

# Calculate shortest distances
distances = shortest_distance(graph, n)

# Print output
for i in range(1, n + 1):
    print(i, distances[i])

"
8247406,ALDS1_11_C,"vertex = int(input())
adj_list = []
for i in range(vertex):
    input_list = list(map(int, input().split()))
    vertex_id = input_list[0]
    degree = input_list[1]

    if degree != 0:
        adj_list.append(input_list[2:])
    else:
        adj_list.append([])

d = [-1]*vertex
d[0] = 0
Q = [0]
visited = []

while Q != []:
    u = Q.pop(0)
    for v in adj_list[u]:
        v-=1
        if d[v] != 1 and v != 0 and v not in visited: 
            d[v] = d[u]+1
            visited.append(v)
            Q.append(v)

for i in range(vertex):
    print(f'{i+1} {d[i]}')
"
8247997,ALDS1_11_C,"from collections import deque

n = int(input())
adj_list = [[] for _ in range(n)]

for u in range(n):
    data = list(map(int, input().split()))
    k = data[1]
    adj_list[u] = data[2:]

color = [""WHITE""] * n
distance = [-1] * n

def BFS(s):
    color[s] = ""GRAY""
    distance[s] = 0

    Q = deque()
    Q.append(s)

    while Q:
        u = Q.popleft()

        for v in adj_list[u]:
            if color[v - 1] == ""WHITE"":
                color[v - 1] = ""GRAY""
                distance[v - 1] = distance[u] + 1
                Q.append(v - 1)

        color[u] = ""BLACK""

BFS(0)

for u in range(n):
    print(u + 1, distance[u])

"
8248127,ALDS1_11_C,"n = int(input())
adj_list = [list(map(int, input().split())) for _ in range(n)]

color = [""WHITE""]*n
d = [-1]*n
p = [None]*n

s = adj_list[0][0] - 1
color[s] = ""GREY""
d[s] = 0
p[s] = None

Q = [s]
while Q:
    u = Q[0]
    del Q[0]

    for i in range(adj_list[u][1]):
        v = adj_list[u][i+2] - 1
        if color[v] == ""WHITE"":
            color[v] = ""GREY""
            d[v] = d[u] + 1
            p[v] = u
            Q.append((v))

    color[u] = ""BLACK""

for v in range(n):
    print(*(v+1,d[v]))
"
8250551,ALDS1_11_C,"n = int(input())
adj_list = [[] for _ in range(n)]

# Parse the input and build the adjacency list
for u in range(1, n + 1):
    data = input().split()
    u = int(data[0])
    k = int(data[1])
    if k > 0:
        neighbors = list(map(int, data[2:]))
        adj_list[u - 1] = [v - 1 for v in neighbors]

color = [""WHITE""] * n
d = [-1] * n
p = [None] * n

# Modify BFS to compute shortest distances from vertex 1 to all other vertices
def bfs(start):
    queue = []
    queue.append(start)
    color[start] = ""GRAY""
    d[start] = 0
    while queue:
        u = queue.pop(0)
        for v in adj_list[u]:
            if color[v] == ""WHITE"":
                queue.append(v)
                color[v] = ""GRAY""
                d[v] = d[u] + 1
                p[v] = u
        color[u] = ""BLACK""

# Call BFS for vertex 0 (vertex 1 in 1-based indexing)
bfs(0)

# Print the results in the required format
for v in range(n):
    if d[v] == -1:
        dv = -1
    else:
        dv = d[v]
    print(""%d %d"" % (v + 1, dv))

"
8250592,ALDS1_11_C,"n = int(input())

G = []
G.append([])
for i in range(n):
    v = list(map(int, input().split()))
    G.append(v[2:])

q = []
q.append(1)

checked = [False] * (n + 1)
checked[1] = True
d = [-1] * (n + 1)
d[1] = 0

while q:
    current = q.pop(0)
    for v in G[current]:
        if not checked[v]:
            q.append(v)
            d[v] = d[current] + 1
            checked[v] = True

for i in range(1, n + 1):
    print(i, d[i])
"
8250670,ALDS1_11_C,"from collections import deque

def bfs_shortest_distance(n, graph):
    distances = [-1] * (n + 1)  
    distances[1] = 0
    queue = deque([1])  
    
    while queue:
        u = queue.popleft()
        for v in graph[u]:
            if distances[v] == -1:
                distances[v] = distances[u] + 1
                queue.append(v)
    
    for u in range(1, n + 1):
        print(u, distances[u])

n = int(input())
graph = [[] for _ in range(n + 1)]

for i in range(1, n + 1):
    data = list(map(int, input().split()))
    u = data[0]
    adj_list = data[2:]
    graph[u] = adj_list

bfs_shortest_distance(n, graph)
"
8250905,ALDS1_11_C,"node = int(input())
adjList = [list() for _ in range(node)]
for i in range(node):
    u, k, *vs = map(int, input().split())
    for j in vs:
        adjList[u - 1].append(j)

def bfs(graph):
    queue = []
    discovered = [False] * len(graph)
    distance = [None] * len(graph)

    discovered[0] = True
    queue.append(0)
    distance[0] = 0

    idx = 0
    while idx < len(queue):
        current = queue[idx]
        idx += 1
        for node in graph[current]:
            if discovered[node-1] == False:
                distance[node-1] = 1 + distance[current]
                discovered[node-1] = True
                queue.append(node-1)

    return distance

distances = bfs(adjList)

for i in range(len(distances)):
    if distances[i] is None:
        print(i + 1, -1)
    else:
        print(i + 1, distances[i])
"
8251162,ALDS1_11_C,"from collections import deque

def shortest_distances(n, graph):
    distances = [-1] * (n + 1)
    visited = [False] * (n + 1)
    distances[1] = 0
    visited[1] = True
    
    queue = deque()
    queue.append(1)

    while queue:
        current_vertex = queue.popleft()
        for neighbor in graph[current_vertex]:
            if not visited[neighbor]:
                distances[neighbor] = distances[current_vertex] + 1
                visited[neighbor] = True
                queue.append(neighbor)
    
    return distances[1:]

# Read input
n = int(input())
graph = [[] for _ in range(n + 1)]
for u in range(1, n + 1):
    data = list(map(int, input().split()))
    k, neighbors = data[1], data[2:]
    graph[u] = neighbors

# Calculate shortest distances
distances = shortest_distances(n, graph)

# Print output
for u, d in enumerate(distances, start=1):
    print(f""{u} {d}"")

"
8251207,ALDS1_11_C,"n = int(input())
ad_list = [list(map(int, input().split())) for _ in range(n)]
color = [""WHITE""]*n
a = [-1]*n
p = [None]*n
s = ad_list[0][0] - 1
color[s] = ""GREY""
a[s] = 0
p[s] = None

Q = [s]
while Q:
    u = Q[0]
    del Q[0]

    for i in range(ad_list[u][1]):
        v = ad_list[u][i+2] - 1
        if color[v] == ""WHITE"":
            color[v] = ""GREY""
            a[v] = a[u] + 1
            p[v] = u
            Q.append((v))

    color[u] = ""BLACK""
for v in range(n):
    print(*(v+1,a[v]))
"
8251221,ALDS1_11_C,"from collections import deque

def bfs_shortest_distance(n, adj_list):
   
   distance = [-1] * n
   distance[0] = 0  


   queue = deque()
   queue.append(0)  

   while queue:
     u = queue.popleft()  
     for v in adj_list[u]:
        if distance[v - 1] == -1: 
            distance[v - 1] = distance[u] + 1
            queue.append(v - 1)  
   return distance


n = int(input())
adj_list = [[] for _ in range(n)]
for i in range(n):
    line = input().split()
    u = int(line[0])
    k = int(line[1])
    if k > 0:
        v_list = list(map(int, line[2:]))
        adj_list[u - 1].extend(v_list)

distance = bfs_shortest_distance(n, adj_list)

for u, dist in enumerate(distance):
 print(u + 1, dist)

"
8251252,ALDS1_11_C,"from collections import deque

def bfs_shortest_distance(n, adj_list):
    distance = [-1] * n
    distance[0] = 0
    queue = deque([0])

    while queue:
        u = queue.popleft()
        for v in adj_list[u]:
            if distance[v - 1] == -1:
                distance[v - 1] = distance[u] + 1
                queue.append(v - 1)

    return distance

n = int(input())
adj_list = [[] for _ in range(n)]

for u in range(n):
    _, k, *v_list = map(int, input().split())
    adj_list[u] = v_list

distance = bfs_shortest_distance(n, adj_list)

for u, dist in enumerate(distance):
    print(u + 1, dist)

"
8251253,ALDS1_11_C,"from collections import deque

def bfs_shortest_distance(n, adj_list):
    distances = [-1] * n
    distances[0] = 0
    queue = deque([0])

    while queue:
        u = queue.popleft()
        for v in adj_list[u]:
            if distances[v - 1] == -1:
                distances[v - 1] = distances[u] + 1
                queue.append(v - 1)
    return distances

n = int(input())
adj_list = [[] for _ in range(n)]

for u in range(n):
    line = input().split()
    k = int(line[1])
    if k > 0:
        v_list = list(map(int, line[2:]))
        adj_list[u].extend(v_list)

distances = bfs_shortest_distance(n, adj_list)
for u, dist in enumerate(distances):
    print(u + 1, dist)
"
8251268,ALDS1_11_C,"from collections import deque

def bfs_shortest_distance(n, adj_list):
    distance = [-1] * n
    distance[0] = 0
    queue = deque([0])

    while queue:
        u = queue.popleft()
        for v in adj_list[u]:
            if distance[v - 1] == -1:
                distance[v - 1] = distance[u] + 1
                queue.append(v - 1)

    return distance

n = int(input())
adj_list = [[] for _ in range(n)]

for u in range(n):
    _, k, *v_list = map(int, input().split())
    adj_list[u] = v_list

distance = bfs_shortest_distance(n, adj_list)

for u, dist in enumerate(distance):
    print(u + 1, dist)
"
8251418,ALDS1_11_C,"from collections import deque

V = int(input())
adj_list = [[] for _ in range(V)]

for i in range(V):
    neighbors = list(map(int, input().split()))[1:]
    for v in neighbors:
        v -= 1  
        if 0 <= v < V:  
            adj_list[i].append(v)

color = [""WHITE""] * V
d = [-1] * V
p = [None] * V

def bfs(s):
    queue = deque()
    queue.append(s)
    color[s] = ""GRAY""
    d[s] = 0

    while queue:
        u = queue.popleft()
        for v in adj_list[u]:
            if color[v] == ""WHITE"":
                color[v] = ""GRAY""
                d[v] = d[u] + 1
                p[v] = u
                queue.append(v)
        color[u] = ""BLACK""


bfs(0)


for v in range(V):
    if d[v] == -1:  
        dv = ""-1""  
    else:
        dv = str(d[v])
    print(f""{v + 1} {dv}"")
"
8251438,ALDS1_11_C,"from collections import deque
def addEdge(adjacencyList, u, v):
    adjacencyList[u].append(v)

def bfs_shortest_path(adjacencyList, u, v):
    global noOfVertices
    visited = [False] * noOfVertices;
    parent = [-1] * noOfVertices;

    queue = deque()
    queue.append(u)
    visited[u] = True

    while queue:
        currentVertex = queue.popleft()
        if currentVertex == v:
            path = [v]
            while parent[v] != -1:
                v = parent[v]
                path.insert(0, v)
            return len(path) - 1

        for neighbour in adjacencyList[currentVertex]:
            if not visited[neighbour]:
                queue.append(neighbour)
                visited[neighbour] = True
                parent[neighbour] = currentVertex
               
    return -1

noOfVertices = int(input()) + 1

adjacencyList = [[] for i in range(noOfVertices)]

for i in range(noOfVertices - 1):
    v, k, *e = map(int, input().split())
    for j in range(k):
        addEdge(adjacencyList, v, e[j])

for i in range(1, noOfVertices):
    length = bfs_shortest_path(adjacencyList, 1, i)
    print(i, length)
"
8251513,ALDS1_11_C,"V = int(input())
adj_list = [[] for _ in range(V)]

# Read input and build the directed graph
for u in range(V):
    line = input().split()
    k = int(line[1])
    v_list = [int(x) - 1 for x in line[2:]]
    adj_list[u] = v_list

color = [""WHITE""] * V
d = [-1] * V
p = [None] * V

# Write your Breast-First Search code below
def bfs(start):
    queue = []
    queue.append(start)
    color[start] = ""GRAY""
    d[start] = 0

    while queue:
        u = queue.pop(0)
        for v in adj_list[u]:
            if color[v] == ""WHITE"":
                color[v] = ""GRAY""
                d[v] = d[u] + 1
                p[v] = u
                queue.append(v)
        color[u] = ""BLACK""

bfs(0)

# The code below is for printing output
for v in range(V):
    if d[v] == -1:
        dv = -1
    else:
        dv = d[v]
    print(f""{v + 1} {dv}"")
"
8255312,ALDS1_11_C,"from collections import deque

n = int(input())
la = [[] for i in range(n)]


for i in range(n):
    l = list(map(int, input().split()))
    if l[1] != 0:
        la[l[0] - 1] = list(map(lambda x: x - 1, l[2:]))

lc = [-1 for i in range(n)]

lc[0] = 0
dq = deque([0])
cnt = 0
while len(dq) > 0:
    p = dq.popleft()
    for a in la[p]:
        if lc[a] == -1:
            lc[a] = lc[p] + 1
            dq.append(a)

for i in range(n):
    print(i + 1, lc[i])

"
8257586,ALDS1_11_C,"from collections import deque

n = int(input()) # number of vertices
G = [0]
distance = [-1 for _ in range(n+1)]
distance[1] = 0

def bfs():
    queue = deque([1])
    while queue:
        v = queue.popleft()
        d = distance[v]
        for w in G[v]:
            if distance[w] > -1:
                continue
            distance[w] = d + 1
            queue.append(w)

def main():
    for _ in range(n):
        table = list(map(int, input().split()))
        G.append(table[2:])
    for id in range(2, n+1): # when id==1, distance==0
        bfs()
    for i in range(1, n+1):
        print('{0} {1}'.format(i, distance[i]))

if __name__ == '__main__':
    main()
"
8276836,ALDS1_11_C,"from queue import Queue
n = int(input())
G = [[] for i in range(n)]
for i in range(n):
    l = list(map(int, input().split()))
    u = l[0] - 1
    k = l[1]
    for i in range (k):
        v = l[i + 2] - 1
        G[u].append(v)
que = Queue()
dist = [-1] * n
# 幅探索の初期条件
que.put(0)
dist[0] = 0

# 幅探索
while not que.empty():
    v = que.get()

    # v につながる頂点を探索
    for v2 in G[v]:
        # v2 がすでに探索済みの場合はスキップする
        if dist[v2] != -1:
            continue
        # v2 を新たにtodo リストに追加
        que.put(v2)

        # v2 の距離を更新
        dist[v2] = dist[v] + 1
for i in range(1, n + 1):
    print(i, dist[i - 1])

#print(G)
#print(dist)
"
8375458,ALDS1_11_C,"from collections import deque

def bfs(graph, n):
    # Initialize distances and visited array
    distances = [-1] * (n + 1)
    visited = [False] * (n + 1)

    # Start BFS from vertex 1
    distances[1] = 0
    visited[1] = True
    queue = deque([1])

    while queue:
        u = queue.popleft()
        for v in graph[u]:
            if not visited[v]:
                visited[v] = True
                distances[v] = distances[u] + 1
                queue.append(v)

    return distances

# Read input
n = int(input())
graph = [[] for _ in range(n + 1)]

for i in range(1, n + 1):
    data = list(map(int, input().split()))
    u, k, *adj_list = data
    graph[u] = adj_list

# Find shortest distances
distances = bfs(graph, n)

# Print the results
for u in range(1, n + 1):
    print(u, distances[u])


"
8380233,ALDS1_11_C,"from collections import deque

# Read input
n = int(input())
adj_list = [[] for _ in range(n)]
for u in range(n):
    line = input().split()
    k = int(line[1])
    for i in range(2, 2 + k):
        v = int(line[i])
        adj_list[u].append(v)

# Initialize distances with -1 (infinity)
distances = [-1] * n

# Perform BFS
queue = deque()
queue.append(0)  # Start from vertex 1 (0-based index)
distances[0] = 0  # Distance from 1 to itself is 0

while queue:
    u = queue.popleft()
    for v in adj_list[u]:
        if distances[v - 1] == -1:  # If v is not visited yet
            distances[v - 1] = distances[u] + 1
            queue.append(v - 1)

# Print the results
for u in range(n):
    print(u + 1, distances[u])


#input
# 4
# 1 2 2 4
# 2 1 4
# 3 0
# 4 1 3
#The first line indicates that there are 4 vertices in the graph (n = 4).

# The next 4 lines provide information about the adjacent vertices for each vertex. Here's what each line represents:

# Line 1: Vertex 1 has 2 adjacent vertices, which are vertex 2 and vertex 4.

# Line 2: Vertex 2 has 1 adjacent vertex, which is vertex 4.

# Line 3: Vertex 3 has 0 adjacent vertices, indicating it has no outgoing edges.

# Line 4: Vertex 4 has 1 adjacent vertex, which is vertex 3.

#output
# 1 0
# 2 1
# 3 2
# 4 1

# The program calculates and prints the shortest distance from vertex 1 to each of the 4 vertices (vertex IDs 1, 2, 3, and 4).

# For each vertex, it displays two values separated by a space:

# The first value is the ID of the vertex (id).

# The second value is the shortest distance (d) from vertex 1 to the current vertex.

# Here's the interpretation of the output:

# Vertex 1 is the starting vertex, so its distance from itself is 0 (1 0).

# Vertex 2 is at a distance of 1 edge away from vertex 1 (2 1).

# Vertex 3 is at a distance of 2 edges away from vertex 1 (3 2).

# Vertex 4 is at a distance of 1 edge away from vertex 1 (4 1).

# So, the output represents the shortest distances from vertex 1 to each of the other vertices in the graph. In this case, it's essentially measuring how many edges you need to traverse to reach each vertex starting from vertex 1.





"
8397171,ALDS1_11_C,"import queue

n=int(input())

G=[[None]]
for i in range(1,n+1):
  top=list(map(int,input().split()))
  G.append(top[2:])
  
dist=[-1]*(n+1)
Q=queue.Queue()
Q.put(1)
dist[1]=0

while not Q.empty():
  pos=Q.get()
  for next in G[pos]:
    if dist[next]==-1:
      dist[next]=dist[pos]+1
      Q.put(next)

for i in range(1,n+1):
  print(i,dist[i])

"
8401103,ALDS1_11_C,"# 幅優先探索

from collections import deque

def bfs(v,dist,G):

    dq = deque([v])

    while len(dq) > 0:
        u = dq.popleft()
        for to in G[u]:
            if dist[to] == -1:
                dist[to] = dist[u] + 1
                dq.append(to)

    return


    



def main():

    n = int(input())

    G = [[] for _ in range(n)]

    for i in range(n):
        uk = list(map(int, input().split()))
        for j in range(uk[1]):
            G[i].append(uk[2+j]-1)
    
    dist = [-1]*(n)
    dist[0] = 0
    bfs(0,dist,G)

    for i in range(n):
        print(i+1,dist[i])



if __name__ == '__main__':
    main()

"
8427539,ALDS1_11_C,"from collections import deque
n = int(input())
uvk = [list(map(int, input().split())) for _ in range(n)]

connect = [[] for _ in range(n+1)]
for i in range(n):
    for j in range(uvk[i][1]):
        connect[uvk[i][0]].append(uvk[i][2+j])
seen = [False] * (n+1)
# print(seen)
dist = [-1]*(n+1)
dist[1] = 0

# print(connect)
def bfs(start):
    que = deque()
    que.append(1)
    seen[start] = True
    while que:
        now = que.popleft()
        for to_g in connect[now]:
            if seen[to_g] == True: continue
            else:
                seen[to_g] = True
                dist[to_g] = dist[now] + 1
                que.append(to_g)

bfs(1)
# print(dist)
for i,j in enumerate(dist[1:]):
    print(i+1,j)
"
8450812,ALDS1_11_C,"from collections import deque

n = int(input())

G = {}
for _ in range(n):
  u, k, *V = map(int, input().split())
  G[u] = V

D = [-1]*(n+1)
D[1] = 0
q = deque([1])
while q:
  node_i = q.popleft()
  for node_j in G[node_i]:
    if D[node_j]!=-1:
      continue
    q.append(node_j)
    D[node_j] = D[node_i]+1
    
for i, d in enumerate(D):
  if i==0:
    continue
  print(i, d)
"
8471827,ALDS1_11_C,"from collections import deque


""""""input""""""
n = int(input())
prox = [ 0 for _ in range(n) ]
for i in range(n):
	temp = list(map(int,input().split()))
	#0Startの隣接リストを作成,子がいなければprox[i] = []になる.
	prox[i] = [ v-1 for v in temp[2:] ]
#print(prox)



""""""define""""""
#頂点0からの距離を-1埋めで定義する.たどり着けなかったらこの値は更新されない.
dist = [-1] * n
dist[0] = 0
que = deque()
que.append(0)


while que:
	v = que.popleft()
	for child in prox[v]:
		if dist[child] != -1:
			continue
		dist[child] = dist[v] + 1
		que.append(child)


for i,d in enumerate(dist):
	print(f""{i+1} {d}"")

"
8483450,ALDS1_11_C,"from collections import deque


n=int(input())
G=[[] for i in range(n)]

for i in range(n):
    read=list(map(int,input().split()))
    u=read[0]
    u-=1
    k=read[1]
    if k==0:
        continue
    else:
        for j in read[2:]:
            G[u].append(j-1)
        
#print(G)
d=deque([0])
dist=[-1]*n
dist[0]=0

while d:
    v=d.pop()
    for nv in G[v]:
        if dist[nv]!=-1:
            continue
        else:
            dist[nv]=dist[v]+1
            d.appendleft(nv)
            
for v,ans in enumerate(dist):
    print(v+1,ans)
    
        
"
8524321,ALDS1_11_C,"#21D8102009G Miyagawa Kai
#Breadth First Search

from collections import deque

n=int(input()) #number of vertices
list=[list(map(int, input().split())) for i in range(n)]

d=[-1]*(n+1) #distance from root

q=deque()
q.append(1) #add_start_point

#bfs
d[1]=0

while len(q)>0:
    now=q.popleft() #search_point
    #print(now)
    for i in range(list[now-1][1]):
        node=list[now-1][2+i] #node is the connected point by now
        if d[node]==-1: #if node have not serched
            q.append(node) 
            d[node]=d[now]+1 

for id in range(1,n+1):
    print(id,d[id])
"
8535679,ALDS1_11_C,"n = int(input())
G = [None] * n
for _ in range(n):
  u, _, *V = map(int, input().split())
  G[u-1] = [v-1 for v in V]

d = [0] + [-1] * (n-1)
q = [0]
while q:
  v = q.pop(0)
  for u in G[v]:
    if d[u] == -1:
      d[u] = d[v] + 1
      q.append(u)

for v in range(n):
  print(v+1, d[v])

"
8571472,ALDS1_11_C,"from collections import deque

def bfs_shortest_distance(graph, start, n):
    distance = [-1] * (n + 1)  # 各頂点への最短距離を記録するリスト
    distance[start] = 0  # 開始頂点からの距離は0

    q = deque([start])  # 幅優先探索で使用するキュー
    while q:
        v = q.popleft()

        for neighbor in graph[v]:
            if distance[neighbor] == -1:  # 未訪問の頂点の場合
                distance[neighbor] = distance[v] + 1
                q.append(neighbor)

    return distance[1:]

# グラフの頂点数を取得
n = int(input())
G = {}
for i in range(1, n + 1):
    data = list(map(int, input().split()))
    G[i] = data[2:]  # 隣接リストの3番目以降が隣接する頂点番号

# 幅優先探索を実行し、各頂点への最短距離を求める
shortest_distances = bfs_shortest_distance(G, 1, n)

# 結果を出力
for i, distance in enumerate(shortest_distances, start = 1):
    print(i, distance)

"
8572988,ALDS1_11_C,"from collections import deque

def breadth_first_search(graph, start, n):
    visited = [False] * (n + 1)
    distance = [-1] * (n + 1)
    queue = deque()

    queue.append(start)
    visited[start] = True
    distance[start] = 0

    while queue:
        u = queue.popleft()

        for v in graph[u]:
            if not visited[v]:
                visited[v] = True
                distance[v] = distance[u] + 1
                queue.append(v)

    return distance

def main():
    # 入力の読み込み
    n = int(input())
    graph = {i: [] for i in range(1, n + 1)}

    for _ in range(n):
        data = list(map(int, input().split()))
        u, k, *neighbors = data
        graph[u] = neighbors

    # 幅優先探索の実行
    distances = breadth_first_search(graph, start=1, n=n)

    # 結果の出力
    for u in range(1, n + 1):
        print(f""{u} {distances[u]}"")

if __name__ == ""__main__"":
    main()

"
8586116,ALDS1_11_C,"""""""
与えられた有向グラフ 
G=(V,E) について、頂点 1 から各頂点への最短距離 d
（パス上の辺の数の最小値）を求めるプログラムを作成してください。
各頂点には1 から n までの番号がふられているものとします。
頂点 1 からたどり着けない頂点については、距離として-1 を出力してください。
""""""

from queue import Queue

# 有向グラフを作成
N = int(input())
G = []
for i in range(N):
    u = list(map(int, input().split(' ')))
    G.append([j - 1 if j > 0 else j for j in u])        

# 頂点の探索の有無& 距離算出用(未探索は-1とする)
dist = [-1 for _ in range(N)]

# キューを作成
que = Queue()

#　先頭の値を始点として設定
dist[0] = 0
que.put(0)

# キューが空になるまで処理を実行
while not que.empty():
    # 現在の座標値を取得
    v = que.get()
    
    # 次の座標値で作業を開始
    for nv in G[v]:
        # 次の座標値が探索済みなら何も処理を行わない
        if dist[nv] != -1:
            continue
        # 次の座標値が未探索であれば、キューの追加&距離の算出を行う
        else:
            que.put(nv)
            dist[nv] = dist[v] + 1

for i in range(len(dist)):
    print(f'{i+1} {dist[i]}')
"
8599738,ALDS1_11_C,"from collections import deque
from enum import Enum


class Color(Enum):
    WHITE = 0
    GRAY = 1
    BLACK = 2


class Node:
    def __init__(self, id: int, neighbors_list: list) -> None:
        self.id = id
        self.neighbors_list = neighbors_list
        self.color = Color.WHITE
        self.distance = -1


def bfs(node: Node):
    global wait_queue
    global node_list
    node.color = Color.GRAY
    node.distance = 0
    wait_queue.append(node)

    while len(wait_queue) > 0:
        search_node: Node = wait_queue.popleft()
        for neighbor in node_list:
            if neighbor.id in search_node.neighbors_list and neighbor.color == Color.WHITE:
                neighbor.color = Color.GRAY
                neighbor.distance = search_node.distance + 1
                wait_queue.append(neighbor)
        search_node.color = Color.BLACK


n = int(input())
node_list: list[Node] = []
for _ in range(n):
    n_list = list(map(int, input().split()))
    n_neighbors = n_list[1]
    neighbors_list = []
    for i in range(n_neighbors):
        neighbors_list.append(n_list[2 + i])
    node_list.append(Node(n_list[0], neighbors_list))

wait_queue = deque([])
bfs(node_list[0])

for i in range(n):
    print(f""{node_list[i].id} {node_list[i].distance}"")

"
8612081,ALDS1_11_C,"import collections
n = int(input())
a=[]
for i in range(n):
    u, k, *b = map(int, input().split())
    a.append(b)

time = 1
d = [-1]*n
d[0] = 0
p = collections.deque()
p.append(0)
while len(p)>0:
    x = p.popleft()
    for i in a[x]:
        if d[i-1] == -1:
            d[i-1] = d[x] + 1
            p.append(i-1)

for i in range(n):
    print(i+1, d[i])
"
8615004,ALDS1_11_C,"n = int(input())
u = [0]
for i in range(n):
    tmp = [int(i) for i in input().split()]
    u.append(tmp)
q = [0]*(n+1)

dis = [-1]*(n+1)
queue = []

dis[1]=0
queue.append(u[1])

while len(queue)>0:
    c = queue[0]
    if q[c[0]]<c[1]:
        q[c[0]]+=1
        u2=c[q[c[0]]+1]
        if dis[u2]==-1:
            dis[u2]=dis[c[0]]+1
            queue.append(u[u2])
    else:
        queue.pop(0)
for i in range(1,n+1):
    print(i,dis[i])
"
8616260,ALDS1_11_C,"G=[]
n=int(input())
for i in range(n):
    T=[int(t) for t in input().split()]
    G.append(T)
from operator import itemgetter
g=sorted(G,key=itemgetter(0))

d=[-1]*n
d[0]=0
v=[1]
while len(v) > 0:
        u=v[0]
        if len(g[u-1]) > 2:
            if d[g[u-1][2]-1]<0:
                v.append(g[u-1][2])
                d[g[u-1][2]-1]=d[u-1]+1
            del g[u-1][2]
        else:
            del v[0]
for i in range(n):
    print(g[i][0],d[i])
"
8616727,ALDS1_11_C,"from collections import deque

def bfs(graph, start, n):
    distance = [-1] * (n + 1)
    distance[start] = 0

    queue = deque([start])

    while queue:
        current_vertex = queue.popleft()

        for neighbor in graph[current_vertex]:
            if distance[neighbor] == -1:
                distance[neighbor] = distance[current_vertex] + 1
                queue.append(neighbor)

    return distance[1:]

# 入力処理
n = int(input())
graph = {i: [] for i in range(1, n + 1)}

for _ in range(n):
    line = list(map(int, input().split()))
    vertex = line[0]
    neighbors = line[2:]
    graph[vertex] = neighbors

# 幅優先探索の実行と出力
for vertex, distances in enumerate(bfs(graph, 1, n), start=1):
    print(f""{vertex} {distances}"")

"
8617737,ALDS1_11_C,"from collections import deque

class Graph:
    def __init__(self, vert):
        self.vert = vert
        self.adjacency_list = [[] for _ in range(vert)]

    def add_edge(self, from_ver, to_ver):
        self.adjacency_list[from_ver].append(to_ver)

    def bfs_min_dis(self, start_ver):
        dis = [-1] * self.vert
        dis[start_ver] = 0

        queue = deque([start_ver])

        while queue:
            tex = queue.popleft()

            for adjacent_ver in self.adjacency_list[tex]:
                if dis[adjacent_ver] == -1:
                    dis[adjacent_ver] = dis[tex] + 1
                    queue.append(adjacent_ver)

        return dis

def main():
    n = int(input())
    g = Graph(n)

    for u in range(n):
        data = input().split()
        k = int(data[1])
        for v in map(int, data[2:]):
            g.add_edge(u, v - 1)  

    dis = g.bfs_min_dis(0) 

    for ver in range(g.vert):
        print(f""{ver + 1} {dis[ver]}"")

if __name__ == ""__main__"":
    main()

"
8659813,ALDS1_11_C,"from collections import deque

class Node:
    def __init__(self):
        self.uid = -1
        self.distance = -1
        self.adj = []

def main():
    n = int(input())
    # グラフ要素
    graph = [Node() for _ in range(n)]
    for node in graph:
        node.uid, k, *node.adj = map(int, input().split())
    # 隣接リストの中身をノード番号からノードそのものに変える
    for node in graph:
        node.adj = [graph[uid-1] for uid in node.adj]
    # 幅優先探索
    graph[0].distance = 0
    breadth_first_search(graph)
    # 出力
    for node in graph:
        print(node.uid, node.distance)


# 幅優先探索
def breadth_first_search(graph):
    # 同じ深さのノードをキューで管理
    node_id = 0
    que = deque([node_id])
    while que:
        node_id = que.popleft()
        # 深さ優先でノードを順番に見ていく
        for vnode in graph[node_id].adj:
            if vnode.distance != -1:
                continue
            vnode.distance = graph[node_id].distance + 1
            que.append(vnode.uid-1)


if __name__ == '__main__':
    main()
"
8664816,ALDS1_11_C,"n=int(input())
connect=[[] for i in range(n)]

for i in range(n):
    t=list(map(int,input().split()))
    for j in range(t[1]):
        connect[t[0]-1].append(t[j+2]-1)
inf=10**20
d=[inf]*n

from heapq import heapify, heappop, heappush
que = []
heapify(que)

heappush(que,(0,0))
d[0]=0

while que:
    dis, now = que.pop()
    for to in connect[now]:
        if d[to]>dis+1:
            d[to]=dis+1
            heappush(que,(dis+1,to))

for i in range(n):
    if d[i]==inf:
        d[i]=-1
    print(i+1,d[i])
"
8675577,ALDS1_11_C,"from collections import defaultdict, deque
n = int(input())
g = defaultdict(list)
for i in range(n):
    u, k, *v = map(int, input().split())
    if v:
        g[u].append(v)

dist = [-1 for _ in range(n)]
dist[0] = 0
nxt = deque()
nxt.append(1)

while nxt:
    t = nxt.popleft()
    if g[t]:
        for nt in g[t][0]:
            if dist[nt-1] >= 0:
                continue
            else:
                dist[nt-1] = dist[t-1]+1
                nxt.append(nt)
for i in range(n):
    print(i+1, dist[i])

"
8686821,ALDS1_11_C,"from sys import stdin
input = stdin.readline

from collections import deque, defaultdict
from copy import deepcopy

INFTY = -1 # 探索しなかったやつを-1としてprintしやすくするために-1とした。

n = int(input())

M = [[0]*n for _ in range(n)]

def bfs(s):
    q = deque()
    q.append(s)
    d = [INFTY]*n
    d[s] = 0
    while q:
        u = q.popleft()
        for v in range(n):
            if M[u][v] == 0:
                continue
            if d[v] != INFTY:
                continue
            d[v] = d[u] + 1
            q.append(v)
    for i in range(n):
        print(str(i+1) + ' ' + str(d[i]))


for _ in range(n):
    u, k, *vv = map(int, input().split())
    u -= 1
    for v in vv:
        v -= 1
        M[u][v] = 1

bfs(0)
"
8722584,ALDS1_11_C,"from collections import deque

N = int(input())
adj = [[]] + [list(map(int, input().split()[2:])) for _ in range(N)]

dist = [-1]*(N+1)
q = deque()
q.append(1)
dist[1] = 0

while q:
    u = q.popleft()
    for v in adj[u]:
        if dist[v] >= 0:
            continue
        dist[v] = dist[u]+1
        q.append(v)

for i in range(1, N+1):
    print(i, dist[i])

"
8730077,ALDS1_11_C,"import collections

d=collections.deque()

n=int(input())
g=[[] for i in range(n+1)]
for i in range(n):
    a=list(map(int,input().split()))
    if a[1]>0:
        g[a[0]]=a[2:]
# print(g)

answer=[-1]*(n+1)

answer[1]=0
d.append(1)
while len(d)>0:
    point=d.popleft()
    for next in g[point]:
        if answer[next]==-1:
            d.append(next)
            answer[next]=answer[point]+1

for i in range(1,n+1):
    print(i,answer[i])
"
8743636,ALDS1_11_C,"from collections import deque

n = int(input())
adj = [list(map(int, input().split()))[2:] for _ in [0]*n]

deq = deque()

# bfs
deq.append(0)
dist = [-1 for _ in [0]*n]
dist[0] = 0
while(len(deq) != 0):
  cur = deq.popleft()
  for next in adj[cur]:
    if dist[next-1] != -1: continue
    deq.append(next-1)
    dist[next-1] = dist[cur]+1
    
for i in range(n):
  print(i+1, dist[i])
"
8752642,ALDS1_11_C,"from collections import deque
from math import inf, isinf


def main():
    n = int(input())
    graph = [set() for _ in range(n)]
    for _ in range(n):
        u, _, *neighbors = map(lambda n: int(n) - 1, input().split())
        if not neighbors:
            continue
        graph[u].update(neighbors)

    distance = [inf for _ in range(n)]
    queue = deque()
    distance[0] = 0
    queue.append(0)
    while queue:
        current = queue.popleft()
        for neighbor in graph[current]:
            if distance[neighbor] > distance[current] + 1:
                distance[neighbor] = distance[current] + 1
                queue.append(neighbor)
    for node_idx, dist in enumerate(distance, 1):
        if isinf(dist):
            print(node_idx, -1)
        else:
            print(node_idx, dist)


if __name__ == ""__main__"":
    main()

"
8758337,ALDS1_11_C,"from collections import deque
n = int(input())
G = [[] for i in range(n)]
for i in range(n):
    row = list(map(int, input().split()))
    u, k = row[:2]
    u -= 1
    for j in range(k):
        G[u].append(row[2+j]-1)
d = [-1]*n

def bfs():
    que = deque([])
    que.append(0)
    d[0] = 0
    while len(que) != 0:
        u = que.popleft()
        for v in G[u]:
            if d[v] != -1:
                continue
            que.append(v)
            d[v] = d[u]+1
    for i in range(n):
        print(i+1,d[i])

bfs()
"
8759941,ALDS1_11_C,"N = int(input())
M = [input().split()[2:]for _ in[0]*N]
q = [0]
d = [0]+[-1]*N
while q:
    u = q.pop(0)
    for v in M[u]:
        v = int(v)-1
        if d[v] < 0: 
            d[v] = d[u] + 1
            q += [v]
for i in range(N):
    print(i+1,d[i])

"
8815715,ALDS1_11_C,"from collections import deque
q = deque([])
n = int(input())
g = [[] for _ in range(n)]

for i in range(n):
    u, k, *vs = map(int, input().split())
    g[u-1] = sorted(list(map(lambda x: int(x) - 1, vs)))

distance = [-1] * n
distance[0] = 0

q.appendleft(0)

while q:
    node = q.popleft()
    for nex in g[node]:
        if distance[nex] != -1: continue
        q.append(nex)
        distance[nex] = distance[node] + 1

for i in range(n):
    print(i+1, distance[i])

"
8824140,ALDS1_11_C,"class Node:
    def __init__(self,index):
        self.index = index
        self.nears = []
        self.color = ""white""

def bfs(G,s):
    Que = []
    for u in V:
        if u != s:
            d[u-1] = -1
    G[s-1].color = ""gray""
    d[s-1] = 0
    Que.append(int(s))
    while len(Que) != 0:
        u = Que.pop(0)
        for v in G[u-1].nears:
            if G[v-1].color == ""white"":
                G[v-1].color = ""gray""
                d[v-1] = d[u-1]+1
                Que.append(int(v))
        G[u-1].color = ""black""

n = int(input())
G = []
V = []
d = [None for i in range(n)]

for i in range(n):
    input_data = list(map(int,input().split()))
    box = Node(input_data[0])
    V.append(input_data[0])
    box.nears = input_data[2:]
    G.append(box)

bfs(G,G[0].index)

for i in range(n):
    print(G[i].index,d[G[i].index-1])
"
8846262,ALDS1_11_C,"# aizu_ALDS1_11_C_BreadthFirstSearch.py  

from collections import deque
n = int(input())
adj = [ ]

for _ in range(n):
    u,k,*v = map(lambda x :int(x)-1,input().split())
    adj.append(v)

visited = [-1]*n
st = 0
dq = deque([[st,0]])
visited[0] = 0

while dq:
    [st,val] = dq.popleft()
    for n_st in adj[st]:
        if visited[n_st] != -1 :continue
        visited[n_st] = val+1
        dq.append([n_st,val+1])

for i in range(n):
    print(i+1,visited[i])

"
8847032,ALDS1_11_C,"from collections import deque

def breadth_first_search(n, graph):
    # Initialize distances with -1
    distances = [-1] * (n + 1)
    distances[1] = 0  # The distance from vertex 1 to itself is 0
    queue = deque([1])  # Start BFS from vertex 1

    # BFS algorithm
    while queue:
        current_vertex = queue.popleft()
        for adjacent_vertex in graph[current_vertex]:
            if distances[adjacent_vertex] == -1:  # Vertex has not been visited
                distances[adjacent_vertex] = distances[current_vertex] + 1
                queue.append(adjacent_vertex)

    return distances[1:]  # We skip index 0 for easier indexing

# Read the number of vertices
n = int(input())

# Read the graph
graph = {i: [] for i in range(1, n + 1)}  # Initialize the graph with empty adjacency lists
for _ in range(n):
    # Read the adjacency list for vertex u
    u_info = list(map(int, input().split()))
    u = u_info[0]
    k = u_info[1]
    graph[u] = u_info[2:]

# Find shortest distances using BFS
distances = breadth_first_search(n, graph)

# Output the distances
for vertex_id in range(1, n + 1):
    print(vertex_id, distances[vertex_id - 1])

"
8847600,ALDS1_11_C,"from collections import deque

def bfs(n, adj):
    dist = [-1] * n
    dist[0] = 0
    q = deque([0])
    visited = set([0])

    while q:
        v = q.popleft()
        for u in adj[v]:
            if u not in visited:
                dist[u] = dist[v] + 1
                q.append(u)
                visited.add(u)

    return dist

def main():
    n = int(input().strip())
    adj = [list(map(int, input().strip().split()))[2:] for _ in range(n)]
    adj = [[v - 1 for v in vertices] for vertices in adj]

    dist = bfs(n, adj)
    for u, d in enumerate(dist):
        print(f'{u + 1} {d}')

if __name__ == '__main__':
    main()
"
8847608,ALDS1_11_C,"from collections import deque
 
def bfs(n, adj):
    dist = [-1] * n
    dist[0] = 0
    q = deque([0])
    visited = set([0])
 
    while q:
        v = q.popleft()
        for u in adj[v]:
            if u not in visited:
                dist[u] = dist[v] + 1
                q.append(u)
                visited.add(u)
 
    return dist
 
def main():
    n = int(input().strip())
    adj = [list(map(int, input().strip().split()))[2:] for _ in range(n)]
    adj = [[v - 1 for v in vertices] for vertices in adj]
 
    dist = bfs(n, adj)
    for u, d in enumerate(dist):
        print(f'{u + 1} {d}')
 
if __name__ == '__main__':
    main()
"
8870127,ALDS1_11_C,"#28
from collections import deque
n = int(input())
g = [[] for _ in range(n)]
for _ in range(n-1):
    i, k, *v = map(lambda x: int(x)-1, input().split())
    if v:
        g[i] = v

dist = [-1]*n
dist[0] = 0
q = deque([0])

while q:
    u = q.popleft()
    for v in g[u]:
        if dist[v] == -1:
            dist[v] = dist[u]+1
            q.append(v)

for i in range(n):
    print(i+1, dist[i])
"
8874832,ALDS1_11_C,"n = int(input())
G = [[] for _ in range(n+1)]
for i in range(n):
    ukv = list(map(int,input().split()))
    u,k,vs = ukv[0], ukv[1], ukv[2:]
    if k > 0:
        for v in vs:
            G[u].append(v)
            # G[v].append(u)

# 幅優先探索
queue = [1]
INF = 10 ** 3
visited = [INF for _ in range(n+1)]
visited[1] = 0

while queue != []:
    q = queue.pop(0)
    for next in G[q]:
        if visited[next] == INF:
            visited[next] = visited[q] + 1
            queue.append(next)

for i in range(1,n+1):
    if visited[i] == INF:
        print(i, -1)
    else:
        print(i, visited[i])
"
8878233,ALDS1_11_C,"V = int(input())
adj_list = [[] for v in range(V)]
for i in range(V):
    ukvs = list(map(int, input().split()))
    u = ukvs[0]-1
    k = ukvs[1]
    for j in range(k):
        v = ukvs[2+j]-1
        adj_list[u].append(v)

color = [""WHITE""]*V
d = [-1]*V

s = 0
color[s] = ""GRAY""
d[s] = s
Q = [s]
while len(Q)!=0:
    u = Q[0]
    del Q[0]
    for v in adj_list[u]:
        if color[v] == ""WHITE"":
            color[v] = ""GRAY""
            d[v] = d[u]+1
            Q.append(v)
    color[u] = ""BLACK""

for v in range(V):
    print(v+1,d[v])

"
8882210,ALDS1_11_C,"# code 
import sys
sys.setrecursionlimit(10**9)
n = int(input())
g = [[] for _ in range(n+1)]
for i in range(n):
    u,k,*v = map(int, input().split())
    g[u] = v
    
from collections import deque
dists = [-1] * (n+1)
start = 1
dists[start] = 0
q = deque([start])
while(q):
    now = q.popleft()
    for next_v in g[now]:
        if dists[next_v] != -1:
            continue
        dists[next_v] = dists[now] + 1
        q.append(next_v)

for i in range(1,n+1):
    print(i, dists[i])
"
8882287,ALDS1_11_C,"def main() -> None:
    import sys
    from collections import deque

    input = sys.stdin.readline

    n = int(input())
    G = [[]]
    for _ in range(n):
        _, _, *v = map(int, input().split())
        G.append(v)

    dist = [-1] * (n + 1)
    dist[1] = 0
    que = deque([1])
    while que:
        now = que.popleft()

        for nv in G[now]:
            if dist[nv] != -1:
                continue
            dist[nv] = dist[now] + 1
            que.append(nv)

    for i in range(1, n + 1):
        print(f""{i} {dist[i]}"")


if __name__ == ""__main__"":
    main()

"
8897174,ALDS1_11_C,"from collections import deque
n=int(input())
ki=[[]]
for _ in range(n):
    ukv=list(map(int,input().split()))
    if ukv[1]==0:
        ki.append([])
    else:
        ki.append(ukv[2:])
#print(ki)
que=deque()
visit=[-1]*(n+1)
visit[1]=0
que.append((1,0))
while len(que)>0:
    now,cnt=que.popleft()
    for to in ki[now]:
        if visit[to]!=-1: continue
        visit[to]=cnt+1
        que.append((to,cnt+1))
for i in range(1,n+1):
    print(i,visit[i])
"
8966933,ALDS1_11_C,"n = int(input())
v = [0] + [[int(i) for i in input().split()[2:]] for _ in range(n)]
d = [-1] * n
d.insert(1, 0)
r = [1]

while r:
    i = r.pop()
    r = v[i] + r
    for j in v[i]:
        if d[j] < 0: d[j] = d[i] + 1
    v[i] = []

for i, j in enumerate(d):
    if i: print(i, j)
"
8967465,ALDS1_11_C,"from collections import deque


def solve(edges):
    N = len(edges) - 1
    dists = [-1 for _ in range(N + 1)]

    breads = deque([1])
    dists[1] = 0

    while breads:
        u = breads.popleft()
        d = dists[u] + 1

        for v in edges[u]:
            if dists[v] == -1:
                dists[v] = d
                breads.append(v)

    for i in range(1, N + 1):
        print(i, dists[i])


if __name__ == ""__main__"":
    N = int(input())
    edges = [None] * (N + 1)

    for _ in range(N):
        u, k, *vs = map(int, input().split())
        edges[u] = vs

    solve(edges)

"
9000134,ALDS1_11_C,"V = int(input())
adj_list = [[] for v in range(V)]

for i in range (V):
    alist = list(map(int, input().split()))
    alist[0] -= 1
    for j in range (alist[1]):
        alist[j+2] -= 1
        adj_list[alist[0]].append(alist[j+2])

color = [""WHITE""]*V
d = [-1]*V
p = [None]*V

# Write your Breast-First Search code below
s = 0
color[s] = ""GRAY""
d[s] = s
p[s] = None
Q = [s]
while len(Q)!=0:
    u = Q[0]
    del Q[0]
    for v in adj_list[u]:
        if(color[v]==""WHITE""):
            color[v] = ""GRAY""
            d[v] = d[u]+1
            p[v] = u
            Q.append(v)
    color[u] = ""BLACK""

for i in range(V):
    print(i+1, d[i])
"
9000438,ALDS1_11_C,"import sys
sys.setrecursionlimit(10**7) 
n = int(input())

G = [[] for _ in range(n+1)]

for _ in range(n):
    l = list(map(int,input().split()))
    u = l[0]
    G[u] = l[2:]

d = [-1]*(n+1)
d[1] = 0
from collections import deque

color = [""White""]*(n+1)
q = deque([1])
color[1] = ""Gray""

while q:
    u = q.popleft()
    
    for v in G[u]:
        if color[v] == ""White"":
            color[v] = ""Gray""
            d[v] = d[u] + 1
            q.append(v)
    
    color[u] = ""Black""
    
for u in range(1,n+1):
    print(u, d[u])
    
"
9004641,ALDS1_11_C,"V = int(input())
adj_list = [[] for v in range(V)]

for i in range(V):
    input_str = list(map(int, input().split()))
    node_id = input_str[0] - 1
    for j in range (input_str[1]):
        adj_list[node_id].append(input_str[2+j]-1)
        
color = [""WHITE""]*V
d = [-1]*V
p = [None]*V

# Write your Breast-First Search code below

s = 0
color[s] = ""GRAY""
d[s] = s
p[s] = None
Q = [s]
while len(Q)!=0:
    u = Q[0]
    del Q[0]
    for v in adj_list[u]:
        if(color[v]==""WHITE""):
            color[v] = ""GRAY""
            d[v] = d[u]+1
            p[v] = u
            Q.append(v)
    color[u] = ""BLACK""

for v in range(V):
    print(v+1, d[v])
"
9012197,ALDS1_11_C,"from collections import deque

v = int(input())
ADJ = [[] for i in range(v)]

class Info:
    def __init__(self, arg_node_id, arg_sum_cost):
        self.node_id = arg_node_id
        self.sum_cost = arg_sum_cost

for loop in range(v):
    input_str = list(map(int, input().split()))
    node_id = input_str[0]-1
    for i in range(input_str[1]):
        ADJ[node_id].append(input_str[2+i]-1)

visited = [False]*v
visited[0] = True

min_dist = [-1]*v
min_dist[0] = 0

Q = deque()
Q.append((Info(0, 0)))

while len(Q) > 0:
    info = Q.popleft()
    for next_node in ADJ[info.node_id]:
        if visited[next_node] == True:
            continue
        visited[next_node] = True
        min_dist[next_node] = info.sum_cost + 1
        Q.append((Info(next_node, min_dist[next_node])))

for i in range(v):
    print(""%d %d""%(i+1, min_dist[i]))
        
    
"
9188387,ALDS1_11_D,"import sys
def s():
 e=sys.stdin.readline
 n,m=map(int,e().split())
 P=[[]for _ in[0]*n]
 C=[0]*n
 k=0
 for _ in[0]*m:
  s,t=map(int,e().split());P[s]+=[t];P[t]+=[s]
 for i in range(n):
  k+=1
  if C[i]<1:
   s=[i];C[i]=k
   while s:
    u=s.pop()
    for v in P[u]:
     if C[v]<1:C[v]=k;s+=[v]
 for _ in[0]*int(e()):
  a,b=map(int,e().split())
  print(['no','yes'][C[a]==C[b]])
s()

"
9136141,ALDS1_11_D,"import sys
r = sys.stdin.readline
w = sys.stdout.write

from collections import deque
def CC():  # スタックを使って実装
    def make_grp(i: int):
        stp[i] = True
        deq = deque()
        deq.append(i)
        
        while len(deq) > 0:
            v = deq.pop()
            for av in a[v]:
                if not stp[av]:
                    grp[av] = i
                    stp[av] = True
                    deq.append(av)

    n, m = map(int, r().split())
    a =[[] for _ in range(n)]
    stp = [False] * n
    *grp, = range(n)
    
    for _ in range(m):
        s, t = map(int, r().split())
        a[s].append(t)
        a[t].append(s)
    
    for i in range(n):
        if stp[i]: continue
        make_grp(i)
        
    q = int(r())
    for _ in range(q):
        s, t = map(int, r().split())
        if grp[s] == grp[t]: w(""yes\n"")
        else: w(""no\n"")
CC()
"
9182792,ALDS1_11_D,"import sys
readline = sys.stdin.readline
write = sys.stdout.write
N, M = map(int, readline().split())
*p, = range(N)
def root(x):
    if x == p[x]:
        return x
    p[x] = x = root(p[x])
    return x
def unite(x, y):
    px = root(x); py = root(y)
    if px < py:
        p[py] = px
    else:
        p[px] = py


for i in range(M):
    s, t = map(int, readline().split())
    unite(s, t)
*_, = map(root, range(N))
Q = int(readline())
ans = []
for q in range(Q):
    s, t = map(int, readline().split())
    ans.append('yes' if p[s] == p[t] else 'no')
write(""\n"".join(ans))
write(""\n"")


"
9180061,ALDS1_11_D,"import sys
input = sys.stdin.readline

def find(parent, i):
    root = i
    while parent[root] != -1:
        root = parent[root]
    while i != root:
        parent[i], i = root, parent[i]
    return root

def union(parent, x, y):
    x_root = find(parent, x)
    y_root = find(parent, y)
    if x_root != y_root:
        parent[x_root] = y_root

n, m = map(int, input().split())
parent = [-1] * n

for _ in range(m):
    s, t = map(int, input().split())
    union(parent, s, t)

q = int(input())

for _ in range(q):
    s, t = map(int, input().split())
    if find(parent, s) == find(parent, t):
        print(""yes"")
    else:
        print(""no"")

"
8271622,ALDS1_11_D,"from collections import defaultdict

class UnionFind():
    '''
    n: int num of elements
    parents: list 
    '''
    def __init__(self, n):
        self.n = n
        self.parents = [-1] * n
    
    def find(self, x):
        # Determine which set an element belongs to
        # -> find the root of x
        if self.parents[x] < 0:
            return x
        else:
            self.parents[x] = self.find(self.parents[x])
            return self.parents[x]
        
    def union(self, x, y):
        # merge two union
        x = self.find(x)
        y = self.find(y)
        if x == y:
            return
        if self.parents[x] > self.parents[y]:
            x, y = y, x
        self.parents[x] += self.parents[y]
        self.parents[y] = x

    def size(self, x):
        # the size of tree which x belongs to
        return -self.parents[self.find(x)]
    
    def same(self, x, y):
        # determine x and y are belong to same tree or not
        return self.find(x) == self.find(y)
    
    def members(self, x):
        # returns the list of elements belonging to the tree to which x belongs
        root = self.find(x)
        return [i for i in range(self.n) if self.find(i) == root]
    
    def roots(self):
        # return all tree as a list
        return [i for i, x in enumerate(self.parents) if x < 0]
    
    def groupCount(self):
        # return the num of groups
        return len(self.roots())
    
    def allGroupMembers(self):
        # return all group of elements info as dictionary
        groupMembers = defaultdict(list)
        for member in range(self.n):
            groupMembers[self.find(member)].append(member)
        return groupMembers
    
    def __str__(self):
        return '\n'.join(f'{r}: {m}' for r, m in self.allGroupMembers().items())

def main():
    n, m = map(int, input().split())
    un = UnionFind(n)
    for _ in range(m):
        s, t = map(int, input().split())
        un.union(s, t)
    q = int(input()) # num of queries
    for _ in range(q):
        s, t = map(int, input().split())
        if un.same(s, t):
            print('yes')
        else: 
            print('no')

if __name__ == '__main__':
    main()
"
9182611,ALDS1_11_D,"from collections import deque

def main():
    n, m = map(int, input().split())  
    friends = [[] for _ in range(n)]  
    for _ in range(m):
        s, t = map(int, input().split()) 
        friends[s].append(t)
        friends[t].append(s)

    group = [-1] * n 
    for u in range(n):
        if group[u] == -1:  
            group[u] = u  
            queue = deque([u]) 
            while queue:
                u1 = queue.popleft()
                for u2 in friends[u1]:
                    if group[u2] == -1:
                        group[u2] = u 
                        queue.append(u2)

    q = int(input())
    for _ in range(q):
        s, t = map(int, input().split()) 
        if group[s] == group[t]: 
            print('yes')
        else:
            print('no')


main()
"
8816161,ALDS1_11_D,"n,m=map(int,input().split())
g=[[] for _ in range(n)]
for i in range(m):
    u,v=map(int,input().split())
    g[u].append(v)
    g[v].append(u)

color=[0]*n
c = 1
for i in range(n):
    if color[i]: continue
    color[i] = c
    s=[i]
    while s:
        p=s.pop()
        for q in g[p]:
            if color[q]: continue
            s.append(q)
            color[q] = c
    c+=1

for i in range(int(input())):
    u,v=map(int,input().split())
    print(""yes"" if color[u] == color[v] else ""no"")

"
8846326,ALDS1_11_D,"# aizu_ALDS1_11_D_Connect.py  

from collections import defaultdict
class UnionFind():
    def __init__(self, n):
        self.n = n
        self.parents = [-1] * n

    def find(self, x):
        if self.parents[x] < 0:
            return x
        else:
            self.parents[x] = self.find(self.parents[x])
            return self.parents[x]

    def union(self, x, y): 
        x = self.find(x)
        y = self.find(y)
        if x == y:return
        if self.parents[x] > self.parents[y]:
            x, y = y, x
        self.parents[x] += self.parents[y]
        self.parents[y] = x

    def size(self, x):
        return -self.parents[self.find(x)]

    def same(self, x, y):
        return self.find(x) == self.find(y)

    def members(self, x):
        root = self.find(x)
        return [i for i in range(self.n) if self.find(i) == root]

    def roots(self):
        return [i for i, x in enumerate(self.parents) if x < 0]

n,m = map(int,input().split())
uf = UnionFind(n)

for _ in range(m):
    s,t = map(int,input().split())
    uf.union(s,t)

q = int(input())
for _ in range(q):
    s,t = map(int,input().split())    
    ret = uf.same(s,t)
    print('yes' if ret else 'no')
"
9027779,ALDS1_11_D,"class UnionFind:

    __slots__ = ""par""

    def __init__(self, n: int):
        self.par = [-1] * n

    def root(self, x: int) -> int:
        y = x
        while self.par[y] >= 0:
            y = self.par[y]
        while self.par[x] >= 0:
            z = self.par[x]
            self.par[x] = y
            x = z
        return y

    def issame(self, x: int, y: int) -> bool:
        return self.root(x) == self.root(y)

    def unite(self, x: int, y: int) -> bool:
        rx = self.root(x)
        ry = self.root(y)
        if rx == ry:
            return False
        if -self.par[rx] < -self.par[ry]:
            rx, ry = ry, rx
        self.par[rx] += self.par[ry]
        self.par[ry] = rx
        return True


N, M = map(int, input().split())

uf = UnionFind(N)
for _ in range(M):
    a, b = map(int, input().split())
    uf.unite(a, b)


Q: int = int(input())
for _ in range(Q):
    s, t = map(int, input().split())
    print(""yes"" if uf.issame(s, t) else ""no"")

"
9117612,ALDS1_11_D,"class UnionFind():
    def __init__(self, n):
        self.n = n
        self.root = [-1] * n
        self.rank = [0] * n

    def find(self, x):
        if self.root[x] < 0:
            return x
        else:
            self.root[x] = self.find(self.root[x])
            return self.root[x]

    def unite(self, x, y):
        x = self.find(x)
        y = self.find(y)

        if x == y:
            return
        elif self.rank[x] > self.rank[y]:
            self.root[x] += self.root[y]
            self.root[y] = x
        else:
            self.root[y] += self.root[x]
            self.root[x] = y
            if self.rank[x] == self.rank[y]:
                self.rank[y] += 1

    def same(self, x, y):
        return self.find(x) == self.find(y)

n, m = map(int, input().split())
uf = UnionFind(n)
for _ in range(m):
    s, t = map(int, input().split())
    uf.unite(s, t)
q = int(input())
for _ in range(q):
    s, t = map(int, input().split())
    print(""yes"" if uf.same(s, t) else ""no"")

"
9168222,ALDS1_11_D,"n,m=map(int,input().split())
friend=[[] for i in range(n)]
for i in range(m):
    s,t=map(int,input().split())
    friend[s].append(t)
    friend[t].append(s)

group=[-1 for i in range(n)]
for u in range(n):
    if group[u]==-1:
        group[u]=u
        q=[u]
        while q:
            u1=q.pop()
            for u2 in friend[u1]:
                if group[u2]==-1:
                    group[u2]=u
                    q.append(u2)

q=int(input())
for i in range(q):
    s,t=map(int,input().split())
    if group[s]==group[t]:
        print('yes')
    else:
        print('no')
"
9202854,ALDS1_11_D,"V, E = map(int, input().split()) # ノード数とエッジ数を入力
edge = [[] for _ in range(V)]
for _ in range(E): #エッジの情報を隣接リストに格納
    s, t = map(int, input().split())
    edge[s].append(t)
    edge[t].append(s)

group = [-1] * V
cnt = 0
for i in range(V): #各ノードについてグループを設定
    if group[i] == -1:
        group[i] = cnt
        stack = [i]
        while stack:
            v = stack.pop()
            for c in edge[v]:
                if group[c] == -1:
                    group[c] = cnt
                    stack.append(c)
        cnt += 1
for _ in range(int(input())):
    s, t = map(int, input().split())
    print('yes' if group[s] == group[t] else 'no') # 同じグループに属するかどうかを判定し、出力

"
9205389,ALDS1_11_D,"n, m = map(int, input().split())

p=[i for i in range(n)]

def par(i):
    if p[i] == i:
        return i
    p[i] = par(p[i])
    return p[i]

for _ in range(m):
    s,t = map(int, input().split())
    ps = par(s)
    pt = par(t)
    if ps == pt:
        continue
    p[pt] = ps

q = int(input())

for _ in range(q):
    s, t = map(int, input().split())
    if par(s) == par(t):
        print('yes')
    else:
        print('no')

"
8590662,ALDS1_11_D,"import collections


class UnionFindTree:

    def __init__(self):
        self.parent_dict = dict()
        self.belong_group_size = collections.defaultdict(lambda: 1)

    def find_root(self, target_element):
        if target_element not in self.parent_dict:
            return target_element
        else:
            parent_element = self.parent_dict[target_element]
            root_parent = self.find_root(parent_element)
            self.parent_dict[target_element] = root_parent

            return root_parent

    def same(self, first_element, second_element):
        return self.find_root(first_element) == self.find_root(second_element)

    def unite(self, first_element, second_element):
        first_element_root = self.find_root(first_element)
        second_element_root = self.find_root(second_element)

        if first_element_root == second_element_root:
            return False

        if self.belong_group_size[first_element_root] < self.belong_group_size[second_element_root]:
            first_element_root, second_element_root = second_element_root, first_element_root

        self.parent_dict[second_element_root] = first_element_root
        self.belong_group_size[first_element_root] += self.belong_group_size[second_element_root]

        return True

def main():
    n, m = map(int, input().split())

    uf = UnionFindTree()

    for i in range(m):
        u, v = map(int, input().split())

        uf.unite(u, v)

    q = int(input())

    for i in range(q):
        s, t = map(int, input().split())

        print(""yes"" if uf.same(s, t) else ""no"")

main()


"
8967467,ALDS1_11_D,"class UnionFind:
    __slots__ = [""roots""]
    roots: list[int]

    def __init__(self, n: int):
        self.roots = [-1] * n

    def root(self, x: int) -> int:
        breads = []
        while self.roots[x] != -1:
            breads.append(x)
            x = self.roots[x]

        for b in breads:
            self.roots[b] = x
        return x

    def unite(self, x: int, y: int) -> bool:
        x = self.root(x)
        y = self.root(y)

        if x == y:
            return False

        self.roots[x] = y
        return True


if __name__ == ""__main__"":
    N, M = map(int, input().split())

    uf = UnionFind(N)

    for _ in range(M):
        a, b = map(int, input().split())
        uf.unite(a, b)

    Q = int(input())
    for _ in range(Q):
        a, b = map(int, input().split())
        print(""yes"" if uf.root(a) == uf.root(b) else ""no"")

"
8688733,ALDS1_11_D,"from sys import stdin
input = stdin.readline

from collections import deque, defaultdict
from copy import deepcopy

MAX = 100000
NIL = -1

# Gはdictで管理する、valueはdeque
G = defaultdict(lambda: deque())
color = [NIL]*MAX

def dfs(r, c):
    S = deque()
    S.append(r)
    color[r] = c
    while S:
        u = S.popleft()
        for v in G[u]:
            if color[v] == NIL:
                color[v] = c
                S.append(v)



def assign_color():
    id = 1
    for u in range(n):
        if color[u] == NIL:
            dfs(u, id)
            id += 1

n, m = map(int, input().split())

for _ in range(m):
    s, t = map(int, input().split())
    G[s].append(t)
    G[t].append(s)

assign_color()

q = int(input())
for _ in range(q):
    s, t = map(int, input().split())
    if color[s] == color[t]:
        print('yes')
    else:
        print('no')
"
8996152,ALDS1_11_D,"n,m = map(int,input().split())
adj_list = [[] for _ in range(n)]
for _ in range(m):
    s,t = map(int,input().split())
    adj_list[s].append(t)
    adj_list[t].append(s)
    
import sys
sys.setrecursionlimit(1 << 25)  # 再起上限引き上げ

q = int(input())
visited = [0]*n

group = [0]*n

def dfs(v,g):
    group[v] = g
    visited[v] = 1
    
    for w in adj_list[v]:
        if not visited[w]:
            dfs(w,g)
    

for i in range(n):
    if not visited[i]:
        dfs(i,i)

for _ in range(q):
    s,t = map(int,input().split())
    if group[s] == group[t]:
        print(""yes"")
    else:
        print(""no"")


"
8838066,ALDS1_11_D,"import sys

sys.setrecursionlimit(10 ** 6)

def change_minus(n):
    return -1

def DFS(number,c):
    id[number] = c
    for u in G[number]:
        if id[u] == -1: 
            DFS(u,c)

def decide_components():
    global id
    c = 0
    id = list(map(change_minus,id))
    for i in range(0,n):
        if id[i] == -1:
            c+=1
            DFS(i,c)


n,m = map(int,(input().split()))

G = [[] for i in range(n)]
id = [-1 for i in range(n)]
cnt = 0

for i in range(m):
    a,b = map(int,input().split())
    G[a].append(b)
    G[b].append(a)

#print(G)

decide_components()

q = int(input())

for i in range(q):
    c,d = map(int,input().split())
    if id[c] == id[d]:
        print(""yes"")
    else :
        print(""no"")


"
8616136,ALDS1_11_D,"import sys

sys.setrecursionlimit(int(1e6))

# 頂点数 n, 無向グラフ G の入力
n, m = map(int, input().split())
G = [[] for _ in [None] * n]

for _ in [None] * m:
    s, t = map(int, input().split())
    G[s].append(t)
    G[t].append(s)

# 質問数 q, 質問 qs の入力
q = int(input())
qs = [[*map(int, input().split())] for _ in [None] * q]


# Union-Find の定義
class UnionFind:
    def __init__(self, n):  # n: 頂点数
        self.n = n
        self.parents = [-1] * n

    def find(self, x):  # 要素 x が属するグループの根を返す
        if self.parents[x] < 0:
            return x
        else:
            self.parents[x] = self.find(self.parents[x])
            return self.parents[x]

    def union(self, x, y):  # 要素 x, y について, x, y が属するグループを併合する
        x = self.find(x)
        y = self.find(y)

        if x == y:
            return

        if self.parents[x] > self.parents[y]:
            x, y = y, x

        self.parents[x] += self.parents[y]
        self.parents[y] = x

# seen[i]: 頂点 i が探索済みかどうか(T/F)
seen = [False] * n

# Union-Find のインスタンス化
uf = UnionFind(n)


# 頂点 u を始点とした深さ優先探索
def dfs(u):
    seen[u] = True
    for v in G[u]:
        if seen[v]:
            continue
        uf.union(u, v)  # uf において u, v が属するグループを併合
        dfs(v)


# 未発見の頂点 u を始点として繰り返し dfs する
for u in range(n):
    if not seen[u]:
        dfs(u)


# st パスが存在するか(T/F)
def is_linked(s, t):
    return uf.find(s) == uf.find(t)  # s, t が同じ連結成分に属しているか(T/F)


# 解の出力
for s, t in qs:
    print('yes' if is_linked(s, t) else 'no')
"
4313249,ALDS1_11_D,"def main():
    class UnionFind:
        def __init__(self, n=0):
            self.d = [-1]*n

        def root(self, x):
            if self.d[x] < 0:
                return x
            self.d[x] = self.root(self.d[x])
            return self.d[x]

        def unite(self, x, y):
            x, y = self.root(x), self.root(y)
            if x == y:
                return False
            if x > y:
                x, y = y, x
            self.d[x] += self.d[y]
            self.d[y] = x
            return True

        def same(self, x, y):
            return self.root(x) == self.root(y)

    raw = tuple(map(int, open(0).read().split()))
    n, m = raw[:2]
    uf = UnionFind(n)
    [uf.unite(a, b) for a, b in zip(*[iter(raw[2:2*m+2])]*2)]

    [print('yes' if uf.same(a, b) else 'no') for a, b in zip(*[iter(raw[2*m+3:])]*2)]

if __name__ == '__main__':
    main()

"
3231532,ALDS1_11_D,"import sys
from collections import defaultdict

def main():
    lines = sys.stdin.readlines()
    n, m = map(int, lines[0].split())
    relation_lines = lines[1:1+m]

    relations = defaultdict(list)

    for idx, relation_line in enumerate(relation_lines):
        s, t = relation_line.split()
        relations[s].append(t)
        relations[t].append(s)

    group = {}
    for key in relations.keys():
        group[key] = -1
    group_num = 0

    # assign a group number for ids
    for key, val in relations.items():
        if group[key] != -1:
            continue

        group[key] = group_num
        group_num += 1

        group_no = group[key]
        friends = [key]

        while len(friends) != 0:
            n_fs = relations[friends.pop()]
            for n_f in n_fs:
                if group[n_f] == -1:
                    group[n_f] = group_no
                    friends.append(n_f)

    q = int(lines[1+m])
    question_lines = lines[1+m+1:]
    answers = [None] * q
    for i, question in enumerate(question_lines):
        s, t = question.split()

        if s not in group or t not in group:
            answers[i] = 'no'
            continue
        elif group[s] == group[t]:
            answers[i] = 'yes'
        else:
            answers[i] = 'no'

    # answer
    [print(ans) for ans in answers]
    return

main()
"
2730837,ALDS1_11_D,"import sys
def s():
 e=sys.stdin.readline
 n,m=map(int,e().split())
 P=[[]for _ in[0]*n]
 C=[0]*n
 k=0
 for _ in[0]*m:
  s,t=map(int,e().split());P[s]+=[t];P[t]+=[s]
 for i in range(n):
  k+=1
  if C[i]<1:
   s=[i];C[i]=k
   while s:
    u=s.pop()
    for v in P[u]:
     if C[v]<1:C[v]=k;s+=[v]
 for _ in[0]*int(e()):
  a,b=map(int,e().split())
  print(['no','yes'][C[a]==C[b]])
s()
"
2717736,ALDS1_11_D,"import sys
readline = sys.stdin.readline
def MAIN():
    n, m = map(int, input().split())
    li = [i for i in range(n)]
    def f(a):
        if li[a] == a:
            return a
        li[a] = f(li[a])
        return li[a]
    def f2(a, b):
        if li[a] == a:
            li[a] = b
            return
        f2(li[a], b)
        li[a] = b
    def solve(a, b):
        if f(a) == f(b):
            return ""yes""
        return ""no""
    for _ in range(m):
        x, y = map(int, readline().split())
        if f(x) > f(y):
            f2(x, li[y])
        else:
            f2(y, li[x])
    for _ in range(int(input())):
        x, y = map(int, readline().split())
        print(solve(x, y))
MAIN()

"
6321131,ALDS1_11_D,"import sys
def s():
 e = sys.stdin.readline
 n, m = map(int, e().split())
 P = [[]for _ in[0] * n]
 C = [0] * n
 k = 0
 for _ in[0] * m:
  s, t = map(int, e().split());P[s] += [t];P[t] += [s]
 for i in range(n):
  k += 1
  if C[i] < 1:
   s = [i];C[i] = k
   while s:
    u = s.pop()
    for v in P[u]:
     if C[v] < 1:C[v] = k;s += [v]
 for _ in[0] * int(e()):
  a, b = map(int, e().split())
  print(['no', 'yes'][C[a] == C[b]])
s()
"
8599895,ALDS1_11_D,"from collections import deque


class Node:
    def __init__(self, id: int, neighbors_list: list) -> None:
        self.id = id
        self.neighbors_list = neighbors_list
        self.color = None


def dfs(node: Node, color: int):
    global node_list
    global wait_stack

    wait_stack.append(node)
    node.color = color

    while len(wait_stack) > 0:
        search_node: Node = wait_stack.pop()
        for neighbor_id in search_node.neighbors_list:
            if node_list[neighbor_id].color is None:
                node_list[neighbor_id].color = color
                wait_stack.append(node_list[neighbor_id])


def assign_color():
    global node_list
    global n

    color = 1
    for i in range(n):
        if node_list[i].color is None:
            dfs(node_list[i], color)
            color += 1


n, m = map(int, input().split())
wait_stack = deque([])
node_list: list[Node] = [Node(i, []) for i in range(n)]
for i in range(m):
    a, b = map(int, input().split())
    node_list[a].neighbors_list.append(b)
    node_list[b].neighbors_list.append(a)

assign_color()

q = int(input())
for _ in range(q):
    a, b = map(int, input().split())
    if node_list[a].color == node_list[b].color:
        print(""yes"")
    else:
        print(""no"")

"
3999661,ALDS1_11_D,"import sys
def s():
 e=sys.stdin.readline
 n,m=map(int,e().split())
 P=[[]for _ in[0]*n]
 C=[0]*n
 k=0
 for _ in[0]*m:
  s,t=map(int,e().split());P[s]+=[t];P[t]+=[s]
 for i in range(n):
  k+=1
  if C[i]<1:
   s=[i];C[i]=k
   while s:
    u=s.pop()
    for v in P[u]:
     if C[v]<1:C[v]=k;s+=[v]
 for _ in[0]*int(e()):
  a,b=map(int,e().split())
  print(['no','yes'][C[a]==C[b]])
s()

"
4027213,ALDS1_11_D,"import sys

input = sys.stdin.readline

def main():
    n, m = map(int, input().split())
    root = {i:i for i in range(n)}
    
    for i in range(m):
        s, t = map(int, input().split())
        
        r, c = s, 0
        while root[s] != s: s, c = root[s], c+1
        while root[t] != t: root[t], t = s, root[t]
        root[t] = s
        
        if c > 10: 
            while root[r] != s: root[r], r = s, root[r]
        
    for i in range(int(input())):
        s, t = map(int, input().split())
        
        while root[s] != s: s = root[s]
        while root[t] != t: t = root[t]
        
        if s == t: print('yes')
        else: print('no')

if __name__ == '__main__':
    main()


"
2530169,ALDS1_11_D,"import sys

def Grouping(F):
    n = len(F)
    G = [None for i in range(n)]
    for u in range(n):
        if G[u] is None:
            G[u] = u
            S = [u]
            while(len(S) > 0):
                u1 = S.pop()
                for u2 in F[u1]:
                    if G[u2] is None:
                        G[u2] = u
                        S.append(u2)
    return G

def main():
    istr = sys.stdin.read()
    ilist = istr.splitlines()
    unum, fnum = list(map(int,ilist[0].split()))

    F = [[]  for i in range(unum)]
    fnum += 1
    for n in range(1, fnum):
        uid, fid = map(int,ilist[n].split())
        F[uid].append(fid)
        F[fid].append(uid)
    
    G = Grouping(F)

    qnum = int(ilist[fnum])
    fnum += 1
    for q in range(fnum, (fnum + qnum)):
        id1, id2 = map(int,ilist[q].split())
        if G[id1] == G[id2]:
            print(""yes"")
        else:
            print(""no"")

if __name__ == '__main__':
    main()
"
3934751,ALDS1_11_D,"import sys
input = sys.stdin.readline
from operator import itemgetter
sys.setrecursionlimit(10000000)
from collections import deque

def main():
    n, m = map(int, input().strip().split())
    nei = [[] for _ in range(n)]
    for _ in range(m):
        s, t = map(int, input().strip().split())
        nei[s].append(t)
        nei[t].append(s)

    nodes = [-1] * n
    color = 1
    for i in range(n):
        if nodes[i] > 0:
            continue
        d = deque()
        d.append(i)
        # print(nei)
        while len(d) != 0:
            k = d.popleft()
            nodes[k] = color
            for j in nei[k]:
                if nodes[j] == -1:
                    d.append(j)
            # print(len(d))
        color += 1

    q = int(input().strip())
    for _ in range(q):
        s, t = map(int, input().strip().split())
        if nodes[s] == nodes[t]:
            print('yes')
        else:
            print('no')

if __name__ == '__main__':
    main()

"
5071561,ALDS1_11_D,"import sys
input = sys.stdin.readline
from operator import itemgetter
from collections import deque

def main():
    n, m = map(int, input().strip().split())
    nei = [[] for _ in range(n)]
    for _ in range(m):
        s, t = map(int, input().strip().split())
        nei[s].append(t)
        nei[t].append(s)

    nodes = [-1] * n
    color = 1
    for i in range(n):
        if nodes[i] > 0:
            continue
        d = deque()
        d.append(i)
        
        while len(d) != 0:
            k = d.popleft()
            nodes[k] = color
            for j in nei[k]:
                if nodes[j] == -1:
                    d.append(j)
            # print(len(d))
        color += 1

    q = int(input().strip())
    for _ in range(q):
        s, t = map(int, input().strip().split())
        if nodes[s] == nodes[t]:
            print('yes')
        else:
            print('no')

if __name__ == '__main__':
    main()


"
7615900,ALDS1_11_D,"import sys
readline=sys.stdin.readline
write=sys.stdout.write
N,M=map(int,readline().split())
*p,=range(N)
def root(x):
    if x==p[x]:
        return x
    p[x]=x=root(p[x])
    return x
def unite(x,y):
    px=root(x);py=root(y)
    if px<py:
        p[py]=px
    else:
        p[px]=py
for i in range(M):
    s,t=map(int,readline().split())
    unite(s,t)
*_,=map(root,range(N))
Q=int(readline())
ans=[]
for q in range(Q):
    s,t=map(int,readline().split())
    ans.append(""yes"" if p[s]==p[t] else ""no"")
write(""\n"".join(ans))
write(""\n"")
    


    
"
8739297,ALDS1_11_D,"from collections import deque

class User:
    def __init__(self, uid):
        self.uid = uid
        self.friends = []

def main():
    n, m = map(int, input().split())
    # グラフ要素
    sns_users = [User(i) for i in range(n)]
    for _ in range(m):
        s,t = map(int, input().split())
        sns_users[s].friends.append(sns_users[t])
        sns_users[t].friends.append(sns_users[s])

    q = int(input())
    # 連絡関係の保存
    all_can_contact = []
    for _ in range(q):
        s,t = map(int, input().split())
        # sとtの連絡関係が探索済みの場合
        for each_can_contact in all_can_contact:
            if (s in each_can_contact) and (t in each_can_contact):
                print('yes')
                break
            elif (s in each_can_contact):
                print('no')
                break
        # 未探索の場合
        # for文でbreakされなかった場合のみelseは実行される
        else:
            can_contact = check_contact(sns_users[s], sns_users)
            if t in can_contact:
                print('yes')
            else:
                print('no')
            all_can_contact.append(can_contact)


# 幅優先探索
def check_contact(user, sns_users):
    can_contact = set()
    # 同じ深さのノードをキューで管理
    user_id = user.uid
    que = deque([user_id])
    while que:
        user_id = que.popleft()
        # 深さ優先でノードを順番に見ていく
        for friend in sns_users[user_id].friends:
            if not (friend.uid in can_contact):
                can_contact.add(friend.uid)
                que.append(friend.uid)      
    return can_contact


if __name__ == '__main__':
    main()
"
5417463,ALDS1_11_D,"import sys
input = sys.stdin.readline
from operator import itemgetter
sys.setrecursionlimit(10000000)
from collections import deque

def main():
    n, m = map(int, input().strip().split())
    nei = [[] for _ in range(n)]
    for _ in range(m):
        s, t = map(int, input().strip().split())
        nei[s].append(t)
        nei[t].append(s)

    nodes = [-1] * n
    color = 1
    for i in range(n):
        if nodes[i] > 0:
            continue
        d = deque()
        d.append(i)
        # print(nei)
        while len(d) != 0:
            i = d.popleft()
            nodes[i] = color
            for i in nei[i]:
                if nodes[i] == -1:
                    d.append(i)
            # print(len(d))
        color += 1

    q = int(input())
    for _ in range(q):
        s, t = map(int, input().split())
        if nodes[s] == nodes[t]:
            print('yes')
        else:
            print('no')

if __name__ == '__main__':
    main()

"
2412517,ALDS1_11_D,"#!/usr/bin/env python
# -*- coding: utf-8 -*-
 
import sys
 
 
def assign_color():
    _color = 1
    for m in range(vertices_num):
        if vertices_status_list[m] == -1:
            graph_dfs(m, _color)
            _color += 1
    return None
 
 
def graph_dfs(vertex, color):
    vertices_stack = list()
    vertices_stack.append(vertex)
    vertices_status_list[vertex] = color
 
    while vertices_stack:
        current_vertex = vertices_stack[-1]
        vertices_stack.pop()
        for v in adj_list[current_vertex]:
            if vertices_status_list[v] == -1:
                vertices_status_list[v] = color
                vertices_stack.append(v)
    return None
 
 
def solve():
    for relation in relation_info:
        key, value = map(int, relation.split())
        adj_list[key].append(value)
        adj_list[value].append(key)
 
    assign_color()
 
    # print(adj_list)
    for question in question_list:
        start, target = map(int, question.split())
        if vertices_status_list[start] == vertices_status_list[target]:
            print(""yes"")
        else:
            print(""no"")
    return vertices_status_list
 
 
if __name__ == '__main__':
    _input = sys.stdin.readlines()
    vertices_num, relation_num = map(int, _input[0].split())
 
    relation_info = _input[1:relation_num + 1]
 
    question_num = int(_input[relation_num + 1])
    question_list = _input[relation_num + 2:]
 
    adj_list = tuple([[] for _ in range(vertices_num)])
    vertices_status_list = [-1] * vertices_num
    ans = solve()
"
5068904,ALDS1_11_D,"from sys import stdin

def main():

    n, m = map(int, stdin.readline().split())
    pa = [-1 for _ in range(n)]
    for _ in range(m):
        x, y = map(int, stdin.readline().split())
        xl = []
        yl = []
        while pa[x] != -1:
            xl.append(x)
            x = pa[x]
        for xli in xl:
            pa[xli] = x
        while pa[y] != -1:
            yl.append(y)
            y = pa[y]
        for yli in yl:
            pa[yli] = x
        if y != x:
            pa[y] = x
    
    q = int(stdin.readline())
    for _ in range(q):
        x, y = map(int, stdin.readline().split())
        xl = []
        yl = []
        while pa[x] != -1:
            xl.append(x)
            x = pa[x]
        for xli in xl:
            pa[xli] = x
        while pa[y] != -1:
            yl.append(y)
            y = pa[y]
        for yli in yl:
            pa[yli] = y

        if x == y:
            print(""yes"")   
        else:
            print(""no"")

main()

"
6049122,ALDS1_11_D,"import sys

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines


class UnionFind:    # uf = UnionFind(N)    N: 要素数
    def __init__(self, n):
        self.par = [-1] * n
    
    def root(self, x):
        if self.par[x] < 0:
            return x
        else:
            self.par[x] = self.root(self.par[x])
            return self.par[x]
    
    def unite(self, x, y):
        x, y = self.root(x), self.root(y)

        if x == y:
            return

        if self.par[x] > self.par[y]:
            x, y = y, x
        
        self.par[x] += self.par[y]
        self.par[y] = x
    
    def same(self, x, y):
        return self.root(x) == self.root(y)
    
    def size(self, x):
        return -self.par[self.root(x)]


def main():
    N, M = map(int, readline().split())
    AB = [list(map(int, readline().split())) for _ in range(M)]
    Q = int(readline())
    que = [list(map(int, line.split())) for line in readlines()]

    uf = UnionFind(N)

    for a, b in AB:
        uf.unite(a, b)
    
    for c, d in que:
        if uf.same(c, d):
            print('yes')
        else:
            print('no')


if __name__ == '__main__':
    main()
"
7017806,ALDS1_11_D,"from sys import stdin 
input = stdin.readline
import sys
sys.setrecursionlimit(10**7)

class UnionFind:
    def __init__(self, n):
        self.par = [i for i in range(n+1)] #0-indexed, 1-indexedどちらでもOKなように、n+1の長さの配列とする
        self.rank = [0]*(n+1) #木の高さ
    
    
    def find(self, x):
        if self.par[x] == x:
            return x
        else:
            self.par[x] = self.find(self.par[x])
            return self.par[x]
    
    
    def same(self, x, y):
        return self.find(x) == self.find(y)
    
    
    def unite(self, x, y):
        x = self.find(x)
        y = self.find(y)
        
        if x == y:
            return
        
        if self.rank[x] < self.rank[y]:
            self.par[x] = y
        else:
            self.par[y] = x
        
        if self.rank[x] == self.rank[y]:
            self.rank[x] += 1



n, m = map(int, input().split())
UF = UnionFind(n)
for _ in range(m):
    u, v = map(int, input().split())
    UF.unite(u, v)
    
q = int(input())
for _ in range(q):
    u, v = map(int, input().split())
    if UF.same(u, v):
        print('yes')
    else:
        print('no')
"
2178216,ALDS1_11_D,"import sys
from collections import deque

def debug(x, table):
    for name, val in table.items():
        if x is val:
            print('DEBUG:{} -> {}'.format(name, val), file=sys.stderr)
            return None

def paint_col(adj, cols, i, col):
    nxt = deque([i])

    while nxt:
        u = nxt.popleft()
        cols[u] = col
        for child in adj[u]:
            if cols[child] == 0:
                nxt.append(child)

def solve():
    n, m = map(int, sys.stdin.readline().split())
    adj = [[] for i in range(n)]

    for i in range(m):
        s, t = map(int, sys.stdin.readline().split())
        adj[s].append(t)
        adj[t].append(s)

    cols = [0] * n
    col = 1

    for i in range(n):
        if cols[i] == 0:
            paint_col(adj, cols, i, col)
            col += 1

    q = int(sys.stdin.readline())

    for i in range(q):
        s, t = map(int, sys.stdin.readline().split())

        if cols[s] == cols[t]:
            ans = 'yes'
        else:
            ans = 'no'

        print(ans)

if __name__ == '__main__':
    solve()
"
4021077,ALDS1_11_D,"import sys
class Union():
    def __init__(self, n):
        self.pre = [i for i in range(n)]
        self.rank = [1 for _ in range(n)]

    def union(self, a, b):
        aroot = self.find(a)
        broot = self.find(b)
        if aroot == broot:
            return
        if self.rank[aroot] < self.rank[broot]:
            aroot, broot = broot, aroot
        self.pre[broot] = self.pre[aroot]
        if self.rank[aroot] == self.rank[broot]:
            self.rank[aroot] += 1

    def find(self, n):
        while self.pre[n] != n:
            n = self.pre[n]
        return n

    def issame(self, a, b):
        if self.find(a) == self.find(b):
            return True
        return False

if __name__ == '__main__':
    m, n = map(int, sys.stdin.readline().split())
    union = Union(m)

    for _ in range(n):
        a, b = map(int, sys.stdin.readline().split())
        union.union(a, b)

    o = int(input())
    for _ in range(o):
        p, q = map(int, sys.stdin.readline().split())
        if union.issame(p, q):
            print('yes')
        else:
            print('no')
"
4305137,ALDS1_11_D,"import sys
sys.setrecursionlimit(15000)
n,m = map(int,sys.stdin.readline().split())
g = list(range(n))
def find(x):
  while g[x] != x:
    x = g[x]
    g[x] = g[g[x]]
  return x
def union(s,t):
  sp = find(s)
  tp = find(t)
  if sp == tp:
    pass
  elif sp < tp:
    g[sp] = tp
  else:
    g[tp] = sp
for i in range(m):
  s,t = map(int,sys.stdin.readline().split())
  union(s,t)

q = int(sys.stdin.readline())
for i in range(q):
  s,t = map(int,sys.stdin.readline().split())
  if find(s) == find(t):
    print(""yes"")
  else:
    print(""no"")
"
4886062,ALDS1_11_D,"import sys
input = sys.stdin.readline # for speed up
#sys.setrecursionlimit(10**9)

n,m=map(int,input().split())
graph=[[] for _ in range(n)]
for _ in range(m):
    s,t=map(int,input().split())
    graph[s].append(t)
    graph[t].append(s)

color=[-1]*n

def assignColor():
    id=1
    for ii in range(n):
        if color[ii]==-1:
            dfs(ii,id)
            id+=1
    return

from collections import deque
def dfs(nod,col):
    dqn=deque()
    dqn.append(nod)
    color[nod]=col
    while len(dqn)>0:
        u=dqn.pop()
        for ii in range(len(graph[u])):
            v=graph[u][ii]
            if color[v]==-1:
                color[v]=col
                dqn.append(v)
    return

assignColor()

q=int(input())
for _ in range(q):
    s,t=map(int,input().split())
    if color[s]==color[t]:
        print(""yes"")
    else:
        print(""no"")

"
6295303,ALDS1_11_D,"from typing import List
import sys
from array import array


sys.setrecursionlimit(10000)
input = sys.stdin.readline


class UnionFind:
    """"""
    Class implementation of disjoint-set data structure
    """"""

    # Constructor
    def __init__(self, N: int):
        self._parent: List[int] = [-1 for i in range(N)]
        self._rank: List[int] = [0 for i in range(N)]
        self._size: List[int] = [1 for i in range(N)]

    # Return the root of the tree to which x is belonging
    def get_root(self, x: int) -> int:
        if self._parent[x] == -1:
            return x
        else:
            self._parent[x] = self.get_root(self._parent[x])
            return self._parent[x]

    # Return true if x and y belong to the same tree
    def is_same(self, x: int, y: int) -> bool:
        return self.get_root(x) == self.get_root(y)

    # Merge the group to which x is belonging and the group to which y is belonging
    def unite(self, x: int, y: int) -> bool:
        # Get root of x and y
        rx = self.get_root(x)
        ry = self.get_root(y)

        # Do nothing when x and y are already in same group
        if rx == ry:
            return False

        # Union by rank
        # Make sure that the rank of ry side is small
        if self._rank[rx] < self._rank[ry]:
            rx, ry = ry, rx

        # Make sure that ry is child of rx
        self._parent[ry] = rx

        # Compute rank of rx side
        if self._rank[rx] == self._rank[ry]:
            self._rank[rx] += 1

        # Compute size of rx side
        self._size[rx] += self._size[ry]

        return True

    # Return size of the group to which x is belonging
    def get_size(self, x: int) -> int:
        return self._size[self.get_root(x)]


def main():
    N, M = map(int, input().split())
    uf = UnionFind(N)

    for i in range(M):
        a, b = map(int, input().split())
        uf.unite(a, b)

    Q = int(input())
    for i in range(Q):
        s, t = map(int, input().split())
        if uf.is_same(s, t):
            print(""yes"")
        else:
            print(""no"")


if __name__ == ""__main__"":
    main()

"
4532375,ALDS1_11_D,"import sys
import itertools
sys.setrecursionlimit(1000000000)
from heapq import heapify,heappop,heappush,heappushpop
import math
import collections
import copy

class UnionFind():
    
    def __init__(self,n):
        self.n = n
        self.parents = [-1]*n #各要素の親要素の番号を格納するリスト
    
    #要素xが属するグループの根を返す
    def find(self,x):
        if self.parents[x]<0:
            return x
        else:
            self.parents[x] = self.find(self.parents[x])
            return self.parents[x]
    
    #要素xと要素yが属するグループを併合する   
    def union(self,x,y):
        x = self.find(x)
        y = self.find(y)

        if x == y:
            return
        
        if self.parents[x]>self.parents[y]:
            x,y = y,x
        
        self.parents[x] += self.parents[y]
        self.parents[y] = x

    #要素xが属するグループのサイズを返す
    def size(self,x):
        return -self.parents[self.find(x)]
    
    #要素x,yが同じグループかどうかを返す
    def same(self,x,y):
        return self.find(x) == self.find(y)
    
    #要素xと同じグループのメンバーを返す
    def members(self,x):
        root = self.find(x)
        return [i for i in range(self.n) if self.find(i) == root]
    
    #すべての根の要素を返す
    def roots(self):
        return [i for i,x in enumerate(self.parents) if x<0]
    
    #グループの数を返す
    def group_count(self):
        return len(self.roots())
    
    def all_group_members(self):
        return {r: self.members(r) for r in self.roots()}
    
    def __str__(self):
        return ""\n"".join(""{}: {}"".format(r,self.members(r)) for r in self.roots())


if __name__  == ""__main__"":
    input = sys.stdin.readline
    n,m = map(int,input().split())
    UF = UnionFind(n)
    for i in range(m):
        a,b = map(int,input().split())
        UF.union(a,b)
    q = int(input())
    for i in range(q):
        c,d = map(int,input().split())
        if UF.same(c,d):
            print(""yes"")
        else:
            print(""no"")    

"
4861903,ALDS1_11_D,"import bisect, collections, copy, heapq, itertools, math, string
import sys
def I(): return int(sys.stdin.readline().rstrip())
def MI(): return map(int, sys.stdin.readline().rstrip().split())
def LI(): return list(map(int, sys.stdin.readline().rstrip().split()))
def S(): return sys.stdin.readline().rstrip()
def LS(): return list(sys.stdin.readline().rstrip().split())


from heapq import heappop, heappush
from collections import deque
class UnionFind():
    def __init__(self, n):
        self.n = n
        self.parents = [-1] * n

    def find(self, x):
        if self.parents[x] < 0:
            return x
        else:
            self.parents[x] = self.find(self.parents[x])
            return self.parents[x]

    def union(self, x, y):
        x = self.find(x)
        y = self.find(y)

        if x == y:
            return

        if self.parents[x] > self.parents[y]:
            x, y = y, x

        self.parents[x] += self.parents[y]
        self.parents[y] = x

    def size(self, x):
        return -self.parents[self.find(x)]

    def same(self, x, y):
        return self.find(x) == self.find(y)

    def members(self, x):
        root = self.find(x)
        return [i for i in range(self.n) if self.find(i) == root]

    def roots(self):
        return [i for i, x in enumerate(self.parents) if x < 0]

    def group_count(self):
        return len(self.roots())

    def all_group_members(self):
        return {r: self.members(r) for r in self.roots()}

    def __str__(self):
        return '\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())
def main():
    N, M = MI()
    uf = UnionFind(N)
    for i in range(M):
        s, t = MI()
        uf.union(s, t)
    Q = I()
    for i in range(Q):
        u, v = MI()
        if uf.same(u, v):
            print('yes')
            continue
        print('no')

if __name__ == ""__main__"":
    main()
"
6888708,ALDS1_11_D,"import sys
from collections import deque


def bfs(u):
    global colors, dq

    if colors[u] == -1:
        colors[u] = color

        for v in V[u]:
            if colors[v] == -1 and v not in dq:
                dq.append(v)

    if len(dq) != 0:
        bfs(dq.popleft())


def bfs_que(u):
    global colors, dq

    dq.append(u)
    colors[u] = color

    while len(dq) != 0:
        now = dq.popleft()
        for v in V[now]:
            if colors[v] == -1:
                dq.append(v)
                colors[v] = color


def bfs_text():
    global d

    d[0] = 0
    dq.append(0)

    while len(dq) != 0:
        u = dq.popleft()
        distance = d[u] + 1

        for v in V[u]:
            if d[v] == -1:
                d[v] = distance
                dq.append(v)


def dfs(u):
    global colors, dq

    colors[u] = color

    for v in V[u]:
        if colors[v] == -1:
            dfs(v)


def main():
    global V, colors, color, dq

    n, m = map(int, input().split())
    V = [[] for _ in range(n)]
    for _ in range(m):
        s, t = map(int, input().split())
        V[s].append(t)
        V[t].append(s)

    colors = [-1] * n
    dq = deque()
    color = 0
    for i in range(n):
        if colors[i] == -1:
            # bfs(i)
            bfs_que(i)
            # dfs(i)
            color += 1

    q = int(input())
    for _ in range(q):
        s, t = map(int, input().split())
        if colors[s] == colors[t]:
            print('yes')
        else:
            print('no')


input = sys.stdin.readline
main()
"
7458657,ALDS1_11_D,"import sys

# READ_FROM_FILE = True
READ_FROM_FILE = False


class UnionFindTree:
    def __init__(self, num_elements):
        self._parents = list(range(num_elements))
        self._rank = [0] * num_elements
        return

    def find(self, idx):
        parent = self._parents[idx]
        if parent == idx:
            return idx
        self._parents[idx] = self.find(parent)
        return self._parents[idx]

    def unite(self, idx0, idx1):
        root0 = self.find(idx0)
        root1 = self.find(idx1)

        if root0 == root1:
            return

        if self._rank[root0] < self._rank[root1]:
            root0, root1 = root1, root0
        if self._rank[root0] == self._rank[root1]:
            self._rank[root0] += 1

        self._parents[root1] = root0
        return

    def is_same(self, idx0, idx1):
        return self.find(idx0) == self.find(idx1)


def main():
    if READ_FROM_FILE:
        f = open('test0.txt', 'r')
    else:
        f = sys.stdin

    n, m = map(int, f.readline().split())
    uft = UnionFindTree(n)
    for _ in range(m):
        s, t = map(int, f.readline().split())
        uft.unite(s, t)

    q = int(f.readline())
    for _ in range(q):
        s, t = map(int, f.readline().split())
        print('yes' if uft.is_same(s, t) else 'no')

    if READ_FROM_FILE:
        f.close()
    return


if __name__ == '__main__':
    main()

"
3184882,ALDS1_11_D,"import sys
readline = sys.stdin.readline
write = sys.stdout.write
N, M = map(int, readline().split())
*p, = range(N)
def root(x):
    if x == p[x]:
        return x
    p[x] = x = root(p[x])
    return x
def unite(x, y):
    px = root(x); py = root(y)
    if px < py:
        p[py] = px
    else:
        p[px] = py


for i in range(M):
    s, t = map(int, readline().split())
    unite(s, t)
*_, = map(root, range(N))
Q = int(readline())
ans = []
for q in range(Q):
    s, t = map(int, readline().split())
    ans.append('yes' if p[s] == p[t] else 'no')
write(""\n"".join(ans))
write(""\n"")

"
5439043,ALDS1_11_D,"from sys import stdin

def parent(x):
  while p[x]!=-1: x = p[x]
  return x

N, M = map(int, stdin.readline().split())
p, r = [-1]*N, [1]*N
for _ in range(M):
  s, t = map(int, stdin.readline().split())
  sp, tp = parent(s), parent(t)
  if sp!=tp:
    if r[sp]>r[tp]:
      p[tp] = sp
      r[sp] += r[tp]
    else:
      p[sp] = tp
      r[tp] += r[sp]
M = int(stdin.readline())
for _ in range(M):
  s, t = map(int, stdin.readline().split())
  sp, tp = parent(s), parent(t)
  print(""yes"" if sp==tp else ""no"")

"
5001127,ALDS1_11_D,"from sys import stdin

input = stdin.readline
n,m = map(int,input().split())

G = [[] for _ in range(n)]
ID = [None for _ in range(n)]
S = []

def dfs(r,c):
    S.append(r)
    ID[r] = c
    while S:
        u = S[-1]
        S.pop()
        for i in range(0,len(G[u]),1):
            v = G[u][i]
            if ID[v] == None:
                ID[v] = c
                S.append(v)

def assignID():
    id = 0
    for u in range(n):
        if ID[u] == None:
            id += 1
            dfs(u,id)

def main():
    for i in range(m):
        s,t = map(int,input().split())
        G[s].append(t)
        G[t].append(s)

    assignID()

    q = int(input())

    for j in range(q):
        s,t = map(int,input().split())
        if ID[s] == ID[t]:
            print(""yes"")
        else:
            print(""no"")


if __name__ == ""__main__"":
    main()
"
4570644,ALDS1_11_D,"import sys, collections
input = lambda: sys.stdin.readline().rstrip() 
sys.setrecursionlimit(10**7)
INF = 10**10
def I(): return int(input())
def F(): return float(input())
def SS(): return input()
def LI(): return [int(x) for x in input().split()]
def LI_(): return [int(x)-1 for x in input().split()]
def LF(): return [float(x) for x in input().split()]
def LSS(): return input().split()

def resolve():
    n, m = LI()
    edge = [[] for _ in range(n)]
    cc = [-1]*n

    for _ in range(m):
        s, t = LI()
        edge[s].append(t)
        edge[t].append(s)

    ccid = 0
    for i in range(n):
        if cc[i]==-1:
            stk = [i]
            cc[i] = ccid
            while stk:
                c = stk.pop()
                for n in edge[c]:
                    if cc[n]==-1:
                        stk.append(n)
                        cc[n] = ccid

            ccid += 1

    q = I()
    for _ in range(q):
        s, t = LI()
        if cc[s] == cc[t]:
            print('yes')
        else:
            print('no')

if __name__ == '__main__':
    resolve()

"
5223435,ALDS1_11_D,"import sys
input = sys.stdin.readline


class UnionFind:
    __slots__ = [""N"", ""root""]

    def __init__(self, N):
        """"""
        N:要素数
        root:各要素の親要素の番号を格納するリスト.
             ただし, root[x] < 0 ならその頂点が根で-root[x]が木の要素数.
        """"""
        self.N = N
        self.root = [-1] * N

    def __repr__(self):
        return '\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())

    def find(self, x):
        """"""頂点xの根を見つける""""""
        r = x
        while self.root[r] >= 0:
            r = self.root[r]

        while self.root[x] >= 0:
            self.root[x], x = r, self.root[x]

        return r

    def union(self, x, y):
        """"""x, yが属する木をunion""""""
        x = self.find(x)
        y = self.find(y)
        if x == y:
            return
        elif self.root[y] < self.root[x]:
            x, y = y, x
        self.root[x] += self.root[y]
        self.root[y] = x

    def same(self, x, y):
        """"""xとyが同じグループに属するかどうか""""""
        return self.find(x) == self.find(y)

    def count(self, x):
        """"""頂点xが属する木のサイズを返す""""""
        return - self.root[self.find(x)]

    def members(self, x):
        """"""xが属する木の要素を列挙""""""
        _root = self.find(x)
        return [i for i in range(self.N) if self.find(i) == _root]

    def roots(self):
        """"""森の根を列挙""""""
        return [i for i, x in enumerate(self.root) if x < 0]

    def group_count(self):
        """"""連結成分の数""""""
        return len(self.roots())

    def all_group_members(self):
        """"""{ルート要素: [そのグループに含まれる要素のリスト], ...}の辞書を返す""""""
        groups = {r: [] for r in self.roots()}
        for i in range(self.N):
            groups[self.find(i)].append(i)
        return groups


n, m = map(int, input().split())
uf = UnionFind(n)
for _ in range(m):
    x, y = map(int, input().split())
    uf.union(x, y)

for _ in range(int(input())):
    x, y = map(int, input().split())
    print(""yes"" if uf.same(x, y) else ""no"")

"
3030132,ALDS1_11_D,"import sys


class UnionFind:
    def __init__(self, node_size):
        self._node = node_size
        self.par = [i for i in range(self._node)]
        self.rank = [0] * self._node

    def find(self, ver):
        if self.par[ver] == ver:
            return ver
        else:
            self.par[ver] = self.find(self.par[ver])
            return self.par[ver]

    def unite(self, ver1, ver2):
        ver1, ver2 = self.find(ver1), self.find(ver2)
        if ver1 == ver2:
            return
        if self.rank[ver1] < self.rank[ver2]:
            ver1, ver2 = ver2, ver1
        self.par[ver2] = ver1
        if self.rank[ver1] == self.rank[ver2]:
            self.rank[ver1] += 1

    def same(self, ver1, ver2):
        return self.find(ver1) == self.find(ver2)

if __name__ == '__main__':
    n, m = map(int, sys.stdin.readline().split())
    uf = UnionFind(n)
    for i in range(m):
        s, t = map(int, sys.stdin.readline().split())
        uf.unite(s, t)
    q = int(sys.stdin.readline())
    for i in range(q):
        s, t = map(int, sys.stdin.readline().split())
        if uf.same(s, t):
            print(""yes"")
        else:
            print(""no"")
"
4287656,ALDS1_11_D,"import sys
input = lambda: sys.stdin.readline().rstrip()
sys.setrecursionlimit(10**6)
def dfs(g,v,z):
    if vis[v]!=0: return
    else:
        vis[v]=z
        for p in g[v]:
            dfs(g,p,z)
n,m=map(int,input().split())
g=[[] for i in range(n)]
for i in range(m):
    x,y=map(int,input().split())
    g[x].append(y)
    g[y].append(x)
z=0 ; vis=[0]*n
for i in range(n):
    if vis[i]==0:
        z+=1
        dfs(g,i,z)
q=int(input())
for i in range(q):
    x,y=map(int,input().split())
    if vis[x]==vis[y]: print('yes')
    else: print('no')

    
"
4748710,ALDS1_11_D,"import sys, os, math, bisect, itertools, collections, heapq, queue, copy, array

# from scipy.sparse.csgraph import csgraph_from_dense, floyd_warshall
# from decimal import Decimal
# from collections import defaultdict, deque

sys.setrecursionlimit(10000000)

ii = lambda: int(sys.stdin.buffer.readline().rstrip())
il = lambda: list(map(int, sys.stdin.buffer.readline().split()))
fl = lambda: list(map(float, sys.stdin.buffer.readline().split()))
iln = lambda n: [int(sys.stdin.buffer.readline().rstrip()) for _ in range(n)]

iss = lambda: sys.stdin.buffer.readline().decode().rstrip()
sl = lambda: list(map(str, sys.stdin.buffer.readline().decode().split()))
isn = lambda n: [sys.stdin.buffer.readline().decode().rstrip() for _ in range(n)]

lcm = lambda x, y: (x * y) // math.gcd(x, y)

MOD = 10 ** 9 + 7
MAX = float('inf')


class UnionFind:
    def __init__(self, N):
        self.tree = list(range(N))

    def root(self, N):
        if self.tree[N] == N:
            return N
        else:
            self.tree[N] = self.root(self.tree[N])
            return self.tree[N]

    def same(self, x, y):
        return self.root(self.tree[x]) == self.root(self.tree[y])

    def unite(self, x, y):
        x = self.root(x)
        y = self.root(y)
        if x == y:
            return
        else:
            self.tree[x] = y


def main():
    if os.getenv(""LOCAL""):
        sys.stdin = open(""input.txt"", ""r"")

    N, M = il()
    uf = UnionFind(N)
    for _ in range(M):
        s, t = il()
        uf.unite(s, t)

    Q = ii()
    for _ in range(Q):
        s, t = il()
        if uf.same(s, t):
            print('yes')
        else:
            print('no')


if __name__ == '__main__':
    main()

"
1925987,ALDS1_11_D,"import sys
 
def make_connected_group(G):
    C = [None]*len(G)
    group = 0
    for i,p in enumerate(C):
        if p != None: continue
        friends = [i]
        while len(friends) > 0:
            f = friends.pop()
            if C[f] == None:
                C[f] = group
                friends += G[f]
        group += 1
    return C
 
 
if __name__=='__main__':
    n,m = list(map(int,sys.stdin.readline().split()))
    G = [[] for _ in range(n)]
    for j,line in enumerate(sys.stdin):
        if not j < m:
            q = int(line)
            break
        s,t = list(map(int,line.split()))
        G[s].append(t)
        G[t].append(s)
    C = make_connected_group(G)
    for j,line in enumerate(sys.stdin):
        if not j < q: break
        s,t = list(map(int,line.split()))
        print('yes' if C[s] == C[t] else 'no')
"
3528259,ALDS1_11_D,"# -*- coding: utf-8 -*-

import sys

sys.setrecursionlimit(10 ** 9)
def input(): return sys.stdin.readline().strip()
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(): return list(map(int, input().split()))
INF=float('inf')

# Union-Find木
class UnionFind:
    def __init__(self, n):
        self.n = n
        # 親要素のノード番号を格納。par[x] == xの時そのノードは根
        # 1-indexedのままでOK、その場合は[0]は未使用
        self.par = [i for i in range(n+1)]
        # 木の高さを格納する（初期状態では0）
        self.rank = [0] * (n+1)
        # あるノードを根とする集合に属するノード数
        self.size = [1] * (n+1)
        # あるノードを根とする集合が木かどうか
        self.tree = [True] * (n+1)

    # 根の検索(グループ番号と言えなくもない)
    def find(self, x):
        # 根ならその番号を返す
        if self.par[x] == x:
            return x
        else:
            # 走査していく過程で親を書き換える
            self.par[x] = self.find(self.par[x])
            return self.par[x]

    # 併合
    def union(self, x, y):
        # 根を探す
        x = self.find(x)
        y = self.find(y)

        # 木かどうかの判定用
        if x == y:
            self.tree[x] = False
            return
        if not self.tree[x] or not self.tree[y]:
            self.tree[x] = self.tree[y] = False

        # 木の高さを比較し、低いほうから高いほうに辺を張る
        if self.rank[x] < self.rank[y]:
            self.par[x] = y
            self.size[y] += self.size[x]
        else:
            self.par[y] = x
            self.size[x] += self.size[y]
            # 木の高さが同じなら片方を1増やす
            if self.rank[x] == self.rank[y]:
                self.rank[x] += 1

    # 同じ集合に属するか判定
    def same(self, x, y):
        return self.find(x) == self.find(y)

    # あるノードの属する集合のノード数
    def get_size(self, x):
        return self.size[self.find(x)]

    # 木かどうかの判定
    def is_tree(self, x):
        return self.tree[self.find(x)]

    # 集合の数
    def len(self):
        res = set()
        for i in range(self.n+1):
            res.add(self.find(i))
        # グループ0の分を引いて返却
        return len(res) - 1

N,M=MAP()
uf=UnionFind(N)
for i in range(M):
    s,t=MAP()
    uf.union(s, t)

Q=INT()
for _ in range(Q):
    s,t=MAP()
    if uf.same(s, t):
        print('yes')
    else:
        print('no')

"
3561677,ALDS1_11_D,"import sys
from collections import deque


def bfs():
    while len(bfs_q)>0:
        u = bfs_q.popleft()
        for v in adj_list[u]:
            if flag_list[v] == 0:
                group_list[v] = g
                flag_list[v] = 1
                bfs_q.append(v)
        flag_list[u] = 2


if __name__ == ""__main__"":
    input = sys.stdin.readline
    n, m = map(int, input().split())
    adj_list = [[] for _ in range(n)]
    for _ in range(m):
        s, t = list(map(int, input().split()))
        adj_list[s].append(t)
        adj_list[t].append(s)

    group_list = [0]*n
    flag_list = [0]*n # 0: 未到達, 1: 処理中, 2: 完了
    bfs_q = deque([])
    g = 0
    for i in range(n):
        if flag_list[i] == 0:
            group_list[i] = g
            flag_list[i] = 1
            bfs_q.append(i)
            bfs()
            g += 1

    q = int(input())
    for _ in range(q):
        s, t = map(int, input().split())
        if group_list[s] == group_list[t]:
            print('yes')
        else:
            print('no')

"
7847223,ALDS1_11_D,"import sys
from collections import defaultdict
from collections import deque
from bisect import bisect_left
MOD = 998_244_353

sys.setrecursionlimit(10**6)  # ネスト数制限

N, M = map(int, sys.stdin.readline().rstrip().split())
E = [[] for _ in range(N)]
for _ in range(M):
    u, v = map(int, sys.stdin.readline().rstrip().split())
    E[u].append(v)
    E[v].append(u)

seen = [-1] * N
for s in range(N):
    if seen[s] == -1:
        q = deque()
        q.append(s)
        seen[s] = s

        while q:
            u = q.popleft()

            for v in E[u]:
                if seen[v] != -1:
                    continue

                seen[v] = s
                q.append(v)

Q = int(sys.stdin.readline().rstrip())
for q in range(Q):
    s, t = map(int, sys.stdin.readline().rstrip().split())

    if seen[s] == seen[t]:
        print(""yes"")
    else:
        print(""no"")
"
4253315,ALDS1_11_D,"if __name__ == '__main__':
    from sys import stdin
    input = stdin.readline

    from collections import deque, defaultdict
    from copy import deepcopy

    MAX = 100000
    NIL = -1

    # Gはdictで管理する、valueはdeque
    G = defaultdict(lambda: deque())
    color = [NIL]*MAX

    def dfs(r, c):
        S = deque()
        S.append(r)
        color[r] = c
        while S:
            u = S.popleft()
            for v in G[u]:  # Gのvalueはdequeなので、それをvに一つずつ入れていく
                if color[v] == NIL:
                    color[v] = c
                    S.append(v)

    def assign_color():
        id = 1
        for u in range(n):
            if color[u] == NIL:
                dfs(u, id)
                id += 1

    n, m = map(int, input().split())

    for _ in range(m):
        s, t = map(int, input().split())
        G[s].append(t)
        G[t].append(s)

    assign_color()

    q = int(input())
    for _ in range(q):
        s, t = map(int, input().split())
        if color[s] == color[t]:
            print('yes')
        else:
            print('no')

"
4804025,ALDS1_11_D,"from sys import stdin
input = stdin.readline
from collections import deque, defaultdict

def DFS(i, key):
    S = deque()
    S.append(i)
    ID[i] = key
    while S:
        u = S.popleft()
        for x in G[u]:
            if ID[x] == -1:
                ID[x] = key
                S.append(x)

def AssignColor():
    key = 1
    for i in range(n):
        if ID[i] == -1:
            DFS(i, key)
            key += 1

G = defaultdict(lambda: deque())
ID = [-1] * 100000
n, m = map(int, input().split())

for _ in range(m):
    s, t = map(int, input().split())
    G[s].append(t)
    G[t].append(s)

AssignColor()

q = int(input())
for _ in range(q):
    s, t = map(int, input().split())
    if ID[s] == ID[t]:
        print('yes')
    else:
        print('no')
"
4368248,ALDS1_11_D,"import sys
input = sys.stdin.readline

from collections import deque, defaultdict
from copy import deepcopy

MAX = 100000
NIL = -1

#グラフGはdictで管理する
G = defaultdict(lambda:deque())
color = [NIL]*MAX

#頂点r,探索ごとに異なる数cによって深さ優先探索をする関数
#つながっている部分は全て色が同じになる
def dfs(r, c):
    S = deque()
    S.append(r) 
    color[r] = c
    while S: #Sが存在する間以下の処理を実行
        u = S.popleft()
        for v in G[u]:#Gのvalueはqueueとなっている
            if color[v] == NIL:#色がない場合のみ以下の操作を行う
                color[v] = c
                S.append(v) #深さを深くして次の頂点を探す準備をする

def make_color():
    id = 1
    for u in range(n):
        if color[u] == NIL:
            dfs(u, id) #色を塗る
            id += 1 #色を変える
        
    
    
n, m = map(int, input().split())

for _ in range(m):
    s, t = map(int, input().split())
    G[s].append(t)
    G[t].append(s)
    

make_color()

q = int(input())
for _ in range(q):
    s, t = map(int, input().split())
    if color[s] == color[t]:
        print('yes')
    else:
        print('no')
"
3951272,ALDS1_11_D,"#!/usr/bin/env python3
import sys
input = lambda: sys.stdin.readline()[:-1]
sys.setrecursionlimit(10**8)

n,m=map(int,input().split())
G=[[]*n for i in range(n)]
color=[-1]*n
for i in range(m):
    v1,v2=map(int,input().split())
    G[v1].append(v2)
    G[v2].append(v1)


def dfs(v,c):
    color[v]=c
    for vi in G[v]:
        if color[vi]==-1:
            dfs(vi,i)


for i in range(n):
    if color[i]==-1:
        dfs(i,i)

q=int(input())
for i in range(q):
    s,t=map(int,input().split())
    print('yes' if color[s]==color[t] else 'no')

"
4080154,ALDS1_11_D,"from collections import deque


def bfs(adj_list, n):
    color = [None] * n
    color_count = 0
    searching = deque()
    for i in range(n):
        if color[i] is None:
            color_count += 1
            color[i] = color_count
            searching.append(i)
            while len(searching) > 0:
                start = searching.popleft()
                for end in adj_list[start]:
                    if color[end] is None:
                        color[end] = color_count
                        searching.append(end)
    return color


def dfs(adj_list, n):
    color = [None] * n
    color_count = 0
    searching = deque()
    for i in range(n):
        if color[i] is None:
            color_count += 1
            color[i] = color_count
            searching.append(i)
            while len(searching) > 0:
                start = searching.pop()
                for end in adj_list[start]:
                    if color[end] is None:
                        color[end] = color_count
                        searching.append(end)
    return color


def main():
    nm = input().split()
    n, m = list(map(int, nm))
    adj_list = [[] for _ in range(n)]
    for _ in range(m):
        st = input().split()
        s, t = list(map(int, st))
        adj_list[s].append(t)
        adj_list[t].append(s)
    color = dfs(adj_list, n)
    q = int(input())
    for _ in range(q):
        st = input().split()
        s, t = list(map(int, st))
        if color[s] == color[t]:
            print(""yes"")
        else:
            print(""no"")


if __name__ == ""__main__"":
    main()

"
1783441,ALDS1_11_D,"#!/usr/bin/env python3

import array
import collections


UNDEF = -1


def compute_connected_components(max_v, adj_list):
    group = array.array(""l"", (UNDEF for _ in range(max_v)))
    g_idx = 0
    for u in range(max_v):
        if group[u] == UNDEF:
            group[u] = g_idx
            q = collections.deque()
            q.append(u)
            while q:
                v = q.popleft()
                for w in adj_list[v]:
                    if group[w] == UNDEF:
                        group[w] = g_idx
                        q.append(w)
            else:
                g_idx += 1
    return group


def main():
    n, m = map(int, input().split())
    adj_list = [set() for _ in range(n)]
    for _ in range(m):
        s, t = map(int, input().split())
        adj_list[s].add(t)
        adj_list[t].add(s)
    group = compute_connected_components(n, adj_list)
    q = int(input())
    for _ in range(q):
        s, t = map(int, input().split())
        print(""yes"" if group[s] == group[t] else ""no"")


if __name__ == '__main__':
    main()
"
2962709,ALDS1_11_D,"#coding:utf-8
#16D8101012J Ito Jun dj Python3

class UnionFind:
    def __init__(self,n):
        self.parent=[i for i in range(n+1)]
        self.rank=[0]*(n+1)
    def find(self,x):
        if self.parent[x] == x: # if x is x`s root
            return x
        else:
            self.parent[x] = self.find(self.parent[x])
            return self.parent[x]
    def is_same_tree(self,x,y):
        return self.find(x) == self.find(y) 
    def union(self,x,y):
        x=self.find(x)
        y=self.find(y)
        if self.rank[x] < self.rank[y]:
            self.parent[x] = y
        else:
            self.parent[y] = x
        if self.rank[x] == self.rank[y]:
            self.rank[x] += 1
        
def main():
    n=list(map(int,input().split()))
    union=UnionFind(n[0])
    friends=[]
    question=[]
    for i in range(n[1]):
        a=tuple(map(int,input().split()))
        friends.append(a)
    for i in friends:
        union.union(i[0],i[1])
    m=int(input())
    for i in range(m):
        b=tuple(map(int,input().split()))
        question.append(b)
    for i in question:
        if union.find(i[0]) == union.find(i[1]):
            print(""yes"")
        else:
            print(""no"")
if __name__ == ""__main__"":
    main()
"
3540322,ALDS1_11_D,"n, m = map(int, input().split())
*p, = range(n)
def root(s):
    if s == p[s]:
        return p[s]
    p[s] = s = root(p[s])
    return s
def unite(a, b):
    aa = root(a);bb = root(b)
    if aa < bb:
        p[bb] = aa
    else:
        p[aa] = bb
        
for i in range(m):
    s, t = map(int, input().split())
    unite(s, t)
N = int(input())
*_, = map(root, range(n))

ans = []
for i in range(N):
    s, t = map(int, input().split())
    ans.append('yes' if p[s] == p[t] else 'no')
print('\n'.join(ans))
"
4751192,ALDS1_11_D,"from sys import stdin
input = stdin.readline

from collections import deque, defaultdict
from copy import deepcopy

MAX = 100000
NIL = -1

# Gはdictで管理する、valueはdeque
G = defaultdict(lambda: deque())
color = [NIL]*MAX

def dfs(r, c):
    S = deque()
    S.append(r)
    color[r] = c
    while S:
        u = S.popleft()
        for v in G[u]:  # Gのvalueはdequeなので、それをvに一つずつ入れていく
            if color[v] == NIL:
                color[v] = c
                S.append(v)

def assign_color():
    id = 1
    for u in range(n):
        if color[u] == NIL:
            dfs(u, id)
            id += 1

n, m = map(int, input().split())

for _ in range(m):
    s, t = map(int, input().split())
    G[s].append(t)
    G[t].append(s)

assign_color()

q = int(input())
for _ in range(q):
    s, t = map(int, input().split())
    if color[s] == color[t]:
        print('yes')
    else:
        print('no')
"
2921869,ALDS1_11_D,"import sys
sys.setrecursionlimit(200000)
input_lines = [[int(i) for i in line.split()] for line in sys.stdin.read().splitlines()]
[user_num, rel_num] = input_lines[0]
rel_list = input_lines[1:rel_num+1]
ques_num = input_lines[rel_num+1][0]
ques_list = input_lines[rel_num+2:]
color_list = [-1] * user_num
adja_list = [set() for i in range(user_num)]

def dfs(id, color):
    if color_list[id] == -1:
        color_list[id] = color
        for a_id in adja_list[id]:
            dfs(a_id, color)



for rel in rel_list:
    adja_list[rel[0]].add(rel[1])
    adja_list[rel[1]].add(rel[0])

color = 0
for id in range(user_num):
    dfs(id, color)
    color += 1

for ques in ques_list:
    if color_list[ques[0]] == color_list[ques[1]]:
        print('yes')
    else:
        print('no')

"
4876770,ALDS1_11_D,"from collections import deque

def bfs(u, g):
    Q.append(u)
    group[u] = g
    while len(Q) > 0:
        loc = Q.popleft()
        for d in adj[loc]:
            if group[d] == None:
                Q.append(d)
                group[d] = g
                
n, m = map(int, input().split())

adj = [[] for _ in range(n)]
for _ in range(m):
    s, d = map(int, input().split())
    adj[s].append(d)
    adj[d].append(s)

q = int(input())

questions = []
for _ in range(q):
    questions.append(list(map(int, input().split())))

group = [None for _ in range(n)]
Q = deque([])

g = 0
for i in range(n):
    if group[i] == None:
        bfs(i, g)
        g += 1

for question in questions:
    if group[question[0]] == group[question[1]]:
        print('yes')
    else:
        print('no')
"
8277001,ALDS1_12_A,"import heapq

def main():
    n = int(input())
    G = [[] for _ in range(n)]

    # make adjacency list
    for v in range(n):
        for w, c in enumerate(map(int, input().split())):
            if c != -1:
                G[v].append((w, c))


    # Prim's algorithm
    # the list which check the vertex or not
    marked = [False for _ in range(n)]
    cost = 0
    # at first we need to check the vertex of 0
    marked[0] = True
    # heap
    heap = []

    # save the edge which adjacent to vertex 0
    for j, c in G[0]:
        heapq.heappush(heap, (c, j))

    # roop until we checked every vertex
    while heap:
        c, i = heapq.heappop(heap)
        if marked[i]:
            continue
        # marked the vertex
        marked[i] = True
        cost += c
        # save the edge which adjacent to vertex i
        for j, c in G[i]:
            if marked[j]:
                continue
            heapq.heappush(heap, (c, j))
    print(cost)

if __name__ == '__main__':
    main()
"
8539852,ALDS1_12_A,"from heapq import heapify, heappop

n = int(input())
G = [[*map(int, input().split())] for _ in range(n)]
heap = [[float(""inf""), v] for v in range(n)]
heap[0] = [0, 0]
weights = 0
while heap:
  heapify(heap)
  w, u = heappop(heap)
  weights += w
  for i, [w, v] in enumerate(heap):
    if 0 <= G[u][v] < w:
      heap[i] = [G[u][v], v]
print(weights)
"
8600659,ALDS1_12_A,"from enum import Enum


class Color(Enum):
    WHITE = 0
    GRAY = 1
    BLACK = 2


class Node:
    def __init__(self, id: int, neighbors_row: list) -> None:
        self.id = id
        self.neighbors_row = neighbors_row
        self.color = Color.WHITE
        self.parent_id = -1


def prim():
    global node_list
    global n
    INFTY = 1e20

    distance_list = [INFTY for _ in range(n)]
    distance_list[0] = 0

    while True:
        min_cost = INFTY
        u = None
        for i in range(n):
            if node_list[i].color != Color.BLACK and distance_list[i] < min_cost:
                min_cost = distance_list[i]
                u = node_list[i]

        if u is None:
            break

        u.color = Color.BLACK

        for i in range(n):
            if node_list[i].color != Color.BLACK and u.neighbors_row[i] != -1:
                if u.neighbors_row[i] < distance_list[i]:
                    distance_list[i] = u.neighbors_row[i]
                    node_list[i].parent_id = u.id
                    node_list[i].color = Color.GRAY

    sum_cost = 0
    for i in range(n):
        if node_list[i].parent_id != -1:
            sum_cost += node_list[i].neighbors_row[node_list[i].parent_id]

    print(sum_cost)


n = int(input())
node_list: list[Node] = []
for i in range(n):
    neighbors_row = list(map(int, input().split()))
    node_list.append(Node(i, neighbors_row))

prim()

"
8775011,ALDS1_12_A,"class UnionFind():
    def __init__(self, n):
        self.n = n
        self.root = [-1] * n
        self.rank = [0] * n

    def find(self, x):
        if self.root[x] < 0:
            return x
        else:
            self.root[x] = self.find(self.root[x])
            return self.root[x]

    def unite(self, x, y):
        x = self.find(x)
        y = self.find(y)

        if x == y:
            return
        elif self.rank[x] > self.rank[y]:
            self.root[x] += self.root[y]
            self.root[y] = x
        else:
            self.root[y] += self.root[x]
            self.root[x] = y
            if self.rank[x] == self.rank[y]:
                self.rank[y] += 1

    def same(self, x, y):
        return self.find(x) == self.find(y)

n = int(input())
g = [list(map(int, input().split())) for _ in range(n)]
edges = []
for i in range(n):
    for j in range(i + 1, n):
        if g[i][j] == -1:
            continue
        edges.append((g[i][j], i, j))
edges.sort()
uf = UnionFind(n)
ans = 0
for w, i, j in edges:
    if uf.same(i, j):
        continue
    ans += w
    uf.unite(i, j)
print(ans)

"
8796618,ALDS1_12_A,"import heapq

def main():
    n = int(input())
    graph = {}
    for i in range(n):
        a = list(map(int, input().split()))
        for j in range(n):
            if a[j] == -1:
                continue
            graph.setdefault(i, []).append([j, a[j]])
    sw = solve_mst_prim(n, graph)
    print(sw)

# プリム法に基づき最小全域木の重みの総和を求める
def solve_mst_prim(n, graph):
    # 各頂点の使用は一回のみ: 閉路ができることを防ぐ
    used_v = [False] * n
    used_count = 0

    # 最初に任意の頂点を1つ選ぶ: ここでは頂点0
    used_v[0] = True
    used_count += 1
    # 頂点0に隣接する辺を調べ, ヒープに追加
    q = []
    for (nv, w) in graph[0]:
        # 先頭の要素で昇順にソートされる
        heapq.heappush(q, (w, nv))
    
    # 最小全域木の作成
    sw = 0
    while used_count < n:
        # 隣接する辺の中で、重みが最小の辺を取り出す
        w,v = heapq.heappop(q)
        # 頂点vが未使用の場合のみ頂点をつなげる
        if used_v[v]:
            continue
        used_v[v] = True
        used_count += 1
        sw += w
        
        # 新たに使った頂点vに隣接する辺を調べる
        for (nv, w) in graph[v]:
            if used_v[nv]:
                continue
            heapq.heappush(q, (w, nv))

    return sw


if __name__ == '__main__':
    main()
"
8808436,ALDS1_12_A,"INF = 10**5
# load data
N = int(input())
M = []
Color = []
D = []
P = []

for _ in range(N):
    Color.append(0)
    D.append(INF)
    P.append(None)
    M.append([x if x != -1 else INF for x in map(int, input().split())])

D[0] = 0
P[0] = None

while True:
    min_cost = INF
    for i in range(N):
        if Color[i] != 2 and D[i] < min_cost:
            min_cost = D[i]
            u = i

    if min_cost == INF:
        break

    Color[u] = 2

    for v in range(N):
        if Color[v] != 2 and M[u][v] != INF:
            if M[u][v] < D[v]:
                D[v] = M[u][v]
                P[v] = u


ans = 0
for i, p in enumerate(P[1:], start = 1):
    ans += M[i][p]

print(ans)
"
8848446,ALDS1_12_A,"from heapq import heappop, heappush
n = int(input())
G = [[] for _ in range(n)]
frag  = [False for _ in range(n)]
heap = []
node_cnt = 0
cnt = 0

for i in range(n):
    input_data = list(map(int,input().split()))
    for j,number in enumerate(input_data):
        G[i].append((j,number))

frag[0] = True
node_cnt = 1

for j,number in G[0]:
    heappush(heap,(number,j))

while node_cnt < n:
    number,i = heappop(heap)
   #print(number,i)

    if frag[i] == True or number == -1:
        continue

    frag[i] = True
    node_cnt += 1
    cnt += number

    for j,number in G[i]:
        if frag[j] == True:
            continue
        heappush(heap,(number,j))

print(cnt)








"
8871477,ALDS1_12_A,"import math

def prim(n, A):
    INF = math.inf
    mincost = [INF] * n #各頂点までの最小コストを保持する配列
    used = [False] * n #各頂点が既に全域木に含まれているかどうかを追跡する配列。初期化時は、全ての頂点が未使用（False）と設定してる。
    mincost[0] = 0
    res = 0

    while True:
        v = -1
        for u in range(n):
            if not used[u] and (v == -1 or mincost[u] < mincost[v]):
                v = u
        if v == -1:
            break
        used[v] = True
        res += mincost[v]
        for u in range(n):
            mincost[u] = min(mincost[u], A[v][u])
    return res

n = int(input())
A = [[int(x) for x in input().split()] for _ in range(n)]
for i in range(n):
    for j in range(n):
        if A[i][j] == -1:
            A[i][j] = math.inf

print(prim(n, A))

"
8247669,ALDS1_12_A,"from heapq import heappush, heappop, heapify
n=int(input())
adj=[list(map(int,input().split())) for _ in range(n)]
g=[[] for _ in range(n)]
for i in range(n):
    for j in range(n):
        if(adj[i][j]==-1 or i==j):continue
        g[i].append((j,adj[i][j]))

deq=[]
heapify(deq)
heappush(deq,(0,0))
vis=[0]*n
dist=[0]*n
while(deq):
    c,u=heappop(deq)
    if(vis[u]):continue
    vis[u]=1
    dist[u]=c
    for v,c in g[u]:
        if(vis[v]):continue
        heappush(deq,(c,v))
print(sum(dist))
"
8833568,ALDS1_12_A,"import heapq
n = int(input())
mat = [list(map(int,input().split())) for _ in range(n)]
distance = [-1] * n
q = [(0, 0, 0)]
ans = 0

while q:
    plus, cur, node = heapq.heappop(q)
    if distance[node] != -1: continue
    distance[node] = cur
    ans += plus
    for nex in range(n):
        w = mat[node][nex]
        if w == -1: continue
        if distance[nex] != -1: continue
        heapq.heappush(q, (w, cur+w, nex))

print(ans)

"
8851431,ALDS1_12_A,"# aizu_ALDS1_12_A_MinimumSpanningTree_a.py  
# prim method
from heapq import heappop,heappush

n = int(input())
graph = [ [] for _ in range(n)]
for i in range(n):
    t = list(map(int,input().split()))
    for j in range(n):
        if t[j] == -1: continue
        graph[i].append([t[j],j])

linked = [False] * n
linked[0] = True
t_cost = 0
hq = []
for t in graph[0]:
    heappush(hq,t)

while hq:
    cost,v = heappop(hq)
    if linked[v] == True: continue
    linked[v] = True
    t_cost += cost
    for t in graph[v]:
        heappush(hq,t)
   
print(t_cost)
"
8967474,ALDS1_12_A,"class UnionFind:
    __slots__ = [""roots""]
    roots: list[int]

    def __init__(self, n: int):
        self.roots = [-1] * n

    def root(self, x: int) -> int:
        breads = []
        while self.roots[x] != -1:
            breads.append(x)
            x = self.roots[x]

        for b in breads:
            self.roots[b] = x
        return x

    def unite(self, x: int, y: int) -> bool:
        x = self.root(x)
        y = self.root(y)

        if x == y:
            return False

        self.roots[x] = y
        return True


def solve(matrix, n):
    weights = []

    for i in range(n):
        for j in range(i + 1, n):
            w = matrix[i * n + j]
            if w == -1:
                continue
            weights.append((w, i, j))

    weights.sort()

    ans = 0
    uf = UnionFind(n)
    for w, i, j in weights:
        if uf.unite(i, j):
            ans += w

    print(ans)


if __name__ == ""__main__"":
    N = int(input())
    matrix = []
    for _ in range(N):
        matrix.extend(map(int, input().split()))

    solve(matrix, N)

"
8975067,ALDS1_12_A,"class UnionFind:

    __slots__ = ""par""

    def __init__(self, n):
        self.par = [-1] * n

    def root(self, x):
        y = x
        while self.par[y] >= 0:
            y = self.par[y]
        while self.par[x] >= 0:
            self.par[x] = y
            x = self.par[x]
        return y

    def issame(self, x, y):
        return self.root(x) == self.root(y)

    def unite(self, x, y):
        rx = self.root(x)
        ry = self.root(y)
        if rx == ry:
            return False
        if -self.par[rx] < -self.par[ry]:
            rx, ry = ry, rx
        self.par[rx] += self.par[ry]
        self.par[ry] = rx
        return True


def main() -> None:
    import sys

    input = sys.stdin.readline

    n = int(input())
    Edges = []
    for i in range(n):
        row = list(map(int, input().split()))
        for j in range(n):
            w = row[j]
            if w == -1:
                continue
            Edges.append((w, i, j))
    Edges.sort()

    uf = UnionFind(n)
    ans = 0
    for w, s, t in Edges:
        if not uf.issame(s, t):
            ans += w
            uf.unite(s, t)
    print(ans)


if __name__ == ""__main__"":
    main()

"
9002179,ALDS1_12_A,"#AOJ - 最小全域木
import heapq

N = int(input())
A = [list(map(int,input().split())) for _ in range(N)]
G = [[] for _ in range(N)]
for i in range(N):
    for j in range(N):
        if A[i][j] != -1:
            G[i].append((A[i][j], j))
            G[j].append((A[i][j], i))

seen = [False]*N
connection = 0

hq = [(0, 0)]
heapq.heapify(hq)
ans = 0

while hq:
    cost, v = heapq.heappop(hq)
    if seen[v]:continue
    seen[v] = True
    connection += 1
    ans += cost
    for nc, nxt in G[v]:
        if not seen[nxt]:
            heapq.heappush(hq, (nc, nxt))
    if connection == N:break
print(ans)
"
9002858,ALDS1_12_A,"n = int(input())
G = [[] for _ in range(n)]

for i in range(n):
    l = list(map(int,input().split()))
    for j in range(n):
        if l[j] != -1:
            G[i].append((l[j],j))

from heapq import heappush, heappop

q = [(0,0)]
used = [0]*n
ans = 0

while len(q):
    w,u = heappop(q)
    if used[u]:
        continue
    used[u] = 1
    ans += w
    
    for w,v in G[u]:
        if not used[v]:
            heappush(q, (w,v))

print(ans)
"
9151571,ALDS1_12_A,"import sys
r = sys.stdin.readline
w = sys.stdout.write

class UnionFindTree:
    def __init__(self, n: int) -> None:
        *self.p, = range(n)  # 最初はそれぞれが一つの木
        self.s = [1 for _ in range(n)]  # それぞれの木のサイズ

    def find(self, x: int) -> int:
        if x == self.p[x]: return x
        self.p[x] = self.find(self.p[x])  # 根を張り替えながら再帰的に親ノードを探す
        return self.p[x]
    
    def unite(self, x: int, y: int) -> None:
        # データの親ノードを得る
        x = self.find(x)
        y = self.find(y)
        if x == y: return  # 既に同じ木に属しているなら終了
        if self.s[x] < self.s[y]: x, y = y, x
        self.p[y] = x
        self.s[x] += self.s[y]
        self.s[y] = 0

    def same(self, x: int, y: int) -> bool:
        return self.find(x) == self.find(y)
    
    def size(self, x: int):
        return self.s[self.find(x)]

class Edge:
    def __init__(self, weight: int, a: int, b: int) -> None:
        self.w = weight
        self.a = a
        self.b = b
    def __lt__(self, other):
        return self.w < other.w

def MS():
    n = int(r())
    a = [list(map(int, r().split())) for _ in range(n)]
    def kruskal(a: list[int]) -> int:
        uft = UnionFindTree(n)
        weight = 0
        edges = [Edge(a[i][j], i, j) for i in range(n) for j in range(i, n) if a[i][j] != -1]
        edges.sort()
        
        for e in edges:
            if not uft.same(e.a, e.b):  # 辺を追加しても閉路が生まれないなら採用 
                weight += e.w
                uft.unite(e.a, e.b)    
        return weight
    
    w(f""{kruskal(a)}\n"")

MS()
"
1662615,ALDS1_12_A,"n = int(input())
G = []
for i in range(n):
    G.append(input().split())
    for j in range(len(G[i])):
        G[i][j] = int(G[i][j])

ans = 0
mincost = [2001] * n
flag = [0] * n
mincost[0] = 0
while True:
    v = -1
    for j in range(n):
        if flag[j] != 1 and (v == -1 or mincost[j] < mincost[v]):
            v = j
    if v == -1:
        break
    flag[v] = 1
    ans += mincost[v]
    for j in range(n):
        if G[v][j] == -1: continue
        mincost[j] = min(mincost[j], G[v][j])

print(ans)
"
1842216,ALDS1_12_A,"n = int(input())

adj = [list(map(int, input().split())) for i in range(n)]


def prim_mst(vn):
    isVisited = [False] * vn
    d = [0] + [2001] * (vn - 1)
    p = [-1] * vn

    while True:
        mincost = 2001
        for i in range(vn):
            if (not isVisited[i]) and (d[i] < mincost):
                mincost = d[i]
                u = i

        if mincost == 2001:
            break

        isVisited[u] = True

        for v in range(vn):
            if (not isVisited[v]) and (adj[u][v] != -1):
                if adj[u][v] < d[v]:
                    d[v] = adj[u][v]
                    p[v] = u

    print(sum(d))


prim_mst(n)
"
2179656,ALDS1_12_A,"import sys

def debug(x, table):
    for name, val in table.items():
        if x is val:
            print('DEBUG:{} -> {}'.format(name, val), file=sys.stderr)
            return None

def solve():
    inf = float('inf')
    n = int(input())
    a = []

    for i in range(n):
        line = [int(i) for i in input().split()]
        line = [i if i != -1 else inf for i in line]
        a.append(line)

    
    checked = [False] * n
    d = [inf] * n
    checked[0] = True
    ans = 0
    nxt = 0

    for i in range(n - 1):
        for j in range(n):
            if a[nxt][j] < d[j]:
                d[j] = a[nxt][j]

        min_w = inf
        min_n = 0

        for j in range(n):
            if not checked[j] and d[j] < min_w:
                min_n = j
                min_w = d[j]

        checked[min_n] = True
        nxt = min_n
        ans += min_w

    # debug(d, locals())
    print(ans)



if __name__ == '__main__':
    solve()
"
2352845,ALDS1_12_A,"n = int(input())
M = [[float(""inf"") for i in range(n)] for i in range(n)]
for i in range(n):
 L = list(map(int, input().split()))
 for j,v in enumerate(L):
  if v != -1:
   M[i][j] = v

def prim():
 color = [0] * n
 d = [float(""inf"")] * n
 d[0] = 0

 while True:
  minv = float(""inf"")
  u = -1
  for i in range(n):
   if minv > d[i] and color[i] != 2:
    u = i
    minv = d[i]
  if u == -1: break
  color[u] = 2
  for v in range(n):
   if color[v] != 2 and M[u][v] != float(""inf""):
    if d[v] > M[u][v]:
     d[v] = M[u][v]
 return sum(d)

print(prim())
"
2431101,ALDS1_12_A,"from sys import stdin
INF = 1<<21
WHITE, GRAY, BLACK = 0, 1, 2
n = int(stdin.readline())
M = [[INF] * n for _ in range(n)]
for i in range(0, n):
    for j, e in enumerate(list(map(int, stdin.readline().split()))):
        if e != -1: M[i][j] = e
d = [INF] * n
d[0] = 0
color = [0] * n
def prim():
    while True:
        minv = INF
        u = -1
        for i in range(0, n):
            if minv > d[i] and color[i] != BLACK:
                u = i
                minv = d[i]
        if u == -1: break
        color[u] = BLACK
        for v in range(0, n):
            if color[v] != BLACK and d[v] > M[u][v]:
                d[v] = M[u][v]
    return sum(d)
print(prim())
"
2627146,ALDS1_12_A,"n = int(input())
edgeList = []
for i in range(n):
    a = list(map(int, input().split()))
    for j in range(i):
        if a[j] != -1:
            edgeList.append([a[j], i, j])
rootList = [-1]*n
sumLength = 0

def getRoot(x):
    r = rootList[x]
    if r < 0:
        rootList[x] = x
    elif r != x:
        rootList[x] = getRoot(r)
    return rootList[x]
        

edgeList.sort(key=lambda x: x[0])
for e in edgeList:
    x = getRoot(e[1])
    y = getRoot(e[2])
    if x != y:
        sumLength += e[0]
        rootList[x] = rootList[y] = min(x, y)
print(sumLength)
"
2627580,ALDS1_12_A,"inf = float('inf')
n = int(input())
a = []

for i in range(n):
    line = list(map(int, input().split()))
    for i in range(len(line)):
        if line[i] == -1:
            # infinity weight if not connected
            line[i] = inf
    a.append(line)

checked = [False] * n
d = [inf] * n
checked[0] = True
ans = 0
nxt = 0

for i in range(n - 1):
    for j in range(n):
        if a[nxt][j] < d[j]:
            d[j] = a[nxt][j]

    min_n = 0
    min_w = inf

    for j in range(n):
        if not checked[j] and d[j] < min_w:
            min_n = j
            min_w = d[j]

    checked[min_n] = True
    nxt = min_n
    ans += min_w

print(ans)
"
2707077,ALDS1_12_A,"# -*- coding: utf-8 -*-


if __name__ == '__main__':

    n = int(input())
    M = [list(map(int, input().split("" "")[1:])) for _ in range(n)]

    color = [0] * n
    d = [float(""inf"")] * n
    p = [None] * n

    def prim():
        d[0] = 0
        p[0] = -1

        while True:
            mincost = float(""inf"")
            for i in range(n):
                if color[i] != 2 and d[i] < mincost:
                    mincost = d[i]
                    u = i

            if mincost == float(""inf""):
                break

            color[u] = 2

            for v in range(n):
                if color[v] != 2 and M[u][v] != -1:
                    if M[u][v] < d[v]:
                        d[v] = M[u][v]
                        p[v] = u
                        color[v] = 1

    prim()
    sum = 0
    for i in range(n):
        if p[i] != -1:
            sum += M[i][p[i]]

    print(sum)

"
2732112,ALDS1_12_A,"n=int(input())
M=[list(map(int,input().split()))for _ in[0]*n]
d=[0]+[1e4]*n
b=[1]*n
a=0
while 1:
 u=-1
 for i in range(n):
  if b[i]and(u<0 or d[i]<d[u]):u=i
 if u<0:break
 b[u]=0
 a+=d[u]
 for v in range(n):
  t=M[u][v]
  if t+1 and d[v]>t:d[v]=t
print(a)
"
2755158,ALDS1_12_A,"n = int(input())

a = []
for i in range(n):
    a.append(list(map(int, input().split())))

ans = 0
mincost = [2001] * n
flag = [0] * n
mincost[0] = 0

while 1:
    v = -1
    for j in range(n):
        if flag[j] != 1 and (v == -1 or mincost[j] < mincost[v]):
            v = j
    if v == -1:
        break
    flag[v] = 1
    ans += mincost[v]
    for j in range(n):
        if a[v][j] == -1:
            continue
        mincost[j] = min(mincost[j], a[v][j])
print(ans)
"
2925150,ALDS1_12_A,"import sys
INF = float('inf')
n = int(input())
adja_matrix = [[int(i) for i in line.split()] for line in sys.stdin.read().splitlines()]
condition = ['INIT'] * n
distance = [INF] * n
p = [0] * n
distance[0] = 0
p[0] = -1

while True:
    mincost = INF
    for i in range(n):
        if condition[i] != 'FINISH' and distance[i] < mincost:
            mincost = distance[i]
            u = i

    if mincost == INF:
        break

    condition[u] = 'FINISH'

    for v in range(n):
        if condition[v] != 'FINISH' and adja_matrix[u][v] != -1:
            if adja_matrix[u][v] < distance[v]:
                distance[v] = adja_matrix[u][v]
                p[v] = u
                condition[v] = 'CHECK'

sum = 0
for i in range(n):
    if p[i] != -1:
        sum += adja_matrix[i][p[i]]

print(sum)
"
2962050,ALDS1_12_A,"n = int(input())

INF = 2147483647
G = [[INF for j in range(n)] for i in range(n+1)]
check = [0 for i in range(n)]


def prim():
    d = [INF for i in range(n)]
    p = [-1 for i in range(n)]
    d[0] = 0
    cost = 0

    while True:
        min_cost = INF
        for i in range(n):
            if check[i] != 2 and d[i] < min_cost:
                min_cost = d[i]
                u = i

        if min_cost == INF:
            break

        cost += d[u]
        check[u] = 2

        for v in range(n):
            if check[v] != 2 and G[u][v] != INF:
                if G[u][v] < d[v]:
                    d[v] = G[u][v]
                    p[v] = u
                    check[v] = 1

    return cost


def main():
    for i in range(n):
        data = list(map(int, input().split()))
        for j in range(n):
            if data[j] != -1:
                G[i][j] = data[j]

    print(prim())


if __name__ == '__main__':
    main()

"
2972300,ALDS1_12_A,"class UnionFindTree:
    """"""
        Disjoint set data structure
        Union-Find tree
        complexity:
            init: O(n)
            find, unite, same: O(alpha(n))
    """"""
    def __init__(self, n):
        self.par = list(range(n))
        self.rank = [0] * n

    def find(self, x):
        if self.par[x] == x:
            return x
        else:
            self.par[x] = self.find(self.par[x])
            return self.par[x]

    def unite(self, x, y):
        x, y = self.find(x), self.find(y)
        if x == y:
            return
        elif self.rank[x] < self.rank[y]:
            self.par[x] = y
        else:
            self.par[y] = x
            if self.rank[x] == self.rank[y]:
                self.rank[x] += 1

    def same(self, x, y):
        return self.find(x) == self.find(y)


class Kruskal:
    """"""
        Kruskal's algorithm: find Minimum Spanning Tree
        complexity:
            O(E logV)
    """"""
    def __init__(self, V, E, start=0, INF=10**9):
        """"""
        :param V: the number of vertices
        :param E:  adjacency list (undirected graph)
        :param start:
        :param INF:
        """"""
        self.kruskal(V, E)

    def kruskal(self, V, E):
        edges = []
        for v1 in range(V):
            for v2, cost in E[v1]:
                if v1 < v2:
                    edges.append((cost, v1, v2))
        edges.sort(reverse=True)
        self.mincost = 0
        self.min_spanning_tree = []
        uf = UnionFindTree(V)
        while len(self.min_spanning_tree) < V - 1:
            cost, v1, v2 = edges.pop()
            if not uf.same(v1, v2):
                self.mincost += cost
                uf.unite(v1, v2)
                self.min_spanning_tree.append((v1, v2, cost))

    def min_cost(self):
        return self.mincost

    def get_min_spanning_tree(self):
        return sorted(self.min_spanning_tree)


V = int(input())
edges = [[] for _ in range(V)]
for i in range(V):
    for j, d in enumerate(map(int, input().split())):
        if d != -1:
            edges[i].append((j, d))
mst = Kruskal(V, edges)
print(mst.min_cost())
"
3031449,ALDS1_12_A,"# -*- coding: utf-8 -*-
from heapq import heappop, heappush


def prim(edges, *, start=0, adj_matrix=False, default_value=float('inf')):
    '''
    Returns the Minimum Spanning Tree(MST) of a given graph

    # sample input when given not as adjacency list (adj_matrix=False) (generally works faster)
    edges = [[(1, 2), (2, 5), (3, 4)],         # node 0
             [(0, 2), (3, 3), (4, 6)],         # node 1
             [(0, 5), (3, 2), (5, 6)],         # node 2
             [(0, 4), (1, 3), (2, 2), (4, 2)], # node 3
             [(1, 6), (3, 2), (5, 4)],         # node 4
             [(2, 6), (4, 4)]]                 # node 5

    # sample input when given as adjacency matrix (adj_matrix=True)
    edges = [[0, 2, 5, 4, inf, inf],           # node 0
             [2, 0, inf, 3, 6, inf],           # node 1
             [5, inf, 0, 2, inf, 6],           # node 2
             [4, 3, 2, 0, 2, inf],             # node 3
             [inf, 6, inf, 2, 0, 4],           # node 4
             [inf, inf, 6, inf, 4, 0]]         # node 5
    '''

    n = len(edges)

    costs = [float('inf')] * n
    costs[start] = 0
    prevs = [-1] * n

    pq = [(0, start)]
    T = [True] * n

    while pq:
        tmp_cost, tmp_node = heappop(pq)
        T[tmp_node] = False

        nxt_edges = ((node, cost) for node, cost in enumerate(edges[tmp_node]) if cost != default_value and T[node]) if adj_matrix else\
                    ((node, cost) for node, cost in edges[tmp_node] if T[node])

        for nxt_node, nxt_cost in nxt_edges:
            if costs[nxt_node] > nxt_cost:
                costs[nxt_node] = nxt_cost
                prevs[nxt_node] = tmp_node
                heappush(pq, (nxt_cost, nxt_node))
                T[nxt_node] = True

    else:
        if len([prev for prev in prevs if prev != -1]) != n - 1:
            raise NoSpanningError(
                'There is no spanning tree in this graph (search started from node{})'.
                format(start))

        else:
            return prevs, costs


class NoSpanningError(Exception):
    pass


if __name__ == '__main__':
    '''
    an example of using this function
    AIZU ONLINE JUDGE - ALDS_1_12_A
    '''

    n = int(input())
    edges = [[(j, int(cost)) for j, cost in enumerate(input().split())
              if int(cost) != -1] for i in range(n)]

    prevs, costs = prim(edges)
    print(sum(costs))

"
3053838,ALDS1_12_A,"n = int(input())
a = [list(map(int, input().split())) for i in range(n)]
m = [2001] * n
f = [0] * n
sum = 0

m[0] = 0
f[0] = 1
v = 0

for i in range(n-1) :
    for j in range(n) :
        if (a[v][j] < m[j]) & (f[j] == 0) & (a[v][j] != -1):
            m[j] = a[v][j]
    
    min = 2001
    minj = 0
    for j in range(n) :
        if (m[j] < min) & (f[j] == 0):
            min = m[j]
            minj = j
    
    v = minj
    f[minj] = 1
    sum += min

print(sum)
"
3068100,ALDS1_12_A,"infinity = float('inf')
n = int(input())
a = []

for i in range(n):

    line = list(map(int, input().split()))

    for i in range(len(line)):
        if line[i] == -1:
            line[i] = infinity
    a.append(line)

checked = [False] * n
d = [infinity] * n
checked[0] = True
ansswer = 0
next = 0

for i in range(n - 1):
    for j in range(n):
        if a[next][j] < d[j]:
            d[j] = a[next][j]

    minimumNeightbor = 0
    minimumWeight = infinity

    for j in range(n):
        if not checked[j] and d[j] < minimumWeight:
            minimumNeightbor = j
            minimumWeight = d[j]

    checked[minimumNeightbor] = True
    next = minimumNeightbor
    ansswer += minimumWeight

print(ansswer)

"
3089954,ALDS1_12_A,"INFTY = 1 << 21
WHITE = 0
GRAY = 1
BLACK = 2

def prim(n, m):
    d = [INFTY] * n
    p = [-1] * n
    color = [WHITE] * n

    d[0] = 0

    while True:
        minv = INFTY
        u = -1
        for i in range(n):
            if minv > d[i] and color[i] != BLACK:
                u = i
                minv = d[i]
        if u == -1:
            break
        color[u] = BLACK
        for v in range(n):
            if color[v] != BLACK and m[u][v] != INFTY:
                if d[v] > m[u][v]:
                    d[v] = m[u][v]
                    p[v] = u
                    color[v] = GRAY

    w_sum = 0
    for i in range(n):
        if p[i] != -1:
            w_sum += m[i][p[i]]

    return w_sum


n = int(input())
m = []
for i in range(n):
    line = [int(v) for v in input().split()]
    for j in range(n):
        if line[j] == -1:
            line[j] = INFTY
    m.append(line)

print(prim(n, m))
"
3101288,ALDS1_12_A,"import heapq

n = int(input())
A = [[int(i) for i in input().split()] for i in range(n)]
h = []
DP = {}
heapq.heappush(h,(0,0))
c = 0
while(len(DP)<n):
    tmp = heapq.heappop(h)
    if tmp[1] in DP:
        continue
    c += tmp[0]
    DP[tmp[1]] = 1
    for i,j in enumerate(A[tmp[1]]):
        if j > -1 and not i in DP:
            heapq.heappush(h,(j,i))
print(c)
"
3104285,ALDS1_12_A,"import sys
def prim(n, m):
	d = [sys.maxsize]*n
	p = [-1]*n
	c = [False]*n
	d[0] = 0
	while True:
		minv = sys.maxsize
		u = -1
		for i in range(n):
			if minv > d[i] and c[i] == False:
				minv = d[i]
				u = i
		if u == -1:
			break
		c[u] = True
		for i in range(n):
			if m[u][i] != sys.maxsize:
				if m[u][i] < d[i] and c[i] == False:
						d[i] = m[u][i]
						p[i] = u
	sum = 0
	for i in range(n):
		if p[i] != -1:
			sum += m[i][p[i]]
	return sum

n = int(input())
m = [[0 for x in range(n)] for x in range(n)]
for i in range(n):
	a = list(map(int, input().split()))
	for j in range(n):
		if a[j] == -1:
			m[i][j] = sys.maxsize
		else:
			m[i][j] = a[j]
print(prim(n, m))

"
3164895,ALDS1_12_A,"N = int(input())
G = [[] for i in range(N)]
for v in range(N):
    for w, c in enumerate(map(int, input().split())):
        if c != -1:
            G[v].append((w, c))

from heapq import heappush, heappop, heapify
used = [0]*N
que = [(c, w) for w, c in G[0]]
used[0] = 1
heapify(que)

ans = 0
while que:
    cv, v = heappop(que)
    if used[v]:
        continue
    used[v] = 1
    ans += cv
    for w, c in G[v]:
        if used[w]:
            continue
        heappush(que, (c, w))
print(ans)

"
3221923,ALDS1_12_A,"from sys import stdin

def read_matrix(n):
    A = []
    for _ in range(n):
        a = [ int(i) for i in stdin.readline().strip().split() ]
        A.append(a)
    return A

def prim(n, A):
    color = [ 'WHITE' for i in range(n) ]
    d = [ float('inf') for i in range(n) ]
    d[0] = 0
    p = [-1] * n

    while True:
        mincost = float('inf')
        for i in range(n):
            if color[i] != 'BLACK' and d[i] < mincost:
                mincost = d[i]
                u = i

        if mincost == float('inf'):
            break

        color[u] = 'BLACK'

        for v in range(n):
            if color[v] != 'BLACK' and A[u][v] != -1:
                if A[u][v] < d[v]:
                    d[v] = A[u][v]
                    p[v] = u
                    color[v] = 'GRAY'

    return sum(d)

n = int(input())
A = read_matrix(n)
print(prim(n, A))
"
3306104,ALDS1_12_A,"n=int(input())
M=[list(map(int,input().split()))for _ in[0]*n]
d=[0]+[1e4]*n
b=[1]*n
a=0
while 1:
 u=-1
 for i in range(n):
  if b[i]and(u<0 or d[i]<d[u]):u=i
 if u<0:break
 b[u]=0
 a+=d[u]
 for v in range(n):
  t=M[u][v]
  if t+1 and d[v]>t:d[v]=t
print(a)
"
3446365,ALDS1_12_A,"#minimum spaning tree

n = int(input())
a = [list(map(int, input().split())) for _ in range(n)]
d = [0] + [1e4]*(n-1)
color = [0]*n

# break = 1 ; glay = 2
while 1:
    mincost = pow(10, 4)
    for i in range(n):
        if color[i] != 1 and d[i] < mincost:mincost = d[i];min_key = i
    if mincost == pow(10,4):
        break
    
    color[min_key] = 1
    
    for i in range(n):
        if color[i] != 1 and a[min_key][i] != -1 and d[i] > a[min_key][i]:
            d[i] = a[min_key][i]
            color[i] = 2
#             parent[i] = min_key
print(f""{sum(d)}"")
"
3492611,ALDS1_12_A,"n = int(input())
M = [list(map(int, input().split())) for _ in range(n)]

WHITE = 0
GREY = 1
BLACK = 2
INFTY = 10**10

color = [WHITE] * n
d = [INFTY] * n
p = [-1] * n


def prim():
    # すべての頂点u について color[u] をwhiteとして、d[u]をINFINITYへ
    d[0] = 0
    p[0] = -1  # 親なし

    while True:
        mincost = INFTY
        for i in range(0, n):
            if color[i] != BLACK and d[i] < mincost:
                # まだ未訪問でコストが最小になるところを探す。
                # WHITEなところはd[i]=INFTYなので来ない
                mincost = d[i]
                # 最小コストになる場所を見つける
                u = i
                # 訪れる場所を決定
        if mincost == INFTY:
            break

        color[u] = BLACK
        # 起点座標の決定

        for v in range(0, n):
            if color[v] != BLACK and M[u][v] != -1:
                if M[u][v] < d[v]:
                    # 最初コストになるノードを探索
                    d[v] = M[u][v]
                    p[v] = u
                    color[v] = GREY


prim()
print(sum(d))

"
3528343,ALDS1_12_A,"# -*- coding: utf-8 -*-

import sys

sys.setrecursionlimit(10 ** 9)
def input(): return sys.stdin.readline().strip()
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(): return list(map(int, input().split()))
INF=float('inf')

# Union-Find木
class UnionFind:
    def __init__(self, n):
        self.n = n
        # 親要素のノード番号を格納。par[x] == xの時そのノードは根
        # 1-indexedのままでOK、その場合は[0]は未使用
        self.par = [i for i in range(n+1)]
        # 木の高さを格納する（初期状態では0）
        self.rank = [0] * (n+1)
        # あるノードを根とする集合に属するノード数
        self.size = [1] * (n+1)
        # あるノードを根とする集合が木かどうか
        self.tree = [True] * (n+1)

    # 根の検索(グループ番号と言えなくもない)
    def find(self, x):
        # 根ならその番号を返す
        if self.par[x] == x:
            return x
        else:
            # 走査していく過程で親を書き換える
            self.par[x] = self.find(self.par[x])
            return self.par[x]

    # 併合
    def union(self, x, y):
        # 根を探す
        x = self.find(x)
        y = self.find(y)

        # 木かどうかの判定用
        if x == y:
            self.tree[x] = False
            return
        if not self.tree[x] or not self.tree[y]:
            self.tree[x] = self.tree[y] = False

        # 木の高さを比較し、低いほうから高いほうに辺を張る
        if self.rank[x] < self.rank[y]:
            self.par[x] = y
            self.size[y] += self.size[x]
        else:
            self.par[y] = x
            self.size[x] += self.size[y]
            # 木の高さが同じなら片方を1増やす
            if self.rank[x] == self.rank[y]:
                self.rank[x] += 1

    # 同じ集合に属するか判定
    def same(self, x, y):
        return self.find(x) == self.find(y)

    # あるノードの属する集合のノード数
    def get_size(self, x):
        return self.size[self.find(x)]

    # 木かどうかの判定
    def is_tree(self, x):
        return self.tree[self.find(x)]

    # 集合の数
    def len(self):
        res = set()
        for i in range(self.n+1):
            res.add(self.find(i))
        # グループ0の分を引いて返却
        return len(res) - 1

N=INT()
G=[[None] for i in range(N)]
for i in range(N):
    G[i]=LIST()

# 隣接行列を辺集合(cost, u, v)にする
edges=[]
for i in range(N):
    for j in range(i+1, N):
        if G[i][j]!=-1:
            edges.append((G[i][j], i, j))

# クラスカル法
edges.sort()
uf=UnionFind(N)
ans=0
for cost, u, v in edges:
    if not uf.same(u, v):
        uf.union(u, v)
        ans+=cost
print(ans)

"
3568078,ALDS1_12_A,"def prim(n):
    d[0] = 0
    while True:
        cost_min = 10**9
        u = -1
        for i in range(n):
            weight = d[i]
            if flag_list[i] < 2 and weight < cost_min:
                u = i
                cost_min = weight
        if u == -1:
            break
        flag_list[u] = 2
        for v in range(n):
            edge = m[u][v]
            if flag_list[v] < 2 and edge > -1:
                if d[v] > edge:
                    d[v] = edge
                    p[v] = u
                    flag_list[v] = 1
    cnt = 0
    for i in range(n):
        if p[i] != -1:
            cnt += m[i][p[i]]
    return cnt


if __name__ == ""__main__"":
    n = int(input())
    m = []
    for _ in range(n):
        in_list = list(map(int, input().split()))
        m.append(in_list)

    flag_list = [0]*n # 0: 未到達, 1: 処理中, 2: 完了
    d = [10**9]*n
    p = [-1]*n
    print(prim(n))

"
3637835,ALDS1_12_A,"n = int(input())

A = []
# A = [[] for _ in range(n)]

for i in range(n):
    A.append(list(map(int, input().split())))
    # A[i] = list(map(int, input().split()))

max_d = 2001

flag = [0] * n
d = [max_d] * n
d[0] = 0
p = [-1] * n

while True:
    min_d = max_d
    for i in range(n):
        if flag[i] == 0 and d[i] < min_d:
            min_d = d[i]
            u = i
    
    if min_d == max_d:
        break
    
    flag[u] = 1
    
    for i in range(n):
        if flag[i] == 0 and A[u][i] >= 0:
            if d[i] > A[u][i]:
                d[i] = A[u][i]
                p[i] = u

print(sum(d))

"
3665213,ALDS1_12_A,"N = int(input())
color = [""w"" for _ in range(N)]
d = [float(""inf"") for _ in range(N)]
p = [-1 for _ in range(N)]

# Make M
M = [list(map(int, input().split())) for _ in range(N)]

d[0] = 0
while True:
    mincost = float(""inf"")
    for i in range(N):
        if color[i] != ""b"" and d[i] < mincost:
            mincost = d[i]
            u = i
    
    if mincost == float(""inf""):
        break
    color[u] = ""b""

    for v in range(N):
        if color[v] != ""b"" and M[u][v] != -1:
            if d[v] > M[u][v]:
                d[v] = M[u][v]
                p[v] = u

s = 0 
for i in range(1, N):
    s += M[i][p[i]]
print(s)
"
3668753,ALDS1_12_A,"import itertools

n = int(input())
A = [list(map(int, input().strip().split(' '))) for _ in range(n)]
uvc = [] # A list of tuples of start, end, and cost
for i in range(n-1):
    for j in range(i+1, n):
        if A[i][j] >= 0:
            uvc.append((i, j, A[i][j]))

# コストでソート
uvc.sort(key=lambda x: x[2])

uf = list(range(n))

def find_root(x):
    global uf
    if x == uf[x]:
        return x
    else:
        uf[x] = find_root(uf[x])
        return uf[x]

def union(x, y):
    global uf
    uf[find_root(x)] = find_root(y)

def is_same_set(x, y):
    return find_root(x) == find_root(y)

def costs():
    global uvc
    for u, v, c in uvc:
        if not is_same_set(u, v):
            union(u, v)
            yield c
print(sum(itertools.islice(costs(), n - 1)))


"
3676025,ALDS1_12_A,"def main():
     def root(x):
          path=[]
          while x!=P[x]:
               path.append(x)
               x=P[x]
          for i in path:
               P[i]=x
          return x
     
     def is_same_set(x,y):
          return root(x)==root(y)
     
     def unite(x,y):
          P[root(x)]=root(y)
     
     n=int(input())
     P=[i for i in range(n)]
     edge_CostAndVertex=[]
     for i in range(n):
          cost=list(map(int,input().split()))
          for j in range(i):
               if cost[j]!=-1:
                    edge_CostAndVertex.append([cost[j],[i,j]])
                    
     edge_CostAndVertex.sort(key=lambda x:x[0])
     ans=0
     check=[]#連結されている頂点
     main_edge=edge_CostAndVertex[0][1][0]
     for i in edge_CostAndVertex:
          cost_i,a,b=i[0],i[1][0],i[1][1]
          if is_same_set(a,b):
               continue
          else:

               unite(a,b)
               ans+=cost_i
               if a not in check:
                    check.append(a)
               if b not in check:
                    check.append(b)
               if len(check)==n:
                    flag=1
                    for i in range(n):
                         for j in range(i):
                              if is_same_set(i,j):
                                   continue
                              else:
                                   flag=0
                                   break
                    if flag==1:
                         break
                    
     print(ans)
                    
if __name__=='__main__':
     main()
"
3719149,ALDS1_12_A,"WHITE = 0
GRAY = 1
BLACK = 2

INF = 1.0e+6

def prim(M):
    n = len(M)
    color = [WHITE] * n
    d = [INF] * n
    p = [-1] * n

    d[0] = 0

    while True:
        minv = INF
        u = -1
        for i in range(n):
            if minv > d[i] and color[i] != BLACK:
                u = i
                minv = d[i]

        if u == -1:
            break

        color[u] = BLACK
        for v in range(n):
            if color[v] != BLACK and M[u][v] != INF:
                if d[v] > M[u][v]:
                    d[v] = M[u][v]
                    p[v] = u
                    color[v] = GRAY

    sum = 0
    for i in range(n):
        if p[i] != -1:
            sum += M[i][p[i]]

    return sum


if __name__ == ""__main__"":
    n = int(input())

    M = [] * n

    for i in range(n):
        M.append(list(map(int, input().split())))
        M[i] = [INF if j == -1 else j for j in M[i]]

    print(prim(M))

"
3825576,ALDS1_12_A,"import heapq


def prim(adj):
    INF = 3000
    n = len(adj)
    state, d, p = [False] * n, [INF] * n, [-1] * n
    d[0] = 0
    pq = [(d[0], 0)]
    while pq:
        f, u = heapq.heappop(pq)
        state[u] = True
        if d[u] < f:
            continue
        for v, c in adj[u]:
            if state[v]:
                continue
            if c < d[v]:
                d[v] = c
                p[v] = u
                heapq.heappush(pq, (d[v], v))
    return d


def adj_matrix_to_list(matrix):
    n = len(matrix)
    li = [[] for _ in range(n)]
    for u in range(n):
        for v in range(n):
            if matrix[u][v] != -1:
                li[u].append((v, matrix[u][v]))
    return li


def main():
    n = int(input())
    m = [list(map(int, input().split())) for _ in range(n)]
    adj = adj_matrix_to_list(m)
    print(sum(prim(adj)))


if __name__ == '__main__':
    main()

"
3897987,ALDS1_12_A,"import sys
input = sys.stdin.readline
INF = 100100

def prim(n: int, M: list):
    ans = 0
    visited = [False] * n
    d = [INF] * n
    p = [-1] * n
    d[0] = 0
    while True:
        mincost = INF
        for i in range(n):
            if not visited[i] and d[i] < mincost:
                mincost = d[i]
                u = i
        if mincost == INF:
            break
        ans += mincost
        visited[u] = True
        for v in range(n):
            if not visited[v] and M[u][v] != -1:
                if M[u][v] < d[v]:
                    d[v] = M[u][v]
                    p[v] = u
    return ans

def main():
    n = int(input())
    M = []
    for _ in range(n):
        Mi = list(map(int, input().split()))
        M.append(Mi)
    ans = prim(n,M)
    print(ans)

if __name__ == '__main__': main()
"
3901392,ALDS1_12_A,"N = int(input())
M = [list(map(int, input().split())) for i in range(N)]
INF = 2001
MAX = 100
d = [INF for i in range(N)]
d[0] = 0
p = [MAX for i in range(N)]
p[0] = -1
mst = [False for i in range(N)]

while True:
  min_w = INF
  for i in range(N):
    if not mst[i] and d[i] < min_w:
      min_w = d[i]
      u = i
  if min_w == INF:
    break
  mst[u] = True
  for v in range(N):
    if not mst[v] and M[u][v] != -1:
      if M[u][v] < d[v]:
        d[v] = M[u][v]
        p[v] = u

print(sum(d))

"
3931278,ALDS1_12_A,"INF = 10000

def prim():
	color = [""WHITE"" for _ in range(n)]
	d = [INF for _ in range(n)]
	pi = [None for _ in range(n)]
	d[0] = 0

	while True:
		mincost = INF
		for i in range(n):
			if color[i] != ""BLACK"" and d[i] < mincost:
				mincost = d[i]
				u = i
		if mincost == INF:
			break
		color[u] = ""BLACK""
		for v in range(n):
			if color[v] != ""BLACK"" and M[u][v] != -1:
				if M[u][v] < d[v]:
					d[v] = M[u][v]
					pi[v] = u
					color[v] = ""GRAY""
	sum = 0
	for u in range(n):
		if pi[u] != None:
			sum += M[u][pi[u]]
	return sum

if __name__ == ""__main__"":
	n = int(input())
	M = []
	for _ in range(n):
		M.append(list(map(int, input().split())))
	print(prim())
"
3939340,ALDS1_12_A,"N = int(input())

a = [list(map(int, input().split())) for _ in range(N)]

vis = [False] * N
inf = 1e9
d = [inf] * N
d[0] = 0
cost = 0
for _ in range(N):
    nv, ni = inf, -1
    for i in range(N):
        if not vis[i] and d[i] < nv:
            nv, ni = d[i], i
    vis[ni] = True
    cost += nv
    for i in range(N):
        c = a[ni][i]
        if c > -1:
            d[i] = min(d[i], c)
print(cost)
"
3959524,ALDS1_12_A,"from heapq import heappush, heappop, heapify

n = int(input())
G = [[] for _ in range(n)]

for i in range(n):
    for j,dist in enumerate(map(int,input().split())):
        if dist != -1:
            G[i].append((j,dist))
sum = 0

def prim(n):
    que = [(w,c) for c,w in G[0]]
    heapify(que)
    color = [0]*n
    color[0] = 1
    global sum
    while que:
        w,node = heappop(que)
        if color[node] == 1:
            continue
        color[node] = 1
        sum += w
        for x,y in G[node]:
            if color[x] == 1:
                continue
            heappush(que,(y,x))
    return sum

print(prim(n))

"
3964143,ALDS1_12_A,"
INFINITY = 10 ** 10
WHITE = 0
GRAY = 1
BLACK = 2


n = int(input())
M = [[INFINITY] * n for _ in range(n)]

for i in range(n):
    for j, weight in enumerate(map(int, input().split())):
        if weight == -1:
            weight = INFINITY

        M[i][j] = weight


def prim():
    color = [WHITE] * n
    d = [INFINITY] * n
    p = [None] * n

    d[0] = 0
    p[0] = -1

    while True:
        cost_min = INFINITY
        for i in range(n):
            if color[i] != BLACK and d[i] < cost_min:
                cost_min = d[i]
                top_now = i

        if cost_min == INFINITY:
            break
    
        color[top_now] = BLACK

        for v in range(n):
            if color[v] == BLACK or M[top_now][v] == INFINITY:
                continue

            if M[top_now][v] < d[v]:
                d[v] = M[top_now][v]
                p[v] = top_now
                color[v] = GRAY

    return sum(d)

cost_min = prim()
print(cost_min)

"
3965710,ALDS1_12_A,"# https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/12/ALDS1_12_A
# 本よりこっちのほうがぶっちゃけわかりやすい http://www.deqnotes.net/acmicpc/prim/
# 螺旋本ではダイクストラとの違いをあまり解説していないが、違いはダイクストラのところで考えよう
# 記号は本に合わせる。
# 制約条件によりノードはたかだか100なのでオーダーを木にせずにナイーブに実装できる。本ではdを導入することにより計算量を少し削減している

INF = 10**5
# load data
N = int(input())
M = []  # 隣接行列
Color = []  # 訪問状態を記録 0:未訪問, 1:訪問経験あり, 2:訪問済み(用済み) #そうはこいつが2になっているノードはMST
D = []  # 本で言うd #こいつの役割はP299の図を追うとわかりやすい #MSTに隣接しているノードへのコストをノードのところに記録する
P = []  # 本で言うp # MSTにおける親を記録

for _ in range(N):
    Color.append(0)  # ノードはすべて未訪問
    D.append(INF)  # 無限で初期化しておく
    P.append(None)
    M.append([x if x != -1 else INF for x in map(int, input().split())])

# primのアルゴリズムを適応する
# ノード0からMSTを構築していく #まずはノード0をMSTに追加する
D[0] = 0
P[0] = None  # 親が存在しないことをNoneで示す

while True:  # MSTができるまで繰り返す ちなみにループの一周目は0をMSTに追加するところから始まる
    # MSTに隣接するノードへのpathの中で一番小さなコストを見つける、ついでにそのノード番号も
    min_cost = INF
    for i in range(N):
        if Color[i] != 2 and D[i] < min_cost:  # 訪問済みかつ最小値を更新したら
            min_cost = D[i]
            u = i  # uにはコストが一番小さい時のノードが追加される

    if min_cost == INF:
        break  # つながりがもうない

    Color[u] = 2  # つながるのに一番コストの小さい訪問済みに(MSTに追加)する

    for v in range(N):
        if Color[v] != 2 and M[u][v] != INF:  # MSTに追加されていなくてかつ、uとつながっている
            if M[u][v] < D[v]:  # 新たに追加したノードuからvに行くほうがコストが小さいならばそれをメモする
                D[v] = M[u][v]
                P[v] = u  # vの親の候補としてuを代入しておく(だいぶ無駄では？)
                Color[v] = 1  # 一度見たことあるのはgrayにしておくが、ぶっちゃけ意味はない

# これにてPに木構造が入ったのでこれをもとにコストを計算すれば良い
# ぶっちゃけこの操作は上のwhileに組み込み可能なんだけどあえてね
ans = 0
for i, p in enumerate(P[1:], start=1):
    ans += M[i][p]

print(ans)

"
3973843,ALDS1_12_A,"N = 100
INF = float('inf')
M = [[INF for _ in range(N)] for _ in range(N)]
n = 0
WHITE = 0
GRAY = 1
BLACK = 2
color = [WHITE for _ in range(N)]
d = [INF for _ in range(N)]
p = [0 for _ in range(N)]


def main():
    global N
    n = int(input())
    for i in range(n):
        a_s = list(map(int, input().split(' ')[1:]))
        for j in range(n):
            if a_s[j] != -1:
                M[i][j] = M[j][i] = a_s[j]
    print(prim(n))


def prim(n):
    d[0] = 0
    p[0] = -1

    while True:
        mincost = INF
        for i in range(n):
            if color[i] != BLACK and d[i] < mincost:
                mincost = d[i]
                u = i

        if mincost == INF:
            break

        color[u] = BLACK

        for v in range(n):
            if color[v] != BLACK and M[u][v] < INF:
                if M[u][v] < d[v]:
                    d[v] = M[u][v]
                    p[v] = u
                    color[v] = GRAY
    return sum(d[:n])


if __name__ == '__main__':
    main()

"
3988216,ALDS1_12_A,"def main():
    N = int(input())
    c = [[int(i) for i in input().split()] for j in range(N)]
    edges = []
    for i in range(N):
        for j in range(i+1, N):
            if c[i][j] != -1:
                edges.append((c[i][j], (i, j)))
    edges.sort()

    par = [i for i in range(N)]
    rank = [0 for i in range(N)]

    def find_root(x):
        if par[x] == x:
            return x
        else:
            par[x] = find_root(par[x])
            return par[x]

    def is_same_group(x, y):
        return find_root(x) == find_root(y)

    def unite(x, y):
        x = find_root(x)
        y = find_root(y)
        if x == y:
            return
        if rank[x] < rank[y]:
            par[x] = y
        else:
            par[y] = x
            if rank[x] == rank[y]:
                rank[x] += 1

    ans = 0
    for c, e in edges:
        if find_root(e[0]) != find_root(e[1]):
            unite(e[0], e[1])
            ans += c
    print(ans)


if __name__ == '__main__':
    main()

"
3990981,ALDS1_12_A,"import sys
input = sys.stdin.readline
from operator import itemgetter
sys.setrecursionlimit(10000000)
INF = 10**30
M = []

def prim(G, root, n):
    BLACK = 1<<10
    WHITE = 1<<20
    nodes = [WHITE] * n
    d = [INF] * n
    d[root] = 0
    p = [0] * n
    p[root] = -1
    while True:
        mincost = INF

        # 探索
        for i in range(n):
            if d[i] < mincost and nodes[i] == WHITE:
                mincost = d[i]
                next = i
        if mincost == INF:
            break
        # 移動
        nodes[next] = BLACK

        # 伝播
        for i in range(n):
            if nodes[i] == WHITE and G[next][i] != INF:
                if G[next][i] < d[i]:
                    d[i] = G[next][i]
                    p[i] = next
    return d

def main():
    global M
    n = int(input().strip())
    M = [[0] * n for _ in range(n)]
    for i in range(n):
        M[i] = list(map(lambda x: INF if x == -1 else x, map(int, input().strip().split())))
    d = prim(M, 0, n)
    print(sum(d))

if __name__ == '__main__':
    main()

"
3996107,ALDS1_12_A,"
def prim():
    global n, color, M, d, p
    d[0] = 0

    while True:
        min_cost = 10000000000
        u = -1

        # まず始点を決める。
        for i in range(n):
            if color[i] != 'BLACK' and d[i] < min_cost:
                min_cost = d[i]
                u = i  # エッジが繋がる中で、最小のもの？？

        if u == -1:
            break

        color[u] = 'BLACK'

        for v in range(n):
            if color[v] != 'BLACK' and M[u][v] != -1:
                if d[v] > M[u][v]:
                    d[v] = M[u][v]
                    p[v] = u
                    color[v] = 'GRAY'

    sum = 0
    for i in range(n):
        if p[i] != -1:
            sum += M[i][p[i]]

    return sum


n = int(input())

color = ['WHITE'] * n
M = []
d = [10000000000] * n  # 重みが最小の辺の重み
p = [-1] * n  # MSTにおけるp[v]の親（どこから来たか？？）

for i in range(n):
    _ = list(map(int, input().split()))
    M.append(_)
# print(A)

print(prim())

"
4038313,ALDS1_12_A,"n = int(input())
edges = [[-1 for i in range(n)] for j in range(n)]

for i in range(n):
  for index, j in enumerate(list(map(int, input().split()))):
    edges[i][index] = j

inf = 9999999999999999
distances = [inf] * n
colors = [""white""] * n

def mst(u):
  distances[u] = 0
  colors[u] = ""gray""

  while True:
    mincost = inf
    for i in range(n):
      if colors[i] != ""black"" and distances[i] < mincost:
        mincost = distances[i]
        u = i

    if mincost == inf:
      break

    colors[u] = ""black""

    for index, weight in enumerate(edges[u]):
      if weight != -1 and colors[index] != ""black"" and distances[index] > weight:
        distances[index] = weight
        colors[index] = ""gray""

mst(0)
print(sum(distances))

"
4038450,ALDS1_12_A,"

WHITE = 0
GRAY = 1
BLACK = 2

INF = 2000000000

def prim():
    d[0] = 0
    p[0] = -1
    
    while True:
        mincost = INF
        for i in range(n):
            if color[i] != BLACK and d[i] < mincost:
                mincost = d[i]
                u = i
        if mincost == INF:
            break
        color[u] = BLACK
        
        for v in range(n):
            if color[v] != BLACK and m[u][v] != -1:
                if m[u][v] < d[v]:
                    d[v] = m[u][v]
                    p[v] = u
                    color[v] = GRAY
            

n = int(input())

m = [[0 for i in range(n)] for j in range(n)]
for i in range(n):
    nums=list(map(int,input().split()))
    for j in range(n):
        m[i][j] = nums[j]

color = [WHITE] * n
d = [INF] * n
p = [-1] * n


prim()

sum = 0
for i in range(n):
    sum += d[i]

print(sum)




















"
4138333,ALDS1_12_A,"inf = float(""inf"")
class Node():

    def __init__(self, _id):
        self.id = _id
        self.d = inf
        self.pi = None
        self.color = 0
    
    def input_data(self):
        data = [int(i) for i in input().split()]
        self.adj = {G[i]: d
                    for i, d in enumerate(data)
                    if d != -1}
    
    def __hash__(self):
        return hash(self.id)
        
    

def prim():
    G[0].d = 0
    while True:
        mincost = inf
        for i in G:
            if i.color != 1 and i.d < mincost:
                mincost = i.d
                u = i
        
        if mincost == inf:
            break

        u.color = 1
        for v in u.adj.keys():
            if v.color != 1 and u.adj[v] < v.d:
                v.pi = u.id
                v.d = u.adj[v]

if __name__ == ""__main__"":
    n = int(input())
    G = [Node(i) for i in range(n)]
    [i.input_data() for i in G]
    prim()
    print(sum(g.d for g in G))
"
4155687,ALDS1_12_A,"def prim(n):
    inf=float(""inf"")
    D=[inf for i in range(n)]
    P=[0 for i in range(n)]
    M=[[inf for i in range(n)] for j in range(n)]
    color=[""white"" for i in range(n)]

    P[0]=-1
    D[0]=0

    for i in range(n):
        for j,num in enumerate(list(map(int,input().split()))):
            if num!=-1:
                M[i][j]=num

    while 1:
        cost,point=inf,0
        for i in range(n):
            if color[i]!=""black"" and D[i]<cost:
                cost=D[i]
                point=i

        if cost==inf:break

        color[point]=""black""

        for i in range(n):
            if color[i]!=""black"" and M[point][i]!=inf:
                if M[point][i]<D[i]:
                    D[i]=M[point][i]
                    P[i]=point
                    color[i]=""gray""

    return D


print(sum(prim(int(input()))))
"
4177426,ALDS1_12_A,"# input
n = int(input())
A = []
for _ in range(n):
    A.append(list(map(int, input().split())))
    
# 変数定義
inf = 100 * 2000 + 1
M = A.copy()
M = [[a if a > -1 else inf for a in line] for line in M]
d = [inf] * n
V = set([i for i in range(n)])
T = set()

# 探索
start = 0
target = start
d[target] = 0
T.add(target)
while V != T:
    for i in (V - T):
        if M[target][i] < d[i]:
            d[i] = M[target][i]

    min_wheght = min([d[i] for i in (V - T)])
    min_path = [i for i in (V - T) if d[i] == min_wheght][0]
    target = min_path
    T.add(target)

# 出力
print(sum(d))
"
8278753,ALDS1_12_B,"import heapq
n = int(input())
G = [[] for _ in range(n)]
d = [float('inf')]*n # the distance form 0 to v

def dijkstra(start):
    que = []
    d[0] = 0
    heapq.heappush(que, (0, start))
    while que:
        cur_dist_from_start, cur_node = heapq.heappop(que)
        if cur_dist_from_start > d[cur_node]:
            continue
        for next_node, edge_weight in G[cur_node]:
            dist_to_next_node = d[cur_node] + edge_weight
            if d[next_node] > dist_to_next_node:
                d[next_node] = dist_to_next_node
                heapq.heappush(que, (dist_to_next_node, next_node))
    return d

def main():
    for _ in range(n):
        table = list(map(int, input().split()))
        for i in range(table[1]):
            G[table[0]].append((table[2+2*i], table[3+2*i]))
    dijkstra(0)
    for i in range(n):
        print(i, d[i])
    


if __name__ == '__main__':
    main()
"
8539903,ALDS1_12_B,"import heapq
N=int(input())
ad_li=[[]for i in range(N)]
for i in range(N):
    nums=list(map(int,input().split()))
    f=nums[0]
    for j in range(nums[1]):
        t=nums[j*2+2]
        c=nums[j*2+3]
        ad_li[f].append([t,c])

memo=[1E18 for i in range(N)]
memo[0]=0
qu=[]
heapq.heappush(qu,(0,0))
while len(qu)!=0:
    atop=heapq.heappop(qu)
    for ne in ad_li[atop[1]]:
        next_cost=atop[0]+ne[1]
        if(memo[ne[0]]>next_cost):
            memo[ne[0]]=next_cost
            heapq.heappush(qu,(next_cost,ne[0]))
for i in range(N):
    print(i,memo[i])
"
8602151,ALDS1_12_B,"from enum import Enum


class Color(Enum):
    WHITE = 0
    GRAY = 1
    BLACK = 2


class Node:
    def __init__(self, id: int, neighbors_list: list) -> None:
        self.id = id
        self.neighbors_list = neighbors_list
        self.color = Color.WHITE
        self.parent_id = -1


def dijkstra():
    global node_list
    global n
    INFTY = 1e20

    distance_list = [INFTY for _ in range(n)]
    distance_list[0] = 0

    while True:
        min_cost = INFTY
        u = None

        for i in range(n):
            if node_list[i].color != Color.BLACK and distance_list[i] < min_cost:
                min_cost = distance_list[i]
                u = node_list[i]

        if u is None:
            break

        u.color = Color.BLACK

        for neighbor_id, weight in u.neighbors_list:
            if node_list[neighbor_id].color != Color.BLACK:
                if distance_list[u.id] + weight < distance_list[neighbor_id]:
                    distance_list[neighbor_id] = distance_list[u.id] + weight
                    node_list[neighbor_id].parent_id = u.id
                    node_list[neighbor_id].color = Color.GRAY

    return distance_list


n = int(input())
node_list: list[Node] = []
for i in range(n):
    n_list = list(map(int, input().split()))
    id = n_list[0]
    n_neighbors = n_list[1]
    neighbors_list = []
    for j in range(n_neighbors):
        neighbor_id = n_list[2 + j * 2]
        weight = n_list[3 + j * 2]
        neighbors_list.append((neighbor_id, weight))
    node_list.append(Node(id, neighbors_list))

distanse_list = dijkstra()

for i in range(n):
    print(f""{node_list[i].id} {distanse_list[i]}"")

"
8688994,ALDS1_12_B,"from sys import stdin
input = stdin.readline

INFTY = 2**21
WHITE = 0
GRAY = 1
BLACK = 2

n = int(input())

M = [[INFTY]*n for _ in range(n)]

for _ in range(n):
    u, k, *vc = map(int, input().split())
    for v, c in zip(vc[::2], vc[1::2]):
        M[u][v] = c

def dijkstra():
    d = [INFTY]*n
    color = [WHITE]*n

    d[0] = 0
    color[0] = GRAY
    while True:
        minv = INFTY
        u = -1
        for i in range(n):
            if minv > d[i] and color[i] != BLACK:
                u = i
                minv = d[i]

        if u == -1:
            break
        color[u] = BLACK
        for v in range(n):
            if color[v] != BLACK and M[u][v] != INFTY:
                if d[v] > d[u]+M[u][v]:
                    d[v] = d[u] + M[u][v]
                    color[v] = GRAY

    for i in range(n):
        print(str(i) + ' ' + str(-1 if d[i] == INFTY else d[i]))

dijkstra()
"
8760333,ALDS1_12_B,"import heapq
N = int(input())
Adj = [[] for _ in range(N)]
for i in range(N):
    u, k, *cv = map(int,input().split())
    for j in range(len(cv)//2):
        Adj[i].append([cv[2*j+1], cv[2*j]])

#print(Adj)

def dijkstra(N, Adj):
    ans = [float('inf')] * N
    ans[0] = 0
    pq = [(0, 0)]
    heapq.heapify(pq)
    checked = set()

    while pq:
        dist, node = heapq.heappop(pq)
        if node in checked:
            continue
        checked.add(node)
        for child_dist, child_node in Adj[node]:
            if child_node not in checked and ans[node] + child_dist < ans[child_node]:
                ans[child_node] = ans[node] + child_dist
                heapq.heappush(pq, (ans[child_node], child_node))

    return ans

ans = dijkstra(N, Adj)
for i in range(len(ans)):
    print(i, ans[i])
"
8833090,ALDS1_12_B,"import heapq

n = int(input())
g = [[] for _ in range(n)]
edge = []
for _ in range(n):
    pos, k, *a = list(map(int, input().split()))
    for i in range(k):
        nex, cost = a[2*i], a[2*i+1]
        g[pos].append((cost, nex))

distance = [-1] * n
q = [(0, 0)]

while q:
    cur, node = heapq.heappop(q)
    if distance[node] != -1: continue
    distance[node] = cur
    for cost, nex in g[node]:
        if distance[nex] != -1: continue
        heapq.heappush(q, (cur + cost, nex))

for i in range(n):
    print(i, distance[i])
"
8871507,ALDS1_12_B,"import math
def dijkstra(n, adj):
    INF = math.inf
    dist = [INF] * n
    dist[0] = 0  #始点の距離を0に設定
    q = [(0, 0)]   #優先度キューを初期化[距離, 頂点]

    while q:
        v = min(q, key=lambda x: x[0]) #キューから最短距離の頂点を取り出す
        q.remove(v)
        if dist[v[1]] < v[0]:
            continue
        for u, w in adj[v[1]]: #頂点vから到達可能な各頂点
            if dist[u] > dist[v[1]] + w:
                dist[u] = dist[v[1]] + w
                q.append((dist[u], u))
    return dist

n = int(input())
adj = [[] for _ in range(n)]
for _ in range(n):
    u, k, *vc = map(int, input().split())
    for i in range(k):
        v, c = vc[i*2:i*2+2]
        adj[u].append((v, c))

dist = dijkstra(n, adj)
for v, d in enumerate(dist):
    print(v, d)

"
8873346,ALDS1_12_B,"import heapq

def dijkstra(n, graph, start=0):
    INF = float('inf')
    dist = [INF] * n
    dist[start] = 0
    queue = [(0, start)]
    
    while queue:
        d, v = heapq.heappop(queue)
        if dist[v] < d:
            continue
        for u, cost in graph[v]:
            if dist[v] + cost < dist[u]:
                dist[u] = dist[v] + cost
                heapq.heappush(queue, (dist[u], u))
                
    return dist

def main():
    n = int(input().strip())
    graph = [[] for _ in range(n)]
    
    for _ in range(n):
        inputs = list(map(int, input().split()))
        u = inputs[0]
        k = inputs[1]
        for i in range(k):
            v, c = inputs[2 + 2*i], inputs[3 + 2*i]
            graph[u].append((v, c))
    
    dist = dijkstra(n, graph)
    
    for v in range(n):
        print(v, dist[v])

if __name__ == ""__main__"":
    main()


"
8894517,ALDS1_12_B,"from heapq import heappush, heappop

class Node:
    def __init__(self, id, weight):
        self.id = id
        self.weight = weight
    # Nodeどうしの比較: less than
    def __lt__(self, node):
        return self.weight < node.weight

def main():
    n = int(input())
    # グラフ作成
    graph = [[] for _ in range(n)]
    for i in range(n):
        u,k,*adg = map(int, input().split())
        for i in range(0, len(adg), 2):
            graph[u].append(Node(adg[i], adg[i+1]))
    # 各ノードの始点からの最短経路の重みを求める
    shortest_paths = solve_sssp(n, graph)
    for i, sw in enumerate(shortest_paths):
        print(i, sw)

# 単一始点最短経路探索により、各ノードの始点からの最短経路を求める
def solve_sssp(n, graph):
    # 各ノードの始点からの最小重みを保持
    nw = [int(1e10) for _ in range(n)]
    # 始点の重みは0
    nw[0] = 0
    
    # ヒープキューを使うことで重みが小さい順にノード探索できるため、探索スピードが上がる
    q = []
    heappush(q, Node(0, 0))
    # 幅優先探索
    while q:
        now = heappop(q)
        if now.weight > nw[now.id]:
            continue
        for node in graph[now.id]:
            w = node.weight + now.weight
            if w < nw[node.id]:
                nw[node.id] = w
                heappush(q, Node(node.id, nw[node.id]))
    return nw

if __name__ == '__main__':
    main()
"
8967486,ALDS1_12_B,"from heapq import heappop, heappush


def solve(edges):
    n = len(edges)

    dists = [100000000] * n
    dists[0] = 0
    breads = []
    heappush(breads, (0, 0))

    while breads:
        (w, u) = heappop(breads)
        for v in edges[u]:
            if w + v[0] < dists[v[1]]:
                dists[v[1]] = w + v[0]
                heappush(breads, (w + v[0], v[1]))

    for i in range(0, n):
        print(i, dists[i])


if __name__ == ""__main__"":
    N = int(input())
    EDGES = [None] * N

    for _ in range(N):
        u, k, *v = map(int, input().split())
        EDGES[u] = [(v[2 * i + 1], v[2 * i]) for i in range(k)]

    solve(EDGES)

"
9117613,ALDS1_12_B,"import heapq

n = int(input())
edges = [[] for _ in range(n)]
for _ in range(n):
    u, k, *l = list(map(int, input().split()))
    for i in range(0, 2*k, 2):
        v, c = l[i], l[i + 1]
        edges[u].append((c, v))
INF = float(""inf"")
dist = [INF] * n
que = [(0, 0)]
heapq.heapify(que)
while que:
    cost, crt = heapq.heappop(que)
    if dist[crt] <= cost:
        continue
    dist[crt] = cost
    for nxt_cost, nxt in edges[crt]:
        if dist[nxt] <= cost + nxt_cost:
            continue
        heapq.heappush(que, (cost + nxt_cost, nxt))
for i in range(n):
    print(i, dist[i])

"
9158205,ALDS1_12_B,"import math, sys
from collections import deque
r = sys.stdin.readline
def SSSPI():
    n = int(r())
    d = [math.inf] * n
    d[0] = 0
    edges = []
    for _ in range(n):
        u, k, *vc = map(int, r().split())
        temp = []
        for i in range(k):
            temp.append((vc[2 * i], vc[2 * i + 1]))
        edges.append(temp)
    
    hp = deque([0])
    while hp:
        c = hp.popleft()
        for next, weight in edges[c]:
            if d[c] + weight < d[next]:
                d[next] = d[c] + weight
                hp.append(next)
    for i, di in enumerate(d):
        print(i, di)
SSSPI()
"
8852360,ALDS1_12_B,"# aizu_ALDS1_12_B_SingleSourceShortestPath.py  
# dijkstra

from heapq import heappop,heappush

n = int(input())
graph = [ [] for _ in range(n)]
for i in range(n):
    u,k,*t = list(map(int,input().split()))
    for j in range(k):
        graph[u].append([t[2*j],t[2*j+1]])

def dijkstra(start):
    INF = 10**15
    dist = [INF] * n
    hq = [(0,start)]
    dist[start] = 0
    visited = [False] * n
    while hq:
        now = heappop(hq)[1]
        visited[now] = True
        for to,cost in graph[now]:
            if visited[to] == False and \
                    dist[now] + cost < dist[to]:
                dist[to] = dist[now ]+ cost
                heappush(hq,(dist[to],to))
    return dist

root = dijkstra(0)
for i,c in enumerate(root):
    print(i,c)
"
8854795,ALDS1_12_B,"import heapq
n = int(input())
G = [[] for i in range(n)]
frag  = [False for _ in range(n)]
heap = []
d = [100000000 for _ in range(n)]
G_0_value = [0 for i in range(n)]
once = False
cnt = 0

for i in range(n):
    input_data = list(map(int,input().split()))
    for j in range(3,len(input_data),2):
        G[input_data[0]].append((input_data[j-1],input_data[j]))
        if input_data[0] == 0:
            G_0_value[input_data[j-1]] = input_data[j]

frag[0] = True
d[0] = 0
heap = [(number,i) for i,number in G[0]]
heapq.heapify(heap)

while heap:
    cost_u,u = heapq.heappop(heap)

    if G_0_value[u] != 0:
        if G_0_value[u] < d[u]:
            d[u] = G_0_value[u]

    frag[u] = True
    
    for v,cost_v in G[u]:
        if frag[v] != True:
            if d[u] + cost_v <= d[v]:
                d[v] = d[u] + cost_v
                heapq.heappush(heap,(d[v],v))

for i in range(n):
    print(i,d[i])



"
1693335,ALDS1_12_B,"def dijkstra(n):
    inf = 10 ** 6 + 1
    dist = [0] + [inf] * (n - 1)
    visited = [False] * n

    while not all(visited):
        dmin = inf
        for i, (d, v) in enumerate(zip(dist, visited)):
            if dmin > d and not v:
                dmin, u = d, i
        visited[u] = True
        for (v, c) in edge[u]:
            if dist[v] > dist[u] + c:
                dist[v] = dist[u] + c
    return dist

n = int(input())
edge = [[]] * n
for _ in range(n):
    l = list(map(int, input().split()))
    edge[l[0]] = (e for e in zip(l[2::2], l[3::2]))
for i, c in enumerate(dijkstra(n)):
    print(i, c)
"
1863262,ALDS1_12_B,"n = int(input())

adj = [[100001 for j in range(n)] for i in range(n)]

for u in range(n):
    x = list(map(int, input().split()))
    for v, c in zip(x[2::2], x[3::2]):
        adj[u][v] = c

unvisited = [v for v in range(n)]

distance = [9900001] * n


def dijkstra(s):
    distance[s] = 0

    while True:
        mincost = 9900001
        for i in unvisited:
            if distance[i] < mincost:
                mincost = distance[i]
                u = i

        if mincost == 9900001:
            break

        unvisited.remove(u)

        for v in unvisited:
            weight_uv = adj[u][v]
            if weight_uv != 100001:
                t_d = distance[u] + weight_uv
                if t_d < distance[v]:
                    distance[v] = t_d



dijkstra(0)

for v, d in enumerate(distance):
    print(v, d)
"
2071183,ALDS1_12_B,"def relax(u, v, w):
    if D[u] + w < D[v]:
        D[v] = D[u] + w
        P[v] = u

INF = float('inf')
N = int(input())
D = [INF for i in range(N)]
P = [None for i in range(N)]
C = ['w' for i in range(N)]
D[0] = 0

G = [[INF for j in range(N)] for i in range(N)]
for i in range(N):
    x = list(map(int, input().split()))
    g = x[2:]
    for j, n in enumerate(g):
        if j % 2 == 0:
            G[i][n] = g[j + 1]


while True:
    mincost = INF
    u = -1
    for i in range(N):
        if C[i] != 'b' and D[i] < mincost:
            mincost = D[i]
            u = i
    if u == -1:
        break
    C[u] = 'b'
    for v, w in enumerate(G[u]):
        if w != INF and C[v] != 'b':
            relax(u, v, w)
            C[v] = 'g'

for i, d in enumerate(D):
    print('{0} {1}'.format(i, d))
"
2184181,ALDS1_12_B,"import sys
inf = float('inf')

def debug(x, table):
    for name, val in table.items():
        if x is val:
            print('DEBUG:{} -> {}'.format(name, val), file=sys.stderr)
            return None

def SSSP(n, Adj):
    d = [inf] * n
    p = [-1] * n
    checked = [False] * n
    d[0] = 0
    checked[0] = True
    u = 0

    for i in range(n - 1):
        for v, cost in Adj[u]:
            if d[u] + cost < d[v]:
                p[v] = u
                d[v] = d[u] + cost

        min_n = 0
        min_w = inf
        for v in range(n):
            if not checked[v] and d[v] < min_w:
                min_n = v
                min_w = d[v]

        u = min_n
        checked[u] = True

    return d

def solve():
    n = int(input())
    Adj = [[] for i in range(n)]

    for i in range(n):
        u, k, *line = [int(i) for i in input().split()]
        for j in range(k):
            Adj[u].append((line[2*j], line[2*j + 1]))

    # debug(Adj, locals())

    d = SSSP(n, Adj)

    for i in range(n):
        print(i, d[i])

if __name__ == '__main__':
    solve()
"
2352914,ALDS1_12_B,"inf = float(""inf"")
n = int(input())
M = [[inf for i in range(n)] for i in range(n)]
for i in range(n):
    L = list(map(int, input().split()))
    for j in range(L[1]):
        M[L[0]][L[2 * j + 2]] = L[2 * j + 3]


def dijkstra(s):
    color = [0] * n
    d = [inf] * n
    d[s] = 0

    while True:
        mincost = inf
        for i in range(n):
            if color[i] !=1 and d[i] < mincost:
                mincost = d[i]
                u = i
        if mincost == inf: break
        color[u] = 1
        for v in range(n):
            if color[v] != 1 and M[u][v] != inf:
                if d[u] + M[u][v] < d[v]:
                    d[v] = d[u] + M[u][v]

    return d

d = dijkstra(0)
for i,v in enumerate(d):
 print(""{} {}"".format(i,v))
"
2495336,ALDS1_12_B,"INF = 1e9

n = int(input())
adj_matrix = [[INF for i in range(n)] for j in range(n)]

for i in range(n):
    u, k, *line = list(map(int, input().split()))
    for j in range(k):
        adj_matrix[u][line[2*j]] = line[2*j+1]

def dijkstra(x):
    isVisited = [False] * x
    d = [INF] * x 
    d[0] = 0
    p = [0] * x 
    
    while True:
        min_cost = INF
        
        for i in range(x):
            if isVisited[i] != True and d[i] < min_cost:
                min_cost = d[i]
                u = i
        
        if min_cost == INF:
            break
        
        isVisited[u] = True
        
        for v in range(x):
            if isVisited[v] != True and adj_matrix[u][v] != INF:
                if d[u] + adj_matrix[u][v] < d[v]:
                    d[v] = d[u] + adj_matrix[u][v]
                    p[v] = u
    return d

for i, di in enumerate(dijkstra(n)):
    print(i, di)
"
2503778,ALDS1_12_B,"# -*- coding: utf-8 -*-
from heapq import heappush, heappop

N = int(input())
INF = float(""inf"")
adj = []
for _ in range(N):
    inp = tuple(map(int, input().split()))
    adj.append(tuple(zip(inp[2::2], inp[3::2])))

checked = [False for _ in range(N)]
d = [float(""inf"") for _ in range(N)]
d[0] = 0

heap = [[0, 0]] # cost, vec

while heap:
    c, u = heappop(heap)
    if d[u] < c or checked[u]:
        continue
    for nu, nc in adj[u]:
        new_d = d[u] + nc
        if new_d < d[nu]:
            d[nu] = new_d
            heappush(heap, [d[nu], nu])
    checked[u] = True

for n in range(N):
    print(""{} {}"".format(n, d[n]))
"
2627591,ALDS1_12_B,"inf = float('inf')
n = int(input())
g = []
for i in range(n):
    line = list(map(int, input().split()))
    k = line[1]
    c = [inf] * n
    for j in range(k):
        v = line[2 + 2 * j]
        c[v] = line[3 + 2 * j]
    g.append(c)

distance = [inf] * n
distance[0] = 0
visited = [False] * n
current = 0

while not all(visited):
    visited[current] = True
    min_i = 0
    min_d = inf
    for i in range(n):
        if not visited[i]:
            if distance[current] + g[current][i] < distance[i]:
                distance[i] = distance[current] + g[current][i]
            if distance[i] < min_d:
                min_i = i
                min_d = distance[i]
    current = min_i

for i in range(n):
    print(i, distance[i])
"
2671220,ALDS1_12_B,"# -*- coding: utf-8 -*-

import heapq
q = [] # プライオリティキュー


n = int(input())
V = dict()
d = dict()

for i in range(n):
    data = list(map(int, input().split()))
    V[data[0]] = data[2:]
    d[data[0]] = float('inf')

d[0] = 0
heapq.heappush(q, (0, 0)) #(d[id], id)
S = set()

while len(S) != len(V):
    dist, node_id = heapq.heappop(q)
    S.add(node_id)
    for u, c in zip(V[node_id][0::2], V[node_id][1::2]): #隣接ノード
        if c + d[node_id] < d[u]:
            d[u] = c + d[node_id]
            heapq.heappush(q, (d[u], u))
            #print(""Update:"", u, d[u])
for i in range(n):
    print(i, d[i])
"
2688169,ALDS1_12_B,"from heapq import *

#edge {to cost}
#P {mindirection, modeNum}
#G a list which contain informations of nodes

# building G from input
V=int(input())
G=[]
for _ in range(V):
    temp=list(map(int,input().split()))
    l=[]
    for i in range(1,temp[1]+1):
        l.append(temp[2*i:2*(i+1)])
    G.append(l)

que=[] #having the minimum distance
INF=1e8
d=[INF for i in range(V)] #having the distance
d[0]=0
heappush(que,[0,0])

while len(que)!=0:
    p=heappop(que)
    v=p[1]
    if(d[v]<p[0]):
        continue
    for i in range(len(G[v])):
        e=G[v][i]
        if(d[e[0]]>d[v]+e[1]):
            d[e[0]]=d[v]+e[1]
            heappush(que,[d[e[0]],e[0]])
            
for i in range(V):
    print(i,d[i])
"
2719942,ALDS1_12_B,"from heapq import heapify, heappush, heappop
INF = float(""inf"")
def MAIN():
    n = int(input())
    G = [[i, INF] for i in range(n)]
    G[0][1] = 0
    m = {}
    for _ in range(n):
        A = list(map(int, input().split()))
        m[A[0]] = {}
        for i in range(2, len(A), 2):
            m[A[0]][A[i]] = A[i + 1]
    dp = [(0, 0)]
    while dp:
        cost, u = heappop(dp)
        for v, c in m[u].items():
            if G[v][1] > G[u][1] + c:
                G[v][1] = G[u][1] + c
                heappush(dp, (G[v][1], v))
    print(""\n"".join("" "".join(map(str, a)) for a in G))
MAIN()

"
2732113,ALDS1_12_B,"n=int(input())
M=[[-1]*n for _ in[0]*n]
for _ in[0]*n:
 e=list(map(int,input().split()))
 for i in range(e[1]):k=2*-~i;M[e[0]][e[k]]=e[k+1]
d=[0]+[1e6]*n
c=[1]*n
while 1:
 m,u=1e6,-1
 for i in range(n):
  if m>d[i]and c[i]:m,u=d[i],i
 if u<0:break
 c[u]=0
 for v in range(n):
  if c[v]and 1+M[u][v]and d[v]>d[u]+M[u][v]:
   d[v]=d[u]+M[u][v]
for i in range(n):print(i,d[i])
"
2920466,ALDS1_12_B,"import heapq


def dijkstra(g, source):
    n = len(g)
    q = []
    heapq.heapify(q)
    heapq.heappush(q, (0, source))
    d = [float('inf') for _ in range(n)]
    d[source] = 0
    while len(q) > 0:
        cur = heapq.heappop(q)
        cur_pos = cur[1]
        for next in g[cur_pos]:
            next_pos = next[0]
            next_d = d[cur_pos] + next[1]
            if next_d < d[next_pos]:
                d[next_pos] = next_d
                heapq.heappush(q, (d[next_pos], next_pos))
    return d


def main():
    n = int(input())
    g = [[] for _ in range(n)]
    for _ in range(n):
        inp = list(map(int, input().split()))
        m = inp[0]
        k = inp[1]
        for i in range(k):
            g[m].append((inp[(i+1)*2], inp[(i+1)*2+1]))
    d = dijkstra(g, 0)
    for i in range(n):
        print(i, d[i])


if __name__ == '__main__':
    main()

"
2962892,ALDS1_12_B,"n = int(input())

INF = 2147483647
M = [[INF for j in range(n)] for i in range(n)]
check, dist = [0 for i in range(n)], [INF for i in range(n)]


def dijkstra(s):
    p = [-1 for i in range(n)]
    dist[s] = 0

    while True:
        min_cost = INF
        for i in range(n):
            if check[i] != 2 and dist[i] < min_cost:
                min_cost = dist[i]
                u = i

        if min_cost == INF:
            break

        check[u] = 2

        for v in range(n):
            if check[v] != 2 and M[u][v] != INF:
                if dist[u] + M[u][v] < dist[v]:
                    dist[v], p[v] = dist[u] + M[u][v], u
                    check[v] = 1


def main():
    for i in range(n):
        data = list(map(int, input().split()))
        for j in range(data[1]):
            M[data[0]][data[2*(j+1)]] = data[2*(j+1)+1]

    dijkstra(0)

    for i in range(n):
        print(i, dist[i])


if __name__ == '__main__':
    main()

"
3008375,ALDS1_12_B,"# coding: utf-8

import heapq


def dj(adjm, start):
    n = len(adjm)
    d = [float(""inf"")] * n
    d[start] = 0
    q = []
    heapq.heappush(q, (0, start))

    while(q):
        td, v = heapq.heappop(q)
        for k in adjm[v].keys():
            nd = td + adjm[v][k]
            if d[k] > nd:
                d[k] = nd
                heapq.heappush(q, (nd, k))
    return d


def main():
    n = int(input())
    # 隣接行列
    adjm = [{} for _ in range(n)]
    for i in range(n):
        vdata = list(map(int, input().split()))
        for j in range(vdata[1]):
            v, c = vdata[j * 2 + 2], vdata[j * 2 + 3]
            adjm[i][v] = c
    ans = dj(adjm, 0)
    for i, d in enumerate(ans):
        print(i, d)


if __name__ == ""__main__"":
    main()

"
3029350,ALDS1_12_B,"# -*- coding: utf-8 -*-
""""""
Created on Sat Jul 14 19:11:44 2018

@author: maezawa
""""""
infinity = 2*10**9

n = int(input())
adj = [[] for _ in range(n)]

for j in range(n):
    ain = list(map(int, input().split()))
    u = ain[0]
    k = ain[1]
    for i in range(2,2+2*k,2):
        adj[u].append([ain[i],ain[i+1]])
    #print(*adj[u])

color = [0]*n
d = [infinity for _ in range(n)]
p = [0]*n
p[0] = -1
d[0] = 0

def dyk(s):
    cnt = 1
    cur = s
    candidates = set() # remaining nodes
    while True:
        for i, w in adj[cur]:
            if color[i] == 2:
                continue
            if d[i] > d[cur] + w:
                d[i] = d[cur] + w
                color[i] = 1
            candidates.add(i)
        min_d = infinity
        for j in candidates:
            if min_d > d[j]:
                min_node = j
                min_d = d[j]
        candidates.remove(min_node)
        p[min_node] = cur
        color[cur] = 2
        cur = min_node
        cnt += 1
        #print(cur, d)
        #print(candidates)
        if cnt == n:
            break
    return

dyk(0)
for i in range(n):
    print(i, d[i])

                    
                    
"
3029414,ALDS1_12_B,"# -*- coding: utf-8 -*-
from heapq import heappop, heappush


def dijkstra(edges, start, *, adj_matrix=False, default_value=float('inf')):
    '''
    Returns best costs to each node from 'start' node in the given graph.
    (Single Source Shortest Path - SSSP)

    If edges only include costs and destination nodes on possible edges,
    adj_matrix should be False(default), and it is generally when this functions works much faster

    Note that costs in edges should follow the rules below
    1. The cost from a node itself should be 0,
    2. If there is no edge between nodes, the cost between them should be default_value
    3. The costs can't be negative

    # sample input when given as adjacency matrix (adj_matrix=True)
    edges = [[0, 2, 5, 4, inf, inf],           # node 0
             [2, 0, inf, 3, 6, inf],           # node 1
             [5, inf, 0, 2, inf, 6],           # node 2
             [4, 3, 2, 0, 2, inf],             # node 3
             [inf, 6, inf, 2, 0, 4],           # node 4
             [inf, inf, 6, inf, 4, 0]]         # node 5

    # sample input when given not as adjacency matrix (adj_matrix=False)
    edges = [[(1, 2), (2, 5), (3, 4)],         # node 0
             [(0, 2), (3, 3), (4, 6)],         # node 1
             [(0, 5), (3, 2), (5, 6)],         # node 2
             [(0, 4), (1, 3), (2, 2), (4, 2)], # node 3
             [(1, 6), (3, 2), (5, 4)],         # node 4
             [(2, 6), (4, 4)]]                 # node 5
    '''

    n = len(edges)

    inf = float('inf')
    costs = [inf] * n
    costs[start] = 0
    pq, rem = [(0, start)], n - 1

    while pq and rem:
        tmp_cost, tmp_node = heappop(pq)
        if costs[tmp_node] < tmp_cost:
            continue
        rem -= 1

        nxt_edges = ((node, cost) for node, cost in enumerate(edges[tmp_node]) if cost != default_value) if adj_matrix else\
                    edges[tmp_node]

        for nxt_node, nxt_cost in nxt_edges:
            new_cost = tmp_cost + nxt_cost
            if costs[nxt_node] > new_cost:
                costs[nxt_node] = new_cost
                heappush(pq, (new_cost, nxt_node))

    return costs


def dijkstra_route(edges,
                   start,
                   goal,
                   *,
                   adj_matrix=False,
                   default_value=float('inf'),
                   verbose=False):
    '''
    Trys to find the best route to the 'goal' from the 'start'
    '''

    n = len(edges)

    inf = float('inf')
    costs = [inf] * n
    costs[start] = 0
    pq, rem = [(0, start)], n - 1
    prevs = [-1 for _ in [None] * n]

    while pq and rem:
        tmp_cost, tmp_node = heappop(pq)
        if costs[tmp_node] < tmp_cost:
            continue
        rem -= 1

        nxt_edges = ((node, cost) for node, cost in enumerate(edges[tmp_node]) if cost != default_value) if adj_matrix else\
                    edges[tmp_node]

        for nxt_node, nxt_cost in nxt_edges:
            new_cost = tmp_cost + nxt_cost
            if costs[nxt_node] > new_cost:
                costs[nxt_node] = new_cost
                heappush(pq, (new_cost, nxt_node))
                prevs[nxt_node] = tmp_node

    min_route = []
    prev = goal
    cnt = 0
    while prev != start:
        min_route.append(prev)
        prev = prevs[prev]

        cnt += 1
        if prev == -1 or cnt > n:
            raise NoRouteError(
                'There is no possible route in this graph \nedges: {} \nstart: {} \ngoal: {}'.
                format(edges, start, goal))

    else:
        min_route.append(prev)
    min_route = min_route[::-1]
    min_cost = costs[goal]

    if verbose:
        print('---route---')
        for node in min_route[:-1]:
            print('{} -> '.format(node), end='')
        else:
            print(min_route[-1])

        print('---distance---')
        print(min_cost)

    return costs, min_route


class NoRouteError(Exception):
    pass


if __name__ == '__main__':
    '''
    an example of using this function
    AIZU ONLINE JUDGE - ALDS_1_12_B
    '''

    n = int(input())
    edges = [[] for i in range(n)]
    for i in range(n):
        i, k, *kedges = map(int, input().split())
        for edge in zip(kedges[::2], kedges[1::2]):
            edges[i].append(edge)

    for i, cost in enumerate(dijkstra(edges, 0)):
        print(i, cost)

"
3035501,ALDS1_12_B,"import sys

def dijkstra(v_count: int, edges: list, start: int,
             *, adj_matrix: bool = False, unreachable=float(""inf"")) -> list:
    """""" ダイクストラ法
    :param v_count: 頂点数
    :param edges: 辺のリスト(隣接リストor隣接行列)
    :param start: スタートする頂点
    :param adj_matrix: edgesに渡したリストが隣接行列ならTrue
    :param unreachable: 到達不能を表すコスト値
                        隣接行列の辺の有無の判定および返すリストの初期値に使用
    """"""
    from heapq import heappush, heappop

    vertices = [unreachable] * v_count
    vertices[start] = 0
    q, rem = [(0, start)], v_count - 1

    while q and rem:
        cost, v = heappop(q)
        if vertices[v] < cost:
            continue
        rem -= 1

        dests = (filter(lambda x: x[1] != unreachable, enumerate(edges[v]))
                 if adj_matrix else edges[v])

        for dest, _cost in dests:
            newcost = cost + _cost
            if vertices[dest] > newcost:
                vertices[dest] = newcost
                heappush(q, (newcost, dest))

    return vertices

n = int(input())
edges = [[] for _ in [0]*n]
for a in (tuple(map(int, l.split())) for l in sys.stdin):
    edges[a[0]] = tuple(zip(a[2::2], a[3::2]))
vertices = dijkstra(n, edges, 0)
for i, n in enumerate(vertices):
    print(i, n)
"
3068266,ALDS1_12_B,"def dijkstra(s):
    color = [""white"" for i in range(n)]

    d = [inf for i in range(n)]

    p = [-1 for i in range(n)]

    d[s] = 0

    while True:
        mincost = inf

        for i in range(n):
            if color[i] != ""black"" and d[i] < mincost:
                mincost = d[i]
                u = i

        if mincost == inf:
            break

        color[u] = ""black""

        for v in range(n):
            if color[v] != ""black"" and ci[u][v] != inf:
                if d[u] + ci[u][v] < d[v]:
                    d[v] = d[u] + ci[u][v]
                    p[v] = u
                    color[v] = ""gray""
    return d


inf = 10 ** 9
n = int(input())
ci = [[inf for i in range(n)] for j in range(n)]

for i in range(n):
    data = list(map(int, input().split()))
    u = data[0]
    k = data[1]

    for j in range(0, 2*k, 2):
        v, w = data[j+2], data[j+3]
        ci[u][v] = w

dList = dijkstra(0)

for i, d in enumerate(dList):
    print(i, d)

"
3068270,ALDS1_12_B,"n=int(input())
d=[0]+[1e6]*n
c=[1]*n
M=[[-1]*n for _ in[0]*n]

for _ in[0]*n:
 data=list(map(int,input().split()))
 for i in range(data[1]):k=2*-~i;M[data[0]][data[k]]=data[k+1]

while 1:
 m,u=1e6,-1
 
 for i in range(n):
  if m>d[i]and c[i]:
      m,u=d[i],i
 if u<0:
     break
 c[u]=0
 
 for v in range(n):
  if c[v]and 1+M[u][v]and d[v]>d[u]+M[u][v]:
   d[v]=d[u]+M[u][v]
   
for i in range(n):
    print(i,d[i])
"
3090024,ALDS1_12_B,"INFTY = 1 << 21
WHITE = 0
GRAY = 1
BLACK = 2

def dijkstra(n, m):
    d = [INFTY] * n
    color = [WHITE] * n

    d[0] = 0
    color[0] == GRAY

    while True:
        minv = INFTY
        u = -1
        for i in range(n):
            if minv > d[i] and color[i] != BLACK:
                u = i
                minv = d[i]
        if u == -1:
            break
        color[u] = BLACK
        for v in range(n):
            if color[v] != BLACK and m[u][v] != INFTY:
                if d[v] > d[u] + m[u][v]:
                    d[v] = d[u] + m[u][v]
                    color[v] = GRAY

    for i in range(n):
        out = d[i]
        if out == INFTY:
            out = -1
        print('{0} {1}'.format(i, out))


n = int(input())
m = [[INFTY] * n for i in range(n)]
for i in range(n):
    line = [int(v) for v in input().split()]
    u = line[0]
    k = line[1]
    for j in range(k):
        v = line[2*j + 2]
        c = line[2*j + 3]
        m[u][v] = c

dijkstra(n, m)
"
3118138,ALDS1_12_B,"#coding: utf-8

inf = 1000000000


def dijkstra(s):
    d = [inf for i in range(n)]
    color = [""white"" for i in range(n)]
    p = [-1 for i in range(n)]
    d[s] = 0

    while True:
        mincost = inf
        for i in range(n):
            if color[i] != ""black"" and d[i] < mincost:
                mincost = d[i]
                u = i
        if mincost == inf:
            break

        color[u] = ""black""

        for v in range(n):
            if color[v] != ""black"" and mtrx[u][v] != False:
                if d[u] + mtrx[u][v] < d[v]:
                    d[v] = d[u] + mtrx[u][v]
                    p[v] = u
                    color[v] = ""gray""
    return d

n = int(input())
mtrx = [[False for j in range(n)] for i in range(n)]
for i in range(n):
    data = list(map(int,input().split()))
    k = data[1]
    for num in range(k):
        mtrx[i][data[2+2*num]] = data[2+2*num+1]

d = dijkstra(0)

for i, num in enumerate(d):
    print(i,num)

"
3206925,ALDS1_12_B,"
n=int(input())
graph=[[0]*n for i in range(n)]


#graph[i][j]は、頂点iから頂点jへの枝の重みを表す(0は枝なし)
for loop in range(n):
    tmp_ope=list(map(int,input().split()))
    for j in range(1,tmp_ope[1]+1):
        graph[tmp_ope[0]][tmp_ope[2*j]]=tmp_ope[2*j+1]

#S[i]＝１の時、頂点iは走査済み
S=[0]*n
#d[i]はSに含まれる点のみを使って、頂点iにたどり着くときの最短パス
d=[999999]*n
d[0]=0

for loop in range(n):
    tmp_vertex=-1

    #tmp_vertexは走査済みでない点の中で、d[i]が最小となるインデックス
    for j in range(n):
        if(S[j]==0):
            if(tmp_vertex!=-1):
                if(d[j] < d[tmp_vertex]):
                    tmp_vertex=j
            else:
                tmp_vertex=j
    
    
    S[tmp_vertex]=1

    #dを更新
    for j in range(n):
        if(graph[tmp_vertex][j]!=0 and S[j]==0):
            d[j]=min([ d[j], d[tmp_vertex] + graph[tmp_vertex][j] ])

for i in range(n):
    print(f""{i} {d[i]}"")
"
3293967,ALDS1_12_B,"import sys
import math

n = int(sys.stdin.readline())

Q = set()
out_edge = [set() for _ in range(n)]
weight = [[0] * n for _ in range(n)]

for _ in range(n):
    ll = list(map(int, sys.stdin.readline().split()))
    sn = ll[0]
    Q.add(sn)
    for j in range(ll[1]):
        en = ll[2+2*j]
        cn = ll[2+2*j+1]
        out_edge[sn].add(en)
        weight[sn][en] = cn

d = [0] + [math.inf for _ in range(n-1)]
prev = [None] * n

while len(Q)>0:
    minval = math.inf
    u = -1
    for q in Q:
        if minval > d[q]:
            minval = d[q]
            u = q
    if minval==math.inf:  break
    Q.remove(u)

    for v in out_edge[u]:
        if weight[u][v]>0:
            if d[v] > d[u] + weight[u][v]:
                d[v] = d[u] + weight[u][v]
                prev[v] = u

for i in range(n):                
    print(i, d[i])
"
3327470,ALDS1_12_B,"import sys
input = sys.stdin.readline


# import heapq
import heapq

# graph: 隣接リスト (頂点、距離）の順に格納
# start: 始点 (0-index)
# n: 頂点数
# memo[t]: startからtまでの最短距離
# return memo

def dijkstra(graph, start, n):
    INF = float('inf')
    memo = [INF] * n
    memo[start] = 0
    q = [(0, start)]

    while q:
        dist, ver = heapq.heappop(q)
        if memo[ver] < dist:
            continue
        for next_ver, next_dist in graph[ver]:
            if memo[next_ver] > dist + next_dist:
                memo[next_ver] = dist + next_dist
                heapq.heappush(q, (dist + next_dist, next_ver))

    return memo

n = int(input())
graph = [[] for i in range(n)]
for i in range(n):
    info = list(map(int, input().split()))
    for j in range(info[1]):
        graph[info[0]].append((info[j*2 + 2], info[j*2 + 3]))

memo = dijkstra(graph, 0, n)
for i, d in enumerate(memo):
    print(i, d)

"
3362158,ALDS1_12_B,"n = int(input())
data = [list(map(int, input().split())) for _ in range(n)]
INF = 10000000000000000000
M = [[-1]*n for _ in range(n)]
for i in data:
    for j in range(i[1]):
        M[i[0]][i[2+j*2]] = i[3+j*2]
color = ['White']*n
d = [INF]*n
p = [None]*n

d[0] = 0
p[0] = -1

while True:
    minct = INF
    for i in range(n):
        if color[i] != 'Black' and d[i] < minct:
            minct = d[i]
            u = i
    if minct == INF:
        break
    color[u] = 'Black'
    for j in range(n):
        if color[j] != 'Black' and M[u][j] != -1:
            if d[u] + M[u][j] < d[j]:
                d[j] = d[u] + M[u][j]
                p[j] = u
                color[j] = 'Gray'
for i in range(n):
    print('{} {}'.format(i, d[i]))
"
3528383,ALDS1_12_B,"# -*- coding: utf-8 -*-

import sys
from heapq import heappush, heappop

sys.setrecursionlimit(10 ** 9)
def input(): return sys.stdin.readline().strip()
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(): return list(map(int, input().split()))
INF=float('inf')

# ダイクストラ(頂点数, 隣接リスト(0-indexed), 始点)
def dijkstra(N: int, nodes: list, src: int) -> list:
    # 頂点[ある始点からの最短距離]
    # (経路自体を知りたい時はここに前の頂点も持たせる)
    res = [float('inf')] * N
    # スタート位置
    que = [(0, src)]
    res[src] = 0
    # キューが空になるまで
    while len(que) != 0:
        # srcからの距離, 現在のノード
        dist, cur = heappop(que)
        # 出発ノードcurの到着ノードでループ
        for nxt, cost in nodes[cur]:
            # 今回の経路のが短い時
            if res[cur] + cost < res[nxt]:
                res[nxt] = res[cur] + cost
                # 現在の移動距離をキューの優先度として、早い方から先に処理するようにする
                heappush(que, (res[nxt], nxt))
    # ノードsrcからの最短距離リストを返却
    return res

N=INT()
nodes=[[] for i in range(N)]
for i in range(N):
    l=LIST()
    u=l[0]
    k=l[1]
    l=l[2:]
    for j in range(0, k*2, 2):
        nodes[u].append((l[j], l[j+1]))

ans=dijkstra(N, nodes, 0)
for i in range(N):
    print(i, ans[i])

"
3540199,ALDS1_12_B,"n = int(input())
adj = [[float('inf')]*n for _ in range(n)]
for i in range(n):
    a = list(map(int, input().split()))
    for j,k in zip(a[2::2], a[3::2]):
        adj[i][j] = k
color = [0]*n
d = [float('inf')]*n
d[0] = 0

while 1:
    mincost = float('inf')
    for i in range(n):
        if color[i] != 1 and d[i] < mincost:
            mincost = d[i]
            u = i
    if mincost == float('inf'):
        break
        
    color[u] = 1
    
    for i in range(n):
        if color[i] != 1 and adj[u][i] != float('inf'):
            if d[u]+adj[u][i] < d[i]:
                d[i] = d[u] + adj[u][i]
                
for i in range(n):
    print(i, d[i])
                
"
3580369,ALDS1_12_B,"def dijkstra(n):
    distance_list[0] = 0
    while True:
        min_distance = 10**9
        u = -1
        for i in range(n):
            distance = distance_list[i]
            if flag_list[i] < 2 and distance < min_distance:
                min_distance = distance
                u = i
        if u == -1:
            break
        flag_list[u] = 2
        for v in range(n):
            edge = m_list[u][v]
            if flag_list[v] < 2 and -1 < edge:
                if distance_list[u] + edge < distance_list[v]:
                    distance_list[v] = distance_list[u] + edge
                    p[v] = u
                    flag_list[v] = 1


if __name__ == ""__main__"":
    n = int(input())
    m_list = [[-1]*n  for _ in range(n)]
    for i in range(n):
        in_list = list(map(int, input().split()))
        adj_num = in_list[1]
        tmp = []
        if adj_num > 0:
            for j in range(adj_num):
                m_list[i][in_list[j*2+2]] = in_list[j*2+3]

    flag_list = [0]*n # 0: 未到達, 1: 処理中, 2: 完了
    distance_list = [10**9]*n
    p = [-1]*n
    dijkstra(n)
    for i, d in enumerate(distance_list):
        print(i, d)

"
3631332,ALDS1_12_B,"n = int(input())
G = [[] for i in range(n)]
for ni in range(n):
    u, k, *tmp = [int(i) for i in input().split()]
    for ki in range(k):
        G[ni].append(tmp[:2])
        del tmp[:2]

INF = 100*100000
D = [INF for i in range(n)]
D[0] = 0
C = [0 for i in range(n)]
while 0 in C:
    U = [INF if C[i] == 1 else D[i] for i in range(n)]
    u = U.index(min(U))

    for i in range(len(G[u])):
        v = G[u][i][0]
        if D[u] + G[u][i][1] < D[v]:
            D[v] = D[u] + G[u][i][1]
    C[u] = 1

for ni in range(n):
    print(ni, D[ni])
"
3665196,ALDS1_12_B,"N = int(input())
color = [""w"" for _ in range(N)]
d = [float(""inf"") for _ in range(N)]
p = [-1 for _ in range(N)]

# Make M
M = [[-1]*N for _ in range(N)]
for i in range(N):
    input_list = list(map(int, input().split()))
    ii = input_list.pop(0)
    k = input_list.pop(0)
    jj = 0
    while jj <= 2*k - 2:
        M[ii][input_list[jj]] = input_list[jj+1]
        jj += 2

d[0] = 0
while True:
    mincost = float(""inf"")
    for i in range(N):
        if color[i] != ""b"" and d[i] < mincost:
            mincost = d[i]
            u = i
    
    if mincost == float(""inf""):
        break
    color[u] = ""b""

    for v in range(N):
        if color[v] != ""b"" and M[u][v] != -1:
            if d[v] > M[u][v] + d[u]:
                d[v] = M[u][v] + d[u]
                p[v] = u
                
for i in range(N):
    print(""{} {}"".format(i, d[i]))
"
3676339,ALDS1_12_B,"WHITE = 0
GRAY = 1
BLACK = 2
INFTY = 10**13
def dijkstra(s):
    color = [WHITE for i in range(N)]
    d = [INFTY for i in range(N)]
    p = [-1 for i in range(N)]
    d[s] = 0

    while True:
        mincost = INFTY
        for i in range(N):
            if color[i] != BLACK and d[i] < mincost:
                mincost = d[i]
                u = i
        if mincost == INFTY:
            break
        
        color[u] = BLACK

        for v in range(N):
            if color[v] != BLACK and M[u][v] != -1:
                if d[u] + M[u][v] < d[v]:
                    d[v] = d[u] + M[u][v]
                    p[v] = u
                    color[v] = GRAY
    return d

N = int(input())
M = [[-1 for j in range(N)] for i in range(N)]
for i in range(N):
    ukvc = list(map(int, input().split()))
    u, k, vc = ukvc[0], ukvc[1], ukvc[2:]
    for v, c in zip(vc[0::2], vc[1::2]):
        M[u][v] = c

d = dijkstra(0)

for i in range(N):
    print(i, d[i])

"
3697637,ALDS1_12_B,"INFINITY = 10 ** 10
WHITE = 0
GRAY = 1
BLACK = 2


n = int(input())
M = [[INFINITY] * n for _ in range(n)]

for _ in range(n):
    u, k, *list_num = map(int, input().split())

    for i in range(0, k * 2, 2):
        M[u][list_num[i]] = list_num[i + 1]

d = [INFINITY] * n

def dijkstra():
    color = [WHITE] * n
    p = [None] * n

    d[0] = 0
    p[0] = -1

    while True:
        cost_min = INFINITY
        for i in range(n):
            if color[i] != BLACK and d[i] < cost_min:
                cost_min = d[i]
                top_now = i

        if cost_min == INFINITY:
            break
    
        color[top_now] = BLACK

        for v in range(n):
            if color[v] == BLACK or M[top_now][v] == INFINITY:
                continue

            cost_now = d[top_now] + M[top_now][v]
            if cost_now < d[v]:
                d[v] = cost_now
                p[v] = top_now
                color[v] = GRAY


dijkstra()

for i, cost in enumerate(d):
    print(i, cost)

"
3825542,ALDS1_12_B,"def dijkstra(matrix, s):
    INF = 200000
    n = len(matrix)
    state, d, p = [False] * n, [INF] * n, [-1] * n
    d[s] = 0
    while True:
        mincost = INF
        for i in range(n):
            if not state[i] and d[i] < mincost:
                mincost = d[i]
                u = i
        if mincost == INF:
            break
        state[u] = True
        for v in range(n):
            if not state[v] and matrix[u][v] != -1:
                if d[u] + matrix[u][v] < d[v]:
                    d[v] = d[u] + matrix[u][v]
                    p[v] = u
    return d


def main():
    n = int(input())
    m = [[-1] * n for _ in range(n)]
    for _ in range(n):
        u, k, *vc = map(int, input().split())
        for v, c in zip(vc[::2], vc[1::2]):
            m[u][v] = c
    dist = dijkstra(m, 0)
    for i, d in enumerate(dist):
        print(i, d)


if __name__ == '__main__':
    main()

"
3899135,ALDS1_12_B,"import sys
input = sys.stdin.readline

INF = 100100

def dijkstra(M: list, u: int = 0) -> list:
    global N
    d = [INF] * N
    d[u] = 0
    visited = [False] * N
    while True:
        mincost = INF
        for i in range(N):
            if not visited[i] and d[i] < mincost:
                mincost = d[i]
                u = i
        if mincost == INF:
            return d
        visited[u] = True
        for v in range(N):
            if not visited[v]:
                if d[u] + M[u][v] < d[v] :
                    d[v] = d[u] + M[u][v]


def main():
    global N
    N = int(input())
    M = [[INF]*N for _ in range(N)]
    for _ in range(N):
        A = list(map(int, input().split()))
        u = A[0]
        k = A[1]
        for i in range(k):
            v = A[2+2*i]
            c = A[3+2*i]
            M[u][v] = c
    d = dijkstra(M)
    for i, di in enumerate(d):
        print(i, di)

if __name__ == '__main__': main()
"
3901413,ALDS1_12_B,"N = int(input())
INF = 10**9

M = [[-1 for i in range(N)] for j in range(N)]
for i in range(N):
  u, k, *vs = list(map(int, input().split()))
  for j in range(k):
    v, c = vs[2*j], vs[2*j+1]
    M[u][v] = c

d = [INF for i in range(N)]
d[0] = 0
p = [-1 for i in range(N)]
mst = [False for i in range(N)]

while True:
  min_w = INF
  for i in range(N):
    if not mst[i] and d[i] < min_w:
      min_w = d[i]
      u = i
  if min_w == INF:
    break
  mst[u] = True
  for v in range(N):
    if M[u][v] != -1 and M[u][v] + d[u] < d[v]:
      d[v] = M[u][v] + d[u]
      p[v] = u

for i in range(N):
  print(i, d[i])

"
3931664,ALDS1_12_B,"INF = 100000 * 100

def dijkstra(s: int) -> None:
	d[s] = 0	
	while True:
		mincost = INF
		for i in range(n):
			if color[i] != ""BLACK"" and d[i] < mincost:
				mincost = d[i]
				u = i
		if mincost == INF:
			break
		color[u] = ""BLACK""
		for v in range(n):
			if color[v] != ""BLACK"" and M[u][v] != None:
				if d[u] + M[u][v] < d[v]:
					d[v] = d[u] + M[u][v]
					pi[v] = u
					color[v] = ""GRAY""


if __name__ == ""__main__"":
	n = int(input())
	G = []
	M = [[None for _ in range(n)] for _ in range(n)]
	color = [""WHITE"" for _ in range(n)]
	d = [INF for _ in range(n)]
	pi = [None for _ in range(n)]

	for _ in range(n):
		l = list(map(int, input().split()))
		u = l[0]
		k = l[1]
		for i in range(k):
			v = l[2 * (i + 1)]
			c = l[2 * (i + 1) + 1]
			M[u][v] = c
	dijkstra(0)
	for v in range(n):
		print(f""{v} {d[v]}"")
"
3939351,ALDS1_12_B,"N = int(input())

E = [None] * N
for _ in range(N):
    u, k, *vs = map(int, input().split())
    E[u] = []
    for i in range(k):
        v, c = vs[i*2], vs[i*2+1]
        E[u].append((v, c))

vis = [False] * N
inf = 1e9
d = [inf] * N
d[0] = 0
for _ in range(N):
    nv, ni = inf, -1
    for i in range(N):
        if not vis[i] and d[i] < nv:
            nv, ni = d[i], i
    vis[ni] = True
    for v, c in E[ni]:
        d[v] = min(d[v], d[ni] + c)

for v in range(N):
    print(v, d[v])
"
3964155,ALDS1_12_B,"#!/usr/bin/env python3
import sys
import heapq
input = lambda: sys.stdin.readline()[:-1]
sys.setrecursionlimit(10**8)
inf = float('inf')
mod = 10**9+7

n=int(input())
G=[[] for i in range(n)]
for _ in range(n):
    inp = list(map(int,input().split()))
    u,k=inp[:2]
    for i in range(k):
        G[u].append((inp[2+2*i],inp[3+2*i]))

def disktra(g,s):
    n=len(g)
    dist = [inf]*n
    dist[s] = 0
    hq=[]
    heapq.heappush(hq,(dist[s],s))
    while hq:
        cost,u =heapq.heappop(hq)
        if dist[u] < cost:
            continue
        for v,c in g[u]:
            if dist[v] <= dist[u] +c:
                continue
            dist[v] = dist[u] + c
            heapq.heappush(hq,(dist[v],v))
    return dist

d=disktra(G,0)
for i in range(n):
    print(i,d[i])
"
3970155,ALDS1_12_B,"def main():
    N = int(input())
    G = [[] for _ in range(N)]
    for _ in range(N):
        u, k, *vc = (int(i) for i in input().split())
        for i in range(0, len(vc), 2):
            G[u].append((vc[i], vc[i+1]))
    d = [[(1 << 63)-1, i] for i in range(N)]
    from heapq import heapify, heappop, heappush

    def dijkstra(s):
        d[s][0] = 0
        que = [(d[s][0], s)]
        heapify(que)
        finished = set()
        while len(finished) < N:
            u = heappop(que)
            while u[1] in finished:
                u = heappop(que)
            for v, c in G[u[1]]:
                if v in finished:
                    continue
                if d[v][0] > u[0] + c:
                    d[v][0] = u[0] + c
                    heappush(que, (d[v][0], v))
            finished.add(u[1])
    dijkstra(0)
    for i, val in enumerate(d):
        print(i, val[0])


if __name__ == '__main__':
    main()

"
4040051,ALDS1_12_B,"# coding: utf-8
# Your code here!

WHITE = 0
GRAY = 1
BLACK = 2

INF = 2000000000

def dijkstra(s):
    while True:
        u = 0
        mincost = INF
        for i in range(n):
            if color[i] != BLACK and d[i] < mincost:
                mincost = d[i]
                u = i
                
        if mincost == INF:
            break
    
        color[u] = BLACK
        
        for v in range(n):
            if color[v] != BLACK and m[i][v] != -1:
                if d[u] + m[u][v] < d[v]:
                    d[v] = d[u] + m[u][v]
                    p[v] = u
                    color[v] = GRAY

n = int(input())

m = [[INF for i in range(n)] for j in range(n)]
for i in range(n):
    nums=list(map(int,input().split()))
    for j in range(nums[1]):
        m[i][nums[2*j+2]] = nums[2*j+3]

color = [WHITE] * n
d = [INF] * n 
d[0] = 0
p = [-1] * n

dijkstra(0)
for v in range(n):
    print(v, d[v])










"
4156406,ALDS1_12_B,"def dijkstra(n,s):
    inf=float(""inf"")
    color=[""white"" for i in range(n)]
    D=[inf for i in range(n)]
    P=[0 for i in range(n)]
    M=[[inf for i in range(n)] for j in range(n)]

    for i in range(n):
        weight=list(map(int,input().split()))[2:]
        for j in range(len(weight)//2):
            M[i][weight[2*j]]=weight[2*j+1]

    D[s]=0
    P[s]=-1

    while 1:
        cost,u=inf,0
        for i in range(n):
            if color[i]!=""black"" and D[i]<cost:
                cost=D[i]
                u=i

        if cost==inf:break

        color[u]=""black""

        for i in range(n):
            if color[i]!=""black"" and M[u][i]!=inf:
                if D[u]+M[u][i]<D[i]:
                    D[i]=D[u]+M[u][i]
                    color[i]=""gray""
                    P[i]=u

    return D


n=int(input())
distant=dijkstra(n,0)
for i in range(n):
    print(i,distant[i])
"
4169859,ALDS1_12_B,"def dijkstra():
    d[0] = 0
    color[0] = GRAY

    while True:
        minv = INF
        u = -1
        for i in range(N):
            if minv > d[i] and color[i] != BLACK:
                u = i
                minv = d[i]
        if u == -1:
            break
        color[u] = BLACK
        for i in range(N):
            if color[i] != BLACK and M[u][i] != INF:
                if d[i] > d[u] + M[u][i]:
                    d[i] = d[u] + M[u][i]
                    color[i] = GRAY

INF = 10 ** 18
WHITH = 0
GRAY = 1
BLACK = 2
N = int(input())
M = [[INF for _ in range(N)] for _ in range(N)]
d = [INF] * N
color = [WHITH] * N

for i in range(N):
    lst = list(map(int, input().split()))
    for j in range(lst[1]):
        M[lst[0]][lst[2 + (j * 2)]] = lst[3 + (j * 2)]

dijkstra()
for i in range(N):
    v = d[i]
    if v == INF:
        v = -1
    print(i, v)
"
4200718,ALDS1_12_B,"n = int(input())
INF = float(""inf"")
edges = [[] for _ in range(n)]
visited = [False]*n
# edges = [[INF for _ in range(n)] for _ in range(n)]
edges = [[] for _ in range(n) for _ in range(n)]
d = [INF]*n
d[0] = 0

for _ in range(n):
    ls = list(map(int, input().split()))
    u = ls[0]
    degrees = ls[1]
    data = ls[2:]
  
    for i in range(degrees):
        v = data[i*2]
        cost = data[i*2+1]
        edges[u].append((v, cost))
        # edges[u][v] = cost

#通常版
# for _ in range(n):
#     dmin = float(""inf"")
#     for i in range(n):
#         if not visited[i] and d[i] < dmin:
#             dmin = d[i]
#             u = i
#     visited[u] = True
#     for v, c in enumerate(edges[u]):
#         d[v] = min(d[v], d[u] + c)

# for i in range(n):
#     print(i, d[i])
    
#heap版
import heapq

heap = [(0, 0)]
d[0] = 0


while heap:
    du, u = heapq.heappop(heap)
    for v, cost in edges[u]:
        if du + cost < d[v]:
            d[v] = du +  cost
            heapq.heappush(heap, (d[v], v))

for i in range(n):
    print(i, d[i])
"
4254114,ALDS1_12_B,"def dijkstra(n, s):
    inf = float('inf')
    color = ['white' for _ in range(n)]
    D = [inf for _ in range(n)]             
    P = [0 for i in range(n)]        
    M = [[inf for _ in range(n)] for _ in range(n)]

    for i in range(n):  
        weight = list(map(int, input().split()))[2:]    
        for j in range(len(weight)//2):
            M[i][weight[2*j]] = weight[2*j+1]   

    D[s] = 0
    P[s] = -1

    while True:
        cost, u = inf, 0
        for i in range(n):
            if color[i] != 'black' and D[i] < cost:  
                cost = D[i]
                u = i
        
        if cost == inf:                         
            break

        color[u] = 'black'                          

        for i in range(n):
            if color[i] != 'black' and M[u][i] != inf:             
                if D[u] + M[u][i] < D[i]:                           
                    D[i] = D[u] + M[u][i]                              
                    color[i] = 'gray'                            
                    P[i] = u                          

    return D

n = int(input())
distance = dijkstra(n, 0)
for i in range(n):
    print(i, distance[i])
"
8282265,ALDS1_12_C,"import heapq
n = int(input())
G = [[] for _ in range(n)]
d = [float('inf')]*n # the distance form 0 to v

def dijkstra(start):
    que = []
    d[0] = 0
    heapq.heappush(que, (0, start))
    while que:
        cur_dist_from_start, cur_node = heapq.heappop(que)
        if cur_dist_from_start > d[cur_node]:
            continue
        for next_node, edge_weight in G[cur_node]:
            dist_to_next_node = d[cur_node] + edge_weight
            if d[next_node] > dist_to_next_node:
                d[next_node] = dist_to_next_node
                heapq.heappush(que, (dist_to_next_node, next_node))
    return d

def main():
    for _ in range(n):
        table = list(map(int, input().split()))
        for i in range(table[1]):
            G[table[0]].append((table[2+2*i], table[3+2*i]))
    dijkstra(0)
    for i in range(n):
        print(i, d[i])

if __name__ == '__main__':
    main()
"
8602406,ALDS1_12_C,"# import heapq
# from enum import Enum
# from functools import total_ordering


# class Color(Enum):
#     WHITE = 0
#     GRAY = 1
#     BLACK = 2


# @total_ordering
# class Node:
#     def __init__(self, id: int, neighbors_list: list) -> None:
#         self.id = id
#         self.neighbors_list = neighbors_list
#         self.color = Color.WHITE
#         self.cost = 1e20

#     def __eq__(self, __value: object) -> bool:
#         if not isinstance(__value, Node):
#             return NotImplemented
#         return self.cost == __value.cost

#     def __lt__(self, __value: object) -> bool:
#         if not isinstance(__value, Node):
#             return NotImplemented
#         return self.cost < __value.cost


# def dijkstra():
#     global node_list
#     global n
#     INFTY = 1e20

#     distance_list = [INFTY for _ in range(n)]
#     distance_list[0] = 0

#     priority_queue = []
#     node_list[0].cost = 0
#     heapq.heappush(priority_queue, node_list[0])

#     while len(priority_queue) > 0:
#         u: Node = heapq.heappop(priority_queue)
#         u.color = Color.BLACK

#         if distance_list[u.id] < u.cost:
#             continue

#         for neighbor_id, weight in u.neighbors_list:
#             if node_list[neighbor_id].color != Color.BLACK:
#                 if distance_list[u.id] + weight < distance_list[neighbor_id]:
#                     distance_list[neighbor_id] = distance_list[u.id] + weight
#                     node_list[neighbor_id].color = Color.GRAY
#                     node_list[neighbor_id].cost = distance_list[neighbor_id]
#                     heapq.heappush(priority_queue, node_list[neighbor_id])

#     return distance_list


# n = int(input())
# node_list: list[Node] = []
# for i in range(n):
#     n_list = list(map(int, input().split()))
#     id = n_list[0]
#     n_neighbors = n_list[1]
#     neighbors_list = []
#     for j in range(n_neighbors):
#         neighbor_id = n_list[2 + j * 2]
#         weight = n_list[3 + j * 2]
#         neighbors_list.append((neighbor_id, weight))
#     node_list.append(Node(id, neighbors_list))

# distanse_list = dijkstra()

# for i in range(n):
#     print(f""{node_list[i].id} {distanse_list[i]}"")

from collections import defaultdict
from heapq import heappop, heappush

n = int(input())
edge = defaultdict(list)
for _ in range(n):
    F = list(map(int, input().split()))
    u = F[0]
    k = F[1]
    for i in range(k):
        v, c = F[2 + 2 * i], F[3 + 2 * i]
        edge[u].append((v, c))

INF = 10**15
ans = [INF for _ in range(n)]
ans[0] = 0
hq = [(0, 0)]
while hq:
    curr_cost, curr_p = heappop(hq)
    if curr_cost > ans[curr_p]:
        continue
    for next_p, dif_cost in edge[curr_p]:
        if curr_cost + dif_cost > ans[next_p]:
            continue
        ans[next_p] = curr_cost + dif_cost
        heappush(hq, (curr_cost + dif_cost, next_p))

for i in range(n):
    print(i, ans[i])

"
8967489,ALDS1_12_C,"from heapq import heappop, heappush


def solve(edges):
    n = len(edges)

    dists = [100000000] * n
    dists[0] = 0
    breads = [(0, 0)]

    while breads:
        w, u = heappop(breads)
        for c, v in edges[u]:
            if w + c < dists[v]:
                dists[v] = w + c
                heappush(breads, (w + c, v))

    for i in range(0, n):
        print(i, dists[i])


if __name__ == ""__main__"":
    N = int(input())
    EDGES = [None] * N

    for _ in range(N):
        u, k, *v = map(int, input().split())
        EDGES[u] = [(v[2 * i + 1], v[2 * i]) for i in range(k)]

    solve(EDGES)

"
2720878,ALDS1_12_C,"import sys
readline = sys.stdin.readline
from heapq import heapify, heappush, heappop
INF = float(""inf"")
def MAIN():
    n = int(input())
    adj = [[]] * n
    for _ in range(0, n):
        U = list(map(int, input().split()))
        adj[U[0]] = zip(U[2::2], U[3::2])
    def dijkstra():
        d = [0] + [INF] * (n - 1)
        hq = [(0, 0)]
        while hq:
            u = heappop(hq)[1]
            for v, c in adj[u]:
                alt = d[u] + c
                if d[v] > alt:
                    d[v] = alt
                    heappush(hq, (alt, v))
        print(""\n"".join(f""{i} {c}"" for i, c in enumerate(d)))
    dijkstra()
MAIN()

"
2732169,ALDS1_12_C,"from heapq import*
def m():
 n=int(input())
 A=[]
 for _ in[0]*n:
  e=list(map(int,input().split()))
  A+=[zip(e[2::2],e[3::2])]
 d=[0]+[float('inf')]*n
 H=[(0,0)]
 while H:
  u=heappop(H)[1]
  for v,c in A[u]:
   t=d[u]+c
   if d[v]>t:
    d[v]=t
    heappush(H,(t,v))
 print('\n'.join(f'{i} {d[i]}'for i in range(n)))
m()
"
2745844,ALDS1_12_C,"# -*- coding: utf-8 -*-
from heapq import heappop, heappush
def inpl(): return list(map(int, input().split()))
INF = float(""inf"")
N = int(input())
G = []
for _ in range(N):
    I = inpl()
    G.append(zip(*[I[3::2], I[2::2]]))

def dijkstra(G):
    C = [INF]*(N)
    C[0] = 0
    visited = [False] * (N)
    Q = [[0, 0]]

    while Q:
        c, u = heappop(Q)
        if C[u] < c:
            continue
        visited[u] = True
        for d, v in G[u]:
            if visited[v]:
                continue
            e = c + d
            if e < C[v]:
                C[v] = e
                heappush(Q, [e, v])
    return C

for i, c in enumerate(dijkstra(G)):
    print(i, c)
"
2515936,ALDS1_12_C,"import heapq

INF = 1e9

n = int(input())
adj_list = [[]] * n

for u in range(n):
    U = list(map(int, input().split()[2:]))
    adj_list[u] = zip(U[0::2], U[1::2]) # adj_list[u] = (v, cost)


def dijkstra(x):
    d = [INF] * x
    d[0] = 0
    isVisited = [False] * x
    hq = [(0, 0)] # (distance, v)??????????????¬??????????????????(key, ????´?)???????????????push, pop?????????
    
    while hq:
        u = heapq.heappop(hq)[1]
        isVisited[u] = True
        
        for v, c in adj_list[u]:
            if not isVisited[v] and d[v] > d[u] + c:
                d[v] = d[u] + c
                heapq.heappush(hq, (d[u] + c, v))
                
    return d

for i, di in enumerate(dijkstra(n)):
    print(i,di)
"
1694249,ALDS1_12_C,"import heapq


def dijkstra(n):
    inf = 10 ** 6 + 1
    dist = [0] + [inf] * (n - 1)
    q = [(0, 0)]
    while q:
        u = heapq.heappop(q)[1]
        for (v, c) in edge[u]:
            alt = dist[u] + c
            if dist[v] > alt:
                dist[v] = alt
                heapq.heappush(q, (alt, v))
    return dist

n = int(input())
edge = [[]] * n
for _ in range(n):
    l = list(map(int, input().split()))
    edge[l[0]] = (e for e in zip(l[2::2], l[3::2]))
for i, c in enumerate(dijkstra(n)):
    print(i, c)
"
2185894,ALDS1_12_C,"V=int(input())
 
G=[[] for i in range(V)]
d=[1001001001 for i in range(V)]
used=[False for i in range(V)]
 
import heapq
 
def dijkstra(s):
    q=[]
    d[s]=0
    heapq.heappush(q,(0, s))
     
    while(len(q)):
         
        p=heapq.heappop(q)
        v=p[1]
        used[v]=True
        if d[v]<p[0]:
            continue
        for e in G[v]:
            if (not used[e[0]]) and d[e[0]]>d[v]+e[1]:
                d[e[0]]=d[v]+e[1]
                 
                heapq.heappush(q, (d[e[0]], e[0]))
 
import sys
for l in sys.stdin:
    l=list(map(int,l.split()))
    u=l[0]
    k=l[1]
    G[u]=zip(*[iter(l[2:])]*2)
     
dijkstra(0)
for i, c in enumerate(d):
    print(i, d[i])
"
3035509,ALDS1_12_C,"import sys

def dijkstra(v_count: int, edges: list, start: int,
             *, adj_matrix: bool = False, unreachable=float(""inf"")) -> list:
    """""" ダイクストラ法
    :param v_count: 頂点数
    :param edges: 辺のリスト(隣接リストor隣接行列)
    :param start: スタートする頂点
    :param adj_matrix: edgesに渡したリストが隣接行列ならTrue
    :param unreachable: 到達不能を表すコスト値
                        隣接行列の辺の有無の判定および返すリストの初期値に使用
    """"""
    from heapq import heappush, heappop

    vertices = [unreachable] * v_count
    vertices[start] = 0
    q, rem = [(0, start)], v_count - 1

    while q and rem:
        cost, v = heappop(q)
        if vertices[v] < cost:
            continue
        rem -= 1

        dests = (filter(lambda x: x[1] != unreachable, enumerate(edges[v]))
                 if adj_matrix else edges[v])

        for dest, _cost in dests:
            newcost = cost + _cost
            if vertices[dest] > newcost:
                vertices[dest] = newcost
                heappush(q, (newcost, dest))

    return vertices

n = int(input())
edges = [[] for _ in [0]*n]
for a in (tuple(map(int, l.split())) for l in sys.stdin):
    edges[a[0]] = tuple(zip(a[2::2], a[3::2]))
vertices = dijkstra(n, edges, 0)
for i, n in enumerate(vertices):
    print(i, n)
"
1947094,ALDS1_12_C,"import heapq
def Dsa(n):
    inf = 10 ** 6 + 1
    dt = [0] + [inf] * (n - 1)
    q = [(0, 0)]
    while q:
        u = heapq.heappop(q)[1]
        for (v, c) in ed[u]:
            alt = dt[u] + c
            if dt[v] > alt:
                dt[v] = alt
                heapq.heappush(q, (alt, v))
    return dt
 
n = int(input())
ed = [[]] * n
for _ in range(n):
    l = list(map(int, input().split()))
    ed[l[0]] = (e for e in zip(l[2::2], l[3::2]))
for i, c in enumerate(Dsa(n)):
    print(i, c)
"
2830645,ALDS1_12_C,"N = int(input())
G = [[] for i in range(N)]
for nod in range(N):
    U = list(map(int, input().split()))[2:]
    G[nod] = zip(U[0::2], U[1::2])



import heapq


def dijkstra(x):
    d = [float('inf')] * N
    d[x] = 0
    visited = {x}

    # d, u
    hq = [(0, x)]

    while hq:
        u = heapq.heappop(hq)[1]
        visited.add(u)

        for node, cost in G[u]:
            if (node not in visited) and d[node] > d[u] + cost:
                d[node] = d[u] + cost
                heapq.heappush(hq, (d[u]+cost, node))
    return d


distance = dijkstra(0)
#print(distance)
for i in range(N):
    print(i, distance[i])


"
8894522,ALDS1_12_C,"from heapq import heappush, heappop

class Node:
    def __init__(self, id, weight):
        self.id = id
        self.weight = weight
    # Nodeどうしの比較: less than
    def __lt__(self, node):
        return self.weight < node.weight

def main():
    n = int(input())
    # グラフ作成
    graph = [[] for _ in range(n)]
    for i in range(n):
        u,k,*adg = map(int, input().split())
        for i in range(0, len(adg), 2):
            graph[u].append(Node(adg[i], adg[i+1]))
    # 各ノードの始点からの最短経路の重みを求める
    shortest_paths = solve_sssp(n, graph)
    for i, sw in enumerate(shortest_paths):
        print(i, sw)

# 単一始点最短経路探索により、各ノードの始点からの最短経路を求める
def solve_sssp(n, graph):
    # 各ノードの始点からの最小重みを保持
    nw = [int(1e10) for _ in range(n)]
    # 始点の重みは0
    nw[0] = 0
    
    # ヒープキューを使うことで重みが小さい順にノード探索できるため、探索スピードが上がる
    q = []
    heappush(q, Node(0, 0))
    # 幅優先探索
    while q:
        now = heappop(q)
        if now.weight > nw[now.id]:
            continue
        for node in graph[now.id]:
            w = node.weight + now.weight
            if w < nw[node.id]:
                nw[node.id] = w
                heappush(q, Node(node.id, nw[node.id]))
    return nw

if __name__ == '__main__':
    main()
"
1882486,ALDS1_12_C,"import sys

f_i = sys.stdin

n = int(f_i.readline())

adj = [[]] * n
for x in f_i:
    x = list(map(int, x.split()))
    adj[x[0]] = (c_v for c_v in zip(x[3::2], x[2::2]))

import heapq

def dijkstra():
    PQ = [(0, 0)]
    isVisited = [False] * n
    distance = [999900001] * n

    distance[0] = 0
    
    while PQ:
        uc, u = heapq.heappop(PQ)

        if uc > distance[u]:
            continue

        isVisited[u] = True
        
        for vc, v in adj[u]:
            if isVisited[v] == True:
                continue
            
            t_cost = distance[u] + vc
            if t_cost < distance[v]:
                distance[v] = t_cost
                heapq.heappush(PQ, (t_cost, v))

    for v, d in enumerate(distance):
        print(v, d)


dijkstra()
"
3826335,ALDS1_12_C,"class RadixHeap:
    __slots__ = [""data"", ""last"", ""siz"", ""used""]

    # (max_key - min_key) <= C
    def __init__(self, N, C):
        self.data = [[] for i in range(C.bit_length() + 1)]
        self.last = self.siz = 0
        self.used = [0]*N

    def push(self, x, key):
        #assert self.last <= x
        self.siz += 1
        self.data[(x ^ self.last).bit_length()].append((x, key))

    def pop(self):
        data = self.data
        used = self.used
        #assert self.siz > 0
        if not data[0]:
            i = 1
            while not data[i]:
                i += 1
            d = data[i]
            new_last, new_key = min(d)
            used[new_key] = 1
            for val in d:
                x, key = val
                if used[key]:
                    self.siz -= 1
                    continue
                data[(x ^ new_last).bit_length()].append(val)
            self.last = new_last
            data[i] = []
        else:
            new_last, new_key = data[0].pop()
            used[new_key] = 1
            self.siz -= 1
        return new_last, new_key

    def __len__(self):
        return self.siz

import sys
readline = sys.stdin.readline
write = sys.stdout.write


N = int(readline())
G = [None] * N
for i in range(N):
    u, k, *V = map(int, readline().split())
    G[i] = [(v, c) for v, c in zip(V[::2], V[1::2])]

def dijkstra(N, G, s):
    que = RadixHeap(N, 10**9 + 1)

    dist = [10**18]*N
    dist[s] = 0
    que.push(0, s)
    while que:
        cost, v = que.pop()
        if dist[v] < cost:
            continue
        for w, c in G[v]:
            if cost + c < dist[w]:
                dist[w] = r = cost + c
                que.push(r, w)
    return dist
dist = dijkstra(N, G, 0)
write(""\n"".join(""%d %d"" % (i, d) for i, d in enumerate(dist)))
write(""\n"")
"
8853179,ALDS1_12_C,"# aizu_ALDS1_12_C_SingleSourceShortestPathII.py  
# dijkstra

from heapq import heappop,heappush

n = int(input())
graph = [ [] for _ in range(n)]
for i in range(n):
    u,k,*t = list(map(int,input().split()))
    for j in range(k):
        graph[u].append([t[2*j],t[2*j+1]])

def dijkstra(start):
    INF = 10**15
    dist = [INF] * n
    hq = [(0,start)]
    dist[start] = 0
    visited = [False] * n
    while hq:
        now = heappop(hq)[1]
        visited[now] = True
        for to,cost in graph[now]:
            if visited[to] == False and \
                    dist[now] + cost < dist[to]:
                dist[to] = dist[now ]+ cost
                heappush(hq,(dist[to],to))
    return dist

root = dijkstra(0)
for i,c in enumerate(root):
    print(i,c)

"
5241278,ALDS1_12_C,"import heapq
from collections import deque
from sys import stdin

input = stdin.readline
n = int(input())
INF = float(""inf"")
adjList = deque()


for i in range(n):
    data = list(map(int, input().split()))
    node = data[0]
    size = data[1]
    adjList.append(list(zip(data[2::2], data[3::2])))


def dijkstra(start):
    minDistance = [INF] * n
    q = []
    minDistance[start] = 0
    heapq.heappush(q, (0, start))

    while len(q) > 0:
        # choice a node
        cost, src = heapq.heappop(q)
        if minDistance[src] < cost:
            continue

        # include dest
        for dst, w in adjList[src]:
            if cost != INF:
                if cost + w < minDistance[dst]:
                    minDistance[dst] = cost + w
                    heapq.heappush(q, (minDistance[dst], dst))
    return minDistance


d = dijkstra(0)
for i in range(n):
    print(i, d[i])

"
8539918,ALDS1_12_C,"from heapq import heappop, heappush

n = int(input())
G = [None] * n
for _ in range(n):
  u, k, *vc = map(int, input().split())
  G[u] = {vc[2*i]:vc[2*i+1] for i in range(k)}

d = [0] + [float(""inf"")] * (n-1)
heap = [[0, 0]]
while heap:
  d_u, u = heappop(heap)
  for v in G[u]:
    d_v = d_u + G[u][v]
    if d[v] > d_v:
      d[v] = d_v
      heappush(heap, [d[v], v])

for v in range(n):
  print(v, d[v])

"
8739429,ALDS1_12_C,"from heapq import heappop, heappush

n = int(input())
G = [None] * n

for i in range(n):
  u, k, *vc = map(int, input().split("" ""))
  G[u] = {vc[2 * i]: vc[2 * i + 1] for i in range(k)}
  
d = [0] + [99999999999] * (n - 1)
heap = [[0, 0]]

while heap:
  dU, u = heappop(heap)
  for v in G[u]:
    dV = dU + G[u][v]
    if d[v] > dV:
      d[v] = dV
      heappush(heap, [d[v], v])
      
for i in range(n):
  print(i, d[i])
























"
3825570,ALDS1_12_C,"import heapq


def dijkstra(adj, s):
    INF = 200000
    n = len(adj)
    state, d, p = [False] * n, [INF] * n, [-1] * n
    d[s] = 0
    pq = [(d[s], s)]
    while pq:
        f, u = heapq.heappop(pq)
        state[u] = True
        if d[u] < f:
            continue
        for v, c in adj[u]:
            if state[v]:
                continue
            if d[u] + c < d[v]:
                d[v] = d[u] + c
                p[v] = u
                heapq.heappush(pq, (d[v], v))
    return d


def main():
    n = int(input())
    adj = [[] for _ in range(n)]
    for _ in range(n):
        u, _, *vc = map(int, input().split())
        for v, c in zip(vc[::2], vc[1::2]):
            adj[u].append((v, c))
    dist = dijkstra(adj, 0)
    for i, d in enumerate(dist):
        print(i, d)


if __name__ == '__main__':
    main()

"
4483545,ALDS1_12_C,"import sys
readline = sys.stdin.readline
from heapq import heapify, heappush, heappop
INF = float(""inf"")
def MAIN():
    n = int(input())
    adj = [[]] * n
    for _ in range(0, n):
        U = list(map(int, input().split()))
        adj[U[0]] = zip(U[2::2], U[3::2])
    def dijkstra():
        d = [0] + [INF] * (n - 1)
        hq = [(0, 0)]
        while hq:
            u = heappop(hq)[1]
            for v, c in adj[u]:
                alt = d[u] + c
                if d[v] > alt:
                    d[v] = alt
                    heappush(hq, (alt, v))
        print(""\n"".join(f""{i} {c}"" for i, c in enumerate(d)))
    dijkstra()
MAIN()

"
9201741,ALDS1_12_C,"import sys
import math
from collections import deque
r = sys.stdin.readline
w = sys.stdout.write

def SSSPI():
    n = int(r())
    d = [math.inf] * n
    d[0] = 0
    edges = []
    for _ in range(n):
        u, k, *vc = map(int, r().split())
        temp = []
        for i in range(k):
            temp.append((vc[2 * i], vc[2 * i + 1]))
        edges.append(temp)
    
    hp = deque([0])
    while hp:
        c = hp.popleft()
        for next, weight in edges[c]:
            if d[c] + weight < d[next]:
                d[next] = d[c] + weight
                hp.append(next)
    for i, di in enumerate(d):
        print(i, di)
SSSPI()

"
5876178,ALDS1_12_C,"from heapq import*

n=int(input())
A=[]
for _ in[0]*n:
    e=list(map(int,input().split()))
    A+=[zip(e[2::2],e[3::2])]
d=[0]+[float('inf')]*n
H=[(0,0)]
while H:
    u=heappop(H)[1]
    for v,c in A[u]:
        t=d[u]+c
        if d[v]>t:
            d[v]=t
            heappush(H,(t,v))
print('\n'.join(f'{i} {d[i]}'for i in range(n)))

"
6357203,ALDS1_12_C,"from heapq import heappop, heappush

inf = float('inf')
n = int(input())
G = []

for _ in range(n):
    line = list(map(int, input().split()[2:]))
    G.append(zip(line[0::2], line[1::2]))

d = [inf] * n
d[0] = 0
heap = [(0, 0)]

while heap:
    current = heappop(heap)[1]
    for v, c in G[current]:
        newdist = d[current] + c
        if newdist < d[v]:
            d[v] = newdist
            heappush(heap, (newdist, v))

for i in range(n):
    print(i, d[i])

"
2628742,ALDS1_12_C,"from heapq import heappush, heappop

inf = float('inf')
n = int(input())
g = []
for i in range(n):
    line = list(map(int, input().split()[2:]))
    g.append(zip(line[0::2], line[1::2]))

dist = [inf] * n
dist[0] = 0
heap = [(0, 0)]

while heap:
    current = heappop(heap)[1]
    for v, c in g[current]:
        new_dist = dist[current] + c
        if new_dist < dist[v]:
            dist[v] = new_dist
            heappush(heap, (new_dist, v))

for i in range(n):
    print(i, dist[i])
"
3029478,ALDS1_12_C,"# -*- coding: utf-8 -*-
from heapq import heappop, heappush


def dijkstra(edges, start, *, adj_matrix=False, default_value=float('inf')):
    '''
    Returns best costs to each node from 'start' node in the given graph.
    (Single Source Shortest Path - SSSP)

    If edges is given as an adjacency list including costs and destination nodes on possible edges, adj_matrix should be False(default), and it is generally when this functions works much faster.

    Note that costs in edges should follow the rules below
    1. The cost from a node itself should be 0,
    2. If there is no edge between nodes, the cost between them should be default_value
    3. The costs can't be negative

    # sample input when given as adjacency list (adj_matrix=False)
    edges = [[(1, 2), (2, 5), (3, 4)],         # node 0
             [(0, 2), (3, 3), (4, 6)],         # node 1
             [(0, 5), (3, 2), (5, 6)],         # node 2
             [(0, 4), (1, 3), (2, 2), (4, 2)], # node 3
             [(1, 6), (3, 2), (5, 4)],         # node 4
             [(2, 6), (4, 4)]]                 # node 5

    # sample input when given as adjacency matrix (adj_matrix=True)
    edges = [[0, 2, 5, 4, inf, inf],           # node 0
             [2, 0, inf, 3, 6, inf],           # node 1
             [5, inf, 0, 2, inf, 6],           # node 2
             [4, 3, 2, 0, 2, inf],             # node 3
             [inf, 6, inf, 2, 0, 4],           # node 4
             [inf, inf, 6, inf, 4, 0]]         # node 5
    '''

    n = len(edges)

    inf = float('inf')
    costs = [inf] * n
    costs[start] = 0
    pq, rem = [(0, start)], n - 1

    while pq and rem:
        tmp_cost, tmp_node = heappop(pq)
        if costs[tmp_node] < tmp_cost:
            continue
        rem -= 1

        nxt_edges = ((node, cost) for node, cost in enumerate(edges[tmp_node]) if cost != default_value) if adj_matrix else\
                    edges[tmp_node]

        for nxt_node, nxt_cost in nxt_edges:
            new_cost = tmp_cost + nxt_cost
            if costs[nxt_node] > new_cost:
                costs[nxt_node] = new_cost
                heappush(pq, (new_cost, nxt_node))

    return costs


def dijkstra_route(edges,
                   start,
                   goal,
                   *,
                   adj_matrix=False,
                   default_value=float('inf'),
                   verbose=False):
    '''
    Trys to find the best route to the 'goal' from the 'start'
    '''

    n = len(edges)

    inf = float('inf')
    costs = [inf] * n
    costs[start] = 0
    pq, rem = [(0, start)], n - 1
    prevs = [-1 for _ in [None] * n]

    while pq and rem:
        tmp_cost, tmp_node = heappop(pq)
        if costs[tmp_node] < tmp_cost:
            continue
        rem -= 1

        nxt_edges = ((node, cost) for node, cost in enumerate(edges[tmp_node]) if cost != default_value) if adj_matrix else\
                    edges[tmp_node]

        for nxt_node, nxt_cost in nxt_edges:
            new_cost = tmp_cost + nxt_cost
            if costs[nxt_node] > new_cost:
                costs[nxt_node] = new_cost
                heappush(pq, (new_cost, nxt_node))
                prevs[nxt_node] = tmp_node

    min_route = []
    prev = goal
    cnt = 0
    while prev != start:
        min_route.append(prev)
        prev = prevs[prev]

        cnt += 1
        if prev == -1 or cnt > n:
            raise NoRouteError(
                'There is no possible route in this graph \nedges: {} \nstart: {} \ngoal: {}'.
                format(edges, start, goal))

    else:
        min_route.append(prev)
    min_route = min_route[::-1]
    min_cost = costs[goal]

    if verbose:
        print('---route---')
        for node in min_route[:-1]:
            print('{} -> '.format(node), end='')
        else:
            print(min_route[-1])

        print('---distance---')
        print(min_cost)

    return costs, min_route


class NoRouteError(Exception):
    pass


if __name__ == '__main__':
    '''
    an example of using this function
    AIZU ONLINE JUDGE - ALDS_1_12_C
    '''

    n = int(input())
    edges = [[] for i in range(n)]
    for i in range(n):
        i, k, *kedges = map(int, input().split())
        for edge in zip(kedges[::2], kedges[1::2]):
            edges[i].append(edge)

    for i, cost in enumerate(dijkstra(edges, 0)):
        print(i, cost)

"
6116160,ALDS1_12_C,"from heapq import heappop, heappush

inf = float(""inf"")
n = int(input())
g = []
for i in range(n):
    u, k, *A = list(map(int, input().split()))
    g.append(zip(A[0::2], A[1::2]))

dist = [inf for i in range(n)]
dist[0] = 0
heap = [(0, 0)]

while heap:
    current = heappop(heap)[1]
    for v, c in g[current]:
        new_dist = dist[current] + c
        if new_dist < dist[v]:
            dist[v] = new_dist
            heappush(heap, (new_dist, v))

for i in range(n):
    print(i, dist[i])
"
7503973,ALDS1_12_C,"import sys
readline = sys.stdin.readline
from heapq import heapify, heappush, heappop
input = sys.stdin.readline
n = int(input())
g = [[]] * n
for _ in range(n):
    x = list(map(int, input().split()))
    g[x[0]] = zip(x[2::2], x[3::2])
d = [0] + [10**9]*(n-1)
h = [[0, 0]]
while h:
    u = heappop(h)[1]
    for v, c in g[u]:
        a = d[u] + c
        if d[v] > a:
            d[v] = a
            heappush(h, [a, v])
for i, c in enumerate(d):
    print(i, c)
"
4754572,ALDS1_12_C,"import sys, os, math, bisect, itertools, collections, heapq, queue, copy, array

# from scipy.sparse.csgraph import csgraph_from_dense, floyd_warshall
# from decimal import Decimal
# from collections import defaultdict, deque

sys.setrecursionlimit(10000000)

ii = lambda: int(sys.stdin.buffer.readline().rstrip())
il = lambda: list(map(int, sys.stdin.buffer.readline().split()))
fl = lambda: list(map(float, sys.stdin.buffer.readline().split()))
iln = lambda n: [int(sys.stdin.buffer.readline().rstrip()) for _ in range(n)]

iss = lambda: sys.stdin.buffer.readline().decode().rstrip()
sl = lambda: list(map(str, sys.stdin.buffer.readline().decode().split()))
isn = lambda n: [sys.stdin.buffer.readline().decode().rstrip() for _ in range(n)]

lcm = lambda x, y: (x * y) // math.gcd(x, y)

MOD = 10 ** 9 + 7
INF = float('inf')


def main():
    if os.getenv(""LOCAL""):
        sys.stdin = open(""input.txt"", ""r"")

    N = ii()

    # (距離, 接する頂点)の情報を持つ有向グラフのデータを生成
    graph = [[] for _ in range(N)]
    for _ in range(N):
        v1, k, *vertices = il()
        for idx in range(0, k * 2, 2):
            v2, c = vertices[idx:idx + 2]
            graph[v1].append((c, v2))

    # ダイクストラ法
    dist = [INF] * N    # 各頂点までの距離を保持する配列
    dist[0] = 0         # 開始始点の頂点は距離をゼロとする
    visited = [0] * N   # 各頂点の訪問状態を保持する配列[0: 未訪問, 1: 訪問済み]
    heap = [(0, 0)]     # 距離と始点頂点（自分自身への移動距離はゼロ）
    heapq.heapify(heap) # 距離と頂点の情報を距離で優先度付きキューとする
    while heap:
        # 頂点uとuに到達するまでの距離
        min_cost, u = heapq.heappop(heap)

        # さらに小さい距離で既に到達済みの場合はcontinue
        if dist[u] < min_cost: continue
        visited[u] = 1  # 頂点uを訪問済みにする

        # グラフの情報から接する頂点と移動距離を順に処理
        for cost, v in graph[u]:
            if visited[v] != 1:
                if dist[u] + cost < dist[v]:
                    # 未到達かつ小さい距離で移動できる場合には
                    # 距離の更新と優先度付きキューに(距離, 頂点)の情報を追加
                    dist[v] = dist[u] + cost
                    heapq.heappush(heap, (dist[v], v))
    # 回答
    for n in range(N):
        print(n, dist[n])


if __name__ == '__main__':
    main()

"
5223385,ALDS1_12_C,"from heapq import heappush, heapify, heappop


def dijkstra(es: ""隣接リスト"", start: ""始点"", INF=2000000000000000):
    # INF = 2 * 10**15 (> 10**6 * 10**9)
    V = len(es)
    d = [INF] * V  # 頂点sからの最短距離
    que = [(0, start)]  # (距離, 頂点)
    d[start] = 0
    while que:
        dv, v = heappop(que)
        if d[v] < dv:
            continue
        for e, de in es[v]:
            if d[e] > d[v] + de:
                d[e] = d[v] + de
                heappush(que, (d[e], e))
    return d


import sys
input = sys.stdin.readline

n = int(input())
es = [[] for _ in range(n)]  # es[i] = (頂点iの(隣接する頂点,コスト)の組)
# 入力
for _ in range(n):
    u, k, *a = map(int, input().split())
    e = []
    for x, y in zip(a[0::2], a[1::2]):
        e.append((x, y))
    es[u] = e
for i, e in enumerate(dijkstra(es, 0)):
    print(i, e)

"
6049104,ALDS1_12_C,"import sys
from heapq import heappop, heappush

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines

INF = float('inf')


def main():
    N = int(readline())

    edge = [[] for _ in range(N)]
    for _ in range(N):
        u, k, *l = map(int, readline().split())
        for i in range(k):
            edge[u].append((l[2 * i], l[2 * i + 1]))
    
    dist = [INF] * N
    dist[0] = 0
    que = [(0, 0)]

    while que:
        d, node = heappop(que)

        if dist[node] < d:
            continue

        for next, cost in edge[node]:
            if dist[next] > d + cost:
                dist[next]  = d + cost
                heappush(que, (dist[next], next))
    
    for i, d in enumerate(dist):
        print(i, d)


if __name__ == '__main__':
    main()
"
8834039,ALDS1_12_C,"import heapq
n = int(input())
g = [[] for _ in range(n)]
for _ in range(n):
    i, k, *a = list(map(int, input().split()))
    g[i] = [(a[2*j+1], a[2*j]) for j in range(k)]
distance = [-1] * n
q = [(0, 0)]
while q:
    cur, node = heapq.heappop(q)
    if distance[node] != -1: continue
    distance[node] = cur
    for cost, nex in g[node]:
        if distance[nex] != -1: continue
        heapq.heappush(q, (cur+cost, nex))
for i in range(n):
    print(i, distance[i])

"
3984950,ALDS1_12_C,"import sys
input = sys.stdin.readline
from operator import itemgetter
sys.setrecursionlimit(10000000)

def dijkstra(n, start, nbl):
    """"""n: 頂点数, start: 始点, nbl: 隣接リスト""""""
    import heapq
    WHITE = 1<<5
    GRAY = 1<<10
    BLACK = 1<<15
    INF = 1<<20
    color = [WHITE] * n
    distance = [INF] * n
    parent = [-1] * n
    q = []

    distance[start] = 0
    heapq.heappush(q, (0, start))
    while len(q) != 0:
        du, u = heapq.heappop(q)
        # print(""u: {}, du: {}"".format(u, du))
        color[u] = BLACK
        if distance[u] < du:
            continue
        for next, cost in nbl[u]:
            if color[next] != BLACK and distance[u] + cost < distance[next]:
                distance[next] = distance[u] + cost
                color[next] = GRAY
                heapq.heappush(q, (distance[next], next))
    return distance


def main():
    n = int(input().strip())
    nb = [[] for _ in range(n)]
    for i in range(n):
        l = list(map(int, input().strip().split()))
        for j in range(l[1]):
            nb[i].append((l[2 + 2 * j], l[3 + 2 * j]))
    d = dijkstra(n, 0, nb)
    for i, v in enumerate(d):
        print(i, v)


if __name__ == '__main__':
    main()

"
4751725,ALDS1_12_C,"from sys import stdin
input = stdin.readline
import heapq

infty = 2**21

def dijkstra(n):
    d = [infty] * n
    color = [0] * n

    d[0] = 0
    PQ = [(0, 0)]
    heapq.heapify(PQ)
    color[0] = 1

    while PQ:
        f = heapq.heappop(PQ)
        u = f[1]
        color[u] = 2

        #最小値を取り出し、それが最短でなければ無視
        if d[u] < f[0]:
            continue

        for adj_u in adj[u]:
            v = adj_u[0]
            if color[v] == 2:
                continue
            if d[v] > d[u] + adj_u[1]:
                d[v] = d[u] + adj_u[1]
                heapq.heappush(PQ, (d[v], v))
                color[v] = 1


    for i in range(n):
        print(str(i) + ' ' + str(-1 if d[i] == infty else d[i]))


n = int(input())

adj = [0]*n

for _ in range(n):
    u, k, *vc = map(int, input().split())
    vx_tuple = [0] * k
    for i, (v, c) in enumerate(zip(vc[::2], vc[1::2])):
        #pythonにはvectorないので、tupleで代用
        vx_tuple[i] = (v, c)
    adj[u] = vx_tuple


dijkstra(n)

"
4886399,ALDS1_12_C,"import bisect, collections, copy, heapq, itertools, math, string
import sys
def I(): return int(sys.stdin.readline().rstrip())
def MI(): return map(int, sys.stdin.readline().rstrip().split())
def LI(): return list(map(int, sys.stdin.readline().rstrip().split()))
def S(): return sys.stdin.readline().rstrip()
def LS(): return list(sys.stdin.readline().rstrip().split())
from collections import deque, defaultdict, Counter
import heapq
import itertools

N = I()
e = [[] for _ in range(N)]
def dijkstra(s, n):
    hq = [(0, s)]
    heapq.heapify(hq)  # リストを優先度付きキューに変換
    cost = [float('inf')] * n  # 行ったことのないところはinf
    cost[s] = 0  # 開始地点は0
    while hq:
        c, v = heapq.heappop(hq)
        if c > cost[v]:  # コストが現在のコストよりも高ければスルー
            continue
        for d, u in e[v]:
            tmp = d + cost[v]
            if tmp < cost[u]:
                cost[u] = tmp
                heapq.heappush(hq, (tmp, u))
    return cost
def main():
    for i in range(N):
        X = LI()
        u = X[0]
        k = X[1]
        for j in range(2, 2 * k + 1, 2):
            e[u].append((X[j + 1], X[j]))
    ans = dijkstra(0, N)
    for i in range(N):
        print(i, ans[i])
if __name__ == ""__main__"":
    main()
"
5128093,ALDS1_12_C,"from sys import stdin
import heapq

input = stdin.readline

n = int(input().rstrip())
adj = [None for _ in range(n)]
color = [""W"" for _ in range(n)]
d = [float('inf') for _ in range(n)]

def dijkstra(s):
    PQ = []
    d[s] = 0
    heapq.heappush(PQ,(0,s))
    color[s] = ""G""
    while PQ:
        f = heapq.heappop(PQ)
        u = f[1]
        color[u] = ""B""
        if d[u] < f[0]:
            continue
        for i in range(len(adj[u])):
            v = adj[u][i][0]
            if color[v] == ""B"":
                continue
            if d[u]+adj[u][i][1] < d[v]:
                d[v] = d[u]+adj[u][i][1]
                color[v] = ""G""
                heapq.heappush(PQ,(d[v],v))

def main():
    for _ in range(n):
        u,k,*vc = map(int,input().split())
        make_pair = [None for _ in range(k)]
        for i,(v,c) in enumerate(zip(vc[::2],vc[1::2])):
            make_pair[i] = (v,c)
        adj[u] = make_pair

    dijkstra(0)

    for j in range(n):
        print(str(j)+"" ""+str(-1 if d[j]==float('inf') else d[j]))


if __name__ == ""__main__"":
    main()


"
5158304,ALDS1_12_C,"def dijkstra(N, G, s, INF=10**18):
    """"""
    https://tjkendev.github.io/procon-library/python/graph/dijkstra.html
    O((|E|+|V|)log|V|)
    V: 頂点数
    g[v] = {(w, cost)}:
        頂点vから遷移可能な頂点(w)とそのコスト(cost)
    r: 始点の頂点""""""
    from heapq import heappush, heappop

    dist = [INF] * N
    h = [(0, s)]  # (c, v)
    dist[s] = 0
    while h:
        c, v = heappop(h)
        if dist[v] < c:
            continue
        for u, cost in G[v]:
            if dist[v] + cost < dist[u]:
                dist[u] = dist[v] + cost
                heappush(h, (dist[u], u))
    return dist


def main():
    import sys
    input = sys.stdin.readline

    N = int(input())

    g = tuple(list() for _ in range(N))
    for _ in range(N):
        v, _, *es = map(int, input().split())
        while es:
            c = es.pop()
            u = es.pop()
            g[v].append((u, c))

    dist = dijkstra(N, g, 0)

    for i, d in enumerate(dist):
        print(i, d)


if __name__ == ""__main__"":
    main()

"
7391255,ALDS1_12_C,"INF = 999999999999

WHITE = 0
GRAY = 1
BLACK = 2

def dijkstra():
    d = [INF] * n
    color = [WHITE] * n

    d[0] = 0
    color[0] = GRAY

    PriQ = [(0, 0)]
    heapq.heapify(PriQ)

    while PriQ:
        f = heapq.heappop(PriQ)
        u = f[1]
        color[u] = BLACK

        if d[u] < f[0]:
            continue

        for adj_u in adj[u]:
            v = adj_u[0]
            if color[v] == BLACK:
                continue
            if d[v] > d[u] + adj_u[1]:
                d[v] = d[u] + adj_u[1]
                heapq.heappush(PriQ, (d[v], v))
                color[v] = GRAY

    for i in range(n):
        if d[i] == INF:
            print(i, -1)
        else:
            print(i, d[i])

import heapq

n = int(input())
adj = [0] * n

for _ in range(n):
    u, k, *v = map(int, input().split())
    tuple_ = [0] * k
    for i, (v, c) in enumerate(zip(v[::2], v[1::2])):
        tuple_[i] = (v, c)
    adj[u] = tuple_

dijkstra()

"
2972333,ALDS1_12_C,"import heapq

class Dijkstra:
    """"""
        Dijkstra's algorithm: find the shortest paths from a vertex
        complexity:
            O(E + logV)
    """"""
    def __init__(self, V, E, start, INF=10**9):
        """"""
        :param V: the number of vertices
        :param E: adjacency list (all edge in E must be non negative)
        :param start: start vertex
        :param INF: Infinity distance
        """"""
        self.V = V
        self.E = E
        self.dijkstra(start, INF)

    def dijkstra(self, start, INF):
        que = list()
        self.distance = [INF] * self.V
        self.prev = [-1] * self.V
        self.distance[start] = 0
        heapq.heappush(que, (0, start))
        while len(que) > 0:
            dist, fr = heapq.heappop(que)
            if self.distance[fr] < dist:
                continue
            for to, cost in self.E[fr]:
                if self.distance[fr] + cost < self.distance[to]:
                    self.distance[to] = self.distance[fr] + cost
                    heapq.heappush(que, (self.distance[to], to))
                    self.prev[to] = fr

    def get_path(self, end):
        path = [end]
        while self.prev[end] != -1:
            end = self.prev[end]
            path.append(end)
            return path[::-1]


V = int(input())
edges = [[] for _ in range(V)]
for _ in range(V):
    u, _, *e = map(int, input().split())
    for t, d in zip(e[::2], e[1::2]):
        edges[u].append((t, d))

djk = Dijkstra(V, edges, 0)
for i, d in enumerate(djk.distance):
    print(i, d)
"
5714095,ALDS1_12_C,"from heapq import heappush, heappop

MAX = 2147483647

# ALDS1_12_C: 単一始点最短経路の高速化
def main():
    n = int(input())
    adj = []
    for _ in range(n):
        line = [int(v) for v in input().split("" "")]
        num = line[1]
        adj.append([ (line[2*j], line[2*j+1]) for j in range(1, num+1)])
    d = [MAX for _ in range(n)]
    d[0] = 0
    s = set()
    hq = []
    heappush(hq, (0, 0))
    while (len(s) != n):
        u = 0
        for _ in range(len(hq)):
            _, i = heappop(hq)
            if not i in s:
                u = i
                break
        s.add(u)
        for i, v in adj[u]:
            if d[i] > d[u] + v:
                d[i] = d[u] + v
                heappush(hq, (d[i], i))
    for i, v in enumerate(d):
        print(i, v)

if __name__ == '__main__':
    main()

"
9117615,ALDS1_12_C,"import heapq

n = int(input())
edges = [[] for _ in range(n)]
for _ in range(n):
    u, k, *l = list(map(int, input().split()))
    for i in range(0, 2*k, 2):
        v, c = l[i], l[i + 1]
        edges[u].append((c, v))
INF = float(""inf"")
dist = [INF] * n
que = [(0, 0)]
heapq.heapify(que)
while que:
    cost, crt = heapq.heappop(que)
    if dist[crt] <= cost:
        continue
    dist[crt] = cost
    for nxt_cost, nxt in edges[crt]:
        if dist[nxt] <= cost + nxt_cost:
            continue
        heapq.heappush(que, (cost + nxt_cost, nxt))
for i in range(n):
    print(i, dist[i])

"
1677701,ALDS1_12_C,"import heapq


class ShortestPath:
    """"""Dijkstra's algorithm : find the shortest path from a vertex
       Complexity: O(E + log(V))
       used in GRL1A(AOJ)
    """"""

    def __init__(self, V, E, start, INF=10**9):
        """""" V: the number of vertexes
            E: adjacency list (all edge in E must be 0 or positive)
            start: start vertex
            INF: Infinity distance
        """"""
        self.V = V
        self.E = E
        self.dijkstra(start, INF)

    def dijkstra(self, start, INF):
        que = list()
        self.distance = [INF] * self.V  # distance from start
        self.prev = [-1] * self.V  # prev vertex of shortest path
        self.distance[start] = 0
        heapq.heappush(que, (0, start))

        while len(que) > 0:
            dist, fr = heapq.heappop(que)
            if self.distance[fr] < dist:
                continue
            for to, cost in self.E[fr]:
                if self.distance[fr] + cost < self.distance[to]:
                    self.distance[to] = self.distance[fr] + cost
                    heapq.heappush(que, (self.distance[to], to))
                    self.prev[to] = fr

    def getPath(self, end):
        path = [end]
        while self.prev[end] != -1:
            end = self.prev[end]
        return path[::-1]
V = int(input())
edge = [[] for _ in range(V)]
for _ in range(V):
    u, _, *e = map(int, input().split())
    for t, d in zip(e[::2], e[1::2]):
        edge[u].append((t, d))

sp = ShortestPath(V, edge, 0)
for i, d in enumerate(sp.distance):
    print(i, d)
"
4261484,ALDS1_12_C,"if __name__ == '__main__':
    from sys import stdin
    input = stdin.readline

    import heapq
    from copy import deepcopy

    INFTY = 2**21
    WHITE = 0
    GRAY = 1
    BLACK = 2

    n = int(input())

    adj = [0]*n

    for _ in range(n):
        u, k, *vc = map(int, input().split())
        vc_tuple = [0]*k
        for i, (v, c) in enumerate(zip(vc[::2], vc[1::2])):
            # pythonにはvectorないので、tupleで代用
            vc_tuple[i] = (v, c)
        adj[u] = vc_tuple

    def dijkstra():
        d = [INFTY]*n
        color = [WHITE]*n

        d[0] = 0
        PQ = [(0, 0)]
        heapq.heapify(PQ) # PQを優先度付きキューにする
        color[0] = GRAY
        while PQ:  # PQの長さ0でwhile抜ける
            f = heapq.heappop(PQ)
            u = f[1]
            color[u] = BLACK

            # 最小値を取り出し、それが最短でなければ無視
            if d[u] < f[0]: # -1かけない理由は9行下のコメント参照
                continue

            for adj_u in adj[u]:
                v = adj_u[0]
                if color[v] == BLACK:
                    continue
                if d[v] > d[u]+adj_u[1]:
                    d[v] = d[u]+adj_u[1]
                    # pythonのheapqはmin-ヒープを使っているので-1かけなくて良い
                    heapq.heappush(PQ, (d[v], v))
                    color[v] = GRAY

        for i in range(n):
            print(str(i) + ' ' + str(-1 if d[i] == INFTY else d[i]))

    dijkstra()

    """"""

    nodes = [[] for _ in range(n)]

    for _ in range(n):
        u, k, *vc = map(int, input().split())
        cv = [0]*k
        for i, (v, c) in enumerate(zip(vc[::2], vc[1::2])):
            cv[i] = (c, v)
        nodes[u] = cv

    d = [INFTY]*n
    d[0] = 0

    d_node = nodes[0]
    heapq.heapify(d_node)

    visited = [False]*n
    visited[0] = True

    while d_node:
        min_c, min_v = heapq.heappop(d_node)
        if visited[min_v]:
            continue
        visited[min_v] = True
        d[min_v] = min_c
        for c, v in nodes[min_v]:
            heapq.heappush(d_node, (min_c+c, v))

    for u, dist in enumerate(d):
        print(str(u) + ' ' + str(dist))
    """"""

"
6312339,ALDS1_12_C,"from typing import List, Tuple
import sys
from array import array
import heapq


sys.setrecursionlimit(10000)
input = sys.stdin.readline


def main():
    N: int = int(input())
    graph: List[List[Tuple[int, int]]] = [[] for i in range(N)]
    for i in range(N):
        u, k, *a = list(map(int, input().split()))

        edges: List[Tuple[int, int]] = []
        for j in range(k):
            edges.append((a[2 * j], a[2 * j + 1]))

        graph[u] = edges

    distance: List[int] = [1000000000 for i in range(N)]
    distance[0] = 0

    heap: List[Tuple[int, int]] = [[0, 0]]

    while heap:
        d, v = heapq.heappop(heap)

        if d > distance[v]:
            continue

        for node, weight in graph[v]:
            if distance[node] > distance[v] + weight:
                distance[node] = distance[v] + weight
                heapq.heappush(heap, (distance[node], node))

    for i, d in enumerate(distance):
        print(f""{i} {d}"")


if __name__ == ""__main__"":
    main()

"
2892338,ALDS1_12_C,"# coding: utf-8

import heapq


class Dijkstra:

    """"""
    Dijkstra's algorithm: find the shortest path from a vertex
    O(E + log(V))
    verified:
        https://onlinejudge.u-aizu.ac.jp/#/courses/lesson/1/ALDS1/12/ALDS1_12_B
    """"""

    def __init__(self, V, G, INF=float(""inf"")):

        """"""
        V: the number of vertexes
        E: adjacency list (all edge in G must be 0 or positive)
        INF: Infinity distance
        """"""
        self.V = V
        self.G = G
        self.INF = INF
        self.distance, self.prev = list(), list()


    def dijkstra(self, start):

        Q = list()
        self.distance = [self.INF for _ in range(self.V)]
        self.prev = [-1 for _ in range(self.V)]

        self.distance[start] = 0
        heapq.heappush(Q, (0, start))

        while len(Q) > 0:
            dist, from_v = heapq.heappop(Q)
            if self.distance[from_v] < dist:
                continue
            for to_v, nxt_dist in self.G[from_v]:
                if self.distance[from_v] + nxt_dist >= self.distance[to_v]:
                    continue
                self.distance[to_v] = self.distance[from_v] + nxt_dist
                heapq.heappush(Q, (self.distance[to_v], to_v))
                self.prev[to_v] = from_v
        
        return self.distance


    def get_path(self, goal):

        path = [goal]
        while self.prev[goal] != -1:
            path.append(prev[goal])
            goal = self.prev[end]

        return path[::-1]


if __name__ == ""__main__"":
    
    """"""
    an example of use
    """"""

    n = int(input())
    g = [[] for _ in range(n)]
    for _ in range(n):
        v, _, *e = map(int, input().split())
        for u, d in zip(e[::2], e[1::2]):
            g[v].append((u, d))
 

    dist = Dijkstra(n, g).dijkstra(0)
    for i, d in enumerate(dist):
        print(i, d)

"
3990971,ALDS1_12_C,"import heapq

MAX = 10000
WHITE = 0
GRAY = 1
BLACK = 2
INF = float('inf')
color = [WHITE for _ in range(MAX)]
d = [INF for _ in range(MAX)]
adj = [None for _ in range(MAX)]
n = 0


def main():
    global n
    n = int(input())

    for _ in range(n):
        u, k, *n_s = map(int, input().split(' '))
        adj[u] = ([(n_s[2*j], n_s[2*j+1]) for j in range(k)])

    dijkstra(0)

    for i in range(n):
        print(f'{i} {d[i] if d[i] != INF else -1}')


def dijkstra(s):
    d[s] = 0

    pq = []

    heapq.heappush(pq, (0, s))

    while len(pq) > 0:
        f = heapq.heappop(pq)
        u = f[1]

        color[u] = BLACK
        if d[u] < f[0]:
            continue

        for j in range(len(adj[u])):
            v = adj[u][j][0]
            if color[v] == BLACK:
                continue
            if d[v] > d[u] + adj[u][j][1]:
                d[v] = d[u] + adj[u][j][1]
                heapq.heappush(pq, (d[v], v))
                color[v] = GRAY


if __name__ == '__main__':
    main()

"
4422114,ALDS1_12_C,"from heapq import heapify, heappop, heappush, heappushpop
INF = 10**6 + 1

class PriorityQueue:
    def __init__(self, heap):
        self.heap = heap
        heapify(self.heap)

    def push(self, item):
        heappush(self.heap, item)

    def pop(self):
        return heappop(self.heap)

    def pushpop(self, item):
        return heappushpop(self.heap, item)

    def __call__(self):
        return self.heap

    def __len__(self):
        return len(self.heap)


def dijkstra(adj: list, s: int):
    Color = [0] * N
    D = [INF] * N
    P = [None] * N

    D[s] = 0
    P[s] = None
    PQ = PriorityQueue([(0, s)])

    while PQ:
        min_cost, u = PQ.pop()

        Color[u] = 2

        if D[u] < min_cost:
            continue

        for idx_adj_u, w_adj_u in adj[u]:
            if Color[idx_adj_u] != 2:
                if D[u] + w_adj_u < D[idx_adj_u]:
                    D[idx_adj_u] = D[u] + w_adj_u
                    P[idx_adj_u] = u
                    PQ.push((D[idx_adj_u], idx_adj_u))
                    Color[idx_adj_u] = 1
    return D, P

N = int(input())
adj = [[] for _ in range(N)]
for _ in range(N):
    tmp = list(map(int, input().split()))
    if tmp[1] != 0:
        node = tmp[0]
        for i in range(2, 2 + tmp[1] * 2, 2):
            adj[node].append((tmp[i], tmp[i + 1]))

D, P = dijkstra(adj, 0)

for i in range(N):
    print(i, D[i])

"
5148533,ALDS1_12_C,"INF = 10**6 + 1
# あとで必要なのでクラスを準備しておく
from heapq import heapify, heappop, heappush, heappushpop


class PriorityQueue:
    def __init__(self, heap):
        '''
        heap ... list
        '''
        self.heap = heap
        heapify(self.heap)

    def push(self, item):
        heappush(self.heap, item)

    def pop(self):
        return heappop(self.heap)

    def pushpop(self, item):
        return heappushpop(self.heap, item)

    def __call__(self):
        return self.heap

    def __len__(self):
        return len(self.heap)


def dijkstra(adj: list, s: int):
    Color = [0] * N  # 0:未訪問 1:訪問経験あり 2:訪問済み(そこまでの最短経路は確定済み)
    D = [INF] * N  # 本のdと同じ 始点からの距離を記録する
    P = [None] * N  # 本のpと同じ 最短経路木における親を記録する
    # スタートとするノードについて初期化
    D[s] = 0  # スタートまでの距離は必ず0
    P[s] = None  # 親がない(ROOTである)ことを示す
    PQ = PriorityQueue([(0, s)])  # (コスト, ノード番号)で格納 こうするとPQでソートするときに扱いやすい

    # while True:
    while PQ:  # PQに候補がある限り続ける
        # min_cost = INF
        # for i in range(N):
        #     if Color[i] != 2 and D[i] < min_cost:
        #         min_cost = D[i]
        #         u = i
        min_cost, u = PQ.pop()  # 上記の処理はこのように簡略化できる

        Color[u] = 2  # uは訪問済み これから最短経路木に突っ込む作業をする

        if D[u] < min_cost:
            # もし今扱っているmin_costがメモしているやつよりも大きいなら何もしないで次へ(メモしている方を扱えばいいので)
            continue

        # 以下のforではsからの最短経路木にuを追加したときの更新、uまわりで次の最短経路になる候補の更新をしている
        for idx_adj_u, w_adj_u in adj[u]:
            if Color[idx_adj_u] != 2:
                # 訪問済みでなく、u→vへの経路が存在するならば
                if D[u] + w_adj_u < D[idx_adj_u]:
                    D[idx_adj_u] = D[u] + w_adj_u  # u周りにおける最短経路の候補の更新
                    P[idx_adj_u] = u
                    PQ.push((D[idx_adj_u], idx_adj_u))  # ここで候補に追加していっている
                    Color[idx_adj_u] = 1

    return D, P
N = int(input())
adj = [[] for _ in range(N)]  # (node_id, 隣接要素, 隣接nodeidとコスト)の順で格納する
'''
例
[
(0について) [(1,1235), (4,65)]
(1について) [(20,6000)]
...
]
'''
for _ in range(N):
    tmp = list(map(int, input().split()))
    if tmp[1] != 0:
        node = tmp[0]
        for i in range(2, 2 + tmp[1] * 2, 2):
            adj[node].append((tmp[i], tmp[i + 1]))

D, P = dijkstra(adj, 0)

for i in range(N):
    print(i, D[i])
"
5151349,ALDS1_12_C,"import heapq
import sys
input = sys.stdin.readline
sys.setrecursionlimit(10 ** 7)

n = int(input())
edge = [[] for _ in range(n)]
for _ in range(n):
    s, k, *arg = map(int, input().split())
    for t, c in zip(arg[::2], arg[1::2]):
        edge[s].append((t, c))

inf = 10 ** 18
dist = [inf] * n
dist[0] = 0
que = [(0, 0)]
while que:
    ds, s = heapq.heappop(que)
    if dist[s] < ds:
        continue
    for t, dt in edge[s]:
        if dist[t] > ds + dt:
            dist[t] = ds + dt
            heapq.heappush(que, (ds + dt, t))

for i, d in enumerate(dist):
    print(i, d)
"
4080483,ALDS1_12_C,"import heapq


def dijkstra(adj_list, n):
    dist = [float(""inf"") for i in range(n)]
    visited = [False for _ in range(n)]
    parent = [-1 for _ in range(n)]
    start = 0
    dist[start] = 0
    dist_heap = []  # 距離が最小のノードをすぐに探せるようにするために使う。次のノードの候補を入れる。
    heapq.heappush(dist_heap, (dist[start], start))

    while len(dist_heap) > 0:
        cost, start = heapq.heappop(dist_heap)  # 一番近いノードがスタート地点となる
        visited[start] = True
        if dist[start] < cost:  # heapのコストが最短でなければ、distを更新する必要はない
            continue
        for end, weight in adj_list[start]:
            # startから出ているノードの距離を計算してheapqに入れる
            if not visited[end] and dist[start] + weight < dist[end]:
                dist[end] = dist[start] + weight
                parent[end] = start
                heapq.heappush(dist_heap, (dist[end], end))

    return parent, dist


def main():
    n = int(input())
    adj_list = []
    for _ in range(n):
        row = []
        line = input().split()
        dim = int(line[1])
        for i in range(dim):
            row.append((int(line[2 + i * 2]), int(line[2 + i * 2 + 1])))  # 番号, 重み
        adj_list.append(row)
    _, dist = dijkstra(adj_list, n)
    for i in range(n):
        print(""{} {}"".format(i, dist[i]))


if __name__ == ""__main__"":
    main()

"
4777365,ALDS1_12_C,"from heapq import heapify, heappop, heappush, heappushpop
from typing import ItemsView

INF = 1e10


class PriorityQueue:
    """"""
    優先度付きキューの
    """"""
    def __init__(self, heap):
        self.heap = heap
        heapify(self.heap)
    
    def push(self, item):
        heappush(self.heap, item)
    
    def pop(self):
        return heappop(self.heap)
    
    def pushpop(self, item):
        return heappushpop(self.heap, item)
    
    def __call__(self):
        return self.heap
    
    def __len__(self):
        return len(self.heap)
    

def dijkstra(adj: list, s: int):
    Color = [0]*N # 0: 未訪問 1: Seen 2: Visited
    D = [INF]*N #始点からの距離(重み)
    P = [None]*N #親

    D[s] = 0
    P[s] = None
    PQ = PriorityQueue([(0, s)]) #(Cost, Node)を格納し、PQにする。

    while PQ: # PQに候補がある限り

        min_cost, u = PQ.pop() # 最小コストなノードu

        Color[u] = 2 # uをVisitedに。

        if D[u] < min_cost:
            # 更新の必要なし.
            continue

        for adj_idx, adj_w in adj[u]:
            if Color[adj_idx] != 2: #訪問済みでないなら
                if D[u] + adj_w < D[adj_idx]: #最小コストを更新できるなら、
                    D[adj_idx] = D[u] + adj_w
                    P[adj_idx] = u
                    # PQに(隣接要素のコスト, 隣接要素の番号)を容れる
                    PQ.push((D[adj_idx], adj_idx))
                    Color[adj_idx] = 1
    
    return D, P

N = int(input())
adj = [[] for _ in range(N)] #(隣接ノード番号, コスト)

for _ in range(N):
    tmp = list(map(int, input().split()))
    if tmp[1] != 0:
        node = tmp[0]
        for i in range(2, 2+tmp[1]*2, 2):
            adj[node].append((tmp[i], tmp[i+1]))

D, P = dijkstra(adj, 0)

for i in range(N):
    print(i, D[i])
"
7687773,ALDS1_12_C,"import sys
from collections import deque
import heapq

BLACK = 2
GRAY = 1
WHITE = 0
def ssd():
    global adjl, N
    d = [sys.maxsize for _ in range(N)]
    d[0] = 0
    color = [ WHITE for _ in range(N)]
    heap = []
    heapq.heapify(heap)
    heapq.heappush(heap, (0, 0))

    while len(heap) != 0:
        u_node = heapq.heappop(heap)
        u = u_node[1]
        color[u] = BLACK

        if d[u] < u_node[0]:
            continue

        for v_node in adjl[u]:
            v = v_node[1]
            if color[v] != BLACK:
                if d[u] + v_node[0] < d[v]:
                    d[v] = d[u] + v_node[0]
                    heapq.heappush(heap, (d[v], v))
                    color[v] = GRAY

    for i in range(N):
        print(""{} {}"".format(i, d[i]))

N = int(input())

adjl = [[] for _ in range(N)]
for i in range(N):
    a = list(map(int, input().split()))
    u = a[0]

    for j in range(2, len(a), 2):
        # (重さ, 番号)
        adjl[u].append((a[j+1], a[j]))

ssd()

"
2187638,ALDS1_12_C,"import sys
import heapq
from collections import namedtuple
inf = float('inf')
Node = namedtuple('Node', 'd, no')

def debug(x, table):
    for name, val in table.items():
        if x is val:
            print('DEBUG:{} -> {}'.format(name, val), file=sys.stderr)
            return None

def SSSP(n, Adj):
    d = [inf] * n
    p = [-1] * n
    checked = [False] * n
    d[0] = 0
    checked[0] = True
    heap = [Node(d[0], 0)]

    while heap:
        u = heapq.heappop(heap)

        if d[u.no] < u.d:
            continue

        checked[u.no] = True

        for v, cost in Adj[u.no]:
            if not checked[v] and d[u.no] + cost < d[v]:
                d[v] = d[u.no] + cost
                p[v] = u.no
                heapq.heappush(heap, Node(d[v], v))

    return d

def solve():
    n = int(input())
    Adj = [[] for i in range(n)]

    for i in range(n):
        u, k, *line = [int(i) for i in input().split()]
        for j in range(k):
            Adj[u].append((line[2*j], line[2*j + 1]))

    # debug(Adj, locals())

    d = SSSP(n, Adj)

    for i in range(n):
        print(i, d[i])

if __name__ == '__main__':
    solve()
"
4450853,ALDS1_12_C,"from heapq import heapify, heappop, heappush, heappushpop


class PriorityQueue:
    def __init__(self, heap):
        '''
        heap ... list
        '''
        self.heap = heap
        heapify(self.heap)

    def push(self, item):
        heappush(self.heap, item)

    def pop(self):
        return heappop(self.heap)

    def pushpop(self, item):
        return heappushpop(self.heap, item)

    def __call__(self):
        return self.heap

    def __len__(self):
        return len(self.heap)


def dijkstra(graph, s, N):
    '''
    graph...隣接リスト形式 リスト内要素は(ノード, エッジ長)
    s...始点ノード
    N...頂点数

    return
    ----------
    D ... 各点までの最短距離
    P ... 最短経路木における親
    '''
    pq = PriorityQueue([])
    P = [None] * N
    D = [float('inf')] * N
    D[s] = 0
    pq.push((D[s], s))  # (最短距離, 次のノード)
    while pq:
        d, v = pq.pop()
        if D[v] < d:  # この辺を扱っても最短距離にならない
            continue  # is_visitedなくてもこれを使うことで最小のものを再び探索するのを防げる
        for to, cost in graph[v]:
            if D[to] > D[v] + cost:  # v周りにおける最短経路の候補の更新
                D[to] = D[v] + cost
                pq.push((D[to], to))
                P[to] = v
    return D, P

# load datas
N = int(input())
adj = [[] for _ in range(N)]  # (node_id, 隣接要素, 隣接nodeidとコスト)の順で格納する
'''
例
[
(0について) [(1,1235), (4,65)]
(1について) [(20,6000)]
...
]
'''
for _ in range(N):
    tmp = list(map(int, input().split()))
    if tmp[1] != 0:
        node = tmp[0]
        for i in range(2, 2 + tmp[1] * 2, 2):
            adj[node].append((tmp[i], tmp[i + 1]))

D, P = dijkstra(adj, 0,N)

for i in range(N):
    print(i, D[i])
"
4848985,ALDS1_12_C,"import heapq

def dijkstra(M, s):
    global n
    color = [0]*n
    d = [float('inf')]*n
    d[s] = 0
    PQ = []
    heapq.heapify(PQ)
    heapq.heappush(PQ, (0, s))

    while PQ:
        mincost, u = heapq.heappop(PQ)

        color[u] = 1

        if d[u] < mincost:
            continue

        for v, w in M[u]:
            if color[v] != 1:
                if d[u] + w < d[v]:
                    d[v] = d[u] + w
                    heapq.heappush(PQ, (d[v], v))

    return d

n = int(input())
M = [[] for i in range(n)]

for i in range(n):
    lst = list(map(int, input().split()))
    if lst[1] != 0:
        node = lst[0]
        for j in range(2, 2 + lst[1]*2, 2):
            M[node].append((lst[j], lst[j+1]))


d = dijkstra(M, 0)

for i in range(n):
    print(i, d[i])
"
2856416,ALDS1_12_C,"from heapq import heappush, heappop
from enum import Enum, auto

INFTY = float('inf')

class Color(Enum):
    WHITE = auto()
    GRAY = auto()
    BLACK = auto()

n = int(input())
adj_list = []
for i in range(n):
    u, k, *kv = list(map(int, input().split(' ')))
    adj_list.append(kv)

colors = []
d = []

def dijkstra(s):
    global d
    colors = [Color.WHITE for i in range(n)]
    d = [INFTY for i in range(n)]
    pque = []
    d[s] = 0

    heappush(pque, (0, s))

    while len(pque) >= 1:
        vert_u = heappop(pque)
        u = vert_u[1]
        colors[u] = Color.BLACK
        if d[u] < vert_u[0]: continue
        i = 0
        while i <= len(adj_list[u])-2:
            v = adj_list[u][i]
            if colors[v] != Color.BLACK:
                if d[u] + adj_list[u][i+1] < d[v]:
                    d[v] = d[u] + adj_list[u][i+1]
                    colors[v] = Color.GRAY
                    heappush(pque, (d[v], v))
            i += 2

dijkstra(0)
for i in range(n):
    print(i, d[i])

"
3970257,ALDS1_12_C,"def main():
    N = int(input())
    G = [[] for _ in range(N)]
    for _ in range(N):
        u, k, *vc = (int(i) for i in input().split())
        for i in range(0, len(vc), 2):
            G[u].append((vc[i], vc[i+1]))
    d = [[(1 << 63)-1, i] for i in range(N)]
    from heapq import heapify, heappop, heappush

    def dijkstra(s):
        d[s][0] = 0
        que = [(d[s][0], s)]
        heapify(que)
        finished = set()
        while len(finished) < N:
            u = heappop(que)
            while u[1] in finished:
                u = heappop(que)
            if d[u[1]][0] < u[0]:
                print('yeah')
            for v, c in G[u[1]]:
                if v in finished:
                    continue
                if d[v][0] > u[0] + c:
                    d[v][0] = u[0] + c
                    heappush(que, (d[v][0], v))
            finished.add(u[1])
    dijkstra(0)
    for i, val in enumerate(d):
        print(i, val[0])


if __name__ == '__main__':
    main()

"
4570791,ALDS1_12_C,"import sys, collections, heapq
input = lambda: sys.stdin.readline().rstrip() 
sys.setrecursionlimit(10**7)
INF = 10**10
def I(): return int(input())
def F(): return float(input())
def SS(): return input()
def LI(): return [int(x) for x in input().split()]
def LI_(): return [int(x)-1 for x in input().split()]
def LF(): return [float(x) for x in input().split()]
def LSS(): return input().split()

def dijkstra(G, s):
    que = []
    d = [INF]*len(G)
    d[s] = 0
    heapq.heappush(que, (d[s], s))

    while que:
        p = heapq.heappop(que)
        v = p[1]
        if d[v] < p[0]: continue
        for e in G[v]:
            if d[e[0]] > d[v] + e[1]:
                d[e[0]] = d[v] + e[1]
                heapq.heappush(que, (d[e[0]], e[0]))
    return d

def resolve():
    n = I()
    G = [[] for _ in range(n)]
    for i in range(n):
        ukvc = LI()
        u = ukvc[0]
        k = ukvc[1]
        for j in range(k):
            v = ukvc[2*j+2]
            c = ukvc[2*j+3]
            G[u].append((v, c))

    ans = dijkstra(G, 0)
    for i, e in enumerate(ans):
        print(i, e)

if __name__ == '__main__':
    resolve()

"
7391563,ALDS1_12_C,"from collections import defaultdict
from heapq import heappush, heappop

def dijkstra(s):
    dist = [float(""inf"") for _ in range(n)]
    dist[s] = 0
    q = [(0, s)]
    while q:
        d, v = heappop(q)
        if dist[v] < d:
            continue
        for v_next, weight in graph[v]:
            if dist[v_next] > d + weight:
                dist[v_next] = d + weight
                heappush(q, (dist[v_next], v_next))
    return dist

n = int(input())
graph = defaultdict(list)
for i in range(n):
    input_line = list(map(int, input().split()))
    u = input_line[0]
    k = input_line[1]
    for j in range(2, 2*k+2, 2):
        v = input_line[j]
        weight = input_line[j+1]
        graph[u].append((v, weight))

dist = dijkstra(0)
for i in range(n):
    print(i, dist[i])

"
7614889,ALDS1_12_C,"from heapq import heappop, heappush

def input_data(num,in_list):
    for i in range(num):
        data = list(map(int, input().split()))
        index = 0
        for j in range(data[1]):
            index += 2
            in_list[data[0]].append([data[index], data[index + 1]])

def minimum_spanning_tree(list,result):
    q = [[0, 0]]
    result[0] = 0
    while q:
        c_now, now = heappop(q)
        if result[now] < c_now:
            continue
        
        for to, c_to in list[now]:
            if result[to] > c_now + c_to:
                result[to] = c_now + c_to
                heappush(q, [c_now + c_to, to])

def min_spanning_tree_proc(num):
    dis_list = [[] for i in range(num)]
    cost_list = [float(""inf"")] * num
    input_data(num,dis_list)
    minimum_spanning_tree(dis_list,cost_list)
    return cost_list

num = int(input())
ans_list = min_spanning_tree_proc(num)

for i in range(num):
    print(i, ans_list[i])

"
8151603,ALDS1_12_C,"# 単一始点経路2
# ネットで調べた
# ダイクストラ法(辺の重みが非負整数の場合にのみ使える)

import heapq


def dijkstra(graph, start):
    
    visited = [False]*n
    distance = [INF]*n
    distance[start] = 0
    pq = [(0,start)]

    # ダイクストラ法
    while pq:
        dist, u = heapq.heappop(pq)
        if visited[u]:
            continue

        visited[u] = True

        for v, weight in graph[u]:
            if not visited[v]:
                new_distance = distance[u] + weight
                if new_distance < distance[v]:
                    distance[v] = new_distance
                    heapq.heappush(pq, (new_distance, v))
    
    return distance



INF = float('inf')

n = int(input())
graph = [[] for _ in range(n)]

for i in range(n):
    VE = list(map(int, input().split()))
    if VE[1] > 0:
        for j in range(VE[1]):
            graph[i].append((VE[2+j*2],VE[3+j*2]))
# print(graph)
start = 0
distance = dijkstra(graph, start)

for i, dist in enumerate(distance):
    print(i,dist)


"
2963049,ALDS1_12_C,"import heapq

n = int(input())

INF = 2147483647
G = [[] for i in range(n)]
check, dist = [0 for i in range(n)], [INF for i in range(n)]


def dijkstra(s):
    dist[s], pq = 0, []
    heapq.heappush(pq, (0, s))

    while len(pq) != 0:
        u = heapq.heappop(pq)
        check[u[1]] = 2

        if dist[u[1]] < u[0]:
            continue

        for v in G[u[1]]:
            if check[v[0]] != 2:
                if dist[u[1]] + v[1] < dist[v[0]]:
                    dist[v[0]], check[v[0]] = dist[u[1]] + v[1], 1
                    heapq.heappush(pq, (dist[v[0]], v[0]))


def main():
    for i in range(n):
        data = list(map(int, input().split()))
        for j in range(data[1]):
            G[data[0]].append((data[2*(j+1)], data[2*(j+1)+1]))

    dijkstra(0)

    for i in range(n):
        print(i, dist[i])


if __name__ == '__main__':
    main()

"
5503660,ALDS1_12_C,"from heapq import heapify,heappop,heappush
from sys import stdin
from pprint import pprint

INF=2**32-1
n=int(input())
####↓馬鹿か！！！入力の隣接リストとPriority Queueは全くの別物！！！よく考えろアホ
#heap=[[] for _ in range(n)]
G=[[] for _ in range(n)]
for i in range(n):
    u,k,*l=map(int,stdin.readline().split())
    if k!=0:
        for v,c in zip(l[::2],l[1::2]):
            G[u].append((v,c))
#pprint(G)

def dijkstra(adj:list,s:int):
    color=[0]*n
######↓heapを検索してノードに対応したコスト探すと時間かかるから、別のリストで保持しておかないといけない！！！
    D=[INF]*n
    P=[None]*n

    D[s]=0
    P[s]=None
#####↓後で追加、取り出しを行うので、最初のPriority Queueは初期状態で渡せば良い！！！
######↓heap=[]だと、このリストに要素が追加されていってしまう！！！アホか！！
    #heap=[s,0]
    heap=[(s,0)]
    heapify(heap)

    while heap:
        min_cost,u=heappop(heap)

    ######↓使わない！！！
        #if min_cost==INF:
        #    break
        if D[u]<min_cost:
            continue

        color[u]=1

    ######↓前問と同様に現在の最短経路に隣接するノードを絞ろうとしたが、今回は隣接リストだからそのまま取り出せば良い！！！
        #for v in range(n):
        #    if color[v]==0 and G[]
        for v_u,c_v_u in G[u]:
    ###########↓そのノードが未訪問であるという条件も忘れずに！！！
            if color[v_u]==0:
                if D[v_u] > min_cost+c_v_u:
                    D[v_u]=min_cost+c_v_u
                    heappush(heap,(min_cost+c_v_u,v_u))
                    P[v_u]=u
        
    return D,P

D,P=dijkstra(G,0)

for i in range(n):
    print(i,D[i])
"
6654683,ALDS1_12_C,"#!/usr/bin/env python3

import heapq


def dijkstra(start_vertex, graph):
    dist = [
        0 if i == start_vertex else float(""inf"") for i in range(len(graph))
    ]
    que = []
    heapq.heappush(que, (0, start_vertex))

    while que:
        cur_distance, cur_vertex = heapq.heappop(que)
        if dist[cur_vertex] < cur_distance:
            continue

        for nxt_vertex, cost in graph[cur_vertex]:
            if dist[cur_vertex] + cost < dist[nxt_vertex]:
                dist[nxt_vertex] = dist[cur_vertex] + cost
                heapq.heappush(que, (dist[nxt_vertex], nxt_vertex))

    return dist


def main():
    n = int(input())
    graph = [[] for _ in range(n)]
    for _ in range(n):
        x = [int(x) for x in input().split()]
        u, k = x[0], x[1]
        for i in range(k):
            v, c = x[i * 2 + 2:i * 2 + 4]
            graph[u].append((v, c))

    dist = dijkstra(0, graph)
    for k, v in enumerate(dist):
        print(k, v)


main()
"
3964157,ALDS1_12_C,"#!/usr/bin/env python3
import sys
import heapq
input = lambda: sys.stdin.readline()[:-1]
sys.setrecursionlimit(10**8)
inf = float('inf')
mod = 10**9+7

n=int(input())
G=[[] for i in range(n)]
for _ in range(n):
    inp = list(map(int,input().split()))
    u,k=inp[:2]
    for i in range(k):
        G[u].append((inp[2+2*i],inp[3+2*i]))

def disktra(g,s):
    n=len(g)
    dist = [inf]*n
    dist[s] = 0
    hq=[]
    heapq.heappush(hq,(dist[s],s))
    while hq:
        cost,u =heapq.heappop(hq)
        if dist[u] < cost:
            continue
        for v,c in g[u]:
            if dist[v] <= dist[u] +c:
                continue
            dist[v] = dist[u] + c
            heapq.heappush(hq,(dist[v],v))
    return dist

d=disktra(G,0)
for i in range(n):
    print(i,d[i])
"
4256641,ALDS1_12_C,"import heapq

class ShortestPath:
    def __init__(self, V, E, start, INF = float('inf')):
        self.V = V
        self.E = E 
        self.dijkstra(start, INF)

    def dijkstra(self, start, INF):
        que = list()
        self.distance = [INF] * self.V
        self.prev = [-1] * self.V
        self.distance[start] = 0
        heapq.heappush(que, (0, start))

        while len(que) > 0:
            dist, fr = heapq.heappop(que)
            if self.distance[fr] < dist:
                continue
            for to, cost in self.E[fr]:
                if self.distance[fr] + cost < self.distance[to]:
                    self.distance[to] = self.distance[fr] + cost
                    heapq.heappush(que, (self.distance[to], to))
                    self.prev[to] = fr 


V = int(input())
edge = [[] for _ in range(V)]
for _ in range(V):
    u, _, *e = map(int, input().split())
    for t, d in zip(e[::2], e[1::2]):
        edge[u].append((t, d))

sp = ShortestPath(V, edge, 0)
for i, d in enumerate(sp.distance):
    print(i, d)

"
5356318,ALDS1_12_C,"N = int(input())
graph = [[] for _ in range(N)]
for _ in range(N):
    lst = list(map(int, input().split()))
    u, k = lst[0], lst[1]
    lst = lst[2:]
    for i in range(0, len(lst), 2):
        v, c = lst[i], lst[i+1]
        graph[u].append((c, v))

import heapq

def dijkstra(graph, num_node, start):
    hq = [(0, start)]
    heapq.heapify(hq)
    distance = [float('inf')] * num_node
    distance[start] = 0
    while hq:
        dist, node = heapq.heappop(hq)
        if dist > distance[node]:
            continue
        for d, n in graph[node]:
            now_dist = d + distance[node]
            if now_dist < distance[n]:
                distance[n] = now_dist
                heapq.heappush(hq, (now_dist, n))
    return distance

dists = dijkstra(graph, N, 0)
for i in range(N):
    print(i, dists[i])
"
8282486,ALDS1_13_A,"N = 8

rs = []
cs = []
k = int(input())
for i in range(k):
    r, c = map(int, input().split())
    rs.append(r)
    cs.append(c)


def put(col):
    for i in range(k):
        if col[rs[i]] != cs[i]:
            return
    for i in range(N):
        for j in range(N):
            if col[i] == j:
                print('Q', end='')
            else:
                print('.', end='')
            if j == N-1:
                print()


def check(x, col):
    for i, row in enumerate(reversed(col), 1):
        if (x + i == row) or (x - i == row):
            return False
    return True


def search(col):
    if len(col) == N:
        put(col)
        return
    for i in range(N):
        if i in col:
            continue
        if check(i, col) == True:
            col.append(i)
            search(col)
            col.pop()


search([])

"
8404514,ALDS1_13_A,"# coding: utf-8

from functools import partial
try:
    dummy = src
    rl = partial(src.pop, 0)
except NameError:
    rl = input
def ints():
    return list(map(int, rl().strip().split()))
def int1():
    return int(rl().strip())

from collections import defaultdict

def pr_brd(brd):
    for row in brd:
        print(*row)

def put_Q(pp, brd0=None):
    '''
    ppはQの座標の配列
    全て置いた後の空きの座標と盤面を返す
    '''
    h = 8
    if brd0 is None:
        brd = [[0] * h for _ in range(h)]
    else:
        brd = [row.copy() for row in brd0]
    for p in pp:
        i, j = p
        brd[i][j] = 2
        for di, dj in ((1, 0), (1, 1), (0, 1), (-1, 1),
                       (-1, 0), (-1, -1), (0, -1), (1, -1)):
            i, j = p
            while True:
                i += di
                j += dj
                if 0 <= i < h and 0 <= j < h:
                    brd[i][j] = 1
                else:
                    break
    s = dict()
    for i in range(h):
        for j in range(h):
            if brd[i][j] == 0:
                s.setdefault(i, []).append(j)
    return s, brd

def dfs(s, brd, k, ans, st=None):
    '''
    sの一番小さなキー（行番号）を選ぶ
    '''
    if st is None:
        st = []
    if s == dict():
        if len(st) == k:
            ans.append(tuple(st))
        return
    r = sorted(s)[0]
    for c in s[r]:
        s2, brd2 = put_Q([(r, c)], brd)
        dfs(s2, brd2, k, ans, st + [(r, c)])

def pr_ans(ans):
    h = 8
    brd = [['.'] * h for _ in range(h)]
    for i, j in ans:
        brd[i][j] = 'Q'
    for row in brd:
        print(''.join(row))
        
#@psecs
def main():
    n = int1()
    pp = [tuple(ints()) for _ in range(n)]
    
    # 初期状態
    # ppを入力して空き（行番号：列番号の配列）と盤面を得る
    s, brd = put_Q(pp)
    
    # ここからDFS
    ans = [] # ここには座標のタプルが入る
    k = 8 - n # 残りのQの数
    dfs(s, brd, k, ans)
    
    # 答えを表示
    pr_ans(pp + list(ans[0]))
    
if __name__ == '__main__':
    main()

"
8751621,ALDS1_13_A,"from itertools import combinations, permutations, product
import sys


def printe(*args, end=""\n"", **kwargs):
    print(*args, end=end, file=sys.stderr, **kwargs)


def main():
    k = int(input())
    queens: set[tuple[int, int]] = {
        tuple(map(int, input().split())) for _ in range(k)}
    queens_r = set(range(8))
    queens_c = set(range(8))
    for queen in queens:
        queens_r.discard(queen[0])
        queens_c.discard(queen[1])

    queens_r_l = sorted(queens_r)
    for queen_c in permutations(queens_c):

        current_queens = queens.copy()
        for r, c in zip(queens_r_l, queen_c):
            current_queens.add((r, c))

        res = True
        for queen1, queen2 in combinations(current_queens, r=2):
            if queen1[0] == queen2[0]:
                res = False
                break
            if queen1[1] == queen2[1]:
                res = False
                break
            if queen1[0] + queen1[1] == queen2[0] + queen2[1]:
                res = False
                break
            if queen1[0] - queen1[1] == queen2[0] - queen2[1]:
                res = False
                break

        if not res:
            continue

        res_board = [['.' for _ in range(8)] for _ in range(8)]
        for r, c in current_queens:
            res_board[r][c] = 'Q'
        for row in res_board:
            print("""".join(row))
        return


if __name__ == ""__main__"":
    main()

"
8861904,ALDS1_13_A,"# aizu_ALDS1_13_A_8QueensProblem.py  

n = int(input())
board = [ ['.']*8 for _ in range(8)]
chk_r,chk_c = [0]*8,[0]*8
chk_u,chk_d = [0]*15,[0]*15

for _ in range(n):
    r,c = map(int,input().split())
    board[r][c] = 'Q'
    chk_r[r] += 1
    chk_c[c] += 1
    chk_u[r+c] += 1
    chk_d[r-c+7] += 1

cnt = 8-n
def put(place,cnt):
    if cnt ==0:
        for r in range(8):
            print(*board[r],sep='')
        exit()
    for p in range(place,64):
        r = p //8
        c = p % 8
        if board[r][c] !='.': continue
        if chk_r[r] !=0: continue
        if chk_c[c] != 0: continue
        if chk_u[r+c] != 0: continue
        if chk_d[r-c+7] != 0: continue
        board[r][c] = 'Q'
        chk_r[r] += 1
        chk_c[c] += 1
        chk_u[r+c] += 1
        chk_d[r-c+7] += 1        
        put(p+1,cnt-1)
        board[r][c] = '.'
        chk_r[r] -= 1
        chk_c[c] -= 1
        chk_u[r+c] -= 1
        chk_d[r-c+7] -= 1         

put(0,cnt)
"
8877161,ALDS1_13_A,"def main() -> None:
    import sys

    input = sys.stdin.readline

    k = int(input())
    preset = []
    for _ in range(k):
        r, c = map(int, input().split())
        preset.append((r, c))

    board = []

    def duplication(x, y):
        for x1 in range(x):
            y1 = board[x1]
            if abs(x - x1) == abs(y - y1):
                return True
        return False

    def queen(x):
        if x == 8:
            f = True
            for r,c in preset:
                if board[r] != c:
                    f = False
            if f:
                ans = [["".""] * 8 for _ in range(8)]
                for r in range(8):
                    c = board[r]
                    ans[r][c] = ""Q""
                for b in ans:
                    print(*b, sep="""")
                exit()

        for y in range(8):
            if y in board or duplication(x, y):
                continue
            board.append(y)
            queen(x + 1)
            board.pop()

    queen(0)


if __name__ == ""__main__"":
    main()

"
8885374,ALDS1_13_A,"def printBoard():
    for x,y in board:
        if row[x] != y:
            return
    
    for i in range(N):
        for j in range(N):
            if row[i] == j:
                print(""Q"",end="""")
            else :
                print(""."",end="""")
        print()

def putQueen(i):
    if i == N:
        printBoard()
        return
    
    for j in range(N):

        if col[j] == 1 or dpos[i + j] == 1 or dneg[i - j + N -1] == 1:
            continue

        row[i] = j
        col[j] = dpos[i + j] = dneg[i - j + N - 1] = 1
        putQueen(i+1)
        row[i] = col[j] = dpos[i + j] = dneg[i - j + N - 1] = -1


N = 8
board = []
row = [-1]*N
col = [-1]*N
dpos = [-1] * (2 * N - 1)
dneg = [-1] * (2 * N - 1)

k = int(input())

for i in range(k):
    x,y = map(int,input().split())
    board.append((x,y))

putQueen(0)

    
"
8894536,ALDS1_13_A,"# チェス盤の初期設定
BOARD_SIZE = 8
chess_board = [['.'] * BOARD_SIZE for _ in range(BOARD_SIZE)]

def main():
    global chess_board
    # クイーン位置の読み込み
    k = int(input())
    for _ in range(k):
        i,j = map(int, input().split())
        chess_board[i][j] = 'Q'
    # 8クイーン問題を解く
    solve_nqueens(0)
    for cb in chess_board:
        print(''.join(cb))

# nクイーン問題を解く
def solve_nqueens(col):
    global chess_board
    # 終端条件
    if col >= BOARD_SIZE:
        return True
    # 1列ずつクイーンを配置していく
    # 同列にクイーンがいたら次列の探索に移る
    for i in range(BOARD_SIZE):
        if chess_board[i][col] == 'Q':
            return solve_nqueens(col+1)
    # 同列にクイーンがいない場合
    # 列内のマスについて、1マスずつ、そのマスにクイーンが置けるかチェック
    for i in range(BOARD_SIZE):
        if can_put(i, col):
            chess_board[i][col] = 'Q'
            # クイーンを置ける場合、次列の探索に移る
            if solve_nqueens(col+1):
                # 全列に置ければ探索終了
                return True
            # 次列以降でクイーンが置けない列があった場合、置き直し
            chess_board[i][col] = '.'
    return False

# 指定したマスにクイーンを置けるか
def can_put(row, col):
    global chess_board
    # 置けないパターン
    # 1. 同行にクイーンがいる場合
    for i in range(BOARD_SIZE):
        if chess_board[row][i] == 'Q':
            return False
    # 2. 右下->左上のラインにクイーンがいる場合
    for i,j in zip(range(row,-1,-1), range(col,-1,-1)):
        if chess_board[i][j] == 'Q':
            return False
    # 3. 左下->右上のラインにクイーンがいる場合
    for i,j in zip(range(row,-1,-1), range(col,BOARD_SIZE,1)):
        if chess_board[i][j] == 'Q':
            return False
    # 4. 右上->左下のラインにクイーンがいる場合
    for i,j in zip(range(row,BOARD_SIZE,1), range(col,-1,-1)):
        if chess_board[i][j] == 'Q':
            return False
    # 5. 左上->右下のラインにクイーンがいる場合
    for i,j in zip(range(row,BOARD_SIZE,1), range(col,BOARD_SIZE,1)):
        if chess_board[i][j] == 'Q':
            return False
    # 1~5すべて該当しなければ、置いてOK
    return True


if __name__ == '__main__':
    main()
"
8905076,ALDS1_13_A,"import itertools

n = int(input())

xs = []
ys = []
xy = []
for i in range(n):
    a = list(map(int, input().split()))
    xs.append(a[1])
    ys.append(a[0])
    xy.append(a)

searchY = []
for i in range(8):
    if i not in ys:
        searchY.append(i)

searchX = []
for i in range(8):
    if i not in xs:
        searchX.append(i)
ans = []
for t in itertools.permutations(searchY, len(searchY)):
    piecesMinus = set()
    piecesPlus = set()
    piece = []
    for i, k in zip(t,searchX):
        piecesMinus.add(i - k)
        piecesPlus.add(i + k)
        piece.append([i, k])
    for i in xy:
        piecesPlus.add(i[0] + i[1])
        piecesMinus.add(i[0] - i[1])
    piece = piece + xy
    if len(piecesPlus) == 8 and len(piecesMinus) == 8:
        ans = piece
        break

ansGrid = [[""."" for _ in range(8)] for _ in range(8)]
for i in ans:
    ansGrid[i[0]][i[1]] = ""Q""

for i in ansGrid:
    for k in i:
        print(k, end="""")
    print("""")
"
8967748,ALDS1_13_A,"class Grid:
    __slots__ = [""grid"", ""cols"", ""diago0"", ""diago1""]
    grid: list[int]
    cols: int
    diago0: int
    diago1: int

    def __init__(self):
        self.grid = [-1] * 8
        self.cols = 0
        self.diago0 = 0
        self.diago1 = 0

    def put(self, row: int, col: int):
        if self.cols & (1 << col):
            return False
        if self.diago0 & (1 << (row + col)):
            return False
        if self.diago1 & (1 << (row - col + 7)):
            return False

        self.cols += 1 << col
        self.diago0 += 1 << (row + col)
        self.diago1 += 1 << (row - col + 7)

        self.grid[row] = col
        return True

    def remove(self, row: int):
        col = self.grid[row]
        self.grid[row] = -1
        self.cols -= 1 << col
        self.diago0 -= 1 << (row + col)
        self.diago1 -= 1 << (row - col + 7)


def dp(row: int, grid: Grid):
    if row == 8:
        return True

    if grid.grid[row] != -1:
        return dp(row + 1, grid)

    for col in range(8):
        if grid.put(row, col):
            if dp(row + 1, grid):
                return True
            else:
                grid.remove(row)

    return False


if __name__ == ""__main__"":
    N = int(input())
    grid = Grid()

    for _ in range(N):
        row, col = map(int, input().split())
        grid.put(row, col)

    dp(0, grid)

    for col in grid.grid:
        for _ in range(col):
            print(""."", end="""")
        print(""Q"", end="""")
        for _ in range(col + 1, 8):
            print(""."", end="""")
        print()

"
9010681,ALDS1_13_A,"def put_queen(row):
    if row >= 8:
        print(*['.' * p + 'Q' + '.' * (7 - p) for p in place], sep='\n')
        exit()
    if place[row] >= 0:
        put_queen(row + 1)
    else:
        for column in range(8):
            for i in range(8):
                if i == row or place[i] < 0:
                    continue
                if place[i] in (column, column - row + i, column + row - i):
                    break
            else:
                place[row] = column
                put_queen(row + 1)
                place[row] = -1


place = [-1] * 8
n = int(input())
for _ in range(n):
    y, x = map(int, input().split())
    place[y] = x
put_queen(0)

"
9114543,ALDS1_13_A,"# https://onlinejudge.u-aizu.ac.jp/problems/ALDS1_13_A
def ok(i, j):
    di, dj = [1, 0, -1, 0, -1, -1, 1, 1], [0, 1, 0, -1, -1, 1, 1, -1]
    for d in range(8):
        i_tmp, j_tmp = i, j
        while 0 <= i_tmp < N and 0 <= j_tmp < N:
            if A[i_tmp][j_tmp] == 'Q':
                return False
            i_tmp += di[d]
            j_tmp += dj[d]
    return True

def dfs(k):
    if k == 8:
        [print(*a, sep='') for a in A]
        exit()
    if 'Q' in A[k]:
        dfs(k + 1)
    for j in range(N):
        if ok(k, j):
            A[k][j] = 'Q'
            dfs(k + 1)
            A[k][j] = '.'

K = int(input())
N = 8
A = [['.'] * N for _ in range(N)]
for _ in range(K):
    r, c = map(int, input().split())
    A[r][c] = 'Q'
dfs(0)

"
5767236,ALDS1_13_A,"from itertools import permutations


K = int(input())
upper_cross, lower_cross, horizontal, vertical = [set() for _ in range(4)]
answer = [['.']*8 for _ in range(8)]
for _ in range(K):
    x, y = map(int, input().split())
    answer[x][y] = 'Q'
    upper_cross.add(x-y)
    lower_cross.add(x+y)
    horizontal.add(x)
    vertical.add(y)
remaind_horizontal = [i for i in range(8) if i not in horizontal]
remaind_vertical = [i for i in range(8) if i not in vertical]
for h_candidate in permutations(remaind_horizontal):
    tmp_upper = upper_cross.copy()
    tmp_lower = lower_cross.copy()
    for h, v in zip(h_candidate, remaind_vertical):
        if h-v in tmp_upper or h+v in tmp_lower:
            break
        tmp_upper.add(h-v)
        tmp_lower.add(h+v)
    else:
        break
for h, v in zip(h_candidate, remaind_vertical):
    answer[h][v] = 'Q'
for line in answer:
    print(''.join(line))

"
8314857,ALDS1_13_A,"import itertools as it

K = int(input())
X = []
Y = []
for _ in range(K):
    x, y = map(int, input().split())
    X.append(x)
    Y.append(y)

F = []
for _ in range(8):
    F.append(["".""]*8)
for i in range(K):
        F[X[i]][Y[i]] = ""Q""

S = list(set(i for i in range(8)) - set(X))
T = list(set(i for i in range(8)) - set(Y))
Perm = list(it.permutations(T))

for perm in Perm:
    for i in range(len(perm)):
        F[S[i]][perm[i]] = 'Q'
    P = True

    for i in range(8):
        c = 0
        for j in range(8 - i):
            if F[j][i + j] == 'Q':
                c += 1
                if c == 2:
                    break
        if c == 2:
            P = False
            break

    for i in range(1, 8):
        c = 0
        for j in range(8 - i):
            if F[i + j][j] == 'Q':
                c += 1
                if c == 2:
                    break
        if c == 2:
            P = False
            break
    
    for i in range(8):
        c = 0
        for j in range(i + 1):
            if F[i - j][j] == 'Q':
                c += 1
                if c == 2:
                    break
        if c == 2:
            P = False
            break
    
    for i in range(1, 8):
        c = 0
        for j in range(8 - i):
            if F[7 - j][i + j] == 'Q':
                c += 1
                if c == 2:
                    break
        if c == 2:
            P = False
            break
    
    if P:
        for i in range(8):
            print("""".join(F[i]))
        exit()

    F = []
    for _ in range(8):
        F.append(["".""]*8)
    for i in range(K):
            F[X[i]][Y[i]] = ""Q""
"
8439213,ALDS1_13_A,"def check(x,y):
    if x < 0 or y < 0 or x >= 8 or y >= 8:
        return False
    return True

k = int(input())
t = {}
for i in range(k):
    x,y = map(int,input().split())
    t[x] = y
from itertools import permutations
for i in permutations(range(8)):
    flg = True
    for j in range(8):
        if j in t and t[j] != i[j]:
            flg = False
            break
    if not flg:
        continue
    d = [(1,1),(-1,1),(1,-1),(-1,-1)]
    for j in range(8):
        for k in d:
            x,y = (j,i[j])
            x += k[0]
            y += k[1]
            while check(x,y):
                if i[x] == y:
                    flg = False
                    break
                x += k[0]
                y += k[1]
            if not flg:
                break
        if not flg:
            break
    if not flg:
        continue
    for j in range(8):
        k = ["".""] * 8
        k[i[j]] = ""Q""
        print("""".join(k))
    break
"
8487281,ALDS1_13_A,"#queen problem
import itertools


def is_false_positions(positions):
	global N 
	for i in range(N):
		if positions[ini[i][0]] != ini[i][1]:
			return 1
	return 0



def is_fine_positions(positions):

	def update_board(row,col):
		for d_r,d_c in [[-1,-1],[-1,1],[1,-1],[1,1],[-1,0],[0,-1],[1,0],[0,1]]:
			r,c=row,col
			while 1:
				r=r+d_r
				c=c+d_c
				if ( not 0<=r<8 ) or ( not 0<=c<8 ):
					break
				chess_board[r][c] = 1

	chess_board = [ [0]*8 for _ in range(8) ]
	for row in range(8):
		col = positions[row]
		if chess_board[row][col] == 1:
			#row行目を置くのに失敗なのでfalseを返し終了.
			return 0
		update_board(row,col)
	return 1


def print_positions(positions):
	for row in range(8):
		row_string = """"
		for i in range(positions[row]):
			row_string += "".""
		row_string += ""Q""
		for i in range(7-positions[row]):
			row_string += "".""
		print(row_string)



#input
N=int(input())
ini=[list(map(int,input().split())) for _ in range(N)]


for positions in itertools.permutations(range(8)):
	#print(positions)
	
	if is_false_positions(positions):
		#print(""no"")
		continue
	#print(f""now:{positions}"")

	if is_fine_positions(positions):
		print_positions(positions)
		break




	

"
8817518,ALDS1_13_A,"from itertools import permutations


k = int(input())
queens = {}
for _ in range(k):
   r, c = map(int, input().split())
   queens[r] = c
   
   
for p in permutations(range(8)):
   ok = True
   for i in range(8):
       if i in queens:
           if p[i] != queens[i]:
               ok = False
               break
   if not ok:
       continue
   naname1 = [p[i] - i for i in range(8)]
   naname2 = [p[i] + i for i in range(8)]
   if len(naname1) > len(set(naname1)):
       ok = False
   if len(naname2) > len(set(naname2)):
       ok = False
   if ok:
       ans = p
       break


for i in range(8):
   for j in range(8):
       if j == ans[i]:
           print('Q', end='')
       else:
           print('.', end='')
       if j == 7:
           print('')
"
8951098,ALDS1_13_A,"N=int(input())
ans=[]
for i in range(N):
    y,x=map(int,input().split())
    ans.append([y,x])

count = 0 # 駒の置き方が何通りか格納する変数
board = [] # 盤上に置かれた駒を表すリスト

def deplication(x, y):
    """"""斜めの重複チェック""""""
    for x1 in range(0, x):
        y1 = board[x1]
        if abs(x - x1) == abs(y - y1):
            return True
    return False


def n_queen(n, x):
    """"""
    xはクイーンを配置する行
    yはクイーンを配置する列
    1行ずつ配置していき最後の行まで配置できたらcountを+1する
    """"""
    global count
    if n == x:
        flag=1
        for y,x in ans:
            if board[y]!=x:
                flag=0
                break
        if flag:
            s=[[""."" for _ in range(8)]for _ in range(8)]
            for y in range(8):
                s[y][board[y]]=""Q""
            for l in s:
                print("""".join(l))

    else:
        for y in range(0, n):
            if y in board or deplication(x, y):
                continue
            board.append(y)
            n_queen(n, x + 1)
            board.pop()


n_queen(8, 0)






"
9091577,ALDS1_13_A,"import sys

def check():
    def resolve(grid,ans,rest,preserved_row,preserved_col):
        for h in range(8):
            for w in range(8):
                if h not in preserved_row and w not in preserved_col and grid[h][w]:
                    rest-=1
                    ans[h][w]=""Q""
                    if not rest:
                        for r in ans:
                            print("""".join(r))
                        sys.exit()
                    preserved_row.add(h)
                    preserved_col.add(w)
                    grid[h][w]=False
                    change_coor=set()
                    for i in range(1,8):
                        nh,nw=h-i,w-i
                        if 0<=nh:
                            if 0<=nw:
                                if grid[nh][nw]:
                                    grid[nh][nw]=False
                                    change_coor.add((nh,nw))
                            nw=w+i
                            if nw<8:
                                if grid[nh][nw]:
                                    grid[nh][nw]=False
                                    change_coor.add((nh,nw))
                        nh,nw=h+i,w-i
                        if nh<8:
                            if 0<=nw:
                                if grid[nh][nw]:
                                    grid[nh][nw]=False
                                    change_coor.add((nh,nw))
                            nw=w+i
                            if nw<8:
                                if grid[nh][nw]:
                                    grid[nh][nw]=False
                                    change_coor.add((nh,nw))
                    resolve(grid,ans,rest,preserved_row,preserved_col)
                    rest+=1
                    preserved_row.remove(h)
                    preserved_col.remove(w)
                    ans[h][w]="".""
                    grid[h][w]=True
                    for ch,cw in change_coor:
                        grid[ch][cw]=True

    input=lambda:sys.stdin.readline().rstrip()
    grid=[[True]*8 for _ in range(8)]
    ans=[["".""]*8 for _ in range(8)]
    preserved_row=set()
    preserved_col=set()
    n=int(input())
    rest=8-n
    for _ in range(n):
        h,w=map(int,input().split())
        preserved_row.add(h)
        preserved_col.add(w)
        ans[h][w]=""Q""
        grid[h][w]=False
        for i in range(1,8):
            nh,nw=h-i,w-i
            if 0<=nh:
                if 0<=nw:
                    grid[nh][nw]=False
                nw=w+i
                if nw<8:
                    grid[nh][nw]=False
            nh,nw=h+i,w-i
            if nh<8:
                if 0<=nw:
                    grid[nh][nw]=False
                nw=w+i
                if nw<8:
                    grid[nh][nw]=False
    if rest:
        resolve(grid,ans,rest,preserved_row,preserved_col)
    for r in ans:
        print("""".join(r))
check()
"
2741969,ALDS1_13_A,"N = 8
board = [['.'] * N for i in range(N)]
k = int(input())
for i in range(k):
    pos = list(map(int, input().split()))
    board[pos[0]][pos[1]] = 'Q'


def is_safe(board, row, col):
    for i in range(N):
        if board[row][i] == 'Q':
            return False

    for i, j in zip(range(row, -1, -1), range(col, -1, -1)):
        if board[i][j] == 'Q':
            return False

    for i, j in zip(range(row, -1, -1), range(col, N, 1)):
        if board[i][j] == 'Q':
            return False

    for i, j in zip(range(row, N, 1), range(col, -1, -1)):
        if board[i][j] == 'Q':
            return False
    
    for i, j in zip(range(row, N, 1), range(col, N, 1)):
        if board[i][j] == 'Q':
            return False

    return True

def solve(board, col):
    if col >= N:
        return True

    for i in range(N):
        if board[i][col] == 'Q':
            return solve(board, col + 1)
        
    for i in range(N):
        if is_safe(board, i, col):
            board[i][col] = 'Q'
            if solve(board, col + 1):
                return True
            board[i][col] = '.'

    return False


solve(board, 0)
for i in range(N):
    print(''.join(board[i]))

"
2773495,ALDS1_13_A,"# -*- coding: utf-8 -*-


if __name__ == '__main__':

    N = 8
    FREE = -1
    NOT_FREE = 1
    row = [FREE] * N
    col = [FREE] * N
    dpos = [FREE] * (2 * N - 1)
    dneg = [FREE] * (2 * N - 1)
    X = [[""."" for _ in range(N)] for _ in range(N)]

    k = int(input())
    for _ in range(k):
        i, j = map(int, input().split())
        X[i][j] = ""Q""
        row[i] = col[j] = dpos[i + j] = dneg[i - j + N - 1] = NOT_FREE

    def printBoard(X):
        for i in range(N):
            print("""".join(X[i]))

    def recursive(i):
        if i == N:
            printBoard(X)
            return
        if ""Q"" in X[i]:
            recursive(i + 1)

        for j in range(N):
            if NOT_FREE in [row[i], col[j], dpos[i + j], dneg[i - j + N - 1]]:
                continue
            else:
                X[i][j] = ""Q""
                row[i] = col[j] = dpos[i + j] = dneg[i - j + N - 1] = NOT_FREE
            recursive(i + 1)
            X[i][j] = "".""
            row[i] = col[j] = dpos[i + j] = dneg[i - j + N - 1] = FREE

    recursive(0)

"
2790812,ALDS1_13_A,"# -*- coding: utf-8 -*-

import sys


BOARD_SIZE_W = 8
BOARD_SIZE_H = 8


def set_queen(board, queen_point):
    """"""
    クイーンを指定座標に配置した後、残りの配置可能な位置の配列を返す
    """"""
    return filter(create_queen_filter(queen_point), board)


def create_queen_filter(queen_point):
    """"""
    指定位置にクイーンを配置したことにより、対象座標へ配置不可能にならないかを確認する関数を返す
    """"""

    def queen_filter(new_point):
        return new_point[1] != queen_point[1] and \
            new_point[0] != queen_point[0] and \
            new_point[0] != new_point[1] + queen_point[0] - queen_point[1] and \
            new_point[0] != -new_point[1] + queen_point[0] + queen_point[1]
    return queen_filter


def get_board_string(queen_points):
    """"""
    クイーンの位置座標の配列を指定出力形式に変換する
    """"""
    queen_points_set = set(list(map(lambda point: ""{}:{}"".format(point[1], point[0]), queen_points)))
    board_string_lines = []
    for y in range(BOARD_SIZE_H):
        line = """"
        for x in range(BOARD_SIZE_W):
            if ""{}:{}"".format(x, y) in queen_points_set:
                line += ""Q""
            else:
                line += "".""
        board_string_lines.append(line)
    return ""\n"".join(board_string_lines)


def get_all_queen_points(board, queen_points):
    if len(queen_points) >= 8:
        return queen_points
    elif not board:
        return []
    for empty_point in board:
        new_queen_points = [empty_point]
        new_queen_points.extend(queen_points)
        new_queen_points = get_all_queen_points(list(set_queen(board, empty_point)), new_queen_points)
        if new_queen_points:
            return get_all_queen_points(list(set_queen(board, empty_point)), new_queen_points)


def main():
    inputStr = sys.stdin.read()
    lines = inputStr.split(""\n"")
    lines = list(filter(lambda line: line, lines))
    if len(lines) <= 1:
        lines = []
    else:
        lines = lines[1:]
    queen_points = list(map(lambda line: list(map(int, line.split("" ""))), lines))
    board = [[i % BOARD_SIZE_W, i // BOARD_SIZE_H] for i in range(BOARD_SIZE_H * BOARD_SIZE_W)]
    for queen_point in queen_points:
        board = list(set_queen(board, queen_point))
    sys.stdout.write(get_board_string(get_all_queen_points(board, queen_points)) + ""\n"")


if __name__ == '__main__':
    main()

"
2846203,ALDS1_13_A,"# 8 Queens Problem
[N, FREE, NOT_FREE] = [8, -1, 1]
initial_Q = [FREE for i in range(N)]
row = [FREE for i in range(N)]
col = [FREE for i in range(N)]
dneg = [FREE for i in range(N*2 - 1)]
dpos = [FREE for i in range(N*2 - 1)]

k = int(input())
for i in range(k):
    [r, c] = list(map(int, input().split()))
    initial_Q[r] = NOT_FREE
    row[r] = c
    [col[c], dpos[r + c], dneg[r - c + N - 1]] = [NOT_FREE, NOT_FREE, NOT_FREE]

def printBoard():
    global N, row
    for i in range(N):
        row_data = [""."" for i in range(N)]
        row_data[row[i]] = ""Q""
        print("""".join(row_data))
    
def putQueen(i):
    global N, FREE, NOT_FREE
    global initial_Q
    global row, col, dneg, dpos
    if i == N:
        printBoard()
        return 1
    
    if initial_Q[i] != FREE:
        if putQueen(i + 1) == 1:
            return 1
        else:
            return 0
    else:
        for j in range(N):
            if col[j] == NOT_FREE or dpos[i + j] == NOT_FREE or dneg[i - j + N - 1] == NOT_FREE:
                continue
            row[i] = j
            [col[j], dpos[i + j], dneg[i - j + N - 1]] = [NOT_FREE, NOT_FREE, NOT_FREE]
            if putQueen(i + 1) == 1:
                return 1
            row[i] = FREE
            [col[j], dpos[i + j], dneg[i - j + N - 1]] = [FREE, FREE, FREE]

    return 0

putQueen(0)
"
2856476,ALDS1_13_A,"
N = 8 # クイーンの数
n = int(input())

raw = [-1 for i in range(N)]
col = [0 for i in range(N)] # FREE: 0, NOT_FREE: 1
dpos = [0 for i in range(2*N-1)] # FREE: 0, NOT_FREE: 1
dneg = [0 for i in range(2*N-1)] # FREE: 0, NOT_FREE: 1


def put_queen(i):
	if i == N:
		return True
	elif raw[i] != -1:
		if put_queen(i+1):
			return True
		else :
			return False
	else:
		for j in range(N):
			if col[j] == 1 or dpos[i+j] == 1 or dneg[i-j+N-1] == 1:
				continue
			raw[i] = j
			col[j] = dpos[i+j] = dneg[i-j+N-1] = 1
			if put_queen(i+1):
				return True
			else :
				raw[i] = -1
				col[j] = dpos[i+j] = dneg[i-j+N-1] = 0
		return False


def output_result():
	for i in range(N):
		out_raw = ['.' for i in range(N)]
		out_raw[raw[i]] = 'Q'
		print(''.join(map(str, out_raw)))


for i in range(n):
	r, c = map(int, input().split())
	raw[r] = c
	col[c] = dpos[r+c] = dneg[r-c+N-1] = 1

put_queen(0)
output_result()
"
2857407,ALDS1_13_A,"N = 8


def putQueen(i):
    if i == N:
        printBoard()
        return

    if i in default:
        putQueen(i+1)

    else:
        for j in range(N):
            if col [j]   or \
               dpos[i+j] or \
               dneg[i-j+N-1]:
                continue

            tmp = row[i]
            row[i] = j
            col[j] = dpos[i+j] = dneg[i-j+N-1] = True

            putQueen(i+1)

            row[i] = tmp
            col[j] = dpos[i+j] = dneg[i-j+N-1] = False


def printBoard():
    for i in range(N):

        line = ''
        for j in range(N):
            if row[i] == j: line += 'Q'
            else          : line += '.'

        print(line)


if(__name__ == '__main__'):
    row  = [None] * N
    col  = [False] * N
    dpos = [False] * (2*N - 1)
    dneg = [False] * (2*N - 1)

    default = []

    n = int(input())

    for _ in range(n):
        r, c = [int(i) for i in input().split()]

        row[r] = c
        col[c] = dpos[r+c] = dneg[r-c+N-1] = True

        default.append(r)

    putQueen(0)

"
2862087,ALDS1_13_A,"FREE = -1
NOT_FREE = 1

N = 8
B = [["".""] * N for _ in range(N)]
row = [FREE] * N
col = [FREE] * N
dpos = [FREE] * (2 * N - 1)
dneg = [FREE] * (2 * N - 1)

def update(r, c, FREE_OR_NOT):
    B[r][c] = ""."" if FREE_OR_NOT == FREE else ""Q""
    row[r] = col[c] = dpos[r + c] = dneg[r - c + N - 1] = FREE_OR_NOT

def draw():
    for i in range(N):
        print("""".join(B[i]))

def recursive(i):
    if i == N:
        draw()
        return
    if ""Q"" in B[i]:
        recursive(i + 1)

    for j in range(N):
        if NOT_FREE in [row[i], col[j], dpos[i + j], dneg[i - j + N - 1]]:
            continue
        else:
            update(i, j, NOT_FREE)
        recursive(i + 1)
        update(i, j, FREE)

k = int(input())

for _ in range(k):
    r, c = map(int, input().split())
    update(r, c, NOT_FREE)
recursive(0)
"
2994600,ALDS1_13_A,"k = int(input())
row = [1] * 8
col = [1] * 8
dpos = [1] * 15
dneg = [1] * 15
X = [['.' for j in range(8)] for i in range(8)]
for i in range(k):
    r, c = map(int, input().split())
    row[r] = col[c] = dpos[r+c] = dneg[r-c+7] = 0
    X[r][c] = 'Q'

def solve(i):
    while i < 8 and not row[i]:i += 1        
    if i == 8:
        for i in range(8):
            print(''.join(X[i]))
    for j in range(8):
        if not col[j] or not dpos[i+j] or not dneg[i-j+7]: continue
        row[i] = col[j] = dpos[i+j] = dneg[i-j+7] = 0
        X[i][j] = 'Q'
        solve(i+1)
        row[i] = col[j] = dpos[i+j] = dneg[i-j+7] = 1
        X[i][j] = '.'
solve(0)
"
3060851,ALDS1_13_A,"import sys
N = 8
board = [[0 for j in range(N)] for i in range(N)]
queen = [-1] * N

def main():
    init()
    search(0)

def search(i):
    if i == N:
        printBoard()
        sys.exit()
    
    if queen[i] != -1:
        search(i + 1)

    else :
        for j in range(N):
            if board[i][j] == 0:
                queen[i] = j
                changeBoard(i, j, 1)
                search(i + 1)
                changeBoard(i, j, -1)
                queen[i] = -1

def init():
    k = int(input())

    for i in range(k):
        a = list(map(int, input().split()))
        queen[a[0]] = a[1]
        changeBoard(a[0], a[1], 1)

def changeBoard(i, j, number):
    for k in range(N):
        board[i][k] += number
        board[k][j] += number

    if i > j :
        for k in range(N - (i - j)) :
            board[k + (i - j)][k] += number
    else:
        for k in range(N - (j - i)) :
            board[k][k + (j - i)] += number
    if i + j < N :
        for k in range(i + j + 1) :
            board[i + j - k][k] += number
    else:
        for k in range(i + j - N + 1, N):
            board[i + j - k][k] += number

def printBoard():
    for i in range(N):
        for j in range(N):
            if queen[i] == j:
                print('Q' ,end = """")
            else:
                print('.' ,end = """")
        print()

if __name__ == '__main__':
    main()
"
3102990,ALDS1_13_A,"def check(a):
    flag = True
    for i in C:
        if (i[0] == a[0]) or (i[1] == a[1]) or (abs(i[0]-a[0]) == abs(i[1]-a[1])):
            flag = False
    return flag

def recq(r):
    if r == 8:
        pass
    elif DPr[r] == 1:
        recq(r+1)
    else:
        for c in range(8):
            if DPc[c]:
                continue
            else:
                if check((r,c)):
                    DPr[r] = 1
                    DPc[c] = 1
                    C.append([r,c])
                    recq(r+1)
                    flag = False
                    for i in range(8):
                        if DPr[i]==0:
                            flag = True
                    if flag:
                        C.pop()
                        DPr[r] = 0
                        DPc[c] = 0
k = int(input())
C = [[int(i) for i in input().split()] for _ in range(k)]
DPr = [0 for i in range(8)]
DPc = [0 for i in range(8)]
for i in C:
    DPr[i[0]]=1
    DPc[i[1]]=1
recq(0)
Q = [[""."" for i in range(8)] for i in range(8)]
for i in C:
    Q[i[0]][i[1]] = ""Q""
for i in Q:
    tmp = """"
    for j in i:
        tmp+=j
    print(tmp)
"
3159474,ALDS1_13_A,"board = [[""."" for i in range(8)] for i in range(8)]
N = int(input())
row = [1] * 8
col = [1] * 8
dpos = [1] * 15
dneg = [1] * 15


for i in range(N):
  x, y = map(int, input().split())
  row[x] = col[y] = dpos[x+y] =dneg[x-y+7] = 0
  board[x][y] = ""Q""

def solve(i):
  while i < 8 and not row[i]:
    i += 1
  if i == 8:
    for i in range(8):
      print(''.join(board[i]))
  for j in range(8):
    if not col[j] or not dpos[i+j] or not dneg[i-j+7]:
      continue
    row[i] = col[j] = dpos[i+j] = dneg[i-j+7] = 0
    board[i][j] ='Q'
    solve(i+1)
    row[i] = col[j] = dpos[i+j] =dneg[i-j+7] = 1
    board[i][j] = '.'

solve(0)
"
3244847,ALDS1_13_A,"vert = [False] * 8
hori = [False] * 8
topright = [False] * (8 * 2 - 1)
topleft = [False] * (8 * 2 - 1)
queens = []
skip_row = []


def put_queen(x, y):
    vert[x] = True
    hori[y] = True
    topright[x + y] = True
    topleft[7 + (x - y)] = True
    queens.append((x, y))


def elim_queen(x, y):
    vert[x] = False
    hori[y] = False
    topright[x + y] = False
    topleft[7 + (x - y)] = False
    queens.remove((x, y))


def is_blank(x, y):
    if not vert[x] and not hori[y] and not topright[x+y] and not topleft[7+(x-y)]:
        return True


def search_blank_in_row(y):
    blanks = []
    for x in range(8):
        if is_blank(x, y):
            blanks.append(x)
    return blanks


def put_queen_in_row(y):
    #print(""put_queen_row"",y, queens)
    if y == 8:
        return True     # 既にQを7行に置いているので正解に到達
    if y in skip_row:
        return put_queen_in_row(y + 1)   # 前提条件にある列は無視して次の行に行く

    for x in search_blank_in_row(y):
        put_queen(x, y)
        if not put_queen_in_row(y + 1):
            elim_queen(x, y)    # クイーンを置けなかったのでx,yを取り除く
        else:
            return True
    return False    # すべての候補が失敗


def main():
    # prepare
    n = int(input())
    for i in range(n):
        x, y = map(int, input().split())
        put_queen(x, y)
        skip_row.append(y)

    # 8 queen main
    put_queen_in_row(0)

    # draw queens
    board = [list('........') for x in range(8)]
    for q_x, q_y in queens:
        board[q_x][q_y] = 'Q'
    [print(''.join(x)) for x in board]
    return


main()
"
3299781,ALDS1_13_A,"row = [False] * 8
col = [False] * 8
dpos = [False] * 15
dneg = [False] * 15


board = [['.', '.', '.', '.', '.', '.', '.', '.'] for i in range(8)]

import sys

file_input = sys.stdin

k = int(file_input.readline())

for line in file_input:
    r, c = map(int, line.split())
    row[r] = True
    col[c] = True
    dpos[r + c] = True
    dneg[r - c + 7] = True
    board[r][c] = 'Q'

def dfs(i = 0):
    if i == 8:
        for line in board:
            print(''.join(line))
    elif row[i]:
        dfs(i + 1)
    else:
        for j in range(8):
            if col[j] or dpos[i + j] or dneg[i - j + 7]:
                continue
            row[i] = True
            col[j] = True
            dpos[i + j] = True
            dneg[i - j + 7] = True
            board[i][j] = 'Q'
            dfs(i + 1)
            row[i] = False
            col[j] = False
            dpos[i + j] = False
            dneg[i - j + 7] = False
            board[i][j] = '.'

dfs()
"
3361591,ALDS1_13_A,"N = 8
tate = [True]*N
yoko = [True]*N
rnaname = [True]*(2*N-1)
lnaname = [True]*(2*N-1)
board = [[True]*N for i in range(N)]


def update(x, y, value):
    tate[x] = value
    yoko[y] = value
    rnaname[x+y] = value
    lnaname[x-y+N-1] = value
    board[x][y] = value


def check(x, y):
    if tate[x] and yoko[y] and rnaname[x+y] and lnaname[x-y+N-1]:
        return True
    return False


def show():
    for i in range(N):
        for j in range(N):
            print('.' if board[i][j] else 'Q', sep='', end='')
        print()


# iは縦ベース
def solve(i):
    if i == N:
        show()
        exit(0)
    if tate[i] is False:
        solve(i+1)
    for j in range(N):
        if check(i, j):
            update(i, j, False)
            solve(i+1)
            update(i, j, True)


n = int(input())
for i in range(n):
    Q = list(map(int, input().split()))
    update(Q[0], Q[1], False)

for i in range(N):
    if tate[i]:
        solve(i)
        break
solve(N)


"
3362536,ALDS1_13_A,"def sakuzyo(i):
    if koteirow[i] == 1:
        sakuzyo(i-1)
    else:
        for j in range(N):
            if haiti[i][j] == 'Q':
                #print('delete {} {}'.format(i, j))
                haiti[i][j] = '.'
                row[i] = 0
                col[j] = 0
                dpos[i + j] = 0
                dneg[i - j + (N - 1)] = 0
                if j == N-1:
                    sakuzyo(i-1)
                else:
                    sounyuu(i, j+1)


def sounyuu(i, j):
    if koteirow[i] == 0:
        for k in range(j, N):
            flag = 0
            if col[k] == 0 and dpos[i+k] == 0 and dneg[i-k+(N-1)] == 0:
                haiti[i][k] = 'Q'
                #print('add {} {}'.format(i, k))
                row[i] = 1
                col[k] = 1
                dpos[i+k] = 1
                dneg[i-k+(N-1)] = 1
                flag = 1
                if i == N-1:
                    for o in range(N):
                        for p in range(N):
                            print(haiti[o][p], end='')
                        print()
                    exit()
                else:
                    sounyuu(i+1, 0)
        if flag == 0:
            sakuzyo(i-1)
    elif i == N-1:
        for o in range(N):
            for p in range(N):
                print(haiti[o][p], end='')
            print()
        exit()
    else:
        sounyuu(i+1, j)


k = int(input())
data = [list(map(int, input().split()))for _ in range(k)]

N = 8
row = [0]*N
col = [0]*N
dpos = [0]*(N*2-1)
dneg = [0]*(N*2-1)
haiti = [['.']*N for _ in range(N)]
koteirow = [0]*N

for i in data:
    haiti[i[0]][i[1]] = 'Q'
    row[i[0]] = 1
    col[i[1]] = 1
    dpos[i[0]+i[1]] = 1
    dneg[i[0] - i[1] + (N - 1)] = 1
    koteirow[i[0]] = 1

sounyuu(0, 0)


"
3563302,ALDS1_13_A,"import sys
import time
input = sys.stdin.readline
FREE = True
NOT_FREE = False

num = int(input())
Q = [list(map(int, input().split())) for i in range(num)]

row = [FREE]*8
col = [FREE]*8
dpos = [FREE]*15
dneg = [FREE]*15
chess_board = [['.' for i in range(8)] for j in range(8)]

def printBoard():
    for c in chess_board:
        print("""".join(c))

def chess_init():
    for q in Q:
        i = q[0]
        j = q[1]
        chess_board[i][j] = 'Q'
        row[i] = col[j] = dpos[i+j] = dneg[i-j+7] = NOT_FREE

def putQueen(i):

    if(i == 8):
        printBoard()
        return
    
    row_idx = 0
    for j in range(8):
        if(row[j] == FREE):
            row_idx = j
            break

    for j in range(8):
        if(col[j] == NOT_FREE or dpos[row_idx+j] == NOT_FREE or dneg[row_idx-j+7] == NOT_FREE):
            continue
        # not free jya nai nara oku
        chess_board[row_idx][j] = 'Q'
        row[row_idx] = col[j] = dpos[row_idx+j] = dneg[row_idx-j+7] = NOT_FREE
        putQueen(i+1)
        # i+1 banme tansaku site kokoni kaette kitara
        # tansaku sippai = backtracking suru kara FREE ni modosu
        chess_board[row_idx][j] = '.'
        row[row_idx] = col[j] = dpos[row_idx+j] = dneg[row_idx-j+7] = FREE

if __name__ == ""__main__"":
    chess_init()
    # sudeni okareta koma igai no koma no tansaku suru
    putQueen(num)




"
3571750,ALDS1_13_A,"import sys

N = 8
row = [-1] * N
col = [0] * N
dpos = [0] * (N*2-1)
dneg = [0] * (N*2-1)


def print_board():
    for i in range(N):
        for j in range(N):
            if row[i] == j:
                print(""Q"", end='')
            else:
                print(""."", end='')
        print(""\n"", end='')


def put_queen(i):
    if i == N:
        return True
    elif row[i] != -1:
        if put_queen(i+1):
            return True
        else:
            return False
    else:
        for j in range(N):
            if col[j] == 1 or dpos[i+j] == 1 or dneg[i-j+N-1] == 1:
                continue
            row[i] = j
            col[j] = dpos[i+j] = dneg[i-j+N-1] = 1
            if put_queen(i+1):
                return True
            else:
                row[i] = -1
                col[j] = dpos[i+j] = dneg[i-j+N-1] = 0
        return False


line = sys.stdin.readline()
n = int(line)
for i in range(n):
    line = sys.stdin.readline()
    r, c = map(int, line.split())
    row[r] = c
    col[c] = dpos[r+c] = dneg[r-c+N-1] = 1

put_queen(0)
print_board()

"
3573232,ALDS1_13_A,"NOT_FREE = 1
FREE = 0

q = [0 for i in range(8)]
row = [0 for i in range(8)]
col = [0 for i in range(8)]
dneg = [0 for i in range (16)]
dpos = [0 for i in range (16)]


def printBord():
    for r in range(8):
        for c in range(8):
            if q[r] == c:
                print(""Q"",end="""")
            else: print(""."",end="""")
        print()


def putQueen(i):
    if i == 8:
        printBord()
        return
    
    if row[i]:
        if putQueen(i+1):return 

    for j in range(8):
        if (row[i] or col[j] or dpos[i+j] or dneg[i-j+7]) == NOT_FREE :continue
        q[i] = j
        col[j] = dpos[i+j] = dneg[i-j+7] = NOT_FREE
        if putQueen(i+1) : return
        col[j] = dpos[i+j] = dneg[i-j+7] = FREE
    return


if __name__=='__main__':
    k = int(input())
    for i in range(k):
        r, c = (int(x) for x in input().split())
        q[r] = c
        row[r] = col[c] = dpos[r+c] = dneg[r-c+7] = NOT_FREE
    putQueen(0)


"
3580708,ALDS1_13_A,"answer_printed = 0
answer=[]
for i in range(8):
    answer.append([])
for i in range(8):
    for j in range(8):
        answer[i].append('.')
row=[]
for i in range(8):
    row.append('.')
col=[]
for i in range(8):
    col.append('.')
right_slope=[]
for i in range(15):
    right_slope.append('.')
left_slope=[]
for i in range(15):
    left_slope.append('.')

def slope_change_r(x,y):
    return (x+y)%15

def slope_change_l(x,y):
    return (x-y+15)%15

def eightqueen(x,y,c):
    global answer_printed
    if c == 8:
        if answer_printed == 0:
            print_answer()
            answer_printed = 1
        return
    if x >= 8:
        return
    if row[x] == 'Q':
        if x<7:
            eightqueen(x+1,0,c)
        else:
            return
    for y in range(8):
        if is_all_clear(x,y):
            mark(x,y)
            eightqueen(x+1,0,c+1)
            unmark(x,y)

def mark(x,y):
    answer[x][y] = 'Q'
    row[x] = 'Q'
    col[y] = 'Q'
    right_slope[slope_change_r(x,y)] = 'Q'
    left_slope[slope_change_l(x,y)] = 'Q'

def unmark(x,y):
    answer[x][y] = '.'
    row[x] = '.'
    col[y] = '.'
    right_slope[slope_change_r(x,y)] = '.'
    left_slope[slope_change_l(x,y)] = '.'

def is_all_clear(x,y):
    if answer[x][y] == 'Q':
        return False
    if row[x] == 'Q':
        return False
    if col[y] == 'Q':
        return False
    if right_slope[slope_change_r(x,y)] == 'Q':
        return False
    if left_slope[slope_change_l(x,y)] == 'Q':
        return False
    return True

def print_answer():
    for i in range(8):
        for j in range(8):
            if answer[i][j] == 'Q':
                print('Q',end='')
            else:
                print('.',end='')
        print('',end='\n')
    
k = int(input())
while True:
    try:
        r,c = map(int,input().split())
    except:
            break
    else:
        mark(r,c)

eightqueen(0,0,k)


"
3581206,ALDS1_13_A,"k = int(input())
row = [1] * 8
col = [1] * 8
dpos = [1] * 15
dneg = [1] * 15
X = [['.' for j in range(8)] for i in range(8)]
for i in range(k):
    r, c = map(int, input().split())
    row[r] = col[c] = dpos[r+c] = dneg[r-c+7] = 0
    X[r][c] = 'Q'
 
def s(i):
    while i < 8 and not row[i]:i += 1        
    if i == 8:
        for i in range(8):
            print(''.join(X[i]))
    for j in range(8):
        if not col[j] or not dpos[i+j] or not dneg[i-j+7]: continue
        row[i] = col[j] = dpos[i+j] = dneg[i-j+7] = 0
        X[i][j] = 'Q'
        s(i+1)
        row[i] = col[j] = dpos[i+j] = dneg[i-j+7] = 1
        X[i][j] = '.'
s(0)
"
3698392,ALDS1_13_A,"NOT_FREE = 1
FREE = 0
 
q = [0 for i in range(8)]
row = [0 for i in range(8)]
col = [0 for i in range(8)]
dneg = [0 for i in range (16)]
dpos = [0 for i in range (16)]
 
 
def printBord():
    for r in range(8):
        for c in range(8):
            if q[r] == c:
                print(""Q"",end="""")
            else: print(""."",end="""")
        print()
 
 
def putQueen(i):
    if i == 8:
        printBord()
        return
     
    if row[i]:
        if putQueen(i+1):return
 
    for j in range(8):
        if (row[i] or col[j] or dpos[i+j] or dneg[i-j+7]) == NOT_FREE :continue
        q[i] = j
        col[j] = dpos[i+j] = dneg[i-j+7] = NOT_FREE
        if putQueen(i+1) : return
        col[j] = dpos[i+j] = dneg[i-j+7] = FREE
    return
 
 
if __name__=='__main__':
    k = int(input())
    for i in range(k):
        r, c = (int(x) for x in input().split())
        q[r] = c
        row[r] = col[c] = dpos[r+c] = dneg[r-c+7] = NOT_FREE
    putQueen(0)
"
4021866,ALDS1_13_A,"import sys
input = sys.stdin.readline
from operator import itemgetter
sys.setrecursionlimit(10000000)
INF = 10**30
col = []
row = []
rd = []
lu = []
board = [['.'] * 8 for _ in range(8)]

def put(r, c):
    global col, row, rd, lu, board
    col.append(c)
    row.append(r)
    rd.append(c-r)
    lu.append(r+c)
    board[r][c] = 'Q'

def canPut(i, j):
    if i not in row and j not in col and j-i not in rd and i+j not in lu:
        return True
    else:
        return False

def unput(i, j):
    global col, row, rd, lu, board
    col.remove(j)
    row.remove(i)
    rd.remove(j-i)
    lu.remove(i+j)
    board[i][j] = '.'

def rec(i):
    if i > 7:
        for p in range(8):
            print(''.join(board[p]))
        exit(0)
    # print(""i: "", i)
    for j in range(8):
        if canPut(i, j):
            put(i, j)
            # print(""put: "", i, j)
            k = i+1
            while k in row:
                k += 1
            rec(k)
            unput(i, j)

def main():
    global col, row, rd, lu
    n = int(input().strip())

    for i in range(n):
        r, c = list(map(int, input().strip().split()))
        put(r, c)
    k = 0
    while k in row:
        k += 1
    rec(k)


if __name__ == '__main__':
    main()

"
4031054,ALDS1_13_A,"def printBorad():
    for i in range(8):
        s = ['.'] * 8
        s[row[i]] = 'Q'
        print(''.join(s))

def putQueen(i, j):
    row[i] = j
    col[j] = True
    left[i+j] = True
    right[7+i-j] = True

def removeQueen(i, j):
    row[i] = False
    col[j] = False
    left[i+j] = False
    right[7+i-j] = False
    


def recursive(i):
    if i == 8:
        printBorad()
        return
    
    if row[i] is not False:
        putQueen(i, row[i])
        recursive(i + 1)
    else:
        for j in range(8):        
            if col[j] or left[i+j] or right[7+i-j]:
                continue
            putQueen(i, j)
            recursive(i + 1)
            removeQueen(i, j)


if __name__ == ""__main__"":
    row = [False for i in range(8)]
    col = [False for i in range(8)]
    left = [False for i in range(15)]
    right = [False for i in range(15)]
    n = int(input())
    for _ in range(n):
        i, j = map(int, input().split())
        putQueen(i, j)
    
    recursive(0)
"
4142546,ALDS1_13_A,"class Field:

    def __init__(self, N):
        self.N = N
        self.row = [-1 for _ in range(N)]
        self.hold = []
        self.col = [0 for _ in range(N)]
        self.dpos = [0 for _ in range(2*N - 1)]
        self.dneg = [0 for _ in range(2*N - 1)]

    def putQueen(self, i):
        if i in self.hold:
            self.putQueen(i + 1)
            return 
        if i == self.N:
            self.printBoard()
            return
        for j in range(self.N):
            if self.col[j] or self.dpos[i+j] or self.dneg[i-j+self.N-1]:
                continue
            self.setQueen(i, j)
            self.putQueen(i + 1)
            self.col[j] = self.dpos[i+j] = self.dneg[i-j+self.N-1] = 0

    def setQueen(self, i, j):
        self.row[i] = j
        self.col[j] = self.dpos[i + j] = self.dneg[i - j + self.N - 1] = 1

    def printBoard(self):
        print('\n'.join(""."" * r + ""Q"" + ""."" * (self.N - r - 1) for r in self.row))


if __name__ == ""__main__"":
    field = Field(8)
    for _ in range(int(input())):
        i, j = (map(int, input().split()))
        field.setQueen(i, j)
        field.hold.append(i)
    field.putQueen(0)
"
4366838,ALDS1_13_A,"vert = [False] * 8
hori = [False] * 8
topright = [False] * (8 * 2 - 1)
topleft = [False] * (8 * 2 - 1)
queens = []
skip_row = []


def put_queen(x, y):
    vert[x] = True
    hori[y] = True
    topright[x + y] = True
    topleft[7 + (x - y)] = True
    queens.append((x, y))


def elim_queen(x, y):
    vert[x] = False
    hori[y] = False
    topright[x + y] = False
    topleft[7 + (x - y)] = False
    queens.remove((x, y))


def is_blank(x, y):
    if not vert[x] and not hori[y] and not topright[x+y] and not topleft[7+(x-y)]:
        return True


def search_blank_in_row(y):
    blanks = []
    for x in range(8):
        if is_blank(x, y):
            blanks.append(x)
    return blanks


def put_queen_in_row(y):
    #print(""put_queen_row"",y, queens)
    if y == 8:
        return True     # 8 Queens have already been existed; reached the solution.
    if y in skip_row:
        return put_queen_in_row(y + 1)   # skip rows where a queen already exists as the precondition

    for x in search_blank_in_row(y):
        put_queen(x, y)
        if put_queen_in_row(y + 1):
            return True
        else:
            elim_queen(x, y)    # can't put next queen; eliminate it
    return False    # all candidate blanks are failed


def main():
    # prepare
    n = int(input())
    for i in range(n):
        x, y = map(int, input().split())
        put_queen(x, y)
        skip_row.append(y)

    # 8 queen main
    put_queen_in_row(0)

    # draw queens
    board = [list('........') for x in range(8)]
    for q_x, q_y in queens:
        board[q_x][q_y] = 'Q'
    [print(''.join(x)) for x in board]
    return


main()
"
4415098,ALDS1_13_A,"# coding: utf-8
import sys

stdin = sys.stdin
ni = lambda: int(ns())
na = lambda: list(map(int, stdin.readline().split()))
ns = lambda: stdin.readline().rstrip() # ignore trailing spaces


def permutation(ret: list, leftovers: list) -> list:
    if len(leftovers) == 0:
        yield ret
    
    for left in leftovers:
        leftoverscopy = [i for i in leftovers]
        leftoverscopy.remove(left)
        yield from permutation(ret+[left], leftoverscopy)


def canAssign(xs, ys):
    for i in range(7):
        for j in range(i+1,8):
            if abs(xs[i]-xs[j]) == abs(ys[i]-ys[j]):
                return False
    return True


def displayChessboard(xs, ys):
    board = [['.']*8 for i in range(8)]
    for i in range(8):
        board[ys[i]][xs[i]] = 'Q'
    for i in range(8):
        for j in range(8):
            print(board[i][j], end='')
        print()
    return


def main():
    k = ni()
    queens = [na() for _ in range(k)]
    xqueens = []
    yqueens = []
    xs = [x for x in range(8)]
    ys = [y for y in range(8)]
    for queen in queens:
        xs.remove(queen[1])
        ys.remove(queen[0])
        xqueens.append(queen[1])
        yqueens.append(queen[0])
    
    for yspernm in permutation([],ys):
        if canAssign(xqueens+xs, yqueens+yspernm):
            displayChessboard(xqueens+xs, yqueens+yspernm)
            return
    
    print(""Can't make chessboard."")
    return


if __name__ == '__main__':
    main()
"
4469413,ALDS1_13_A,"# バックトラック法
class EightQueens:
    def __init__(self,p):
        self.p = p
        # 前提 8*8の盤
        self.N = 8
        # 下準備
        # row[k] : k行目におけるクイーンの列番号
        self.row = [None] * 8
        # col[n] : n列目上にクイーンがなければFREE,あればNOT_FREE,それが8列分
        self.col = ['FREE'] * 8
        # 8 * 8 のマスに対角線を引いていくと15本引くことができる
        # dpos : 45度方向の対角線　dneg : 135度方向の対角線
        self.dpos = ['FREE'] * 15
        self.dneg = ['FREE'] * 15

        # 入力された位置にクイーンを置く
        i = 0
        while i < len(p):
            self.row[p[i][0]] = p[i][1]
            self.col[p[i][1]] = self.dpos[p[i][0] + p[i][1]] = self.dneg[p[i][0] - p[i][1] + self.N - 1] = 'NOT_FREE'
            i = i + 1


        # self.printBoard()

    """"""
    盤面の状態を表示
    """"""
    def printBoard(self):
        i = 0
        while i < self.N:
            j = 0
            while j < self.N:
                if j == self.row[i]:
                    print(""Q"", end="""")
                # elif self.col[j] == 'NOT_FREE' or self.dpos[i+j] == 'NOT_FREE' or self.dneg[i-j + self.N-1] == 'NOT_FREE':
                    # print(""N "", end="""")
                else:
                    print(""."", end="""")
                    #print(""F "", end="""")
                j = j + 1
            print()
            i = i + 1
        return

    def putQueen(self,i):
        N = self.N

        # 初期化で置かれたクイーンだったらスキップ
        k = 0
        while k < len(self.p):
            if i == self.p[k][0]:
                i = i + 1
                k = 0
            k = k + 1


        # iが8(9行目)に到達したら終了
        if i == N:
            # print(""解を発見"")
            self.printBoard()
            return

        j = 0
        while j < N :
            # print(str(i)+"", ""+str(j))
            # self.printBoard()

            # 置こうとした位置がそれ以前の行のクイーンの領域だったら次の列へスキップ
            if self.col[j] == 'NOT_FREE' or self.dpos[i+j] == 'NOT_FREE' or self.dneg[i-j + N-1] == 'NOT_FREE':
                # print(""置けません"")
                j = j + 1
                continue

            # クイーンを(i,j)に置く
            self.row[i] = j

            # print()
            self.col[j] = self.dpos[i+j] = self.dneg[i-j+N-1] = 'NOT_FREE'
            # 次の行にクイーンを置くことを試みる（ダメだったら戻る）
            self.putQueen(i+1)
            # バックトラックキングのために(i,j)からクイーンを取り除く
            self.col[j] = self.dpos[i+j] = self.dneg[i-j+N-1] = 'FREE'
            j = j + 1
        return





def main():
    p = []  ##appendのために宣言が必要
    # 入力受付
    k = int(input())
    i = 0
    while i < k:
        try:
            p.append(list(map(int, input().split())))
            i = i + 1
        except:
            break;

    # 読み込み完了
    # pを行でソート
    p.sort()
    q = EightQueens(p)
    q.putQueen(0)
    return






if __name__ == '__main__':
    main()
"
4478114,ALDS1_13_A,"def putQueen(i):
    while i < 8 and row[i]:i += 1
    if i == 8:
        for i in range(8):
            print(''.join(queen[i]))
    for j in range(8):
        if col[j] or dpos[i+j] or dneg[i-j+7]: continue
        queen[i][j] = 'Q'
        row[i] = col[j] = dpos[i+j] = dneg[i-j+7] = 1
        putQueen(i+1)
        queen[i][j] = '.'
        row[i] = col[j] = dpos[i+j] = dneg[i-j+7] = 0

k = int(input())
row = [0] * 8
col = [0] * 8
dpos = [0] * 15
dneg = [0] * 15
queen = [['.' for j in range(8)] for i in range(8)]

for i in range(k):
    r, c = map(int, input().split())
    row[r] = col[c] = dpos[r+c] = dneg[r-c+7] = 1
    queen[r][c] = 'Q'

putQueen(0)
"
4492278,ALDS1_13_A,"board = [['#']*8 for i in range(8)]
n = int(input())
v1=[0]*8
v2=[0]*8
v3=[0]*16
v4=[0]*16


def dot(y,x):
    for j in range(8):
        board[y][j]='.'
        board[j][x]='.'
    for i in range(1,min(x,y)+1):
        board[y-i][x-i]='.'
    for i in range(1,min(7-x,y)+1):
        board[y-i][x+i]='.'
    for i in range(1,min(x,7-y)+1):
        board[y+i][x-i]='.'
    for i in range(1,min(7-x,7-y)+1):
        board[y+i][x+i]='.'
    board[y][x]='Q'
st=set()
ans=[]

def dfs(now,k,stock):
    if now == 8:
        ans.append(list(stock))
        return stock
    if not li[now]:
        dfs(now+1,k,stock)
    for i in li[now]:
        x,y1,y2=i
        if v2[x]==0 and v3[y1+7]==0 and v4[y2]==0:
            stock.add((now,x))
            v2[x]=1
            v3[y1+7]=1
            v4[y2]=1
            dfs(now+1,k,stock)
            v2[x]=0
            v3[y1+7]=0
            v4[y2]=0
            stock.remove((now,x))

for i in range(n):
    y , x = map(int, input().split())
    dot(y,x)
    v1[y]=1
    v2[x]=1
    v3[y-x+7]=1
    v4[y+x]=1

li=[[]for i in range(8)]
for i in range(8):
    for j in range(8):
        if board[i][j]=='#':
            li[i].append((j,i-j,j+i))

dfs(0,2,st)

for i in ans[0]:
    y,x=i
    dot(y,x)

for i in board:
    print(''.join(i))

"
4546081,ALDS1_13_A,"import itertools

k = int(input())

area = [["".""]*8 for i in range(8)]

X = set(range(8))
Y = set(range(8))
A = set()
B = set()

for i in range(k):
    x, y = map(int, input().split())
    area[x][y] = ""Q""

    X.remove(x)
    Y.remove(y)
    A.add(x-y)
    B.add(x+y)
for v in itertools.permutations(Y):
    ok = 1
    A_ = A.copy()
    B_ = B.copy()
    for x, y in zip(X, v):
        if x-y in A_ or x+y in B_:
            ok = 0
            break

        A_.add(x-y)
        B_.add(x+y)
    
    if ok:
        for x, y in zip(X, v):
            area[x][y] = ""Q""
        break

for i in range(8):
    print("""".join(area[i]))

"
5073653,ALDS1_13_A,"def Search(row, P, Q, R, S):
    
    if(row == 8):
        for p in P:
            x, y = p
            A[x][y] = ""Q""
    ret = row
    
    for col in range(8):
        
        P_ = P.copy()
        Q_ = Q.copy()
        R_ = R.copy()
        S_ = S.copy()
        
        if((row, col) in P):
            ret = Search(row+1, P_, Q_, R_, S_)
        elif(col in Q):
            continue
        elif(row+col in R):
            continue
        elif(row-col in S):
            continue
        else:
            P_.append((row, col))
            Q_.append(col)
            R_.append(row+col)
            S_.append(row-col)

            ret = Search(row+1, P_, Q_, R_, S_)
    return ret

n = int(input())

A = [[""."" for i in range(8)] for i in range(8)]
X = []
Y = []
Z1 = []
Z2 = []
for i in range(n):
    x, y = map(int, input().rstrip().split("" ""))
    X.append((x, y))
    Y.append(y)
    Z1.append(x+y)
    Z2.append(x-y)
Search(0, X, Y, Z1, Z2)  

for a in A:
    print("""".join(a))
"
5180394,ALDS1_13_A,"k=int(input())
B=[["".""]*8 for i in range(8)]
for i in range(k):
  a,b=map(int,input().split())
  B[a][b]=""Q""
def check(x,y):
  dx=[-1,-1,-1,0,0,1,1,1]
  dy=[-1,0,1,-1,1,-1,0,1]
  for d in range(8):
    tx=x
    ty=y
    while True:
      tx+=dx[d]
      ty+=dy[d]
      if not (0<=tx<8 and 0<=ty<8):
        break
      if B[ty][tx]==""Q"":
        return False
  return True
def f(y):
  if y==8:
    for b in B:
      print("""".join(b))
    exit(0)
  for x in range(8):
    if check(x,y):
      old=B[y][x]
      B[y][x]=""Q""
      f(y+1)
      B[y][x]=old
f(0)
"
5441155,ALDS1_13_A,"N = 8
board = [['.'] * N for _ in range(N)]
k = int(input())
for _ in range(k):
    queenList = list(map(int, input().split()))
    board[queenList[0]][queenList[1]] = 'Q'


def is_safe(board, row, col):
    # 同じ行にクイーンがあるか見に行く
    for i in range(N):
        if board[row][i] == 'Q':
            return False
    # 左上にクイーンがあるか見に行く
    for i, j in zip(range(row, -1, -1), range(col, -1, -1)):
        if board[i][j] == 'Q':
            return False
    # 右上にクイーンがあるか見に行く
    for i, j in zip(range(row, -1, -1), range(col, N, 1)):
        if board[i][j] == 'Q':
            return False
    # 左下にクイーンがあるか見に行く
    for i, j in zip(range(row, N, 1), range(col, -1, -1)):
        if board[i][j] == 'Q':
            return False
    # 右下にクイーンがあるか見に行く
    for i, j in zip(range(row, N, 1), range(col, N, 1)):
        if board[i][j] == 'Q':
            return False
    return True


def solve(board, col):
    # 全ての列を見切ったら。
    if col >= N:
        return True
    # 同じ列にクイーンがある場合、次の列を見に行く
    for i in range(N):
        if board[i][col] == 'Q':
            return solve(board, col + 1)
    # 同じ列にクイーンがない場合、他の条件を全てチェックし、問題なければクイーンを置き、他の列におけるパターンが全てあるかみる。
    # 問題あれば、クイーンを消し、次の行を見に行く
    # その後、次の列に行く。
    for i in range(N):
        if is_safe(board, i, col):
            board[i][col] = 'Q'
            if solve(board, col + 1):
                return True
            board[i][col] = '.'

    return False


# ボード情報を元に、ボードにクイーンを入れていく
solve(board, 0)
for i in range(N):
    print(''.join(board[i]))

"
5477087,ALDS1_13_A,"
N = 8
NOT_FREE = -1
FREE = 1
row = [-1 for _ in range(N)]
col = [FREE for _ in range(N)]
dpos = [FREE for _ in range(2*N-1)]
dneg = [FREE for _ in range(2*N-1)]

def putQueen(i):
    if i == N:
        printBoard()
        return
    if row[i] >= 0:
        putQueen(i+1)
    else:
        for j in range(N):
            if col[j] == FREE and dpos[i+j] == FREE and dneg[i-j+N-1] == FREE:
                row[i] = j
                col[j] = dpos[i+j] = dneg[i-j+N-1] = NOT_FREE
                putQueen(i+1)
                row[i]= -1
                col[j] = FREE
                dpos[i+j] = FREE
                dneg[i-j+N-1] = FREE

def printBoard():
    for i in range(N):
        output = """"
        for j in range(N):
            if row[i] == j:
                output+=""Q""
            else:
                output+="".""
        print(output)

if __name__ == ""__main__"":
    n = int(input())
    i = 0
    while i < n:
        i += 1
        x, y = map(int, input().split())
        row[x] = y
        col[y] = NOT_FREE
        dpos[x+y] = NOT_FREE
        dneg[x-y+N-1] = NOT_FREE

    putQueen(0)

"
5501871,ALDS1_13_A,"k = int(input())
# x, y = [list(i) for i in zip(*[map(int, input().split()) for _ in range(k)])]
pos = [0] * 8
col = [0] * 8
up = [0] * 15
down = [0] * 15
for i in range(k):
    x, y = map(int, input().split())
    pos[x] = str(y)
    col[y] = 1
    up[x+y] = 1
    down[x-y+7] = 1

i, j = 0, 0
while True:
    if isinstance(pos[i], int):
        if pos[i] == 0 and col[j] == 0 and up[i+j] == 0 and down[i-j+7] == 0:
            pos[i] = j
            col[j] = 1
            up[i+j] = 1
            down[i-j+7]=1
            i += 1
            j = 0
            if i >= 8:
                break
        else:
            j += 1
            if j > 7:
                for l in range(i-1, -1 , -1):
                    if isinstance(pos[l], int):
                        j = pos[l]
                        pos[l] = 0
                        col[j] = 0
                        up[l+j] = 0
                        down[l-j+7] = 0
                        i = l
                        j += 1
                        if j < 8:
                            break
                        else:
                            continue
    else:
        i += 1
        if i >= 8:
            break
        j = 0
    
    # print('i:{}, j:{}, pos:{}'.format(i, j, pos))

for i in range(8):
    for j in range(8):
        if int(pos[i]) == j:
            print('Q', end="""")
        else:
            print('.', end="""")
    print('\n', end="""")

       

"
5602894,ALDS1_13_A,"n = 8
FREE = -1
NOT_FREE = 1
col = []
row = []
dpos = []
dneg = []


def print_board():
    for i in range(n):
        for j in range(n):
            if board[i][j] and row[i] != j:
                return
    for i in range(n):
        for j in range(n):
            if row[i] == j:
                print(""Q"", end="""")
            else:
                print(""."", end="""")
        print("""")


def recursive(i):
    if i == n:
        print_board()
        return
    for j in range(n):
        if (
            col[j] == NOT_FREE
            or dpos[i + j] == NOT_FREE
            or dneg[i - j + n - 1] == NOT_FREE
        ):
            continue
        row[i] = j
        col[j] = NOT_FREE
        dpos[i + j] = NOT_FREE
        dneg[i - j + n - 1] = NOT_FREE
        recursive(i + 1)
        row[i] = FREE
        col[j] = FREE
        dpos[i + j] = FREE
        dneg[i - j + n - 1] = FREE


for i in range(n):
    col.append(FREE)
    row.append(FREE)

for i in range(2 * n - 1):
    dpos.append(FREE)
    dneg.append(FREE)

k = int(input())
board = [[False] * n for _ in range(n)]

for i in range(k):
    r, c = map(int, input().split())
    board[r][c] = True

recursive(0)

"
5840011,ALDS1_13_A,"#使用済みになったらTrueにして、Qを置けるかどうか確認する
row = [False] * 8
col = [False] * 8
pos = [False] * 15 #斜めは行と列を足し算もしくは引き算した数が同じになる
neg = [False] * 15 #行列の引き算の結果は−7〜7になる、結果に7足して0〜14で考える

chess = [['.']*8 for _ in range(8)] 

k = int(input())
for i in range(k):
  r, c = map(int,input().split())
  row[r] = True
  col[c] = True
  pos[r+c] = True
  neg[r-c+7] = True
  chess[r][c] = 'Q'

def dfs(i):
  if i == 8:
    for j in range(8):
      print(''.join(chess[j]))
  elif row[i] == True:
    dfs(i+1)
  else:
    for j in range(8):
      if col[j] or pos[i+j] or neg[i-j+7]:
        continue
      else:
        row[i] = True
        col[j] = True
        pos[i+j] = True
        neg[i-j+7] = True
        chess[i][j] = 'Q'
        dfs(i+1)  #最後までQが入ったらi=8でprint、ダメだったらTrueにしたのをFalseに戻して考え直す
        row[i] = False
        col[j] = False
        pos[i+j] = False
        neg[i-j+7] = False
        chess[i][j] = '.'

dfs(0)
"
6012168,ALDS1_13_A,"# coding: utf-8

# stdin.readline().rstrip()
from sys import stdin

def print_board(board):
    for i in range(8):
        for j in range(8):
            if board[i][j] == 1:
                print(""Q"", end="""")
            else:
                print(""."", end="""")
        print("""")

def mark_board(board, r, c):
    for i in range(8):
        if i != r:
            if board[i][c] != 1:
                board[i][c] = -1
            else:
                return False
        if i != c:
            if board[r][i] != 1:
                board[r][i] = -1
            else:
                return False
    
    for j in range(-8, 9):
        if j == 0:
            continue
        if r + j >= 0 and r + j < 8:
            if c + j >= 0 and c + j < 8:
                if board[r + j][c + j] != 1:
                    board[r + j][c + j] = -1
                else:
                    return False
            if c - j >= 0 and c - j < 8:
                if board[r + j][c - j] != 1:
                    board[r + j][c - j] = -1
                else:
                    return False
    return True
                
def try_put_queen(board):
    min_squre = 9
    min_r = -1
    all_put = True
    all_squre_already_put = True
    for i in range(8):
        if board[i].count(0) > 0 and board[i].count(0) < min_squre:
            min_squre = board[i].count(0)
            min_r = i
        if all_squre_already_put and board[i].count(0) > 0:
            all_squre_already_put = False
        if all_put and board[i].count(1) < 1:
            all_put = False
    
    if all_put:
        return board
    elif all_squre_already_put:
        return []
    
    for j in range(8):
        if board[min_r][j] == 0:
            temp = [ board[i][:] for i in range(8) ]
            temp[min_r][j] = 1
            if not mark_board(temp, min_r, j):
                continue
            ans = try_put_queen(temp)
            if len(ans) > 0:
                return ans
    
    return []

k = int(stdin.readline().rstrip())

board = [ [0 for _ in range(8)] for _ in range(8) ]
for _ in range(k):
    r, c = list(map(int, stdin.readline().rstrip().split()))
    board[r][c] = 1
    
    mark_board(board, r, c)

print_board(try_put_queen(board))

"
6048164,ALDS1_13_A,"N = int(input())
Q = [tuple(map(int, input().split())) for _ in range(N)]
board = [-1] * 8

for x, y in Q:
    board[x] = y


def deplication(x, y):
    """"""斜めの重複チェック""""""
    for x1 in range(8):
        y1 = board[x1]
        if y1 == -1:
            continue
        if abs(x - x1) == abs(y - y1):
            return True
    return False


ans = [[""."" for _ in range(8)] for _ in range(8)]


def n_queen(n, x):
    if n == x:
        for x in range(8):
            y = board[x]
            ans[x][y] = ""Q""

        print(*map(lambda x: """".join(x), ans), sep=""\n"")
        exit()

    else:
        if board[x] != -1:
            n_queen(n, x + 1)
        else:
            for y in range(0, 8):
                if y in board or deplication(x, y):
                    continue
                board[x] = y
                n_queen(n, x + 1)
                board[x] = -1


n_queen(8, 0)
print(board)

"
6050327,ALDS1_13_A,"N = 8
board = [['.'] * N for i in range(N)]
k = int(input())
for i in range(k):
    pos = list(map(int, input().split()))
    board[pos[0]][pos[1]] = 'Q'


def is_safe(row, col):
    # 左右
    for i in range(N):
        if board[row][i] == 'Q':
            return False
    # 左上
    for i, j in zip(range(row, -1, -1), range(col, -1, -1)):
        if board[i][j] == 'Q':
            return False
    # 左下
    for i, j in zip(range(row, -1, -1), range(col, N, 1)):
        if board[i][j] == 'Q':
            return False
    # 右上
    for i, j in zip(range(row, N, 1), range(col, -1, -1)):
        if board[i][j] == 'Q':
            return False
    # 右下
    for i, j in zip(range(row, N, 1), range(col, N, 1)):
        if board[i][j] == 'Q':
            return False

    return True


def solve(col):
    if col >= N:
        return True

    # 縦方向でクイーンが存在するか確認
    for i in range(N):
        if board[i][col] == 'Q':
            return solve(col + 1)

    for i in range(N):
        if is_safe(i, col):
            # 置ける場合は一旦クイーンを置く
            board[i][col] = 'Q'
            # その後全ての列に対して全てTrueが帰ったらボードにクイーンを置いたままにする
            # 置けない列が存在したら、クイーンを削除して次の行に進む
            if solve(col + 1):
                return True
            board[i][col] = '.'

    # 置ける行列がない場合はFalseを返す
    return False


solve(0)
for i in range(N):
    print(''.join(board[i]))

"
6055423,ALDS1_13_A,"class Queen:
    def __init__(self, givenQ):
        self.x = 0
        self.board = givenQ


def setNQueen(n, givenQ):
    
    
    def setQueen(n, qlist):
        if qlist.x >= n:
            return qlist.board
        
        while qlist.x < n:
            if qlist.board[qlist.x] is not None:
                qlist.x += 1
            else:
                break
        
        for y in range(n):
            if y in qlist.board or duplication(qlist.x, y):
                continue
            
            qlist.board[qlist.x] = y
            qlist.x += 1
            plus = 1
            while qlist.x < n:
                if qlist.board[qlist.x] is not None:
                    qlist.x += 1
                    plus += 1
                else:
                    break
            ans = setQueen(n, qlist)
            
            if ans is None:
                qlist.x -= plus
                qlist.board[qlist.x] = None
            else:
                break
        else:
            return None
        return qlist.board

    def duplication(x, y):
        for r, c in enumerate(qlist.board):
            if c is None:
                continue
            elif abs(r - x) == abs(c - y):
                return True
        return False
    
    qlist = Queen(givenQ)
    setQueen(n, qlist)
    printBoard2(qlist.board)


def printBoard2(board):
    for i in range(8):
        for j in range(8):
            if j == board[i]:
                print(""Q"", end='')
            else:
                print(""."", end='')
        print()


if __name__ == '__main__':
    k = int(input())
    givenQ = [None for _ in range(8)]
    for i in range(k):
        r, c = map(int, input().split())
        givenQ[r] = c
    
    setNQueen(8, givenQ)
"
6212237,ALDS1_13_A,"import sys

row = [False] * 8
col = [False] * 8
dpos = [False] * 15
dneg = [False] * 15

board = [['.'] * 8 for i in range(8)]


def place_queen(i, j, row, col, dpos, dneg, board):
    row[i] = True
    col[j] = True
    dpos[i + j] = True
    dneg[i - j + 7] = True
    board[i][j] = 'Q'


def remove_queen(i, j, row, col, dpos, dneg, board):
    row[i] = False
    col[j] = False
    dpos[i + j] = False
    dneg[i - j + 7] = False
    board[i][j] = '.'


def dfs(i=0):
    if i == 8:
        for line in board:
            print(''.join(line))
    elif row[i]:
        dfs(i + 1)
    else:
        for j in range(8):
            if col[j] or dpos[i + j] or dneg[i - j + 7]:
                continue
            place_queen(i, j, row, col, dpos, dneg, board)
            dfs(i + 1)
            remove_queen(i, j, row, col, dpos, dneg, board)


def main():
    _ = sys.stdin.readline()

    for line in sys.stdin:
        i, j = map(int, line.split())
        place_queen(i, j, row, col, dpos, dneg, board)

    dfs()


if __name__ == ""__main__"":
    main()
"
6227717,ALDS1_13_A,"import sys
from itertools import permutations

K = int(input())
R, C = [], []
for _ in range(K):
    r, c = map(int, input().split())
    R.append(r)
    C.append(c)

Du = set([R[i]-C[i] for i in range(K)])
Dd = set([R[i]+C[i] for i in range(K)])

Rc = set(list(range(8))) - set(R)
Cc = set(list(range(8))) - set(C)

for rp in permutations(Rc):
    x1 = Du.copy()
    x2 = Dd.copy()
    for r, c in zip(rp, Cc):
        x1.add(r-c)
        x2.add(r+c)
    if len(x1)==8 and len(x2)==8:
        bd = [['.']*8 for _ in range(8)]
        for r, c in zip(rp, Cc):
            bd[r][c] = 'Q'
        for r, c in zip(R, C):
            bd[r][c] = 'Q'
        for l in bd:
            print(''.join(l))
        sys.exit()
            


"
6269007,ALDS1_13_A,"n = int(input())
board = [['.' for i in range(8)] for j in range(8)]
queens = []
for i in range(n):
    y,x = map(int, input().split())
    board[y][x] = 'Q'
    queens.append((x,y))
N = 8
def rec(i: int)->None:
    # i: y座標
    if i==N:
        return True
    used = [False for i in range(N)]
    skip = False
    for px,py in queens:
        used[px] = True
        if py==i:
            return rec(i+1)
        for j in range(N):
            if abs(py-i)==abs(px-j):
                used[j] = True
    for j in range(N):
        # j: x座標
        if not used[j]:
            queens.append((j,i))
            board[i][j] = 'Q'
            if rec(i+1):
                return True
            board[i][j] = '.'
            queens.pop(-1)
#%%
rec(0)
for j in range(N):
    for i in range(N):
        print(board[j][i], end='')
    print()
"
6285541,ALDS1_13_A,"# Input:
#     - r:現在探索しているチェス盤の行番号
# Description:
#     - 0行目から7行目までを順に、生じうるクイーンの配置を全探索し解を求める
# Output:
#     - r-1行目までを決めた段階で条件を満たすようなクイーンの配置が見つかったかをTrue/Falseで示す
def solve(r):
    if r == 8: # 解が見つかった場合、Trueを返す
        return True  
    if r in sr: # すでにr行目にクイーンが配置されていた場合
        return solve(r+1) # そのままr+1行目を探索する
    for c in range(8): # 0から7まで繰り返し(全ての列について繰り返し)
        if c in sc or r+c in ad or r-c in sb: # 既に配置されているクイーンが(r,c)を襲撃できる場合、探索を行わない
            continue
        sc.add(c); ad.add(r+c); sb.add(r-c) # scにcを、adにr+cを、sbにr-cを追加する
        queen.append((r,c)) # (r,c)をqueenに追加する
        if solve(r+1): # (r,c)にクイーンを配置して解が見つかった場合、Trueを返す
            return True 
        sc.remove(c); ad.remove(r+c); sb.remove(r-c) # scからcを、adからr+cを、sbからr-cを取り除く
        queen.pop() # queenから(r,c)を取り除く
    return False # 解が見つからなかった場合、Falseを返す
        
k = int(input()) # 既に配置されているクイーンの数kを入力する
sr = set([]); sc = set([]) # クイーンが配置されている行番号、列番号を表わす集合sr、scを用意
ad = set([]); sb = set([]) # クイーンが配置されているマス(r,c)全てについての、r+c、r-cを表わす集合ad、sbを用意
queen = [] # クイーンが配置されているマス(r,c)を表わす配列queenを用意
for i in range(k): # k回繰り返し
    r,c = map(int,input().split()) # 行番号r、列番号cを入力
    sr.add(r) # srにrを追加
    sc.add(c) # scにcを追加
    ad.add(r+c) # adにr+cを追加
    sb.add(r-c) # sbにr-cを追加
    queen.append((r,c)) # queenに(r,c)を追加
solve(0) # 0行目から探索を開始
ans = [['.']*8 for i in range(8)] # 答えを表わす配列ansを初期化
for r,c in queen: # クイーンが配置されている全てのマスについて繰り返し
    ans[r][c] = 'Q' # ans[r][c]をQに変更
for i in range(8): # 0から7まで繰り返し
    print(''.join(ans[i])) # i行目の配置を出力
"
6317722,ALDS1_13_A,"
import itertools # .permutations(list, r)

def main():
    # 入力・下処理
    N = int(input())
    Q = [list(map(int, input().split())) for _ in range(N)]
    # 計算・出力
    rpos = list(range(8))
    cpos = list(range(8))
    for q in Q:
        rpos.remove(q[0])
        cpos.remove(q[1])
    for pattern in itertools.permutations(rpos):
        queens = [q for q in Q]
        for c, r in enumerate(pattern):
            queens.append([r, cpos[c]])
        if isOK(queens):
            printqueens(queens)
            return

def isOK(queens):
    for n1 in range(8):
        r1 = queens[n1][0]
        c1 = queens[n1][1]
        for n2 in range(n1+1, 8):
            r2 = queens[n2][0]
            c2 = queens[n2][1]
            if r1 == r2 or c1 == c2:
                return False
            if abs(r1-r2) == abs(c1-c2):
                return False
    return True

def printqueens(queens):
    field = [['.']*8 for i in range(8)]
    for q in queens:
        field[q[0]][q[1]] = 'Q'
    [print(''.join(r)) for r in field]

if __name__ == ""__main__"":
    main()

"
6504444,ALDS1_13_A,"row=[1]*8
column=[1]*8
diagonal_r=[1]*15
diagonal_l=[1]*15
ans=[-1]*8
def check(r, c):
    if row[r] == 1\
            and column[c] == 1\
            and diagonal_r[c-r+7] == 1\
            and diagonal_l[c+r] == 1:
        return True
def assign(r,c):
    row[r]=0
    column[c]=0
    diagonal_r[c-r+7]=0
    diagonal_l[c+r]=0
    ans[r]=c
def unassign(r,c):
    row[r]=1
    column[c]=1
    diagonal_r[c-r+7]=1
    diagonal_l[c+r]=1
    ans[r]=-1
def solve(r):
    if r == 8:
        for j in range(8):
            print("".""*ans[j]+""Q""+"".""*(7-ans[j]))
        exit()
    if ans[r] != -1:
        solve(r+1)
    for i in range(8):
        if check(r,i):
            assign(r,i)
            solve(r+1)
            unassign(r,i)
k=int(input())
for i in range(k):
    r,c=map(int,input().split())
    assign(r,c)
solve(0)
"
6556883,ALDS1_13_A,"import itertools

n = int(input())

yoko = set() # a: 0-7
tate = set() # b: 0-7
migiue = set() # a + b: 0-14
migisita = set() # a - b: -7-7
ql = []

for _ in range(n):
    a, b = map(int, input().split())
    tate.add(a)
    yoko.add(b)
    migiue.add(a + b)
    migisita.add(a - b)
    ql.append((a, b))

xl = [x for x in range(8) if x not in tate]
yl = [y for y in range(8) if y not in yoko]


for xll in itertools.permutations(xl):
    for yll in itertools.permutations(yl):
        tmp_tate = set() # a: 0-7
        tmp_yoko = set() # b: 0-7
        tmp_migiue = set() # a + b: 0-14
        tmp_migisita = set() # a - b: -7-7

        ok = True

        for i in range(len(xll)):
            _x = xll[i]
            _y = yll[i]
            if _x not in tate and _y not in yoko and \
                    (_x + _y) not in migiue and (_x - _y) not in migisita and\
                    _x not in tmp_tate and _y not in tmp_yoko and \
                    (_x + _y) not in tmp_migiue and (_x - _y) not in tmp_migisita:
                tmp_tate.add(_x)
                tmp_yoko.add(_y)
                tmp_migiue.add(_x + _y)
                tmp_migisita.add(_x - _y)
            else:
                ok = False
                break

        if ok:
            ans = [['.' for _ in range(8)] for _ in range(8)]
            for q in ql:
                ans[q[0]][q[1]] = 'Q'
            for _x, _y in zip(xll, yll):
                ans[_x][_y] = 'Q'

            for a in ans:
                print(''.join(a))
            exit()

"
6677510,ALDS1_13_A,"import sys
import builtins
import math
sys.setrecursionlimit(10**7)
builtins.input = lambda: sys.stdin.readline().strip()


def main():
    g = [['.']*8 for _ in range(8)]
    n = int(input())

    for _ in range(n):
        y, x = map(int, input().split(' '))
        g[y][x] = 'Q'

    def check(h, w):
        velocity = [[0, 1], [1, 0], [-1, 0], [0, -1], [1, 1], [-1, -1], [1, -1], [-1, 1]]

        for hv, wv in velocity:
            _h = h + hv
            _w = w + wv
            while 0 <= _h <= 7 and 0 <= _w <= 7:
                if g[_h][_w] == 'Q':
                    return 0
                else:
                    _h += hv
                    _w += wv

        return 1

    def r():
        for h in range(8):
            if 'Q' not in g[h]:
                for w in range(8):
                    g[h][w] = 'Q'
                    if check(h, w):
                        r()
                    g[h][w] = '.'
                return

        print('\n'.join([''.join(v) for v in g]))
        sys.exit(0)

    r()


if __name__ == '__main__':
    main()

"
6807644,ALDS1_13_A,"import sys
sys.setrecursionlimit(10 ** 7)


d = [-1] * 8

for _ in range(int(input())):
    r_i, c_i = map(int, input().split())
    d[r_i] = c_i

def check(now, i, data):
    for a in [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]:
        r_i = now
        c_i = i
        while 0 <= r_i < 8 and 0 <= c_i < 8:
            if data[r_i] == c_i:
                return False
            else:
                r_i += a[0]
                c_i += a[1]
    
    return True

def write(d):
    ans = [["".""] * 8 for _ in range(8)]
    for i in range(8):
        ans[i][d[i]] = ""Q""
    
    for a in ans:
        print("""".join(a))

def dfs(now, data):
    if now == 8:
        write(data)
        exit()
            
    elif data[now] >= 0:
        dfs(now + 1, data)
    
    else:
        for i in range(8):
            if check(now, i, data):
                d_i = data[:]
                d_i[now] = i
                dfs(now + 1, d_i)


lst = dfs(0, d)

"
7038278,ALDS1_13_A,"K=int(input())
C = [-1] * 8
R = [False] * 8
for i in range(K):
	r,c=map(int,input().split())
	R[r] = True
	C[c] = r

def can_place(x,y):
	if R[y]:
		return False
	for i in range(8):
		if C[i] == -1:
			continue
		if x - y == i - C[i]:
			return False
		if x + y == i + C[i]:
			return False
	return True

def answer():
	res = [[None] * 8 for i in range(8)]
	for x in range(8):
		for y in range(8):
			res[y][x] = ""Q"" if C[x] == y else "".""
	for i in range(8):
		print("""".join(res[i]))

def rec(x):
	if x == 8:
		answer()
		exit()
	if C[x] != -1:
		rec(x+1)
		return
	for y in range(8):
		if can_place(x, y):
			C[x] = y
			R[y] = True
			rec(x+1)
			C[x] = -1
			R[y] = False

rec(0)

"
7145536,ALDS1_13_A,"from itertools import permutations

k = int(input())
q_list = [tuple(map(int, input().split())) for _ in range(k)]

x_list = []
y_set = set()
for i in range(8):
    for q in q_list:
        if q[0] == i:
            break
    else:
        x_list.append(i)
    for q in q_list:
        if q[1] == i:
            break
    else:
        y_set.add(i)

for case in permutations(x_list):
    case_cursor = 0
    curr = 0
    queens = q_list[:]
    while curr < 8:
        if curr not in y_set:
            curr += 1
            continue
        for q in queens:
            if abs(q[0] - case[case_cursor]) == abs(q[1] - curr):
                break
        else:
            queens.append((case[case_cursor], curr))
        case_cursor += 1
        curr += 1
    if len(queens) == 8:
        break

queens.sort()
for q in queens:
    print('.' * q[1] + 'Q' + '.' * (7 - q[1]))
"
7409629,ALDS1_13_A,"import sys

def solve(y):
  if y == 8:
    for i in range(8):
      for j in range(8):
        print(c[i][j], end='')
      print()

    sys.exit()
    
  if a[y] == 1:
    solve(y + 1)
    
  for x in range(8):
    if b[x] == 0 and u[y + x] == 0 and v[y + (7 - x)] == 0:
      c[y][x] = 'Q'
      b[x] = u[y + x] = v[y + (7 - x)] = 1
      solve(y + 1)
      c[y][x] = '.'
      b[x] = u[y + x] = v[y + (7 - x)] = 0
      
n = int(input())

c = [['.']*8 for i in range(8)]
a = [0]*30
b = [0]*30
u = [0]*30
v = [0]*30

for i in range(n):
  y, x = map(int, input().split())
  c[y][x] = 'Q'
  u[y + x] = v[y + (7 - x)] = 1
  a[y] = b[x] = 1
  
solve(0)
"
8138359,ALDS1_13_A,"N = 8
arrs = [1, 2, 4, 8, 16, 32, 64, 128]
rows = [-1] * N
goal = False

def recursive_search(r, left_diagonal, right_diagonal, column):
    global goal
    if r == N:
        goal = True
    else:
        temp = rows[r]
        for i in range(N):
            position = arrs[i]
            if (rows[r] == -1) or (rows[r] == i):
                if (position & (left_diagonal | right_diagonal | column)) == 0:
                    rows[r] = i
                    recursive_search(r + 1, ((left_diagonal | position) << 1), ((right_diagonal | position) >> 1), (column | position))
                    if goal == True:
                        return
                    rows[r] = temp

k = int(input())
for _ in range(k):
    r, c = map(int, input().split())
    rows[r] = c
recursive_search(0, 0, 0, 0)
for i in range(N):
    for j in range(N):
        if rows[i] == j:
            print('Q', end='')
        else:
            print('.', end='')
    print()

"
8251813,ALDS1_13_A,"#8クイーン問題
k=int(input())
lis=[list(map(int,input().split())) for i in range(k)]
f=[[False]*(8) for i in range(8)]
dx=[1,0,-1,0,1,1,-1,-1]
dy=[0,1,0,-1,1,-1,1,-1]
for i in range(k):
    x,y=lis[i]
    
    for d in range(8):
        s=0
        while 0<=x+s*dx[d]<8 and 0<=y+s*dy[d]<8:
            f[x+s*dx[d]][y+s*dy[d]]=True
            s+=1

def rec(lis,f,nex=None):
    changed=[]
    if len(lis)==8:
        F=[["".""]*8 for i in range(8)]
        for i in lis:
            x,y=i
            F[x][y]=""Q""
        for i in range(8):
            print("""".join(F[i]))
        exit()
    if nex:
        x,y=nex
        for d in range(8):
            s=0
            while 0<=x+s*dx[d]<8 and 0<=y+s*dy[d]<8:
                if not f[x+s*dx[d]][y+s*dy[d]]:
                    changed.append((x+s*dx[d],y+s*dy[d]))
                f[x+s*dx[d]][y+s*dy[d]]=True
                s+=1

    for i in range(8):
        for j in range(8):
            if f[i][j]:
                continue
            lis.append((i,j))
            rec(lis,f,(i,j))
            lis.pop()
    
    for i in changed:
        x,y=i
        f[x][y]=False
    
    return 

rec(lis,f)




"
1684453,ALDS1_13_A,"from itertools import permutations


def check(queen):
    for r1, c1 in queen:
        if not all((r1 == r2 and c1 == c2) or (r1 + c1 != r2 + c2 and r1 - c1 != r2 - c2) for r2, c2 in queen):
            return False
    return True


N = int(input())
row, col = list(range(8)), list(range(8))
queen = []
for _ in range(N):
    r, c = map(int, input().split())
    queen.append((r, c))
    row.remove(r)
    col.remove(c)
for l in permutations(col):
    queen_tmp = queen[:]
    for r, c in zip(row, l):
        queen_tmp.append((r, c))
    if check(queen_tmp):
        board = [''.join('Q' if (r, c) in queen_tmp else '.' for c in range(8)) for r in range(8)]
        print(*board, sep='\n')
        break
"
2559968,ALDS1_13_B,"adjacent = (
    (1, 3),       # 0
    (0, 2, 4),    # 1
    (1, 5),       # 2
    (0, 4, 6),    # 3
    (1, 3, 5, 7), # 4
    (2, 4, 8),    # 5
    (3, 7),       # 6
    (4, 6, 8),    # 7
    (5, 7)        # 8
)

GOAL = [1, 2, 3, 4, 5, 6, 7, 8, 0]

# Bidirectional search using breadth-first search
def solve(start):
    if start == GOAL:
        return 0
    # 0: forward, 1: backward
    generated_state = {tuple(start): 0, tuple(GOAL): 1}
    step = {tuple(start): 0, tuple(GOAL): 0}
    s = 0
    state1 = [(start, 0), (GOAL, 1)]
    while state1:
        state2 = state1[:]
        state1 = []
        s += 1
        for s2, d in state2:
            i = s2.index(0)
            for p in adjacent[i]:
                s1 = s2[:]
                s1[i], s1[p] = s1[p], 0
                key = tuple(s1)
                if key in generated_state:
                    if generated_state[key] != d:
                        return s + step[key]
                    continue
                state1.append((s1, d))
                generated_state[key] = d
                step[key] = s

import sys

start = list(map(int, sys.stdin.read().split()))

print(solve(start))
"
2725457,ALDS1_13_B,"from collections import deque
N = 3
m = {8: {7, 5}, 7: {8, 6, 4}, 6: {7, 3}, 5: {8, 4, 2}, 4: {7, 5, 3, 1}, 3: {6, 4, 0}, 2: {5, 1}, 1: {4, 2, 0},
     0: {3, 1}}
goal = 123456780
def g(i, j, a):
    t = a // (10 ** j) % 10
    return a - t * (10 ** j) + t * (10 ** i)
def solve():
    MAP = """".join(input().replace("" "", """") for _ in range(N))
    zero = 8 - MAP.find(""0"")
    start = int(MAP)
    if start == goal:
        return 0
    dp = deque([(0, start, zero, 1), (0, goal, 0, 0)])
    TABLE = {start: (1, 0), goal: (0, 0)}
    while dp:
        cnt, M, yx, flg = dp.popleft()
        cnt += 1
        for nyx in m[yx]:
            key = g(yx, nyx, M)
            if key in TABLE:
                if TABLE[key][0] != flg:
                    return TABLE[key][1] + cnt
                continue
            TABLE[key] = (flg, cnt)
            dp.append((cnt, key, nyx, flg))
def MAIN():
    print(solve())
MAIN()

"
3581230,ALDS1_13_B,"adjacent = (
    (1, 3),       # 0
    (0, 2, 4),    # 1
    (1, 5),       # 2
    (0, 4, 6),    # 3
    (1, 3, 5, 7), # 4
    (2, 4, 8),    # 5
    (3, 7),       # 6
    (4, 6, 8),    # 7
    (5, 7)        # 8
)
 
GOAL = [1, 2, 3, 4, 5, 6, 7, 8, 0]
 
# Bidirectional search using breadth-first search
def solve(start):
    if start == GOAL:
        return 0
    # 0: forward, 1: backward
    generated_state = {tuple(start): 0, tuple(GOAL): 1}
    step = {tuple(start): 0, tuple(GOAL): 0}
    s = 0
    state1 = [(start, 0), (GOAL, 1)]
    while state1:
        state2 = state1[:]
        state1 = []
        s += 1
        for s2, d in state2:
            i = s2.index(0)
            for p in adjacent[i]:
                s1 = s2[:]
                s1[i], s1[p] = s1[p], 0
                key = tuple(s1)
                if key in generated_state:
                    if generated_state[key] != d:
                        return s + step[key]
                    continue
                state1.append((s1, d))
                generated_state[key] = d
                step[key] = s
 
import sys
 
start = list(map(int, sys.stdin.read().split()))
 
print(solve(start))
"
2807991,ALDS1_13_B,"# -*- coding: utf-8 -*-
import sys
from itertools import chain


def get_completed_board(height, width):
    return [str((i + 1) % (width * height)) for i in range(width * height)]


def serialize_board(board):
    return "":"".join(board)


def get_empty_pos(board, width, height):
    for i, cell in enumerate(board):
        if cell == ""0"":
            return i


def get_all_possible_next_boards(board, height, width, empty_pos=None):
    if empty_pos is None:
        empty_pos = get_empty_pos(board, height, width)
    next_boards = []
    x, y = empty_pos % width, empty_pos // height
    # 左との入れ替え
    if x > 0:
        next_board = []
        next_board.extend(board)
        dest_pos = empty_pos - 1
        next_board[empty_pos], next_board[dest_pos] = next_board[dest_pos], next_board[empty_pos]
        next_boards.append((next_board, dest_pos))
    # 右との入れ替え
    if x < width - 1:
        next_board = []
        next_board.extend(board)
        dest_pos = empty_pos + 1
        next_board[empty_pos], next_board[dest_pos] = next_board[dest_pos], next_board[empty_pos]
        next_boards.append((next_board, dest_pos))
    # 上との入れ替え
    if y > 0:
        next_board = []
        next_board.extend(board)
        dest_pos = empty_pos - height
        next_board[empty_pos], next_board[dest_pos] = next_board[dest_pos], next_board[empty_pos]
        next_boards.append((next_board, dest_pos))
    # 下との入れ替え
    if y < height - 1:
        next_board = []
        next_board.extend(board)
        dest_pos = empty_pos + height
        next_board[empty_pos], next_board[dest_pos] = next_board[dest_pos], next_board[empty_pos]
        next_boards.append((next_board, dest_pos))

    return next_boards


def resolve(board, height, width):
    # 既知の盤面を保存
    known_serialized_boards = set([serialize_board(board)])
    # 正解の盤面を保存
    completed_board = get_completed_board(width, height)
    known_serialized_completed_boards = set([serialize_board(completed_board)])
    if known_serialized_boards & known_serialized_completed_boards:
        return 0
    current_boards = [(board, None)]
    current_completed_boards = [(get_completed_board(width, height), None)]
    step_count = 1
    while step_count <= 45:
        # インプット側の盤面を一つ進める
        next_boards = []
        for board, empty_pos in current_boards:
            # 次のステップでの現れ得る局面を全て取得
            tmp_next_boards = get_all_possible_next_boards(board, height, width, empty_pos)
            filtered_next_board = []
            for board, empty_pos in tmp_next_boards:
                serialized_board = serialize_board(board)
                if serialized_board not in known_serialized_boards:
                    known_serialized_boards.add(serialized_board)
                    filtered_next_board.append((board, empty_pos))
            next_boards.extend(filtered_next_board)

        if known_serialized_boards & known_serialized_completed_boards:
            return step_count

        step_count = step_count + 1
        current_boards = next_boards

        # 正解盤面側を１つ進める
        next_completed_boards = []
        for board, empty_pos in current_completed_boards:
            # 次のステップでの現れ得る局面を全て取得
            tmp_next_boards = get_all_possible_next_boards(board, height, width, empty_pos)
            filtered_next_board = []
            for board, empty_pos in tmp_next_boards:
                serialized_board = serialize_board(board)
                if serialized_board not in known_serialized_completed_boards:
                    known_serialized_completed_boards.add(serialized_board)
                    filtered_next_board.append((board, empty_pos))
            next_completed_boards.extend(filtered_next_board)

        if known_serialized_boards & known_serialized_completed_boards:
            return step_count
        step_count = step_count + 1
        current_completed_boards = next_completed_boards

    return None


def main():
    inputStr = sys.stdin.read()
    lines = inputStr.split(""\n"")
    lines = filter(lambda line: line, lines)
    board = list(map(lambda line: line.split("" ""), lines))
    height = len(board)
    width = len(board[0])
    board = list(chain.from_iterable(board))
    print(resolve(board, height, width))


if __name__ == '__main__':
    main()
"
5477684,ALDS1_13_B,"adjacent = (
    (1, 3),       # 0
    (0, 2, 4),    # 1
    (1, 5),       # 2
    (0, 4, 6),    # 3
    (1, 3, 5, 7), # 4
    (2, 4, 8),    # 5
    (3, 7),       # 6
    (4, 6, 8),    # 7
    (5, 7)        # 8
)

GOAL = [1, 2, 3, 4, 5, 6, 7, 8, 0]

# Bidirectional search using breadth-first search
def solve(start):
    if start == GOAL:
        return 0
    # 0: forward, 1: backward
    generated_state = {tuple(start): 0, tuple(GOAL): 1}
    step = {tuple(start): 0, tuple(GOAL): 0}
    s = 0
    state1 = [(start, 0), (GOAL, 1)]
    while state1:
        state2 = state1[:]
        state1 = []
        s += 1
        for s2, d in state2:
            i = s2.index(0)
            for p in adjacent[i]:
                s1 = s2[:]
                s1[i], s1[p] = s1[p], 0
                key = tuple(s1)
                if key in generated_state:
                    if generated_state[key] != d:
                        return s + step[key]
                    continue
                state1.append((s1, d))
                generated_state[key] = d
                step[key] = s

import sys

start = list(map(int, sys.stdin.read().split()))

print(solve(start))

"
6024564,ALDS1_13_B,"# stdin.readline().rstrip()
from sys import stdin

adj_panel = [
    (1, 3),
    (0, 2, 4),
    (1, 5),
    (0, 4, 6),
    (1, 3, 5, 7),
    (2, 4, 8),
    (3, 7),
    (4, 6, 8),
    (5, 7)
]

def search_puzzle(start_panel):
    goal_panel = [1, 2, 3, 4, 5, 6, 7, 8, 0]

    cost = { tuple(start_panel): 0, tuple(goal_panel): 0 }
    checked_panel = { tuple(start_panel): 0, tuple(goal_panel): 1 }
    puzzle_queue = [(start_panel[:], 0, 0), (goal_panel[:], 0, 1)]
    
    while len(puzzle_queue) > 0:
        panel, c, d = puzzle_queue.pop(0)
        
        space = panel.index(0)
        for c_idx in adj_panel[space]:
            temp = panel[:]
            temp[space], temp[c_idx] = temp[c_idx], 0
            
            key = tuple(temp)
            if key in checked_panel:
                if checked_panel[key] != d:
                    return cost[key] + c + 1
                continue
            
            puzzle_queue.append( (temp, c + 1, d) )
            checked_panel[ tuple(temp) ] = d
            cost[ tuple(temp) ] = c + 1

start_panel = []
for _ in range(3):
    start_panel += list( map( int, stdin.readline().rstrip().split("" "") ) )

if """".join( [str(i) for i in start_panel] ) == ""123456780"":
    print(0)
else:
    print( search_puzzle(start_panel) )
"
1293429,ALDS1_13_B,"from sys import stdin
readline = stdin.readline


adjacent = (
    (1, 3),        # 0
    (0, 2, 4),     # 1
    (1, 5),        # 2
    (0, 4, 6),     # 3
    (1, 3, 5, 7),  # 4
    (2, 4, 8),     # 5
    (3, 7),        # 6
    (4, 6, 8),     # 7
    (5, 7)         # 8
)


def next_board(board, space, prev):
    for nxt in adjacent[space]:
        if nxt == prev:
            continue
        b = board[:]
        b[space], b[nxt] = b[nxt], 0
        yield b, nxt
from heapq import heappop, heappush

end = [1, 2, 3, 4, 5, 6, 7, 8, 0]

# ???????????¨????????°
FORE = 1
BACK = 0


def search(start):
    if start == end:
        return 0
    table = {}

    table[tuple(start)] = (FORE, 0)
    table[tuple(end)] = (BACK, 0)

    heap = [(0, start, start.index(0), None, FORE), (0, end, end.index(0), None, BACK)]
    while heap:
        i, board, space, prev, direction = heappop(heap)
        i += 1
        for b, nxt in next_board(board, space, prev):
            key = tuple(b)
            if key in table:
                if table[key][0] != direction:
                    return table[key][1] + i
                continue
            table[key] = (direction, i)
            if b == end:
                return i
            heappush(heap, (i, b, nxt, space, direction))


def main():
    start = (map(int, readline().split()) for _ in range(3))
    start = [y for x in start for y in x]
    print(search(start))
main()
"
5215367,ALDS1_13_B,"import heapq

n = 3
n2 = n ** 2
limit = 45

board = [list(map(int, input().split())) for _ in range(n)]
code = 0
dist = 0
for i in range(n):
    for j in range(n):
        x = board[i][j]
        if x == 0:
            k0 = i * n + j
        else:
            ix, jx = (x - 1) // n, (x - 1) % n
            dist += abs(i - ix) + abs(j - jx)
        code += x * pow(n2, i * n + j)

heap = [(dist, dist, 0, code, k0)]
visited = set()
while heap:
    cost, dist, cnt, code, k0 = heapq.heappop(heap)
    if dist == 0:
        print(cnt)
        exit()
    if (cost > limit) or (code in visited):
        continue
    visited.add(code)
    i0, j0 = k0 // n, k0 % n
    for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
        i, j = i0 + di, j0 + dj
        if i < 0 or i >= n or j < 0 or j >= n:
            continue
        k = i * n + j
        x = (code // pow(n2, k)) % n2
        new_code = code + x * (pow(n2, k0) - pow(n2, k))
        new_dist = dist
        new_dist -= abs(i - (x - 1) // n) + abs(j - (x - 1) % n)
        new_dist += abs(i0 - (x - 1) // n) + abs(j0 - (x - 1) % n)
        new_cnt = cnt + 1
        new_cost = new_dist + new_cnt
        heapq.heappush(heap, (new_cost, new_dist, new_cnt, new_code, k))

"
6591041,ALDS1_13_B,"from heapq import heappop, heappush

LIMIT = 45
N = 3                                                       

adj = [{1, 3}, {0, 2, 4}, {1, 5}, {0,4,6},                  
      {1, 3, 5,7}, {2, 4, 8}, {3, 7}, {4, 6, 8},      
      {5,7}] 

pieces = [[[0] for j in range(N)] for i in range(N)]          

MD = [[abs(i//N-j//N)+abs(i%N-j%N) for j in range(N*N) ] for i in range(N*N)]    
PW = [16**i for i in range(N*N)]                              
SW = [[i*PW[j] for j in range(N*N) ] for i in range(N*N)]     

initial_v, initial_h, initial_b = 0, 0, -1
target = 0

p = 0
for i in range(N):
    row = list(map(int, input().split()))
    for j in range(N):
        pieces[i][j] = row[j]
        if row[j] == 0:
            initial_b = i*N + j                               
        else:            
            initial_v += row[j]*PW[p]                         
            initial_h += MD[p][row[j]-1]                      
        if (p+1) <= 8: target += (p+1)*PW[p]
        p += 1

ans = -1
parent = {}                                                  
def aster():
    global ans, parent
    queue = [(initial_h, 0, initial_h, initial_v, initial_b, -1, -1)]
    visited = set()
    parent[initial_v] = [-1, -1]
    
    while len(queue) > 0:
        estimated, cost, heuristic, val, blank, pre_v, pre = heappop(queue)
        parent[val] = [pre_v, pre]
        if val in visited: continue
        if val == target:
            ans = estimated
            return True
        visited.add(val)
        for next_b in adj[blank]:
            num = (val >> (4*next_b)) & 15
            next_v = val - SW[num][next_b] + SW[num][blank]
            if next_v in visited: continue
            next_h = heuristic + MD[blank][num-1] - MD[next_b][num-1]
            if cost + 1 > LIMIT: continue
            heappush(queue, (cost + 1+next_h, cost + 1, next_h, next_v, next_b, val, num))
    return False

aster()
print(ans)

"
6619294,ALDS1_13_B,"# 2022/04/29
# Yutaka Watanobe
from heapq import heappop, heappush

LIMIT = 45
N = 3                                                          # N * N pieces

adj = [{1, 3}, {0, 2, 4}, {1, 5},                   # N * N pieces are represented by 0, 1, ..., (N*N-1)
      {0, 4, 6}, {1, 3, 5, 7}, {2, 4, 8},     # adj[i]: an adj list for piece i
      {3, 7}, {4, 6, 8}, {5, 7}] # ** this is for only N = 3

pieces = [[[0] for j in range(N)] for i in range(N)]           # contents for simulation

MD = [[abs(i//N-j//N)+abs(i%N-j%N) for j in range(N*N) ] for i in range(N*N)]    # manhattan dist between piece i and j
PW = [16**i for i in range(N*N)]                               # 16^i
SW = [[i*PW[j] for j in range(N*N) ] for i in range(N*N)]      # i * 16^j

initial_v, initial_h, initial_b = 0, 0, -1
target = 0

p = 0
for i in range(N):
    row = list(map(int, input().split()))
    for j in range(N):
        pieces[i][j] = row[j]
        if row[j] == 0:
            initial_b = i*N + j                                # set the place of the blank 0の位置
        else:            
            initial_v += row[j]*PW[p]                          # initial hash value of the puzzle 開始盤面のハッシュ値
            initial_h += MD[p][row[j]-1]                       # initial estimation cost f(x)=h(x)
        if (p+1) <= 8: target += (p+1)*PW[p]
        p += 1

ans = -1
parent = {}                                                    # parent of BFS tree to simulate 中括弧は辞書かセット

def aster():
    global ans, parent
    queue = [(initial_h, 0, initial_h, initial_v, initial_b, -1, -1)]       #()はタプルを表す。このqueueがopenList。開始盤面の前の盤面と前の盤面で動かしたピースは存在しないので-1と表す。
    visited = set()                         #visitedはハッシュ値のclosedList
    parent[initial_v] = [-1, -1]
    
    while len(queue) > 0:
        estimated, cost, heuristic, val, blank, pre_v, pre = heappop(queue)
        parent[val] = [pre_v, pre]                              #今の盤面の、親ノード(前の盤面)と前の盤面で動かしたピースの記録
        if val in visited: continue                         #無くても解けたが、必要な行なのか？
        if val == target:
            ans = estimated
            return True
        visited.add(val)
        for next_b in adj[blank]:                               #子ノード展開
            num = (val >> (4*next_b)) & 15                    #16進数および2進数で盤面を表せることを利用したビット演算
            next_v = val - SW[num][next_b] + SW[num][blank]           #前のハッシュ値の0と0と隣接するピースに対応する値を交換
            if next_v in visited: continue
            next_h = heuristic + MD[blank][num-1] - MD[next_b][num-1]             #(前のヒューリスティック)-(前のヒューリスティックのnum成分)+(次のヒューリスティックのnum成分)とし、次のヒューリスティックを直接計算せずコストを抑えている。
            if cost + 1 > LIMIT: continue                                    #深さの制限
            heappush(queue, (cost + 1 + next_h, cost + 1, next_h, next_v, next_b, val, num))     #もともとは1つ目にnext_hが無いので、g(x)でソートをしてしまっている。next_hを足すことで、f(x)=g(x)+h(x)でソートされ、A*アルゴリズムが実行できる。
			#f(x)が同じなら、次にg(x)を比較して小さいほうを取り出すというような、タプルのインデックスがレベルになっている木構造の優先度付きキューがヒープである。
    return False

def simulate(v):
    if v == -1: return        #ベースケースの指定(再帰を切るための条件)
    simulate(parent[v][0])     #盤面が-1,つまり開始盤面に行くまで戻り、再帰をreturnで切る。
    if parent[v][1] != -1:     #前の盤面から動かしたピースの確認、表示。開始盤面のみ、ここは表示せず、盤面のみ表示する。
        print('\n', 'Move', parent[v][1], '\n')
    for i in range(N*N):       #各盤面の表示
        if i%3 == 0: print('[', end='')
        print(v >> (4*i) & 15, end='')
        if (i+1)%3 == 0: print(']')
        else: print(', ', end='')

if aster():
    print(ans)
    #simulate(target)
else:
    print(""unsolvable"")
"
7297739,ALDS1_13_B,"import copy

Dir = [[1,3],[0,2,4],[1,5],[0,4,6],[1,3,5,7],[2,4,8],[3,7],[4,6,8],[5,7]]
goal = (1,2,3,4,5,6,7,8,0)

start = []
for _ in range(3):
	start.extend(list(map(int, input().split("" ""))))
start = tuple(start)

bwhist = {goal:True}
fwhist = {start:True}

cnt = 0
fw = {start}
bw = {goal}
while len(fw & bw) == 0:
	nfw = set()
	for f in fw:
		f = list(f)
		i = f.index(0)
		for j in Dir[i]:
			nf = copy.copy(f)
			nf[i], nf[j] = nf[j], nf[i]
			nf = tuple(nf)
			if nf not in fwhist:
				nfw.add(nf)
				fwhist[nf] = True
	fw = nfw
	cnt += 1
	if len(fw & bw) > 0:
		break
	nbw = set()
	for b in bw:
		b = list(b)
		i = b.index(0)
		for j in Dir[i]:
			nb = copy.copy(b)
			nb[i], nb[j] = nb[j], nb[i]
			nb = tuple(nb)
			if nb not in bwhist:
				nbw.add(nb)
				bwhist[nb] = True
	bw = nbw
	cnt += 1	

print(cnt)

"
1668847,ALDS1_13_B,"import heapq
from itertools import chain
from operator import mul

exp10 = [10 ** a for a in range(8, -1, -1)]
movables = [{1, 3}, {0, 2, 4}, {1, 5}, {0, 4, 6}, {1, 3, 5, 7}, {2, 4, 8}, {3, 7}, {4, 6, 8}, {5, 7}]

destination = 123456780


def swap(board, move_from, move_to):
    return board + (exp10[move_to] - exp10[move_from]) * (board // exp10[move_from] % 10)


board0 = sum(map(mul, exp10, chain.from_iterable(map(int, input().split()) for _ in range(3))))
p0 = ('0' + str(board0))[-9:].index('0')

appeared = ({board0: 0}, {destination: 0})
queue = []
queue.extend((0, 0, move_from, p0, board0) for move_from in movables[p0])
queue.extend((0, 1, move_from, 8, destination) for move_from in movables[8])
heapq.heapify(queue)

while True:
    total_cost, direction, move_from, move_to, board = heapq.heappop(queue)
    if board in appeared[not direction]:
        print(total_cost + appeared[not direction][board])
        break
    new_board = swap(board, move_from, move_to)
    if new_board in appeared[direction]:
        continue
    appeared[direction][new_board] = total_cost + 1
    for move_from2 in movables[move_from]:
        if move_from2 != move_to:
            heapq.heappush(queue, (total_cost + 1, direction, move_from2, move_from, new_board))
"
6606460,ALDS1_13_B,"from heapq import heappop, heappush

LIMIT = 45
N = 3                                                          # N * N pieces

adj = [{1, 3}, {0, 2, 4}, {1, 5},                   # N * N pieces are represented by 0, 1, ..., (N*N-1)
      {0, 4, 6}, {1, 3, 5, 7}, {2, 4, 8},      # adj[i]: an adj list for piece i
      {3, 7}, {6, 4, 8}, {5, 7},
      ]

pieces = [[[0] for j in range(N)] for i in range(N)]           # contents for simulation

MD = [[abs(i//N-j//N)+abs(i%N-j%N) for j in range(N*N) ] for i in range(N*N)]    # manhattan dist between piece i and j
PW = [16**i for i in range(N*N)]                               # 16^i
SW = [[i*PW[j] for j in range(N*N) ] for i in range(N*N)]      # i * 16^j

initial_v, initial_h, initial_b = 0, 0, -1
target = 0

p = 0
for i in range(N):
    row = list(map(int, input().split()))
    #piecesに書く数字の位置を読み込む
    for j in range(N):
        pieces[i][j] = row[j]
        if row[j] == 0:
            initial_b = i*N + j                                # set the place of the blank
        else:            
            initial_v += row[j]*PW[p]                          # initial hash value of the puzzle
            initial_h += MD[p][row[j]-1]                       # initial estimation cost
        if (p+1) <= 8: target += (p+1)*PW[p]
        p += 1

ans = -1
parent = {}                                                    # parent of BFS tree to simulate

def aster():
    global ans, parent
    queue = [(initial_h , 0, initial_h, initial_v, initial_b, -1, -1)]
    visited = set()
    parent[initial_v] = [-1, -1]
    
    while len(queue) > 0:
        estimated, cost, heuristic, val, blank, pre_v, pre = heappop(queue)
        

        parent[val] = [pre_v, pre]
        if val in visited: continue
        if val == target:
            # ans = estimated
            ans = cost
            return True
        visited.add(val)
        #空白を次はどこに動かすか
        for next_b in adj[blank]:
            num = (val >> (4*next_b)) & 15
            #空白を動かした後の盤面の評価値
            next_v = val - SW[num][next_b] + SW[num][blank]
            if next_v in visited: continue
            #空白を動かした後の盤面のヒューリスティック
            next_h = heuristic + MD[blank][num-1] - MD[next_b][num-1]
            if cost + 1 > LIMIT: continue
            heappush(queue, (next_h+cost+1, cost + 1, next_h, next_v, next_b, val, num))

    return False

def simulate(v):
    if v == -1: return
    simulate(parent[v][0])
    if parent[v][1] != -1:
        print('\n', 'Move', parent[v][1], '\n')
    for i in range(N*N):
        if i%4 == 0: print('[', end='')
        print(v >> (4*i) & 15, end='')
        if (i+1)%4 == 0: print(']')
        else: print(', ', end='')

if aster():
    print(ans)

    

"
6020816,ALDS1_13_B,"import sys
import heapq
import copy

# READ_FROM_FILE = True
READ_FROM_FILE = False

RIGHT = 0
DOWN = 1
LEFT = 2
UP = 3
DIRECTION_BEGIN = RIGHT
DIRECTION_END = RIGHT + 4
DUMMY_DIRECTION = DIRECTION_END + 1

opposite_dir_dic = {RIGHT: LEFT,
                    DOWN: UP,
                    LEFT: RIGHT,
                    UP: DOWN,
                    DIRECTION_END: DUMMY_DIRECTION}
dx_dy_dic = {RIGHT: [1, 0], DOWN: [0, 1], LEFT: [-1, 0], UP: [0, -1]}


def show_puzzle(puzzle, width, height):
    for y in range(height):
        for x in range(width):
            print(f'{puzzle[y][x]:2d}', end=' ')
        print('')
    return


def calc_manhattan_distance_table(width, num_idx, goal_state):
    manhattan_distance_table = [[0] * num_idx for _ in range(num_idx)]

    for c_num in range(num_idx):
        g_idx = goal_state.index(c_num)
        gx = g_idx % width
        gy = g_idx // width
        for c_idx in range(num_idx):
            cx = c_idx % width
            cy = c_idx // width

            manhattan_distance_table[c_num][c_idx] = abs(gx - cx) + abs(gy - cy)

    return manhattan_distance_table


def calc_manhattan_distance(num_idx, manhattan_distance_table, state):
    m_dist = 0
    for c_idx in range(num_idx):
        c_num = state[c_idx]
        m_dist += manhattan_distance_table[c_num][c_idx]
    return m_dist


def get_next_state_list(adjacency_list, manhattan_distance_table, c_h_dist, c_state, c_zero_idx, c_dir):
    next_state_list = []
    for adjacent in adjacency_list[c_zero_idx]:
        n_dir = adjacent[1]
        if c_dir == opposite_dir_dic[n_dir]:
            continue
        n_idx = adjacent[0]
        num_c_state_n_idx = c_state[n_idx]
        n_state = copy.copy(c_state)
        n_state[c_zero_idx] = c_state[n_idx]
        n_state[n_idx] = 0
        n_h_dist = c_h_dist \
                   - manhattan_distance_table[0][c_zero_idx] - manhattan_distance_table[num_c_state_n_idx][n_idx] \
                   + manhattan_distance_table[0][n_idx] + manhattan_distance_table[num_c_state_n_idx][c_zero_idx] + 1
        next_state_list.append((n_h_dist, n_state, n_idx, n_dir))
    return next_state_list


def solve_a_star(num_idx, adjacency_list, manhattan_distance_table, start_state, zero_idx, goal_state):
    m_dist = calc_manhattan_distance(num_idx, manhattan_distance_table, start_state)
    h_q = [(m_dist, 0, start_state, zero_idx, DIRECTION_END)]
    searched_state_tuple_set = set()

    heapq.heapify(h_q)
    while len(h_q) > 0:
        c_h_dist, c_num_moves, c_state, c_zero_idx, c_dir = heapq.heappop(h_q)
        if c_state == goal_state:
            return c_num_moves

        c_state_tuple = tuple(c_state)
        if c_state_tuple in searched_state_tuple_set:
            continue
        searched_state_tuple_set.add(c_state_tuple)

        next_state_list = get_next_state_list(adjacency_list, manhattan_distance_table,
                                              c_h_dist, c_state, c_zero_idx, c_dir)
        for next_state in next_state_list:
            n_h_dist = next_state[0]
            n_state = next_state[1]
            n_zero_idx = next_state[2]
            n_dir = next_state[3]
            n_num_moves = c_num_moves + 1

            heapq.heappush(h_q, (n_h_dist, n_num_moves, n_state, n_zero_idx, n_dir))

    return 0


def main():
    if READ_FROM_FILE:
        f = open('test0.txt', 'r')
    else:
        f = sys.stdin

    goal_state = []
    width = 3
    height = 3
    num_idx = width * height
    adjacency_list = [[] for _ in range(num_idx)]

    for y in range(height):
        offset = y * width
        for x in range(width):
            idx = offset + x
            goal_state.append(idx + 1)

            for d in range(DIRECTION_BEGIN, DIRECTION_END):
                dx = dx_dy_dic[d][0]
                dy = dx_dy_dic[d][1]
                nx = x + dx
                ny = y + dy
                n_idx = ny * width + nx
                if 0 <= nx < width and 0 <= ny < height:
                    adjacency_list[idx].append((n_idx, d))

    goal_state[-1] = 0
    manhattan_distance_table = calc_manhattan_distance_table(width, num_idx, goal_state)
    start_state = []
    for _ in range(height):
        row = list(map(int, f.readline().split()))
        start_state += row

    zero_idx = start_state.index(0)

    min_num_moves = solve_a_star(num_idx, adjacency_list, manhattan_distance_table, start_state, zero_idx, goal_state)

    print(min_num_moves)
    return


if __name__ == '__main__':
    main()


"
6663636,ALDS1_13_B,"import sys
from heapq import heappush, heappop

# READ_FROM_FILE = True
READ_FROM_FILE = False


def calc_manhattan_distance_table(width, num_elements, goal_state):
    manhattan_distance_table = [[0] * num_elements for _ in range(num_elements)]

    for c_num in range(num_elements):
        g_idx = goal_state.index(c_num)
        gx = g_idx % width
        gy = g_idx // width
        for c_idx in range(num_elements):
            cx = c_idx % width
            cy = c_idx // width

            if c_num != 0:
                manhattan_distance_table[c_num][c_idx] = abs(gx - cx) + abs(gy - cy)
            else:
                manhattan_distance_table[c_num][c_idx] = 0
    return manhattan_distance_table


def calc_manhattan_distance(num_elements, manhattan_distance_table, state):
    m_dist = 0
    for c_idx in range(num_elements):
        c_num = state[c_idx]
        m_dist += manhattan_distance_table[c_num][c_idx]
    return m_dist


def get_next_state_list(adjacency_list, manhattan_distance_table, c_h_dist, c_state, c_zero_idx):
    next_state_list = []
    for n_idx in adjacency_list[c_zero_idx]:
        num_c_state_n_idx = c_state[n_idx]
        n_state = c_state[:]
        n_state[c_zero_idx] = c_state[n_idx]
        n_state[n_idx] = 0
        n_h_dist = c_h_dist - manhattan_distance_table[num_c_state_n_idx][n_idx] \
                   + manhattan_distance_table[num_c_state_n_idx][c_zero_idx] + 1
        next_state_list.append((n_h_dist, n_state, n_idx))
    return next_state_list


def solve_a_star(num_elements, adjacency_list, manhattan_distance_table, start_state, zero_idx, goal_state):
    m_dist = calc_manhattan_distance(num_elements, manhattan_distance_table, start_state)
    hq = [(m_dist, 0, start_state, zero_idx)]
    searched_state_tuple_set = set()

    while hq:
        c_h_dist, c_num_moves, c_state, c_zero_idx = heappop(hq)
        if c_state == goal_state:
            return c_num_moves

        next_state_list = get_next_state_list(adjacency_list, manhattan_distance_table,
                                              c_h_dist, c_state, c_zero_idx)
        for next_state in next_state_list:
            next_state_tuple = tuple(next_state[1])
            if next_state_tuple not in searched_state_tuple_set:
                searched_state_tuple_set.add(next_state_tuple)
                n_h_dist = next_state[0]
                n_state = next_state[1]
                n_zero_idx = next_state[2]
                n_num_moves = c_num_moves + 1
                heappush(hq, (n_h_dist, n_num_moves, n_state, n_zero_idx))

    return 0


def main():
    if READ_FROM_FILE:
        f = open('test0.txt', 'r')
    else:
        f = sys.stdin

    width = 3
    height = 3
    num_elements = width * height
    dx_dy_tuple = ((1, 0), (0, 1), (-1, 0), (0, -1))
    adjacency_list = [[] for _ in range(num_elements)]
    goal_state = []

    for y in range(height):
        offset = y * width
        for x in range(width):
            idx = offset + x
            goal_state.append(idx + 1)

            for dx, dy in dx_dy_tuple:
                nx = x + dx
                ny = y + dy
                n_idx = ny * width + nx
                if 0 <= nx < width and 0 <= ny < height:
                    adjacency_list[idx].append(n_idx)

    goal_state[-1] = 0
    manhattan_distance_table = calc_manhattan_distance_table(width, num_elements, goal_state)
    start_state = []
    for _ in range(height):
        row = list(map(int, f.readline().split()))
        start_state += row

    zero_idx = start_state.index(0)
    min_num_moves = solve_a_star(num_elements, adjacency_list, manhattan_distance_table,
                                 start_state, zero_idx, goal_state)
    print(min_num_moves)

    if READ_FROM_FILE:
        f.close()
    return


if __name__ == '__main__':
    main()

"
8866213,ALDS1_13_B,"# aizu_ALDS1_13_B_8Puzzle.py  

from collections import deque
init =''
for _ in range(3):
    init += ''.join(map(str,input().split()))
idx = init.find('0')
goal = '123456780'
swapdata = [ [1,3],[0,2,4],[1,5],[0,4,6],[1,3,5,7],
                      [2,4,8],[3,7],[4,6,8],[5,7]]

dq = deque([init])
state_d = {init:[idx,0]}

def swap(state,i,j):
    t = list(state)
    t[i],t[j] = t[j],t[i]
    r = ''.join(t)
    return r

def bfs():
    while dq:
        state = dq.popleft()
        idx0,cnt = state_d[state]
        for i in range(len(swapdata[idx0])):
            n_state = swap(state,idx0,swapdata[idx0][i])
            if n_state in state_d:continue
            dq.append(n_state)
            state_d[n_state] = [swapdata[idx0][i],cnt+1]
            if n_state == goal:
                print(cnt+1)
                exit()

if init == goal:
    print(0)
    exit()
bfs()

"
5190114,ALDS1_13_B,"import sys,queue,heapq,copy
input=sys.stdin.readline
W=3
H=3
RIGHT=0
LEFT=1
UP=2
DOWN=3
class Puzzle:
    def __init__(self,m,z,h,g=0,bef=None):
        self.bef=bef
        self.m=[mm[:] for mm in m]
        self.z=z
        self.h=h
        self.g=g
    def __lt__(self,other):
        return (self.h+self.g)<(other.h+other.g)
def Hur(num,i,j):
    return abs(i-(num-1)//W)+abs(j-(num-1)%W)
Map=[]
for y in range(H):
    Map.append(list(map(int,input().split())))
z=[]
h=0
for i in range(H):
    for j in range(W):
        if Map[i][j]==0:
            z=[j,i]
            continue
        num=Map[i][j]
        h+=Hur(num,i,j)
hq=[Puzzle(Map,z,h)]
while True:
    p=heapq.heappop(hq)
    if p.h==0:
        print(p.g)
        break
    y=p.z[1]
    x=p.z[0]
    if x>0 and p.bef!=RIGHT:
        h=p.h
        Map=[mm[:] for mm in p.m]
        h-=Hur(Map[y][x-1],y,x-1)
        Map[y][x]=Map[y][x-1]
        Map[y][x-1]=0
        h+=Hur(Map[y][x],y,x)
        z=[x-1,y]
        heapq.heappush(hq,Puzzle(Map,z,h,p.g+1,LEFT))
    if x<W-1 and p.bef!=LEFT:
        h=p.h
        Map=[mm[:] for mm in p.m]
        h-=Hur(Map[y][x+1],y,x+1)
        Map[y][x]=Map[y][x+1]
        Map[y][x+1]=0
        h+=Hur(Map[y][x],y,x)
        z=[x+1,y]
        heapq.heappush(hq,Puzzle(Map,z,h,p.g+1,RIGHT))
    if y>0 and p.bef!=DOWN:
        h=p.h
        Map=[mm[:] for mm in p.m]
        h-=Hur(Map[y-1][x],y-1,x)
        Map[y][x]=Map[y-1][x]
        Map[y-1][x]=0
        h+=Hur(Map[y][x],y,x)
        z=[x,y-1]
        heapq.heappush(hq,Puzzle(Map,z,h,p.g+1,UP))
    if y<H-1 and p.bef!=UP:
        h=p.h
        Map=[mm[:] for mm in p.m]
        h-=Hur(Map[y+1][x],y+1,x)
        Map[y][x]=Map[y+1][x]
        Map[y+1][x]=0
        h+=Hur(Map[y][x],y,x)
        z=[x,y+1]
        heapq.heappush(hq,Puzzle(Map,z,h,p.g+1,DOWN))
"
7675353,ALDS1_13_B,"import sys
import os
from collections import deque
from heapq import heapify, heappop, heappush

def manhatan_distance(panels):
    d=0
    for i,p in enumerate(panels):
        y,x=divmod(i,n)
        x0,y0=origin[p]
        d+=abs(x-x0)+abs(y-y0)
    return d
        
def exchange(a, num, cnt):
    for i in nexts[num]:
        temp = list(a)
        temp[i], temp[num] = temp[num], temp[i]
        mdis=manhatan_distance(temp)
        heappush(hq,(mdis+cnt+1,i, cnt + 1, tuple(temp)))

istest = False
fn = ""inputdata.txt""
if os.path.exists(fn):
    istest = True
    sys.stdin = open(fn)

ini = tuple(map(int, sys.stdin.read().split()))
n = int(len(ini) ** 0.5)
fin = tuple(list(range(1, n * n)) + [0])

nexts = []
origin=[(n-1,n-1)]
for i in range(n * n):
    y, x = divmod(i, n)
    temp = []
    if y - 1 > -1:
        temp.append(i - n)
    if x - 1 > -1:
        temp.append(i - 1)
    if x + 1 < n:
        temp.append(i + 1)
    if y + 1 < n:
        temp.append(i + n)
    nexts.append(tuple(temp))
    if n*n-1!=i:
        origin.append((x,y))
        
zerof = ini.index(0)
zeror = fin.index(0)
permdic = {}
M = ini
hq=[]
mdist=manhatan_distance(ini)
heappush(hq,(mdist,zerof, 0, ini))
while 1:
    d,z, cnt, M = heappop(hq)
    if M == fin:
        break
    if M in permdic:
        continue
    permdic[M] = cnt
    exchange(M, z, cnt)
print(cnt)
"
4583027,ALDS1_13_B,"from itertools import permutations
from heapq import heappop, heappush


def main():
    *A, = map(int, open(0).read().split())
    initial = get_hash(A)
    goal = get_hash([1, 2, 3, 4, 5, 6, 7, 8, 0])

    ans = search(initial, goal)
    print(ans)


def get_hash(A):
    board = 0
    for i, a in enumerate(A):
        board += a << i*4
    return board


def gen_move_table():
    mask = 0b1111
    dirs = [(-1, 0), (0, -1), (0, 1), (1, 0)]
    ret = [[] for _ in [0]*9]
    for y in range(3):
        for x in range(3):
            i = 3*y+x
            for dy, dx in dirs:
                dr = 3*dy+dx
                if 0 <= y+dy < 3 and 0 <= x+dx < 3:
                    sqmask = mask << (i+dr)*4
                    ret[i].append((dr, sqmask))
    return ret


def gen_next_board(board, move_table):
    mask = 0b1111
    ret = []
    for i in range(9):
        piece = board >> 4*i & mask
        if piece == 0:
            for move in move_table[i]:
                ret.append(do_move(board, move))
    return ret


def do_move(board, move):
    dr, sqmask = move

    sq = board & sqmask
    board ^= sq
    if dr > 0:
        board ^= sq >> dr*4
    else:
        board ^= sq << -dr*4

    return board


def heuristic(board):
    mask = 0b1111
    h = 0
    for i in range(9):
        y, x = divmod(i, 3)

        piece = board >> 4*i & mask
        if piece == 0:
            py, px = 2, 2
        else:
            py, px = divmod(piece-1, 3)
        h += abs(py-y)+abs(px-x)

    return h


def search(initial, goal):
    move_table = gen_move_table()

    dist = {}
    q = []

    dist[initial] = 0
    heappush(q, (heuristic(initial), 0, initial))
    while q:
        _, d, board = heappop(q)

        if board == goal:
            return d

        if board in dist and d > dist[board]:
            continue
        dist[board] = d

        for nboard in gen_next_board(board, move_table):
            nd = d + 1
            if (
                nboard not in dist or
                nboard in dist and nd < dist[nboard]
            ):
                heappush(q, (nd+heuristic(nboard), nd, nboard))


if __name__ == '__main__':
    main()

"
9206489,ALDS1_13_B,"from collections import deque

edge = {}
edge[0] = [1, 3]
edge[1] = [0, 2, 4]
edge[2] = [1, 5]
edge[3] = [0, 4, 6]
edge[4] = [1, 3, 5, 7]
edge[5] = [2, 4, 8]
edge[6] = [3, 7]
edge[7] = [4, 6, 8]
edge[8] = [5, 7]

A = [list(map(int, input().split())) for _ in range(3)]
initial = 0
for i in range(3):
    for j in range(3):
        initial += A[i][j] * 10**(3 * i + j)

dq = deque([(initial, 0)])
visited = set([initial])
while dq:
    state, cnt = dq.popleft()
    if state == 87654321:
        print(cnt)
        break
    state_c = state
    for i in range(9):
        if state_c % 10 == 0:
            v = i
            break
        state_c //= 10
    for t in edge[v]:
        state_c = state
        t_num = (state_c // 10**t) % 10
        state_c -= t_num * 10**t
        state_c += t_num * 10**v
        if state_c in visited:
            continue
        visited.add(state_c)
        dq.append((state_c, cnt + 1))

"
2642691,ALDS1_13_B,"import heapq

def d_manhattan(node_list):
    s = 0
    for i in range(9):
        x_goal = i%3
        y_goal = i//3
        x_now = (node_list[i] - 1)%3
        y_now = (node_list[i] - 1)//3
        if y_now == -1:
            y_now = 2
        dx = abs(x_now - x_goal)
        dy = abs(y_now - y_goal)
        s += dx + dy
    return s

def moveNodeE(node_list, space):
    node_tmp = node_list[:]
    node_tmp[space], node_tmp[space + 1] = node_tmp[space + 1], node_tmp[space]
    return node_tmp
def moveNodeW(node_list, space):
    node_tmp = node_list[:]
    node_tmp[space], node_tmp[space - 1] = node_tmp[space - 1], node_tmp[space]
    return node_tmp
def moveNodeN(node_list, space):
    node_tmp = node_list[:]
    node_tmp[space], node_tmp[space - 3] = node_tmp[space - 3], node_tmp[space]
    return node_tmp
def moveNodeS(node_list, space):
    node_tmp = node_list[:]
    node_tmp[space], node_tmp[space + 3] = node_tmp[space + 3], node_tmp[space]
    return node_tmp

class board:
    def __init__(self, node_list, g):
        self.node = node_list
        self.space = node_list.index(0)
        self.g = g
        self.h = d_manhattan(node_list)
        self.f = self.g + self.h

    def makeBoard(self):
        space = self.space
        cost_now = self.f
        x_s = space%3
        y_s = space//3
        if x_s < 2:
            node_tmp = moveNodeE(self.node, space)
            yield board(node_tmp, self.g + 1)
        if x_s > 0:
            node_tmp = moveNodeW(self.node, space)
            yield board(node_tmp, self.g + 1)
        if y_s < 2:
            node_tmp = moveNodeS(self.node, space)
            yield board(node_tmp, self.g + 1)
        if y_s > 0:
            node_tmp = moveNodeN(self.node, space)
            yield board(node_tmp, self.g + 1)

b_open = []
n_close = {}
n_goal = [1,2,3,4,5,6,7,8,0]
n_start = []

for i in range(3):
    inp = list(map(int, input().split()))
    n_start.extend(inp)

b_start = board(n_start, 0)
heapq.heappush(b_open, (b_start.f, b_start.h, 0, b_start))

i = 0
while b_open:
    _, _, _, b_now = heapq.heappop(b_open)
    if b_now.node == n_goal:
        b_goal = b_now
        break
    n_close["""".join(map(str, b_now.node))] = i
    for b_new in b_now.makeBoard():
        if """".join(map(str, b_new.node)) in n_close:
            continue
        heapq.heappush(b_open, (b_new.f, b_new.h, i, b_new))
        i += 1

print(b_goal.g)
"
4522774,ALDS1_13_B,"import queue
import time

N=3
N2=9
diry=[0,1,0,-1]
dirx=[1,0,-1,0]
pos=[[2,2],[0,0],[0,1],[0,2],[1,0],[1,1],[1,2],[2,0],[2,1]]
move=[[1,3],[0,2,4],[1,5],[0,4,6],[1,3,5,7],[2,4,8],[3,7],[4,6,8],[5,7]]

class Puzzle:
    board=""""
    space=0

    def __init__(self,board,space):
        self.board=board
        self.space=space

    #盤面を表示
    def showBoard(self):
        for i in range(N2):
            if self.board[i]!=0:
                print(self.board[i],end=' ')
            else:
                print('  ',end='')
            if i%3==2:
                print()
        print()

class State:
    pz=None
    g=0
    h=0
    f=0
    pr=None

    def __init__(self,pz,g,h=0,pr=None):
        self.pz=pz
        self.g=g
        self.h=h
        self.f=g+h
        self.pr=pr

    #初期盤面から1手ずつ表示
    def showRoot(self):
        if self.pr!=None:
            self.pr.showRoot()
        self.pz.showBoard()

    def __lt__(self,other):
        if self.f==other.f:
            return self.g>other.g
        return self.f<other.f

#正解とのマンハッタン距離
def h2(p):
    count=0
    for i in range(N2):
        n=int(p.board[i])
        count+=abs(pos[n][0]-i//N)+abs(pos[n][1]-i%N)
    return count

#h1を用いたヒューリスティック探索
def heuristic(pz,h):
    closedList=set()
    s=State(pz,0,h(pz),None)
    q=queue.PriorityQueue()
    q.put(s)
    while not q.empty():
        s=q.get()
        if s.pz.board in closedList:
            continue
        if s.pz.board=='123456780':
            return s.g
        space=s.pz.space
        for next in move[space]:
            nb=list(s.pz.board)
            nb[space],nb[next]=nb[next],nb[space]
            newb=''.join(nb)
            if not newb in closedList:
                np=Puzzle(newb,next)
                ns=State(np,s.g+1,h(np),s)
                q.put(ns)
        closedList.add(s.pz.board)
    return -1

#初期盤面の読み込み
s=''
for i in range(3):
    s+=input()
initialBoard=s.replace(' ','')

#空白の設定
space=initialBoard.find('0')

#Puzzleオブジェクトの作成
initialPuzzle=Puzzle(initialBoard,space)

if initialBoard=='123456780':
    print(0)
else:
    print(heuristic(initialPuzzle,h2))

"
8285524,ALDS1_13_B,"from collections import deque

def ind(x, y):
    return x*3 + y

goal = [1, 2, 3, 4, 5, 6, 7, 8, 0]

board = []
for i in range(3):
    a = list(map(int, input().split()))
    if 0 in a:
        x = i
        y = a.index(0)
    board.append(a)
board = sum(board, [])

q = deque()
q.append([0, x, y, board])

d = dict()
d[tuple(board)] = 0

while q:
    cost, x, y, b = q.popleft()
    if b == goal:
        print(cost)
        exit()
    if d[tuple(b)] < cost:
        continue
    for i in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
        xi = x + i[0]
        yi = y + i[1]
        if 0 <= xi < 3 and 0 <= yi < 3:
            b_copy = b[:]
            b_copy[ind(x, y)], b_copy[ind(xi, yi)] = b_copy[ind(xi, yi)], b_copy[ind(x, y)]
            t = tuple(b_copy)
            if t not in d or d[t] > cost + 1:
                d[t] = cost + 1
                q.append([cost + 1, xi, yi, b_copy])
"
8624452,ALDS1_13_B,"N=3
F=[list(input().split()) for i in range(N)]
S=[]
for i in range(N):
    for j in range(N):
        S.append(int(F[i][j]))
S=tuple(S)
G=tuple([(i+1)%N**2 for i in range(N**2)])

##状態をtuppleとしてエンコードし、toGでグラフと対応づける
gN=10**6 #グラフのノード数
toG={}
toG[S]=0
c=1
dist=[10**10]*(N+1)
from collections import *
que=deque()
que.append((S,0))
while len(que):
    v,d=que.popleft()
    if v==G:
        print(d)
        break
    s=list(v)
    for i in range(N):
        for j in range(N):
            if s[N*i+j]:
                continue
            nslist=[]
            if i:
                ns=s[:]
                ns[N*i+j],ns[N*(i-1)+j]=ns[N*(i-1)+j],ns[N*i+j]
                nslist.append(tuple(ns))
            if i<N-1:
                ns=s[:]
                ns[N*i+j],ns[N*(i+1)+j]=ns[N*(i+1)+j],ns[N*i+j]
                nslist.append(tuple(ns))
            if j:
                ns=s[:]
                ns[N*i+j],ns[N*i+j-1]=ns[N*i+j-1],ns[N*i+j]
                nslist.append(tuple(ns))
            if j<N-1:
                ns=s[:]
                ns[N*i+j],ns[N*i+j+1]=ns[N*i+j+1],ns[N*i+j]
                nslist.append(tuple(ns))
            for ns in nslist:
                if ns not in toG:
                    toG[ns]=c
                    c+=1
                    que.append((ns,d+1))
            

            
                




"
8969407,ALDS1_13_B,"from collections import deque

ALL_BITS = (1 << 36) - 1


class Pazzle:
    __slots__ = [""pos_panel"", ""pos0""]
    pos_panel: int
    pos0: int

    def __init__(self, pos_panel=0, pos0=0):
        self.pos_panel = pos_panel
        self.pos0 = pos0

    def __setitem__(self, pos: int, panel: int):
        mask = ALL_BITS ^ (0x0F << (4 * pos))
        self.pos_panel = (self.pos_panel & mask) + (panel << (4 * pos))
        if panel == 0:
            self.pos0 = pos

    def __getitem__(self, pos: int):
        bits = self.pos_panel >> (4 * pos)
        return bits & 0x0F

    def __hash__(self):
        return self.pos_panel

    def __eq__(self, other):
        return self.pos_panel == other.pos_panel

    def swap0(self, other_pos: int):
        ret = Pazzle(pos_panel=self.pos_panel)
        ret[other_pos] = 0
        ret[self.pos0] = self[other_pos]
        return ret

    def nexts(self):
        pos0 = self.pos0
        if pos0 == 0:
            yield self.swap0(1)
            yield self.swap0(3)
        elif pos0 == 1:
            yield self.swap0(0)
            yield self.swap0(2)
            yield self.swap0(4)
        elif pos0 == 2:
            yield self.swap0(1)
            yield self.swap0(5)
        elif pos0 == 3:
            yield self.swap0(0)
            yield self.swap0(4)
            yield self.swap0(6)
        elif pos0 == 4:
            yield self.swap0(1)
            yield self.swap0(3)
            yield self.swap0(5)
            yield self.swap0(7)
        elif pos0 == 5:
            yield self.swap0(2)
            yield self.swap0(4)
            yield self.swap0(8)
        elif pos0 == 6:
            yield self.swap0(3)
            yield self.swap0(7)
        elif pos0 == 7:
            yield self.swap0(4)
            yield self.swap0(6)
            yield self.swap0(8)
        elif pos0 == 8:
            yield self.swap0(5)
            yield self.swap0(7)
        else:
            assert False


def solve(start: Pazzle):
    goal = Pazzle()
    for i in range(1, 9):
        goal[i - 1] = i
    goal[8] = 0

    visited = set()
    visited.add(start)
    breads = deque([(start, 0)])

    while True:
        p, c = breads.popleft()
        if p == goal:
            return c
        for next_p in p.nexts():
            if next_p not in visited:
                visited.add(next_p)
                breads.append((next_p, c + 1))


if __name__ == ""__main__"":
    start = Pazzle()
    for i in range(3):
        a, b, c = map(int, input().split())
        start[3 * i] = a
        start[3 * i + 1] = b
        start[3 * i + 2] = c

    print(solve(start))

"
2997952,ALDS1_13_B,"dy = [-1, 0, 1, 0]
dx = [0, 1, 0, -1]
t = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]


def get_heuri():
    res = 0
    for i in range(3):
        for j in range(3):
            if t[i][j] == 0:
                continue
            a = t[i][j] - 1
            res += abs(a // 3 - i) + abs(a % 3 - j)
    return res


def check(depth, prev, py, px, limit):
    heuri = get_heuri()
    if heuri + depth > limit:
        return False
    if heuri == 0:
        return True
    for i in range(4):
        if abs(i - prev) == 2:
            continue
        ny = py + dy[i]
        nx = px + dx[i]
        if ny < 0 or nx < 0 or ny >= 3 or nx >= 3:
            continue
        t[ny][nx], t[py][px] = t[py][px], t[ny][nx]
        if check(depth + 1, i, ny, nx, limit):
            return True
        t[ny][nx], t[py][px] = t[py][px], t[ny][nx]
    return False

for i in range(3):
    s = list(map(int, input().split()))
    for j in range(3):
        if s[j] == 0:
            py = i
            px = j
        t[i][j] = s[j]
limit = 0
while True:
    if check(0, 99, py, px, limit):
        print(limit)
        break
    limit += 1
"
4573469,ALDS1_13_B,"import sys, collections
input = lambda: sys.stdin.readline().rstrip() 
sys.setrecursionlimit(10**7)
INF = 10**10
def I(): return int(input())
def F(): return float(input())
def SS(): return input()
def LI(): return [int(x) for x in input().split()]
def LI_(): return [int(x)-1 for x in input().split()]
def LF(): return [float(x) for x in input().split()]
def LSS(): return input().split()

def resolve():
    S = []
    SOLVED = (1, 2, 3, 4, 5, 6, 7, 8, 0)
    for _ in range(3):
        S += LI()

    neighbor = (
        (1, 3),      
        (0, 2, 4),   
        (1, 5),      
        (0, 4, 6),   
        (1, 3, 5, 7),
        (2, 4, 8),   
        (3, 7),      
        (4, 6, 8),   
        (5, 7)       
    )

    dist = dict()
    que = collections.deque()
    S = tuple(S)
    que.append((S, S.index(0)))
    dist[S] = 0
    while que:
        c, idx_0 = que.popleft()
        if c == SOLVED:
            break
        for i in neighbor[idx_0]:
            c_l = list(c)
            c_l[idx_0], c_l[i] = c_l[i], c_l[idx_0]
            n = tuple(c_l)
            if not n in dist:
                que.append((n, i))
                dist[n] = dist[c] + 1

    print(dist[SOLVED])

if __name__ == '__main__':
    resolve()

"
5189917,ALDS1_13_B,"import heapq
import copy

def main() :
    firstBoard = list(list(map(int, input().split())) for _ in range(3))

    result = solve8Puzzle(firstBoard)

    print(result)

def solve8Puzzle(firstBoard) :
    global boardSet
    global puzzleHeap

    nowPuzzle = Puzzle(firstBoard, 0)

    if nowPuzzle.distance == 0 :
        return nowPuzzle.move
        
    boardSet.add(tuple(tuple(firstBoard[i]) for i in range(3)))

    while True :

        if nowPuzzle.distance == 0 :
            break

        for i in range(3) :
            for j in range(3) :

                if nowPuzzle.board[i][j] == 0 :
                    if i - 1 >= 0 :
                        changeBoard = copy.deepcopy(nowPuzzle.board)
                        changeBoard[i][j], changeBoard[i - 1][j] = changeBoard[i - 1][j], changeBoard[i][j]
                        existCheckAndHeapPush(changeBoard, nowPuzzle.move + 1)
                    if i + 1 <= 2 :
                        changeBoard = copy.deepcopy(nowPuzzle.board)
                        changeBoard[i][j], changeBoard[i + 1][j] = changeBoard[i + 1][j], changeBoard[i][j]
                        existCheckAndHeapPush(changeBoard, nowPuzzle.move + 1)
                    if j - 1 >= 0 :
                        changeBoard = copy.deepcopy(nowPuzzle.board)
                        changeBoard[i][j], changeBoard[i][j - 1] = changeBoard[i][j - 1], changeBoard[i][j]
                        existCheckAndHeapPush(changeBoard, nowPuzzle.move + 1)
                    if j + 1 <= 2 :
                        changeBoard = copy.deepcopy(nowPuzzle.board)
                        changeBoard[i][j], changeBoard[i][j + 1] = changeBoard[i][j + 1], changeBoard[i][j]
                        existCheckAndHeapPush(changeBoard, nowPuzzle.move + 1)
                    
        nowPuzzle = heapq.heappop(puzzleHeap)
    
    return nowPuzzle.move

def existCheckAndHeapPush(newBoard, newMove) :
    global boardSet
    global puzzleHeap

    newBoardTuple = tuple(tuple(newBoard[i]) for i in range(3))
    if newBoardTuple not in boardSet :
        boardSet.add(newBoardTuple)
        newPuzzle = Puzzle(newBoard, newMove)
        heapq.heappush(puzzleHeap, newPuzzle)
    
def calculateDistance(board) :
    global correctLocationDict

    distance = 0

    for i in range(3) :
        for j in range(3) :
            boardNowNum = board[i][j]

            if boardNowNum == 0 :
                continue

            collectLocation = correctLocationDict[boardNowNum]
            distance += (abs(i - collectLocation[0]) + abs(j - collectLocation[1]))
    
    return distance


class Puzzle :
    board = list()
    distance = int()
    move = int()

    def __init__(self, board, move) :
        self.board = board
        self.distance = calculateDistance(board)
        self.move = move
    
    def __lt__(self, other) :
        return self.move + self.distance < other.move + other.distance


boardSet = set()
puzzleHeap = list()
correctLocationDict = { 1 : [0, 0],
                        2 : [0, 1],
                        3 : [0, 2],
                        4 : [1, 0],
                        5 : [1, 1],
                        6 : [1, 2],
                        7 : [2, 0],
                        8 : [2, 1],
                        0 : [2, 2] }

main()
"
7009809,ALDS1_13_B,"
from typing import Dict, Optional, Sequence, List, Any, Tuple, Union
from itertools import product
from functools import lru_cache
import heapq


class Board:
    searched = {}
    __answer = (1, 2, 3, 4, 5, 6, 7, 8, 0)

    def __init__(self,
                 board_nums: Sequence[int],
                 current_distance: int):
        self.board = tuple(board_nums)
        self._current_distance = current_distance
        self._heauristic_distace = self._calc_heuristic_distance()
        self.distance = self._current_distance + self._heauristic_distace
        self._space_idx = self.board.index(0)
        self._space_idx_r = self._space_idx // 3
        self._space_idx_c = self._space_idx % 3
        if self.is_current_best_board():
            Board.searched[self.board] = self.distance

    def _calc_heuristic_distance(self) -> int:
        return Board.calc_heuristic_distance(self.board, Board.__answer)

    def is_answer(self) -> bool:
        return self._heauristic_distace == 0

    @staticmethod
    @lru_cache(maxsize=None)
    def calc_heuristic_distance(current_board: Sequence[int],
                                answer: Sequence[int]) -> int:
        dist = 0
        for idx, num in enumerate(current_board):
            dist += Board.single_heuristic_distance(num, idx, answer)

        return dist

    @staticmethod
    @lru_cache(maxsize=None)
    def single_heuristic_distance(
        num: int, idx_num: int, answer: Sequence[int]
    ) -> int:

        ans_idx = answer.index(num)
        idx_r, idx_c = idx_num // 3, idx_num % 3
        ans_idx_r, ans_idx_c = ans_idx // 3, ans_idx % 3
        return abs(idx_r - ans_idx_r) + abs(idx_c - ans_idx_c)

    def __eq__(self, __o: object) -> bool:
        if isinstance(__o, Board):
            return self.distance == __o.distance
        super().__eq__(__o)

    def __ne__(self, __o: object) -> bool:
        if isinstance(__o, Board):
            return not self.__eq__(__o)
        super().__ne__(__o)

    def __lt__(self, __o: object) -> bool:
        if isinstance(__o, Board):
            return self.distance < __o.distance
        super().__lt__(__o)

    def __le__(self, __o) -> bool:
        if isinstance(__o, Board):
            return self.__eq__(__o) or self.__lt__(__o)
        super().__le__(__o)

    def __gt__(self, __o) -> bool:
        if isinstance(__o, Board):
            return not self.__le__(__o)
        super().__gt__(__o)

    def __ge__(self, __o) -> bool:
        if isinstance(__o, Board):
            return not self.__lt__(__o)
        super().__ge__(__o)

    def move(self) -> List:
        return [
            board for board
            in (self.up(), self.down(), self.left(), self.right())
            if board is not None
        ]

    def up(self) -> Optional[Any]:
        if self._space_idx_r == 0:
            return
        next_space_idx = (self._space_idx_r - 1) * 3 + self._space_idx_c
        next_space_idx_num = self.board[next_space_idx]
        next_board_nums = list(self.board)
        next_board_nums[self._space_idx] = next_space_idx_num
        next_board_nums[next_space_idx] = 0
        return Board(next_board_nums, self._current_distance + 1)

    def down(self) -> Optional[Any]:

        if self._space_idx_r == 2:
            return
        next_space_idx = (self._space_idx_r + 1) * 3 + self._space_idx_c
        next_space_idx_num = self.board[next_space_idx]
        next_board_nums = list(self.board)
        next_board_nums[self._space_idx] = next_space_idx_num
        next_board_nums[next_space_idx] = 0
        return Board(next_board_nums, self._current_distance + 1)

    def left(self) -> Optional[Any]:
        if self._space_idx_c == 0:
            return
        next_space_idx = self._space_idx_r * 3 + self._space_idx_c - 1
        next_space_idx_num = self.board[next_space_idx]
        next_board_nums = list(self.board)
        next_board_nums[self._space_idx] = next_space_idx_num
        next_board_nums[next_space_idx] = 0
        return Board(next_board_nums, self._current_distance + 1)

    def right(self) -> Optional[Any]:
        if self._space_idx_c == 2:
            return
        next_space_idx = self._space_idx_r * 3 + self._space_idx_c + 1
        next_space_idx_num = self.board[next_space_idx]
        next_board_nums = list(self.board)
        next_board_nums[self._space_idx] = next_space_idx_num
        next_board_nums[next_space_idx] = 0
        return Board(next_board_nums, self._current_distance + 1)

    def is_current_best_board(self) -> bool:
        if not self.board in Board.searched:
            return True
        return self.distance <= Board.searched[self.board]


def main():
    initial_board_nums = []
    for _ in range(3):
        nums = map(int, input().split())
        initial_board_nums.extend(nums)

    initial_board = Board(initial_board_nums, 0)
    search_boards = [(initial_board.distance, initial_board)]

    while search_boards:
        current_distance, current_board = heapq.heappop(search_boards)
        if not current_board.is_current_best_board():
            continue
        if current_board.is_answer():
            break

        next_boards = current_board.move()
        for next_board in next_boards:
            heapq.heappush(search_boards, (next_board.distance,  next_board))

    print(current_distance)


if __name__ == ""__main__"":
    main()

"
3579916,ALDS1_13_B,"N = 3
dx = [0,-1,0,1]
dy = [1,0,-1,0]
limit = 0
t = [[0 for i in range(N)] for j in range(N)]

def getH():
    sum = 0
    x = int(0)
    for i in range(N):
        for j in range(N):
            if t[i][j]==0:continue
            x=t[i][j]-1
            sum += abs(int(x/N)-i)+abs((int(x%N)-j))
    return sum

def dfs( depth, prev,py,px):
    h=getH()
    if h == 0 :return True 
    if depth+h > limit: return False
    for i in range(4):
        if abs(i-prev) == 2 : continue
        tx=px+dx[i]
        ty=py+dy[i]
        if tx<0 or ty<0 or tx>=N or ty>=N:continue
        t[ty][tx],t[py][px] = t[py][px],t[ty][tx]
        if dfs(depth+1,i,ty,tx) :return True
        t[ty][tx],t[py][px] = t[py][px],t[ty][tx]
    return False

def Solve(py, px):
    global limit
    limit =0
    while True:
        if dfs(0,99,py,px):
            print(limit)
            return 
        limit += 1
 
if __name__=='__main__':
    for i in range(N):
        tmp =list(map(int, input().split()))
        for j in range(N):
            t[i][j]=tmp[j]
            if t[i][j]==0:
                py=i
                px=j
    Solve(py,px)


"
4593543,ALDS1_13_B,"from collections import deque

class Puzzle:
    def __init__(self, ls, answer_flag=False):
        self.piece_vec = list(ls)
        self.update_value = [-3, 3, -1, 1]
        for idx, piece in enumerate(ls):
            if piece == 0:
                self.space_idx = idx
        
        self.space_idx_before_slide = deque()
        self.manhattan_distance = list()
        if answer_flag:
            for i in range(9):
                self.manhattan_distance.append([(abs(i % 3 - j % 3) + abs(i // 3 - j // 3)) for j in range(9)])
                    
        
    def GetManhattanDistance(self, ans_idx, idx):
        return self.manhattan_distance[ans_idx][idx]
        
    def SumManhattanDistance(self, answer_board):
        sum_MD = 0
        for idx, piece in enumerate(self.piece_vec):
            if piece == 0:
                continue
            answer_idx = piece - 1
            sum_MD += answer_board.GetManhattanDistance(answer_idx, idx)
        return sum_MD
    
    def SlideSpace(self, command):
        is_frame = [self.space_idx < 3, self.space_idx >= 6, self.space_idx % 3 == 0, self.space_idx % 3 == 2]
        if is_frame[command]:
            return False
        
        next_space_idx = self.space_idx + self.update_value[command]
        if len(self.space_idx_before_slide) > 0 and next_space_idx == self.space_idx_before_slide[-1]:
            return False
        
        self.piece_vec[self.space_idx], self.piece_vec[next_space_idx] = self.piece_vec[next_space_idx], self.piece_vec[self.space_idx]
        self.space_idx_before_slide.append(self.space_idx)
        self.space_idx = next_space_idx
        return True
    
    def BackState(self):
        self.piece_vec[self.space_idx], self.piece_vec[self.space_idx_before_slide[-1]] = self.piece_vec[self.space_idx_before_slide[-1]], self.piece_vec[self.space_idx]
        self.space_idx = self.space_idx_before_slide.pop()

def SolvePuzzleByDFS(board, answer_board, limit, depth = 0):
    if board.SumManhattanDistance(answer_board) == 0:
        return True
    
    if depth + board.SumManhattanDistance(answer_board) > limit:
        return False
    
    for command in range(4):
        if board.SlideSpace(command) == False:
            continue
        
        if SolvePuzzleByDFS(board, answer_board, limit, depth+1):
            return True
        board.BackState()
    
    return False

def CalcMinStepOf15Puzzle(board, answer_board):
    for limit in range(board.SumManhattanDistance(answer_board), 35):
        if SolvePuzzleByDFS(board, answer_board, limit):
            return limit
    
    return -1

def main():
    inputLs = list()
    answerLs = [ 1, 2, 3,
                 4, 5, 6, 
                 7, 8, 9]
    for _ in range(3):
        inputLs += list(map(int, input().split()))

    start_board = Puzzle(inputLs)
    answer_board = Puzzle(answerLs, True)
    
    min_step = CalcMinStepOf15Puzzle(start_board, answer_board);
    
    print(min_step)

if __name__ == '__main__':
    main()

"
2602967,ALDS1_13_B,"import copy
def hashnum(state):
    num = 0
    for i in range(3):
        for j in range(3):
            num *= 10
            num += state[i][j]
    return num

answer = 123456780
ini_state = []
for i in range(3):
    temp = [int(n) for n in input().split("" "")]
    if 0 in temp:
        zero_x, zero_y = temp.index(0), i
    ini_state.append(temp)
end_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]
queue = [[ini_state, zero_x, zero_y, 0], [end_state, 2, 2, 1]]
dx = [1, 0, -1, 0]
dy = [0, 1, 0, -1]
visited = {}
if hashnum(ini_state) == answer:
    print(0)
else:
    visited[hashnum(ini_state)] = [0, 0]
    visited[answer] = [0, 1]
    trial = 0
    ended = 0
    while queue:
        new_queue = []
        trial += 1
        for q in queue:
            if ended:
                break
            state, zero_x, zero_y, direction = q
            for i in range(len(dx)):
                new_state = copy.deepcopy(state)
                new_x = zero_x + dx[i]
                new_y = zero_y + dy[i]
                if 0 <= new_x < 3 and 0 <= new_y < 3:
                    new_state[new_y][new_x], new_state[zero_y][zero_x] = new_state[zero_y][zero_x], new_state[new_y][new_x]
                    perm = hashnum(new_state)
                    if perm in visited and direction != visited[perm][1]:
                        print(trial + visited[perm][0])
                        ended = 1
                        break
                    elif perm not in visited:
                        visited[perm] = [trial, direction]
                        new_queue.append([new_state, new_x, new_y, direction])
        queue = new_queue
"
3802947,ALDS1_13_B,"import copy
from typing import List, Tuple


def _generate_goal() -> List[List[int]]:
    goal = [[0] * 3 for _ in range(3)]
    for row in range(3):
        for col in range(3):
            if 9 == 3 * row + col + 1:
                goal[row][col] = 0
            else:
                goal[row][col] = 3 * row + col + 1
    return goal


def _find_zero_pos(board: List[List[int]]) -> Tuple[int, int]:
    for row in range(3):
        for col in range(3):
            if 0 == board[row][col]:
                return (row, col)
    # Never reaches here.
    return (-1, -1)


def _swappable_cand(zero_pos: Tuple[int, int]) -> List[Tuple[int, int]]:
    row, col = zero_pos[0], zero_pos[1]
    cand_pos_list: List[Tuple[int, int]] = []
    if 0 != row:
        cand_pos_list.append((row - 1, col))
    if 2 != row:
        cand_pos_list.append((row + 1, col))
    if 0 != col:
        cand_pos_list.append((row, col - 1))
    if 2 != col:
        cand_pos_list.append((row, col + 1))

    return cand_pos_list


def solve_8puzzle(board: List[List[int]]) -> int:
    goal = _generate_goal()
    if board == goal:
        return 0
    generated_boards = {tuple(sum(board, [])): 0, tuple(sum(goal, [])): 1}
    steps = {tuple(sum(board, [])): 0, tuple(sum(goal, [])): 0}
    step = 0
    state = [(board, 0), (goal, 1)]
    while state:
        state_copied = copy.deepcopy(state)
        state = []
        step += 1
        for s2, d in state_copied:
            zero_row, zero_col = _find_zero_pos(s2)
            cand_pos_list = _swappable_cand((zero_row, zero_col))
            for (row, col) in cand_pos_list:
                s1 = copy.deepcopy(s2)
                s1[zero_row][zero_col], s1[row][col] = s1[row][col], 0
                key = tuple(sum(s1, []))
                if key in generated_boards:
                    if generated_boards[key] != d:
                        return step + steps[key]
                    continue
                state.append((s1, d))
                generated_boards[key] = d
                steps[key] = step
    # Never reaches here.
    return -1


if __name__ == ""__main__"":
    board = [[0] * 3 for _ in range(3)]

    for row in range(3):
        input_nums = list(map(lambda x: int(x), input().split()))
        for col in range(3):
            # if 0 == input_nums[col]:
            #     zero_pos = (row, col)
            board[row][col] = input_nums[col]

    print(f""{solve_8puzzle(board)}"")

"
6667655,ALDS1_13_B,"import copy
import heapq

class Node:
    def __init__(self, state, g, h, parent):
        self.state = state
        self.g = g
        self.h = h
        self.parent = parent
        
    def cost(self):
        return self.g + self.h
    
    def __lt__(self, other):
        if (self.g + self.h) < (other.g + other.h):
            return True
        elif (self.g + self.h) == (other.g + other.h):
            return self.h < other.h
        else:
            return False
        
class State:
    def __init__(self, pos):
        self.pos = pos
    
    def __str__(self):
        string = """"
        for i in range(3):
            for j in range(3):
                string += ' ' + str(self.pos[i][j])
            string += '\n'
        return string

    def __eq__(self, other):
        return self.pos == other.pos
    
    def get_position(self, num):
        for i in range(3):
            for j in range(3):
                if self.pos[i][j] == num:
                    return (i, j)
        # should throw exception
        return None
    
class Puzzle:
    def __init__(self, init_pos):
        self.start = State(init_pos)
        self.goal = State([[1, 2, 3], [4, 5, 6], [7, 8, 0]])
        
class AStar:
    def __init__(self, puzzle):
        self.puzzle = puzzle
        self.closed_list = { }
        self.expcnt = 0

    def solution_path(self, goal):
        solution = []
        node = goal
        i = -1
        while True:
            i += 1
            if node.parent.pos[0][0] < 0:
                break
            node = self.closed_list[str(node.parent)]
        return i
        
    def heuristic(self, state):
        # 0以外のパネルのマンハッタン距離の和
        h_value = 0
        for i in range(3):
            for j in range(3):
                if(state.pos[i][j] > 0):
                    h_value += abs((state.pos[i][j]-1)%3 -j)+abs((state.pos[i][j]-1)//3 -i)
        return h_value
    
    def expand(self, node):
        # cstate = node.state.pos.copy()
        children = []
        for i in range(3):
            for j in range(3):
                if(node.state.pos[i][j] == 0):
                    x,y = i,j
                    break
        if(x>0):
            self.expcnt += 1
            cstate = copy.deepcopy(node.state.pos)
            cstate[x-1][y],cstate[x][y] = cstate[x][y],cstate[x-1][y]
            children.append(Node(State(cstate),node.g+1,self.heuristic(State(cstate)),node.state))
        if(y>0):
            self.expcnt += 1
            cstate = copy.deepcopy(node.state.pos)
            cstate[x][y-1],cstate[x][y] = cstate[x][y],cstate[x][y-1]
            children.append(Node(State(cstate),node.g+1,self.heuristic(State(cstate)),node.state))
        if(x<2):
            self.expcnt += 1
            cstate = copy.deepcopy(node.state.pos)
            cstate[x+1][y],cstate[x][y] = cstate[x][y],cstate[x+1][y]
            children.append(Node(State(cstate),node.g+1,self.heuristic(State(cstate)),node.state))
        if(y<2):
            self.expcnt += 1
            cstate = copy.deepcopy(node.state.pos)
            cstate[x][y+1],cstate[x][y] = cstate[x][y],cstate[x][y+1]
            children.append(Node(State(cstate),node.g+1,self.heuristic(State(cstate)),node.state))
        return children

    def search(self):
        start_state = self.puzzle.start
        dummy_state = State([[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]])
        start_node = Node(start_state, 0, self.heuristic(start_state), dummy_state)
        
        # open_list の初期化
        open_queue = [start_node]
        heapq.heapify(open_queue)
        
        # ハッシュ表の初期化。ここではハッシュ表のキーとしてStateの文字列を使っている
        self.closed_list = { }
        self.closed_list[str(start_state)] = start_node
        
        if str(start_state) == str(self.puzzle.goal):
            return 0
        while len(open_queue) != 0:
            n = heapq.heappop(open_queue)
            if n.state == self.puzzle.goal:
                return self.solution_path(n)
                # return str(n.state)
            child_nodes = self.expand(n)
            for c in child_nodes:
                if str(c.state) not in self.closed_list or c < self.closed_list[str(c.state)]:
                    self.closed_list[str(c.state)] = c
                    heapq.heappush(open_queue, c)
        return None

pzl = Puzzle([list(map(int,input().split())) for i in range(3)])
solver = AStar(pzl)
solution = solver.search()
print(solution)
"
4437050,ALDS1_13_B,"import sys
from heapq import heappop, heappush


adjacent = (
    (1, 3),        # 位置 0 に 0が存在したときに入れ替え可能な位置
    (0, 2, 4),     # 位置 1 に 0が存在したときに入れ替え可能な位置
    (1, 5),        # 位置 2 に 0が存在したときに入れ替え可能な位置
    (0, 4, 6),     # 位置 3 に 0が存在したときに入れ替え可能な位置
    (1, 3, 5, 7),  # 位置 4 に 0が存在したときに入れ替え可能な位置
    (2, 4, 8),     # 位置 5 に 0が存在したときに入れ替え可能な位置
    (3, 7),        # 位置 6 に 0が存在したときに入れ替え可能な位置
    (4, 6, 8),     # 位置 7 に 0が存在したときに入れ替え可能な位置
    (5, 7)         # 位置 8 に 0が存在したときに入れ替え可能な位置
)


def move(board, space, prev_space):
    for next_space in adjacent[space]:
        if next_space == prev_space:
            continue
        next_board = board[:]
        next_board[space], next_board[next_space] = next_board[next_space], 0
        yield next_board, next_space


end = [1, 2, 3, 4, 5, 6, 7, 8, 0]
discovered_state = set()  # すでに知っている状態を記録する


def search(start):
    discovered_state.add(tuple(start))
    heap = [(0, start, start.index(0), None)]  # 今の状態へ到達する手順回数

    while heap:
        i, board, space, prev = heappop(heap)

        if board == end:
            return i

        i += 1
        for next_board, next_space in move(board, space, prev):
            if tuple(next_board) in discovered_state:
                continue
            discovered_state.add(tuple(next_board))
            heappush(heap, (i, next_board, next_space, space))


def main():
    start = []
    for _ in range(3):
        start.extend(list(map(int, sys.stdin.readline().strip().split())))
    ans = search(start)
    print(ans)


if __name__ == '__main__':
    main()



"
8138383,ALDS1_13_B,"from collections import deque

DIRECTIONS = [(-1, 0), (0, 1), (1, 0), (0, -1)]

def is_inside_board(row, col):
    if row < 0 or col < 0 or row >= 3 or col >= 3:
        return False
    return True

def solve_puzzle(start, goal):
    queue = deque()
    distance = {}
    distance[start] = 0
    queue.append(start)
    while queue:
        current_state = queue.popleft()
        cost = distance[current_state]
        if current_state == goal:
            print(distance[current_state])
            break
        zero_index = current_state.index('0')
        zero_row = zero_index // 3
        zero_col = zero_index % 3
        for direction in DIRECTIONS:
            new_row = zero_row + direction[0]
            new_col = zero_col + direction[1]
            if not is_inside_board(new_row, new_col):
                continue
            new_index = new_row * 3 + new_col
            new_state = list(current_state)
            new_state[zero_index], new_state[new_index] = new_state[new_index], new_state[zero_index]
            new_state = ''.join(new_state)
            if new_state not in distance:
                distance[new_state] = cost + 1
                queue.append(new_state)

goal = ""123456780""
start = """"
for _ in range(3):
    start += ''.join(input().split())
solve_puzzle(start, goal)

"
7017932,ALDS1_13_B,"from collections import deque 

B = ''
for _ in range(3):
    a, b, c = input().split()
    B = B + a + b + c
    
i = B.find('0')
D = {}
D[B] = 0
seen = set()
seen.add(B)
que = deque([(B, i)])

while que:
    b, i = que.popleft()
    if i % 3 == 0: #左端
        for j in [-3, 3, 1]: 
            k = i + j #入れ替え候補位置のindex
            if 0 <= k <= 8:
                c = [s for s in b]
                c[i], c[k] = c[k], c[i]
                x = ''.join(c)
                if x not in D:
                    D[x] = D[b] + 1
                    que.append((x, k))
    if i % 3 == 1: #中央
        for j in [-3, 3, -1, 1]: 
            k = i + j #入れ替え候補位置のindex
            if 0 <= k <= 8:
                c = [s for s in b]
                c[i], c[k] = c[k], c[i]
                x = ''.join(c)
                if x not in D:
                    D[x] = D[b] + 1
                    que.append((x, k))
    if i % 3 == 2: #右端
        for j in [-3, 3, -1]: 
            k = i + j #入れ替え候補位置のindex
            if 0 <= k <= 8:
                c = [s for s in b]
                c[i], c[k] = c[k], c[i]
                x = ''.join(c)
                if x not in D:
                    D[x] = D[b] + 1
                    que.append((x, k))
                    
if '123456780' in D:
    print(D['123456780'])
"
6972824,ALDS1_13_B,"from collections import deque

def swap(s,i,j):
    ls = list(s)
    ls[i], ls[j] = ls[j], ls[i]
    return ''.join(ls)

def solve(init):
    # 処理をゴールの状態からはじめて入力の状態に持っていく形にする
    goal = ''.join([str(i) for i in range(1, 9)]) + '0' # 123456780
    ng = [[2,3],[3,2],[5,6],[6,5]] # 0オリジンでの交換できない盤面上の場所

    used = {goal : 0}
    que = deque([[goal, 8, 0]]) # state: パズルの状態, p: 0の位置, cnt: 交換回数

    # 交換した状態はキューの後ろに追加: 後ろに交換回数の多い状態がどんどん積まれる
    # 交換回数が少ないキューの前から適切な状態かチェックする
    while que:
        state, zero_pos, cnt = que.popleft()
        if state == init:
            ans = cnt
            break

        # val: 0の場所を見て交換できる盤面上の位置
        # 適切にカウントアップしながらパズルの状態・0の位置・交換回数を記録して試行キューに追加
        for change_pos in [chg for chg in [zero_pos-1, zero_pos+1, zero_pos-3, zero_pos+3]
                           if 0 <= chg <= 8 and [zero_pos, chg] not in ng]:
            tmp = swap(state, zero_pos, change_pos)
            if tmp in used:
                continue
            que.append([tmp, change_pos, cnt+1])
            used[tmp] = cnt + 1

    return ans

init = ''
for i in range(3): init += input().replace(' ', '')
print(solve(init))

"
6060954,ALDS1_13_B,"from collections import deque

edge = {}
edge[0] = [1, 3]
edge[1] = [0, 2, 4]
edge[2] = [1, 5]
edge[3] = [0, 4, 6]
edge[4] = [1, 3, 5, 7]
edge[5] = [2, 4, 8]
edge[6] = [3, 7]
edge[7] = [4, 6, 8]
edge[8] = [5, 7]

A = [list(map(int, input().split())) for _ in range(3)]
initial = 0
for i in range(3):
    for j in range(3):
        initial += A[i][j] * 10**(3 * i + j)

dq = deque([(initial, 0)])
visited = set([initial])
while dq:
    state, cnt = dq.popleft()
    if state == 87654321:
        print(cnt)
        break
    state_c = state
    for i in range(9):
        if state_c % 10 == 0:
            v = i
            break
        state_c //= 10
    for t in edge[v]:
        state_c = state
        t_num = (state_c // 10**t) % 10
        state_c -= t_num * 10**t
        state_c += t_num * 10**v
        if state_c in visited:
            continue
        visited.add(state_c)
        dq.append((state_c, cnt + 1))
"
3701426,ALDS1_13_B,"import heapq


N = 3
FORE = 1
BACK = 0

board_goal = [i for i in range(1, N ** 2)] + [0]


BOARD_ADJACENT = (
    (1, 3),        # 0
    (0, 2, 4),     # 1
    (1, 5),        # 2
    (0, 4, 6),     # 3
    (1, 3, 5, 7),  # 4
    (2, 4, 8),     # 5
    (3, 7),        # 6
    (4, 6, 8),     # 7
    (5, 7)         # 8
)


def slove(board_start):
    if board_start == board_goal:
        return 0

    dict_board_state = {}
    dict_board_state[tuple(board_start)] = (FORE, 0)

    heap_board = [(0, board_start, board_start.index(0), None, FORE)]

    while heap_board:
        cnt_move, board, space_now, space_prev, direction = heapq.heappop(heap_board)
        cnt_move += 1

        for board_next, space_next in next_board(board, space_now, space_prev):
            key = tuple(board_next)
            if key in dict_board_state:
                continue

            dict_board_state[key] = (direction, cnt_move)
            if board_next == board_goal:
                return cnt_move

            heapq.heappush(heap_board, (cnt_move, board_next, space_next, space_now, direction))

            
def next_board(board, space_now, space_prev):
    for space_next in BOARD_ADJACENT[space_now]:
        if space_next == space_prev:
            continue

        board_next = board[:]
        board_next[space_now], board_next[space_next] = board_next[space_next], 0
        yield board_next, space_next



board_input = []

for _ in range(N):
    board_input.extend(list(map(int, input().split())))


print(slove(board_input))
"
5481900,ALDS1_13_B,"from collections import deque

def swap(s, i, j):
    ls = list(s)
    ls[i], ls[j] = ls[j], ls[i]
    return ''.join(ls)

initial = ''
for i in range(3): initial += input().replace(' ', '')
# print(initial)

start = ''.join([str(i) for i in range(1, 9)]) + '0'
ng = [[2, 3], [3, 2], [5, 6], [6, 5]]

used = {start : 0}
que = deque([[start, 8, 0]])

while que:
    puz, p, cnt = que.popleft()
    # print(puz, p, cnt)
    if puz == initial:
        ans = cnt
        break
    
    for d in [val for val in [p-1, p+1, p-3, p+3] if 0 <= val <= 8 and [p, val] not in ng]:
        tmp = swap(puz, p, d)
        if tmp in used:
            continue
        que.append([tmp, d, cnt+1])
        used[tmp] = cnt + 1

print(ans)
"
2851857,ALDS1_13_B,"import sys;
import heapq

def iterative(i,j):
    q = []
    heapq.heappush(q,(sumcost,(0,i,j,0,puz)))
    global finding

    while len(q):
        cost, items = heapq.heappop(q)
        c_depth = items[0]
        _i = items[1]
        _j = items[2]
        prev_move = items[3]
        c_puz = items[4]
        _sum_cost = cost - c_depth
        if(_sum_cost == 0):
            finding = 1
            print(c_depth)
            break
        if(cost > depth):
            continue

        c_cost = HS(_i,_j,c_puz[_i*3+_j])

        if(_i != 0 and prev_move != 1):
            swap_puz = swapPuz(c_puz[0:],_i,_j,_i-1,_j)
            n_cost = cost+1+checkCost(c_cost,HS(_i-1,_j,c_puz[(_i-1)*3+_j]),HS(_i,_j,swap_puz[_i*3+_j]),HS(_i-1,_j,swap_puz[(_i-1)*3+_j]))
            if(n_cost <= depth):
                heapq.heappush(q,(n_cost,(c_depth+1,_i-1,_j,2,swap_puz)))
        if(_i != 2 and prev_move != 2):
            swap_puz = swapPuz(c_puz[0:],_i,_j,_i+1,_j)
            n_cost = cost+1+checkCost(c_cost,HS(_i+1,_j,c_puz[(_i+1)*3+_j]),HS(_i,_j,swap_puz[_i*3+_j]),HS(_i+1,_j,swap_puz[(_i+1)*3+_j]))
            if(n_cost <= depth):
                heapq.heappush(q,(n_cost,(c_depth+1,_i+1,_j,1,swap_puz,)))
        if(_j != 0 and prev_move != 3):
            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j-1)
            n_cost = cost+1+checkCost(c_cost,HS(_i,_j-1,c_puz[_i*3+_j-1]),HS(_i,_j,swap_puz[_i*3+_j]),HS(_i,_j-1,swap_puz[_i*3+_j-1]))
            if(n_cost <= depth):
                heapq.heappush(q,(n_cost,(c_depth+1,_i,_j-1,4,swap_puz)))
        if(_j != 2 and prev_move != 4):
            swap_puz = swapPuz(c_puz[0:],_i,_j,_i,_j+1)
            n_cost = cost+1+checkCost(c_cost,HS(_i,_j+1,c_puz[_i*3+_j+1]),HS(_i,_j,swap_puz[_i*3+_j]),HS(_i,_j+1,swap_puz[_i*3+_j+1]))
            if(n_cost <= depth):
                heapq.heappush(q,(n_cost,(c_depth+1,_i,_j+1,3,swap_puz)))

def checkCost(c_cost,m_cost,c2_cost,m2_cost):
    return c2_cost - c_cost + m2_cost - m_cost

def sumCost(puz):
    value = 0
    for i in range(3):
        value += HS(i,0,puz[i*3])
        value += HS(i,1,puz[i*3+1])
        value += HS(i,2,puz[i*3+2])
    return value

def HS(i,j,num):
    if(num != 0):
        k = num-1
    else:
        k = 8
    ki = (int)(k/3)
    kj = k - ki*3
    value = abs(i-ki)+abs(j-kj)
    return value


def swapPuz(c_puz, i, j, i2,j2):
    c_puz[i2*3+j2],c_puz[i*3+j] = c_puz[i*3+j],c_puz[i2*3+j2]
    return c_puz

correctPuz = [i+1 for i in range(9)]
correctPuz[8] = 0
puz = [0 for i in range(9)]

i_start = 0
j_start = 0

for i in range(3):
    puz[i*3],puz[i*3+1],puz[i*3+2] = map(int, input().split());
    if(puz[i*3] == 0):
        i_start,j_start = i,0
    elif(puz[i*3+1] == 0):
        i_start,j_start = i,1
    elif(puz[i*3+2] == 0):
        i_start,j_start = i,2

sumcost = sumCost(puz)

finding = 0
depth = 0
while True:
    if(finding == 1):
        break
    iterative(i_start,j_start)
    depth+=1

"
3121418,ALDS1_13_B,"from collections import deque
board = [int(s) for _ in range(3) for s in input().split()]
end = [1, 2, 3, 4, 5, 6, 7, 8, 0]
table = set()
def print_board(board):
    for i in range(0, 9, 3):
        print(*board[i:i + 3])

def swap(q, step_q, step, board):
    key = tuple(board)
    if key in table:
        return
    else:
        table.add(key)

    empty = board.index(0)
    def _swap(q, step_q, step, board, k, s):
        b = board.copy()
        b[k], b[s] = b[s], b[k]
        q.append(b)
        step_q.append(step + 1)

    if empty % 3 != 2:
        _swap(q, step_q, step, board, empty, empty + 1)
    if empty % 3 != 0:
        _swap(q, step_q, step, board, empty, empty - 1)
    if empty // 3 < 2:
        _swap(q, step_q, step, board, empty, empty + 3)
    if empty // 3 > 0:
        _swap(q, step_q, step, board, empty, empty - 3)


q = deque([board])
step_q = deque([0])
# print_board(board)
while q[0] != end:
    b = q.popleft()
    step = step_q.popleft()
    swap(q, step_q, step, b)
# print_board(q.popleft())
print(step_q.popleft())
"
3367879,ALDS1_13_B,"import copy
def decision(a):
    #print(a)
    #print(data)
    #print(count)
    if a == 123456789:
        print(count)
        exit()
    if a in data:
        pass
    else:
        data[a] = 1
        kariokiba.append(a)
        #print(a)
        #print(data)


def str_create(i, j, h):
    h = h[:i] + h[j] + h[i+1:j] + h[i] + h[j+1:]
    #print(h)
    decision(int(h))


def create(a):
    #print(a)
    a = str(a)
    place = a.find('9')
    #print(place)
    b = c = d = e = a
    if place == 0:
        str_create(0, 1, b)
        str_create(0, 3, c)
    elif place == 1:
        str_create(0, 1, b)
        str_create(1, 2, c)
        str_create(1, 4, d)
    elif place == 2:
        str_create(1, 2, b)
        str_create(2, 5, c)
    elif place == 3:
        str_create(0, 3, b)
        str_create(3, 4, c)
        str_create(3, 6, d)
    elif place == 4:
        str_create(1, 4, b)
        str_create(3, 4, c)
        str_create(4, 5, d)
        str_create(4, 7, e)
    elif place == 5:
        str_create(2, 5, b)
        str_create(4, 5, c)
        str_create(5, 8, d)
    elif place == 6:
        str_create(3, 6, b)
        str_create(6, 7, c)
    elif place == 7:
        str_create(6, 7, b)
        str_create(4, 7, c)
        str_create(7, 8, d)
    elif place == 8:
        str_create(5, 8, b)
        str_create(7, 8, c)



tmp0 = [list(map(int, input().split())) for _ in range(3)]
data = {}
tmp1 = 0
kariokiba = []
kariokiba1 = []
for i in tmp0:
    for j in i:
        if j == 0:
            j = 9
        tmp1 *= 10
        tmp1 += j
data[tmp1] = 1
#print(data)
#print(tmp1)
tmp1 = str(tmp1)
count = 0
kariokiba.append(int(tmp1))

if tmp1 == '123456789':
    print(0)
    exit()
'''
create(tmp1)
print(kariokiba)
#print(data)

'''
while True:
    #print(kariokiba)
    kariokiba1 = copy.deepcopy(kariokiba)
    kariokiba.clear()
    count += 1
    #print(count)
    #print(data)
    for i in kariokiba1:
        create(i)


"
6674526,ALDS1_13_B,"from collections import deque

N=3

a,b,c=map(int,input().split())
d,e,f=map(int,input().split())
g,h,i=map(int,input().split())

GOAL=(1,2,3,4,5,6,7,8,0)

Q=[((a,b,c,d,e,f,g,h,i),0,-10)]
Q=deque(Q)

USE=set()
USE.add((a,b,c,d,e,f,g,h,i))

while Q:
    NOW,ANS,fr=Q.popleft()

    if NOW==GOAL:
        print(ANS)
        break

    for i in range(N*N):
        if NOW[i]==0:
            zero=i

    for i in [1,-1,N,-N]:
        if i==fr:
            continue

        if i==1:
            if zero%N==N-1:
                continue
        elif i==-1:
            if zero%N==0:
                continue
        elif i==N or i==-N:
            if zero+i<0 or zero+i>=N*N:
                continue

        NOW_LIST=list(NOW)
        NOW_LIST[zero],NOW_LIST[zero+i]=NOW_LIST[zero+i],NOW_LIST[zero]

        NOW_tuple=tuple(NOW_LIST)

        if NOW_tuple in USE:
            continue
        USE.add(NOW_tuple)

        Q.append((NOW_tuple,ANS+1,-i))
                
            

    

"
5106135,ALDS1_13_B,"from collections import deque

def swap(s, i, j):
    ls = list(s)
    ls[i], ls[j] = ls[j], ls[i]
    return ''.join(ls)

goal = ''
for i in range(3): goal += input().replace(' ', '')
#print(goal)

start = ''.join([str(i) for i in range(1, 9)]) + '0'
ng = [[2, 3], [3, 2], [5, 6], [6, 5]]

used = {start : 0}
que = deque([[start, 8, 0]])

while que:
    puz, p, cnt = que.popleft()
    #print(puz, p, cnt)
    if puz == goal:
        ans = cnt
        break
    
    for d in [val for val in [p-1, p+1, p-3, p+3] if 0 <= val <= 8 and [p, val] not in ng]:
        tmp = swap(puz, p, d)
        if tmp in used:
            continue
        que.append([tmp, d, cnt+1])
        used[tmp] = cnt + 1

print(ans)

"
8139994,ALDS1_13_B,"import sys
from collections import deque
input = sys.stdin.readline


def gen_hash(panel):
    _hash = """"
    for i in range(3):
        for j in range(3):
            _hash += str(panel[i][j])
    return _hash


def get_matchings(_hash):
    ans = ""123456780""
    cnt = 0
    for i in range(9):
        if _hash[i] == str(ans[i]):
            cnt += 1
    return cnt


def bfs(panel):
    swap_candidates = {
        0: (1, 3),
        1: (0, 2, 4),
        2: (1, 5),
        3: (0, 4, 6),
        4: (1, 3, 5, 7),
        5: (2, 4, 8),
        6: (3, 7),
        7: (4, 6, 8),
        8: (5, 7)
    }
    dq = deque()
    dq.append((gen_hash(panel), 0))
    seen = set()
    seen.add(gen_hash(panel))
    while dq:
        _hash, cnt = dq.popleft()
        if get_matchings(_hash) == 9:
            return cnt
        z_ptr = _hash.index(""0"")
        for n_ptr in swap_candidates[z_ptr]:
            next_hash = list(_hash)
            next_hash[z_ptr], next_hash[n_ptr] = next_hash[n_ptr], next_hash[z_ptr]
            next_hash = """".join(next_hash)
            if next_hash not in seen:
                seen.add(next_hash)
                dq.append((next_hash, cnt + 1))


panel = []
for _ in range(3):
    panel.append([int(i) for i in input().split()])

ans = bfs(panel)
print(ans)


"
8076757,ALDS1_13_B,"from collections import deque


puzzle = []

for _ in range(3):
    puzzle = puzzle + list(map(int, input().split()))

puzzle = tuple(i if i != 0 else 9 for i in puzzle)
goal = tuple([1, 2, 3, 4, 5, 6, 7, 8, 9])
dxs = [-1, 0, 1, 0]
dys = [0, -1, 0, 1]

queue = deque()
checked = set()

queue.append((puzzle, 0))
checked.add(puzzle)

while queue:
    que = queue.popleft()

    u = que[0]
    d = que[1]

    if u == goal:
        ans = d
        break

    space = u.index(9)

    sx = space // 3
    sy = space % 3

    for dx, dy in zip(dxs, dys):
        tx = sx + dx
        ty = sy + dy

        if (tx < 0) or (ty < 0) or (tx >= 3) or (ty >= 3):
            continue

        v = list(u)
        v[space], v[tx * 3 + ty] = v[tx * 3 + ty], v[space]

        v = tuple(v)

        if v not in checked:
            checked.add(v)
            queue.append((v, d + 1))

print(d)

"
3865697,ALDS1_13_B,"# -*- coding: utf-8 -*-

import sys
from collections import deque

def input(): return sys.stdin.readline().strip()
def list2d(a, b, c): return [[c] * b for i in range(a)]
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]
def ceil(x, y=1): return int(-(-x // y))
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(): return list(map(int, input().split()))
def Yes(): print('Yes')
def No(): print('No')
def YES(): print('YES')
def NO(): print('NO')
sys.setrecursionlimit(10 ** 9)
INF = float('inf')
MOD = 10 ** 9 + 7

N = 3
# グリッドを最初から文字列として1次元で保持する
grid = '*' * (N+2)
for i in range(N):
    grid += '*' + input().replace(' ', '') + '*'
grid += '*' * (N+2)
start = grid.find('0')

# 完成形の盤面
goal = '******123**456**780******'
que = deque()
que.append((grid, 0, start))
# その盤面に至る移動コスト
memo = {}
while len(que):
    grid, cost, cur = que.popleft()
    if grid in memo:
        continue
    memo[grid] = cost
    grid = list(grid)
    # 4方向見る
    for direction in (-1, 1, -(N+2), N+2):
        nxt = cur + direction
        if grid[nxt] != '*':
            grid[cur], grid[nxt] = grid[nxt], grid[cur]
            que.append((''.join(grid), cost+1, nxt))
            grid[cur], grid[nxt] = grid[nxt], grid[cur]

print(memo[goal])

"
4764977,ALDS1_13_B,"import sys
from collections import deque
input = sys.stdin.readline


def gen_hash(panel):
    _hash = """"
    for i in range(3):
        for j in range(3):
            _hash += str(panel[i][j])
    return _hash


def get_matchings(_hash):
    ans = ""123456780""
    cnt = 0
    for i in range(9):
        if _hash[i] == str(ans[i]):
            cnt += 1
    return cnt


def bfs(panel):
    swap_candidates = {
        0: (1, 3),
        1: (0, 2, 4),
        2: (1, 5),
        3: (0, 4, 6),
        4: (1, 3, 5, 7),
        5: (2, 4, 8),
        6: (3, 7),
        7: (4, 6, 8),
        8: (5, 7)
    }
    dq = deque()
    dq.append((gen_hash(panel), 0))
    seen = set()
    seen.add(gen_hash(panel))
    while dq:
        _hash, cnt = dq.popleft()
        if get_matchings(_hash) == 9:
            return cnt
        z_ptr = _hash.index(""0"")
        for n_ptr in swap_candidates[z_ptr]:
            next_hash = list(_hash)
            next_hash[z_ptr], next_hash[n_ptr] = next_hash[n_ptr], next_hash[z_ptr]
            next_hash = """".join(next_hash)
            if next_hash not in seen:
                seen.add(next_hash)
                dq.append((next_hash, cnt + 1))


panel = []
for _ in range(3):
    panel.append([int(i) for i in input().split()])

ans = bfs(panel)
print(ans)

"
2878024,ALDS1_13_B,"from heapq import heappop, heappush
from copy import deepcopy


class Board:
    def __init__(self, size, nums):
        self.size = size
        self.nums = nums
        self.code = self._code()

    def __eq__(self, other):
        return self.code == other.code

    def __lt__(self, other):
        return self.code < other.code

    def __gt__(self, other):
        return self.code > other.code

    def __hash__(self):
        nums = tuple(self.nums[i][j]
                     for i in range(self.size)
                     for j in range(self.size))
        return hash(nums)

    def same(self, other):
        if other is None:
            return False
        if self.__class__ != other.__class__:
            return False

        for i in range(self.size):
            for j in range(self.size):
                if self.nums[i][j] != other.nums[i][j]:
                    return False
        return True

    def solved(self):
        for i in range(self.size):
            for j in range(self.size):
                if (i, j) != self._validpos(self.nums[i][j]):
                    return False
        return True

    def _validpos(self, num):
        if num > 0:
            return ((num-1) // self.size, (num-1) % self.size)
        else:
            return (self.size-1, self.size-1)

    def _code(self):
        code = 0
        for i in range(self.size):
            for j in range(self.size):
                if self.nums[i][j] != 0:
                    vi, vj = self._validpos(self.nums[i][j])
                    code += abs(vi - i) + abs(vj - j)
        return code

    def find(self, num):
        for i in range(self.size):
            for j in range(self.size):
                if self.nums[i][j] == num:
                    return (i, j)
        raise IndexError()

    def move(self, p1, p2):
        i1, j1 = p1
        i2, j2 = p2
        nums = deepcopy(self.nums)
        nums[i1][j1], nums[i2][j2] = nums[i2][j2], nums[i1][j1]
        return self.__class__(self.size, nums)

    def moves(self):
        i, j = self.find(0)
        if i > 0:
            yield self.move((i, j), (i-1, j))
        if j > 0:
            yield self.move((i, j), (i, j-1))
        if i < self.size-1:
            yield self.move((i, j), (i+1, j))
        if j < self.size-1:
            yield self.move((i, j), (i, j+1))

    def __str__(self):
        s = ''
        for i in range(self.size):
            for j in range(self.size):
                s += ' {}'.format(self.nums[i][j])
            s += '\n'
        return s


class EightPuzzle:
    def __init__(self, board):
        self.board = Board(3, board)
        self.steps = 0

        if not self.board.solved():
            self._solve()

    def _solve(self):
        bs = []
        checked = {}
        heappush(bs, (self.board.code, self.board, 0))

        while len(bs) > 0:
            w, b, step = heappop(bs)
            if 0 < self.steps <= step:
                continue
            checked[b] = step
            for nb in b.moves():
                if nb.solved():
                    self.steps = step+1
                    return
                elif nb in checked and checked[nb] <= step:
                    continue
                else:
                    heappush(bs, (nb.code + step + 1, nb, step+1))


def run():
    board = []
    for i in range(3):
        board.append([int(i) for i in input().split()])

    eight_puzzle = EightPuzzle(board)
    print(eight_puzzle.steps)


if __name__ == '__main__':
    run()

"
4836179,ALDS1_13_B,"from collections import deque

N = 3

grid = '*' * (N+2)
for i in range(N):
    grid += ""*"" + input().replace("" "", """") + ""*""
grid += ""*"" * (N+2)
start = grid.find('0')


goal = ""******123**456**780******""
queue = deque()
queue.append((grid, 0, start))

memo = {}
while queue:
    grid, cost, cur = queue.popleft()
    if grid in memo:
        continue
    memo[grid] = cost
    if grid == goal:
        print(cost)
        break

    for direction in (-1, 1, -(N+2), N+2):
        nxt = cur + direction
        grid = list(grid)
        if grid[nxt] != '*':
            grid[cur], grid[nxt] = grid[nxt], grid[cur]
            queue.append((("""").join(grid), cost+1, nxt))
            grid[cur], grid[nxt] = grid[nxt], grid[cur]
"
7867473,ALDS1_13_B,"from heapq import heappop, heappush

LIMIT = 45
N = 3                                                          # N * N pieces

adj = [{1, 3}, {0, 2, 4}, {1, 5},                   # N * N pieces are represented by 0, 1, ..., (N*N-1)
      {0, 4, 6}, {1, 3, 5, 7}, {2, 4, 8},           # adj[i]: an adj list for piece i
      {3, 7}, {4, 6, 8}, {5, 7}]                    # ** this is for only N = 4 -> 3

pieces = [[[0] for j in range(N)] for i in range(N)]           # contents for simulation

MD = [[abs(i//N-j//N)+abs(i%N-j%N) for j in range(N*N) ] for i in range(N*N)]    # manhattan dist between piece i and j
PW = [16**i for i in range(N*N)]                               
SW = [[i*PW[j] for j in range(N*N) ] for i in range(N*N)]      

initial_v, initial_h, initial_b = 0, 0, -1
target = 0

p = 0
for i in range(N):
    row = list(map(int, input().split()))
    for j in range(N):
        pieces[i][j] = row[j]
        if row[j] == 0:
            initial_b = i*N + j                                # set the place of the blank
        else:            
            initial_v += row[j]*PW[p]                          # initial hash value of the puzzle
            initial_h += MD[p][row[j]-1]                       # initial estimation cost
        if (p+1) <= 8: target += (p+1)*PW[p]                   # (p+1) <= 15 -> (p+1) <= 8
        p += 1

parent = {}                                                    # parent of BFS tree to simulate

queue = [(initial_h, 0, initial_h, initial_v, initial_b, -1, -1)] # estimated_cost, true cost, heuristic, hash value,  the place of the blank, previous hash value, number
visited = set()
parent[initial_v] = [-1, -1]

while len(queue) > 0:
    estimated, cost, heuristic, val, blank, pre_v, pre = heappop(queue)
    parent[val] = [pre_v, pre]
    if val in visited: continue 
    if val == target:
        print(estimated) # 最短手数

    visited.add(val)
    for next_b in adj[blank]:
        num = (val >> (4*next_b)) & 15
        next_v = val - SW[num][next_b] + SW[num][blank]
        if next_v in visited: continue
        next_h = heuristic + MD[blank][num-1] - MD[next_b][num-1]
        if cost + 1 > LIMIT: continue
        heappush(queue, (cost + 1 + next_h, cost + 1, next_h, next_v, next_b, val, num))
"
6654351,ALDS1_13_B,"import copy
import heapq

class Node:
    def __init__(self, state, g, h, parent):
        self.state = state
        self.g = g
        self.h = h
        self.parent = parent
        
    def cost(self):
        return self.g + self.h

    def __lt__(self, other):
        if (self.g + self.h) < (other.g + other.h):
            return True
        elif (self.g + self.h) == (other.g + other.h):
            return self.h < other.h
        else:
            return False

class State:
    def __init__(self, pos):
        self.pos = pos

    def __str__(self):
        string = """"
        for i in range(3):
            for j in range(3):
                string += str(self.pos[i][j])
            string += '\n'
        return string

    def __eq__(self, other):
        return self.pos == other.pos

    def get_position(self, num):
        for i in range(3):
            for j in range(3):
                if self.pos[i][j] == num:
                    return (i, j)
        # should throw exception
        return None

    def expand(self,gg):

        global cnt_expand

        children = []
        init_pos = State([[0,1,3],[4,5,6],[7,8,2]])

        i,j = self.get_position(0)
        for di,dj in [(0,1),(0,-1),(1,0),(-1,0)]:
            ni,nj = i+di, j+dj
            if 0<=ni<3 and 0<=nj<3:
                new_state = copy.deepcopy(self.pos)
                new_state[ni][nj],new_state[i][j] = new_state[i][j],new_state[ni][nj]
                next_node = Node(State(new_state), gg+1, Puzzle(init_pos).heuristic(State(new_state)), self.pos)
                children.append(next_node)
                cnt_expand += 1
        return children


class Puzzle:
    def __init__(self, init_pos):
        self.start = State(init_pos)
        self.goal = State([[1, 2, 3], [4, 5, 6], [7, 8, 0]])

    def heuristic(self,state):

        h_value = 0
        for num in range(1, 9):
            p,q = state.get_position(num)
            r,s = self.goal.get_position(num)
            h_value += abs(p-r) + abs(q-s)

        return h_value
                

class AStar:
    def __init__(self, puzzle):
        self.puzzle = puzzle
        self.closed_list = { }

    def solution_path(self, goal):
        solution = []
        node = goal
        while True:
            solution = [str(node.state)] + solution
            if node.parent.pos[0][0] < 0:
                break
            node = self.closed_list[str(node.parent)]
        sol_str = ""len: "" + str(goal.g) + '\n'
        for pos in solution:
            sol_str += pos + '\n'
        return sol_str

    def search(self):
        start_state = self.puzzle.start
        dummy_state = State([[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]])
        start_node = Node(start_state, 0, self.puzzle.heuristic(start_state), dummy_state)
        
        # open_list の初期化
        open_queue = [ start_node ]
        heapq.heapify(open_queue)
        
        # ハッシュ表の初期化。ここではハッシュ表のキーとしてStateの文字列を使っている
        self.closed_list = { }
        self.closed_list[str(start_state)] = start_node

        if start_state == self.puzzle.goal:
            return 0

        while len(open_queue) != 0:

            n = heapq.heappop(open_queue)

            if n.state == self.puzzle.goal:
                return n.g

            child_nodes = n.state.expand(n.g)

            for c in child_nodes:
                if (str(c.state) not in self.closed_list) or (c.g + c.h < self.closed_list[str(c.state)].g + self.closed_list[str(c.state)].h):
                    self.closed_list[str(c.state)] = c
                    heapq.heappush(open_queue, c)
            
        return None
        
cnt_expand = 0
L = [list(map(int,input().split())) for _ in range(3)]
pz = Puzzle(L) 
solver = AStar(pz)
ans = solver.search()
print(ans)

"
2865339,ALDS1_13_B," 
goal = ((1, 2, 3), (4, 5, 6), (7, 8, 0))

parents = {}
total = {}
flag = True

initial = []
position = []
for i in range(3):
	a, b, c = map(int, input().split())
	if a == 0:
		position.extend([i, 0])
	elif b == 0:
		position.extend([i, 1])
	elif c == 0:
 		position.extend([i, 2])
	initial.append( (a, b, c) )

parents[tuple(initial)] = position
total[tuple(initial)] = 1

count = 0

if tuple(initial) == goal:
	flag = False

while flag:
	count += 1
	children = {}
	for par_key in parents.keys():
		position = parents[par_key]

		if position[0] < 2:
			child = [list(par_key[0]), list(par_key[1]), list(par_key[2])]
			child[position[0]][position[1]] = child[position[0]+1][position[1]]
			child[position[0]+1][position[1]] = 0
			child_tuple = (tuple(child[0]), tuple(child[1]), tuple(child[2]))
			if child_tuple == goal:
				flag = False
				break
			elif child_tuple not in total:
				children[child_tuple] = [position[0]+1, position[1]]
				total[child_tuple] = 1

		if position[0] > 0:
			child = [list(par_key[0]), list(par_key[1]), list(par_key[2])]
			child[position[0]][position[1]] = child[position[0]-1][position[1]]
			child[position[0]-1][position[1]] = 0
			child_tuple = (tuple(child[0]), tuple(child[1]), tuple(child[2]))
			if child_tuple == goal:
				flag = False
				break
			elif child_tuple not in total:
				children[child_tuple] = [position[0]-1, position[1]]
				total[child_tuple] = 1

		if position[1] < 2:
			child = [list(par_key[0]), list(par_key[1]), list(par_key[2])]
			child[position[0]][position[1]] = child[position[0]][position[1]+1]
			child[position[0]][position[1]+1] = 0
			child_tuple = (tuple(child[0]), tuple(child[1]), tuple(child[2]))
			if child_tuple == goal:
				flag = False
				break
			elif child_tuple not in total:
				children[child_tuple] = [position[0], position[1]+1]
				total[child_tuple] = 1

		if position[1] > 0:
			child = [list(par_key[0]), list(par_key[1]), list(par_key[2])]
			child[position[0]][position[1]] = child[position[0]][position[1]-1]
			child[position[0]][position[1]-1] = 0
			child_tuple = (tuple(child[0]), tuple(child[1]), tuple(child[2]))
			if child_tuple == goal:
				flag = False
				break
			elif child_tuple not in total:
				children[child_tuple] = [position[0], position[1]-1]
				total[child_tuple] = 1

	parents = children

print(count)
"
6842692,ALDS1_13_B,"from collections import deque

tn  = []
def po(w, x):
    return w * 3 + x

for i in range(3):
    a = list(map(int, input().split()))
    if 0 in a:
        c = i
        y = a.index(0)
    tn.append(a[0])
    tn.append(a[1])
    tn.append(a[2])
    

dq = deque()
f = dict()
f[tuple(tn)] = 0
dq.append([0, c, y, tn])


khj =  False

while khj == False:
    pass
    break

while dq:
    cost, c, y, b = dq.popleft()
    if b == [1, 2, 3, 4, 5, 6, 7, 8, 0]:
        print(cost)
        exit()
    
    if f[tuple(b)] < cost:
        continue
    
    for i in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
        c_i = c + i[0]
        y_i = y + i[1]
        if 0 <= c_i < 3 and 0 <= y_i < 3:
            v_c = b[:]
            v_c[po(c, y)], v_c[po(c_i, y_i)] = v_c[po(c_i, y_i)], v_c[po(c, y)]
            t = tuple(v_c)
            if t not in f or f[t] > cost + 1:
                f[t] = cost + 1
                dq.append([cost + 1, c_i, y_i, v_c])
"
6807718,ALDS1_13_B,"from collections import deque


def ind(x, y):
    return x * 3 + y


board  = []
for i in range(3):
    a = list(map(int, input().split()))
    if 0 in a:
        x = i
        y = a.index(0)
    board.append(a[0])
    board.append(a[1])
    board.append(a[2])
    

q = deque()
q.append([0, x, y, board])

d = dict()
d[tuple(board)] = 0

while q:
    cost, x, y, b = q.popleft()
    if b == [1, 2, 3, 4, 5, 6, 7, 8, 0]:
        print(cost)
        exit()
    
    if d[tuple(b)] < cost:
        continue
    
    for i in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
        x_i = x + i[0]
        y_i = y + i[1]
        if 0 <= x_i < 3 and 0 <= y_i < 3:
            b_copy = b[:]
            b_copy[ind(x, y)], b_copy[ind(x_i, y_i)] = b_copy[ind(x_i, y_i)], b_copy[ind(x, y)]
            t = tuple(b_copy)
            if t not in d or d[t] > cost + 1:
                d[t] = cost + 1
                q.append([cost + 1, x_i, y_i, b_copy])

"
2861148,ALDS1_13_B,"# 8 Puzzle
import copy
[N, d] = [3, 0]
start = []
goal = [[i + j*N for i in range(1, N + 1)] for j in range(N)]
goal[2][2] = 0
for i in range(N):
    start.append(list(map(int, input().split())))


def manhattan(value, pairs):
    h = 0

    if value == 1:
        h = (pairs[0] + pairs[1])
    if value == 2:
        h = (pairs[0] + abs(pairs[1] - 1))
    if value == 3:
        h = (pairs[0] + abs(pairs[1] - 2))
    
    if value == 4:
        h = (abs(pairs[0] - 1) + pairs[1])
    if value == 5:
        h = (abs(pairs[0] - 1) + abs(pairs[1] - 1)) 
    if value == 6:
        h = (abs(pairs[0] - 1) + abs(pairs[1] - 2))
        
    if value == 7:
        h = (abs(pairs[0] - 2) + pairs[1])      
    if value == 8:
        h = (abs(pairs[0] - 2) + abs(pairs[1] - 1))
        
    return h

s_h = 0
for i in range(N):
    for j in range(N):
        s_h += manhattan(start[i][j], [i, j])

for i in range(N):
        check = start[i].count(0)
        if check != 0:
            [s_r, s_c] = [i, start[i].index(0)]
            break
        if i == 3:
            print(""Error"")

while True:
    d += 1
    flag = 0
    queue = [[s_h, start, 0, [s_r, s_c], flag]]
    
    while len(queue) != 0:
        short_n = queue.pop(0)
        h = short_n[0] - short_n[2]
        state = short_n[1]
        g = short_n[2]
        [r, c] = short_n[3]
        flag = short_n[4]
        
        if h == 0:
            print(short_n[2])
            break
       
        if r - 1 >= 0 and flag != 3:
            temp = copy.deepcopy(state)
            h = short_n[0] - short_n[2] - manhattan(temp[r - 1][c], [r - 1, c]) + manhattan(temp[r - 1][c], [r, c])
            [temp[r][c], temp[r - 1][c]] = [temp[r - 1][c], temp[r][c]]
            if g + 1 + h <= d:
                queue.append([h + g + 1, temp, g + 1, [r - 1, c], 1])
        
        if c + 1 < N and flag != 4:
            temp = copy.deepcopy(state)
            h = short_n[0] - short_n[2] - manhattan(temp[r][c + 1], [r, c + 1]) + manhattan(temp[r][c + 1], [r, c])
            [temp[r][c], temp[r][c + 1]] = [temp[r][c + 1], temp[r][c]]
            if g + 1 + h <= d:
                queue.append([h + g + 1, temp, g + 1, [r, c + 1], 2])

        if r + 1 < N and flag != 1:
            temp = copy.deepcopy(state)
            h = short_n[0] - short_n[2] - manhattan(temp[r + 1][c], [r + 1, c]) + manhattan(temp[r + 1][c], [r, c])
            [temp[r][c], temp[r + 1][c]] = [temp[r + 1][c], temp[r][c]]
            if g + 1 + h <= d:
                queue.append([h + g + 1, temp, g + 1, [r + 1, c], 3])
        
        if c - 1 >= 0 and flag != 2:
            temp = copy.deepcopy(state)
            h = short_n[0] - short_n[2] - manhattan(temp[r][c - 1], [r, c - 1]) + manhattan(temp[r][c - 1], [r, c])
            [temp[r][c], temp[r][c - 1]] = [temp[r][c - 1], temp[r][c]]
            if g + 1 + h <= d:
                queue.append([h + g + 1, temp, g + 1, [r, c - 1], 4])
                
        queue.sort(key = lambda data:data[0])
        queue.sort(key = lambda data:data[2], reverse = True)

        data = []
        g_data = []

    if state == goal:
        break
"
8130295,ALDS1_13_B,"from collections import deque

class PuzzleState:
    def __init__(self, place, empty, open):
        self.place = place
        self.empty = empty
        self.open = open

def check_match(a):
    for i in range(8):
        if a.place[i] != i + 1:
            return False
    return True

def solve(a):
    queue = deque()
    visited = set()
    queue.append(a)
    visited.add(tuple(a.place))
    
    while queue:
        b = queue.popleft()
        if check_match(b):
            return b.open
        x, y = divmod(b.empty, 3)
        for dx, dy in [(-1, 0), (0, -1), (0, 1), (1, 0)]:
            nx, ny = x + dx, y + dy
            if nx < 0 or ny < 0 or nx >= 3 or ny >= 3:
                continue
            new_state = PuzzleState(list(b.place), b.empty, b.open)
            num = new_state.place[new_state.empty]
            new_state.place[new_state.empty], new_state.place[nx * 3 + ny] = new_state.place[nx * 3 + ny], num
            new_state.empty = nx * 3 + ny
            if tuple(new_state.place) not in visited:
                visited.add(tuple(new_state.place))
                new_state.open += 1
                queue.append(new_state)
    return None

if __name__ == ""__main__"":
    puzzle_input = []
    for _ in range(3):
        row = list(map(int, input().split()))
        puzzle_input.extend(row)
    empty_index = puzzle_input.index(0)
    puzzle = PuzzleState(puzzle_input, empty_index, 0)
    output = solve(puzzle)
    print(output)

"
3102637,ALDS1_13_B,"from collections import deque

N = 3
N2 = 9

dx = [-1, 0, 1, 0]
dy = [0, -1, 0, 1]
dirc = ['u', 'l', 'd', 'r']

class Puzzle:
    def __init__(self, f=None, space=None, path=None):
        if f is None:
            self.f = []
        else:
            self.f = f
        self.space = space
        self.path = path

    def __lt__(self, p):
        for i in range(N2):
            if self.f[i] == p.f[i]:
                continue
            return self.f[i] > p.f[i]
        return False


def isTarget(p):
    for i in range(N2):
        if p.f[i] != (i + 1):
            return False
    return True


def bfs(s):
    q = deque()
    dic = {}
    s.path = ''
    q.append(s)
    dic[tuple(s.f)] = True

    while len(q) != 0:
        u = q.popleft()
        if isTarget(u):
            return u.path
        sx = u.space // N
        sy = u.space % N
        for r in range(4):
            tx = sx + dx[r]
            ty = sy + dy[r]
            if tx < 0 or ty < 0 or tx >= N or ty >= N:
                continue
            v = Puzzle(u.f[:], u.space, u.path)
            v.f[u.space], v.f[tx * N + ty] = v.f[tx * N + ty], v.f[u.space]
            v.space = tx * N + ty
            key = tuple(v.f)
            if key not in dic:
                dic[key] = True
                v.path += dirc[r]
                q.append(v)

    return 'unsolvable'


if __name__ == '__main__':
    p = Puzzle()
    for i in range(N):
        line = [int(v) for v in input().split()]
        for j in range(N):
            if line[j] == 0:
                line[j] = N2
                p.space = i * N + j
        p.f.extend(line)

    ans = bfs(p)
    print(len(ans))
"
3245859,ALDS1_13_B,"from collections import deque
CORRECT_STATE = ""123456780""


class PuzzleState:
    __slots__ = ['state', 'spc_x', 'spc_y', 'depth']

    def __init__(self, state: str, depth=0):
        self.state = state
        index = state.find('0')
        self.spc_x = index % 3
        self.spc_y = index // 3
        self.depth = depth

    def swap_state(self, ch_x, ch_y):
        conv_char = self.state[ch_y * 3 + ch_x]
        self.state = self.state.replace('0', 'X')
        self.state = self.state.replace(conv_char, '0')
        self.state = self.state.replace('X', conv_char)
        self.spc_x, self.spc_y = ch_x, ch_y

    def is_correct(self):
        return self.state == CORRECT_STATE

    def __repr__(self):
        return f'{self.state}'


move = [(0, -1), (0, 1), (-1, 0), (1, 0)]
def puzzle8_breadth_first_search(puzzle: PuzzleState):
    mem_state = {puzzle.state: ''}
    p_queue = deque()
    p_queue.append(puzzle)

    while len(p_queue) != 0:
        u = p_queue.popleft()
        if u.is_correct():
            #print(""CORRECT"")
            return u.depth
        for mx, my in move:
            sp_new_x = u.spc_x + mx
            sp_new_y = u.spc_y + my
            if not(0 <= sp_new_x <= 2 and 0 <= sp_new_y <= 2):
                continue
            new_puzzle = PuzzleState(u.state, depth=u.depth+1)
            new_puzzle.swap_state(sp_new_x, sp_new_y)

            if new_puzzle.state not in mem_state:
                mem_state[new_puzzle.state] = ''
                p_queue.append(new_puzzle)
    return False


def main():
    input_text = """"
    for i in range(3):
        input_text += """".join(input().split())

    # 8 puzzle main
    ans_puzzle = puzzle8_breadth_first_search(PuzzleState(input_text))
    print(ans_puzzle)
    return

main()
"
6292032,ALDS1_13_B,"from collections import deque # dequeをimportして使用できるようにする

l = [] # 初期配置を表わす配列lを用意
for i in range(3): # 3回繰り返し
    l += list(map(int,input().split())) # 初期配置を入力

goal = (1,2,3,4,5,6,7,8,0) # ゴールの配置をgoalとする
s = set([]) # 発見済みの配置を表わす集合sを用意
go = deque([[l,0]]) # 発見済みで未探索の配置とそれまでの最小手数を表わすdequeを用意
d = [(1,0),(-1,0),(0,1),(0,-1)] # 0の移動のさせ方を表わす配列dを用意
while go: # goが空になるまで繰り返し
    p,tm = go.popleft() # goに含まれる内, 最も早く発見された配置とその手数をp,tmとする
    if tuple(p) == goal: # pがゴールの配置である場合
        print(tm) # 最短手数を出力し, 探索を終える
        break
    for i in range(3): # 0から2まで繰り返し
        for j in range(3): # 0から2まで繰り返し
            if p[i*3+j] == 0: # (i,j)に0がある場合
                i0 = i; j0 = j # 0の位置を表わす変数i0, j0をi, jとする
    for di,dj in d: # 0の動かし方全てについて繰り返し
        if 0 <= i0 + di < 3 and 0 <= j0 + dj < 3: # 可能な動かし方である場合
            p[(di+i0)*3 + dj+j0],p[i0*3 + j0] = p[i0*3 + j0],p[(di+i0)*3 + dj+j0] # p[i0*3 + j0]とp[(di+i0)*3 + dj+j0]を交換(0を動かす)
            if tuple(p) not in s: # この配置が未発見である場合
                go.append((p[:],tm+1)) # goに現在の配置を追加
                s.add(tuple(p)) # sに現在の配置を追加
            p[(di+i0)*3 + dj+j0],p[i0*3 + j0] = p[i0*3 + j0],p[(di+i0)*3 + dj+j0] # p[i0*3 + j0]とp[(di+i0)*3 + dj+j0]を交換(0を元の位置に戻す)
"
4376323,ALDS1_13_B,"import sys
import copy
from collections import deque

def main():
    s = []
    for _ in range(3):
        s+=list(map(int,input().split()))
    g = [1,2,3,4,5,6,7,8,0]
    st = set()
    inf = 1000000007
    move = [[1,3],
            [0,2,4],
            [1,5],
            [0,4,6],
            [1,3,5,7],
            [2,4,8],
            [3,7],
            [4,6,8],
            [5,7]]

    def bfs():
        k = 0
        for i in range(9):
            if s[i]==0:k = i
        dq = deque()
        dq.append([s,k,0])
        st.add(''.join(map(str,s)))
        while dq:
            state = dq.popleft()
            t,i,steps = state[0],state[1],state[2]
            if t==g:return steps
            for j in move[i]:
                u = copy.copy(t)
                u[i],u[j] = u[j],u[i]
                if ''.join(map(str,u)) in st:continue
                dq.append([u,j,steps+1])
                st.add( ''.join(map(str,u)))

    print (bfs())

if __name__ == '__main__':
    main()


"
8285535,ALDS1_13_C,"# 2022/04/29
# Yutaka Watanobe
from heapq import heappop, heappush

LIMIT = 45
N = 4                                                          # N * N pieces

adj = [{1, 4}, {0, 2, 5}, {1, 3, 6}, {2, 7},                   # N * N pieces are represented by 0, 1, ..., (N*N-1)
      {0, 5, 8}, {1, 4, 6, 9}, {2, 5, 7, 10}, {3, 6, 11},      # adj[i]: an adj list for piece i
      {4, 9, 12}, {5, 8, 10, 13}, {6, 9, 11, 14}, {7, 10, 15}, # ** this is for only N = 4
      {8, 13}, {9, 12, 14}, {10, 13, 15}, {11, 14}]

pieces = [[[0] for j in range(N)] for i in range(N)]           # contents for simulation

MD = [[abs(i//N-j//N)+abs(i%N-j%N) for j in range(N*N) ] for i in range(N*N)]    # manhattan dist between piece i and j
PW = [16**i for i in range(N*N)]                               # 16^i
SW = [[i*PW[j] for j in range(N*N) ] for i in range(N*N)]      # i * 16^j

initial_v, initial_h, initial_b = 0, 0, -1
target = 0

p = 0
for i in range(N):
    row = list(map(int, input().split()))
    for j in range(N):
        pieces[i][j] = row[j]
        if row[j] == 0:
            initial_b = i*N + j                                # set the place of the blank
        else:            
            initial_v += row[j]*PW[p]                          # initial hash value of the puzzle
            initial_h += MD[p][row[j]-1]                       # initial estimation cost
        if (p+1) <= 15: target += (p+1)*PW[p]
        p += 1

ans = -1
parent = {}                                                    # parent of BFS tree to simulate

def aster():
    global ans, parent
    queue = [(initial_h, initial_h, initial_v, initial_b, -1, -1)]
    visited = set()
    parent[initial_v] = [-1, -1]
    
    while len(queue) > 0:
        estimated, heuristic, val, blank, pre_v, pre = heappop(queue)
        cost = estimated - heuristic
        parent[val] = [pre_v, pre]
        if val in visited: continue
        if val == target:
            ans = cost
            return True
        visited.add(val)
        for next_b in adj[blank]:
            num = (val >> (4*next_b)) & 15
            next_v = val - SW[num][next_b] + SW[num][blank]
            if next_v in visited: continue
            next_h = heuristic + MD[blank][num-1] - MD[next_b][num-1]
            if cost + 1 > LIMIT: continue
            heappush(queue, (cost + 1 + next_h, next_h, next_v, next_b, val, num))
    return False

def simulate(v):
    if v == -1: return
    simulate(parent[v][0])
    if parent[v][1] != -1:
        print('\n', 'Move', parent[v][1], '\n')
    for i in range(N*N):
        print(v >> (4*i) & 15,  end=' ')
        if (i+1)%4 == 0: print()

if aster():
    print(ans)
#    simulate(target)
else:
    print(""unsolvable"")
    


"
6663639,ALDS1_13_C,"import sys

# READ_FROM_FILE = True
READ_FROM_FILE = False


def calc_manhattan_distance_table(width, num_elements, goal_state):
    manhattan_distance_table = [[0] * num_elements for _ in range(num_elements)]

    for c_num in range(num_elements):
        g_idx = goal_state.index(c_num)
        gx = g_idx % width
        gy = g_idx // width
        for c_idx in range(num_elements):
            cx = c_idx % width
            cy = c_idx // width

            if c_num != 0:
                manhattan_distance_table[c_num][c_idx] = abs(gx - cx) + abs(gy - cy)
            else:
                manhattan_distance_table[c_num][c_idx] = 0
    return manhattan_distance_table


def calc_manhattan_distance(num_elements, manhattan_distance_table, state):
    m_dist = 0
    for c_idx in range(num_elements):
        c_num = state[c_idx]
        m_dist += manhattan_distance_table[c_num][c_idx]
    return m_dist


def dls(num_elements, adjacency_list, manhattan_distance_table, goal_state, depth_limit,
        c_h_dist, c_state, c_zero_idx, c_num_moves, p_num):
    if c_state == goal_state:
        return c_num_moves

    if c_num_moves > depth_limit:
        return -1

    for i in adjacency_list[c_zero_idx]:
        c_num = c_state[i]
        if c_num == p_num:
            continue

        c_state[i] = 0
        c_state[c_zero_idx] = c_num
        n_h_dist = c_h_dist - manhattan_distance_table[c_num][i] + manhattan_distance_table[c_num][c_zero_idx] + 1
        n_zero_idx = i
        n_num_moves = c_num_moves + 1

        if n_h_dist <= depth_limit:
            min_num_moves = dls(num_elements, adjacency_list, manhattan_distance_table, goal_state, depth_limit,
                                n_h_dist, c_state, n_zero_idx, n_num_moves, c_num)
            if min_num_moves >= 0:
                return min_num_moves

        c_state[i] = c_num
        c_state[c_zero_idx] = 0

    return -1


def iddfs(num_elements, adjacency_list, manhattan_distance_table, max_depth, start_state, zero_idx, goal_state):
    c_m_dist = calc_manhattan_distance(num_elements, manhattan_distance_table, start_state)
    is_start_zero_idx_even = (zero_idx % 2 == 0)
    g_zero_idx = goal_state.index(0)
    is_goal_zero_idx_even = (g_zero_idx % 2 == 0)
    start_depth = c_m_dist

    if is_start_zero_idx_even != is_goal_zero_idx_even:
        start_depth += 1

    for depth_limit in range(start_depth, max_depth + 1, 2):
        if depth_limit == max_depth:
            return depth_limit

        min_num_moves = dls(num_elements, adjacency_list, manhattan_distance_table, goal_state, depth_limit,
                            c_m_dist, start_state, zero_idx, 0, None)

        if min_num_moves >= 0:
            return min_num_moves

    return -1


def main():
    if READ_FROM_FILE:
        f = open('test0.txt', 'r')
    else:
        f = sys.stdin

    max_depth = 45
    width = 4
    height = 4
    num_elements = width * height
    dx_dy_tuple = ((1, 0), (0, 1), (-1, 0), (0, -1))
    adjacency_list = [[] for _ in range(num_elements)]
    goal_state = []

    for y in range(height):
        offset = y * width
        for x in range(width):
            idx = offset + x
            goal_state.append(idx + 1)

            for dx, dy in dx_dy_tuple:
                nx = x + dx
                ny = y + dy
                n_idx = ny * width + nx
                if 0 <= nx < width and 0 <= ny < height:
                    adjacency_list[idx].append(n_idx)

    goal_state[-1] = 0
    manhattan_distance_table = calc_manhattan_distance_table(width, num_elements, goal_state)
    start_state = []
    for _ in range(height):
        row = list(map(int, f.readline().split()))
        start_state += row

    zero_idx = start_state.index(0)
    min_num_moves = iddfs(num_elements, adjacency_list, manhattan_distance_table, max_depth,
                          start_state, zero_idx, goal_state)

    print(min_num_moves)

    if READ_FROM_FILE:
        f.close()
    return


if __name__ == '__main__':
    main()

"
6555505,ALDS1_13_C,"# 2022/04/29
# Yutaka Watanobe
from heapq import heappop, heappush

LIMIT = 45
N = 4                                                          # N * N pieces

adj = [{1, 4}, {0, 2, 5}, {1, 3, 6}, {2, 7},                   # N * N pieces are represented by 0, 1, ..., (N*N-1)
      {0, 5, 8}, {1, 4, 6, 9}, {2, 5, 7, 10}, {3, 6, 11},      # adj[i]: an adj list for piece i
      {4, 9, 12}, {5, 8, 10, 13}, {6, 9, 11, 14}, {7, 10, 15}, # ** this is for only N = 4
      {8, 13}, {9, 12, 14}, {10, 13, 15}, {11, 14}]

pieces = [[[0] for j in range(N)] for i in range(N)]           # contents for simulation

MD = [[abs(i//N-j//N)+abs(i%N-j%N) for j in range(N*N) ] for i in range(N*N)]    # manhattan dist between piece i and j
PW = [16**i for i in range(N*N)]                               # 16^i
SW = [[i*PW[j] for j in range(N*N) ] for i in range(N*N)]      # i * 16^j

initial_v, initial_h, initial_b = 0, 0, -1
target = 0

p = 0
for i in range(N):
    row = list(map(int, input().split()))
    for j in range(N):
        pieces[i][j] = row[j]
        if row[j] == 0:
            initial_b = i*N + j                                # set the place of the blank
        else:            
            initial_v += row[j]*PW[p]                          # initial hash value of the puzzle
            initial_h += MD[p][row[j]-1]                       # initial estimation cost
        if (p+1) <= 15: target += (p+1)*PW[p]
        p += 1

ans = -1
parent = {}                                                    # parent of BFS tree to simulate

def aster():
    global ans, parent
    queue = [(initial_h, initial_h, initial_v, initial_b, -1, -1)]
    visited = set()
    parent[initial_v] = [-1, -1]
    
    while len(queue) > 0:
        estimated, heuristic, val, blank, pre_v, pre = heappop(queue)
        cost = estimated - heuristic
        parent[val] = [pre_v, pre]
        if val in visited: continue
        if val == target:
            ans = cost
            return True
        visited.add(val)
        for next_b in adj[blank]:
            num = (val >> (4*next_b)) & 15
            next_v = val - SW[num][next_b] + SW[num][blank]
            if next_v in visited: continue
            next_h = heuristic + MD[blank][num-1] - MD[next_b][num-1]
            if cost + 1 > LIMIT: continue
            heappush(queue, (cost + 1 + next_h, next_h, next_v, next_b, val, num))
    return False

def simulate(v):
    if v == -1: return
    simulate(parent[v][0])
    if parent[v][1] != -1:
        print('\n', 'Move', parent[v][1], '\n')
    for i in range(N*N):
        print(v >> (4*i) & 15,  end=' ')
        if (i+1)%4 == 0: print()

if aster():
    print(ans)
#    simulate(target)
else:
    print(""unsolvable"")
    

"
6713604,ALDS1_13_C,"# 2022/04/29
# Yutaka Watanobe
from heapq import heappop, heappush

LIMIT = 45
N = 4                                                          # N * N pieces

adj = [{1, 4}, {0, 2, 5}, {1, 3, 6}, {2, 7},                   # N * N pieces are represented by 0, 1, ..., (N*N-1)
      {0, 5, 8}, {1, 4, 6, 9}, {2, 5, 7, 10}, {3, 6, 11},      # adj[i]: an adj list for piece i
      {4, 9, 12}, {5, 8, 10, 13}, {6, 9, 11, 14}, {7, 10, 15}, # ** this is for only N = 4
      {8, 13}, {9, 12, 14}, {10, 13, 15}, {11, 14}]

pieces = [[[0] for j in range(N)] for i in range(N)]           # contents for simulation

MD = [[abs(i//N-j//N)+abs(i%N-j%N) for j in range(N*N) ] for i in range(N*N)]    # manhattan dist between piece i and j
PW = [16**i for i in range(N*N)]                               # 16^i
SW = [[i*PW[j] for j in range(N*N) ] for i in range(N*N)]      # i * 16^j

initial_v, initial_h, initial_b = 0, 0, -1
target = 0

p = 0
for i in range(N):
    row = list(map(int, input().split()))
    for j in range(N):
        pieces[i][j] = row[j]
        if row[j] == 0:
            initial_b = i*N + j                                # set the place of the blank
        else:            
            initial_v += row[j]*PW[p]                          # initial hash value of the puzzle
            initial_h += MD[p][row[j]-1]                       # initial estimation cost
        if (p+1) <= 15: target += (p+1)*PW[p]
        p += 1

ans = -1
parent = {}                                                    # parent of BFS tree to simulate

def aster():
    global ans, parent
    queue = [(initial_h, initial_h, initial_v, initial_b, -1, -1)]
    visited = set()
    parent[initial_v] = [-1, -1]
    
    while len(queue) > 0:
        estimated, heuristic, val, blank, pre_v, pre = heappop(queue)
        cost = estimated - heuristic
        parent[val] = [pre_v, pre]
        if val in visited: continue
        if val == target:
            ans = cost
            return True
        visited.add(val)
        for next_b in adj[blank]:
            num = (val >> (4*next_b)) & 15
            next_v = val - SW[num][next_b] + SW[num][blank]
            if next_v in visited: continue
            next_h = heuristic + MD[blank][num-1] - MD[next_b][num-1]
            if cost + 1 > LIMIT: continue
            heappush(queue, (cost + 1 + next_h, next_h, next_v, next_b, val, num))
    return False

def simulate(v):
    if v == -1: return
    simulate(parent[v][0])
    if parent[v][1] != -1:
        print('\n', 'Move', parent[v][1], '\n')
    for i in range(N*N):
        print(v >> (4*i) & 15,  end=' ')
        if (i+1)%4 == 0: print()

if aster():
    print(ans)
#    simulate(target)
else:
    print(""unsolvable"")
    


"
5261251,ALDS1_13_C,"def solve():
    import copy, heapq

    def hash(a):
        res = 0
        for i in range(4):
            for j in range(4):
                res += a[i][j] * pow(2, 4 * (i * 4 + j))
        return res


    checked = set()

    score = 0
    zi, zj = 0, 0

    s = [list(map(int, input().split())) for _ in range(4)]
    for i in range(4):
        for j in range(4):
            if s[i][j] != 0:
                score += abs(i - (s[i][j] - 1) // 4) + abs(j - (s[i][j] - 1) % 4)
            else:
                zi, zj = i, j

    checked.add(hash(s))

    dx = [0, 1, 0, -1]
    q = [(score, score, 0, hash(s), zi, zj)]

    while q:
        cost, score, dist, now, r, c = heapq.heappop(q)

        if score == 0:
            print(dist)
            exit(0)
        
    
        for t in range(4):
            ni, nj = r + dx[t], c + dx[t ^ 1]
            if 0 <= ni and 0 <= nj and ni < 4 and nj < 4:
                x = (now >> (4 * (ni * 4 + nj))) % 16
                nxt = now + x * ((1 << (4 * (r * 4 + c))) - (1 << (4 * (ni * 4 + nj))))
        
                if not nxt in checked:
                    nd = score
                    nd -= abs((x - 1) // 4 - ni) + abs((x - 1) % 4 - nj)
                    nd += abs((x - 1) // 4 - r) + abs((x - 1) % 4 - c)
                    
                    checked.add(nxt)
                    heapq.heappush(q, (nd + dist + 1, nd, dist + 1, nxt, ni, nj))
                

if __name__ == '__main__':
    solve()
"
5477687,ALDS1_13_C,"def solve():
    import copy, heapq

    def hash(a):
        res = 0
        for i in range(4):
            for j in range(4):
                res += a[i][j] * pow(2, 4 * (i * 4 + j))
        return res


    checked = set()

    score = 0
    zi, zj = 0, 0

    s = [list(map(int, input().split())) for _ in range(4)]
    for i in range(4):
        for j in range(4):
            if s[i][j] != 0:
                score += abs(i - (s[i][j] - 1) // 4) + abs(j - (s[i][j] - 1) % 4)
            else:
                zi, zj = i, j

    checked.add(hash(s))

    dx = [0, 1, 0, -1]
    q = [(score, score, 0, hash(s), zi, zj)]

    while q:
        cost, score, dist, now, r, c = heapq.heappop(q)

        if score == 0:
            print(dist)
            exit(0)
        
    
        for t in range(4):
            ni, nj = r + dx[t], c + dx[t ^ 1]
            if 0 <= ni and 0 <= nj and ni < 4 and nj < 4:
                x = (now >> (4 * (ni * 4 + nj))) % 16
                nxt = now + x * ((1 << (4 * (r * 4 + c))) - (1 << (4 * (ni * 4 + nj))))
        
                if not nxt in checked:
                    nd = score
                    nd -= abs((x - 1) // 4 - ni) + abs((x - 1) % 4 - nj)
                    nd += abs((x - 1) // 4 - r) + abs((x - 1) % 4 - c)
                    
                    checked.add(nxt)
                    heapq.heappush(q, (nd + dist + 1, nd, dist + 1, nxt, ni, nj))
                

if __name__ == '__main__':
    solve()

"
8133095,ALDS1_13_C,"import heapq

# Define movement direction
dx = [0, 1, 0, -1]

def calculate_hash(board):
    result = 0
    for i in range(4):
        for j in range(4):
            result += board[i][j] * pow(2, 4 * (i * 4 + j))
    return result

def calculate_initial_score_and_zero_position(board):
    initial_score = 0
    zero_i, zero_j = 0, 0
    for i in range(4):
        for j in range(4):
            if board[i][j] != 0:
                initial_score += abs(i - (board[i][j] - 1) // 4) + abs(j - (board[i][j] - 1) % 4)
            else:
                zero_i, zero_j = i, j
    return initial_score, zero_i, zero_j

def process_next_states(current_state, current_score, current_distance, r, c, visited_states, states_queue):
    for t in range(4):
        ni, nj = r + dx[t], c + dx[t ^ 1]
        if 0 <= ni < 4 and 0 <= nj < 4:
            x = (current_state >> (4 * (ni * 4 + nj))) % 16
            next_state = current_state + x * ((1 << (4 * (r * 4 + c))) - (1 << (4 * (ni * 4 + nj))))
            if next_state not in visited_states:
                next_distance = current_score
                next_distance -= abs((x - 1) // 4 - ni) + abs((x - 1) % 4 - nj)
                next_distance += abs((x - 1) // 4 - r) + abs((x - 1) % 4 - c)
                visited_states.add(next_state)
                heapq.heappush(states_queue, (next_distance + current_distance + 1, next_distance, current_distance + 1, next_state, ni, nj))

def solve_puzzle():
    board = [list(map(int, input().split())) for _ in range(4)]
    initial_score, zero_i, zero_j = calculate_initial_score_and_zero_position(board)
    visited_states = set()
    visited_states.add(calculate_hash(board))
    states_queue = [(initial_score, initial_score, 0, calculate_hash(board), zero_i, zero_j)]
    while states_queue:
        current_cost, current_score, current_distance, current_state, r, c = heapq.heappop(states_queue)
        if current_score == 0:
            print(current_distance)
            return
        process_next_states(current_state, current_score, current_distance, r, c, visited_states, states_queue)

if __name__ == '__main__':
    solve_puzzle()

"
6675203,ALDS1_13_C,"from heapq import heappop,heappush

N=4

a,b,c,d=map(int,input().split())
e,f,g,h=map(int,input().split())
i,j,k,l=map(int,input().split())
m,n,o,p=map(int,input().split())


X=(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p)
GOAL=(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,0)

POW16=[1]

for i in range(20):
    POW16.append(POW16[-1]*16)

def hash(X):
    score=0
    for i in range(16):
        score+=POW16[i]*X[i]
    return score

def manh(X):
    score=0
    for i in range(16):
        x=X[i]
        if x==0:
            continue
        score+=abs(i//N-(x-1)//N) + abs(i%N-(x-1)%N)
    return score

for i in range(16):
    if X[i]==0:
        zero=i

Q=[(manh(X),manh(X),hash(X),-10,zero)]

USE=set()
USE.add(hash(X))

ANS=45

while Q:
    dis_score,dis,NOW,fr,zero=heappop(Q)

    if dis==0:
        ANS=min(ANS,dis_score-dis)
        print(ANS)
        break

    for i in [N,-N,1,-1]:
        if i==fr:
            continue

        if i==1:
            if zero%N==N-1:
                continue
        elif i==-1:
            if zero%N==0:
                continue
        elif i==N or i==-N:
            if zero+i<0 or zero+i>=16:
                continue

        x=NOW//(POW16[zero+i])%16

        NEXT_NOW=NOW-POW16[zero+i]*x+POW16[zero]*x

        if NEXT_NOW in USE:
            continue

        manh_dis=dis

        manh_dis-=abs((zero+i)//N-(x-1)//N) + abs((zero+i)%N-(x-1)%N)
        manh_dis+=abs(zero//N-(x-1)//N) + abs(zero%N-(x-1)%N)

        USE.add(NEXT_NOW)

        if dis_score-dis+1+manh_dis>ANS:
            continue

        heappush(Q,(manh_dis+dis_score-dis+1,manh_dis,NEXT_NOW,-i,zero+i))
"
8970101,ALDS1_13_C,"from functools import total_ordering
from heapq import heappop, heappush
from typing import Final

ALL_BITS = 0xFFFFFFFFFFFFFFFF

NEIGHBORS = (
    (1, 4),
    (0, 2, 5),
    (1, 3, 6),
    (2, 7),
    (0, 5, 8),
    (1, 4, 6, 9),
    (2, 5, 7, 10),
    (3, 6, 11),
    (4, 9, 12),
    (5, 8, 10, 13),
    (6, 9, 11, 14),
    (7, 10, 15),
    (8, 13),
    (9, 12, 14),
    (10, 13, 15),
    (11, 14),
)


@total_ordering
class Pazzle:
    __slots__ = [""lst"", ""pos0""]
    lst: int
    pos0: Final[int]

    def __init__(self, pos0):
        self.lst = 0
        self.pos0 = pos0

    def __setitem__(self, pos: int, panel: int):
        mask = ALL_BITS ^ (0x0F << (4 * pos))
        self.lst = (self.lst & mask) | (panel << (4 * pos))

    def __getitem__(self, pos: int):
        bits = self.lst >> (4 * pos)
        return bits & 0x0F

    def __eq__(self, other):
        return self.lst == other.lst

    def __lt__(self, other):
        return self.lst < other.lst

    def swap0(self, other_pos: int):
        ret = Pazzle(other_pos)
        ret.lst = self.lst
        ret[other_pos] = 0
        ret[self.pos0] = self[other_pos]
        return ret

    def nexts(self):
        for p in NEIGHBORS[self.pos0]:
            yield self.swap0(p)


def m_dist(p: Pazzle) -> int:
    ret = 0

    for pos in range(0, 16):
        panel = p[pos]
        if panel == 0:
            continue
        dest = panel - 1
        ret += abs(pos // 4 - dest // 4) + abs(pos % 4 - dest % 4)

    return ret


def solve(start: Pazzle):
    if m_dist(start) == 0:
        return 0

    visited = set()
    visited.add(start.lst)
    breads = [(0, 0, 0, start)]

    while True:
        _, _, c, p = heappop(breads)
        for next_p in p.nexts():
            if next_p.lst not in visited:
                md = m_dist(next_p)
                if md == 0:
                    return c + 1
                visited.add(next_p.lst)
                heappush(breads, (md + c + 1, md, c + 1, next_p))


if __name__ == ""__main__"":

    _start = []
    for _ in range(4):
        _start.extend(map(int, input().split()))

    start = Pazzle(_start.index(0))
    for i, panel in enumerate(_start):
        start[i] = panel

    print(solve(start))

"
6842695,ALDS1_13_C,"distance = (
    (),
    (0, 1, 2, 3, 1, 2, 3, 4, 2, 3, 4, 5, 3, 4, 5, 6),
    (1, 0, 1, 2, 2, 1, 2, 3, 3, 2, 3, 4, 4, 3, 4, 5),
    (2, 1, 0, 1, 3, 2, 1, 2, 4, 3, 2, 3, 5, 4, 3, 4),
    (3, 2, 1, 0, 4, 3, 2, 1, 5, 4, 3, 2, 6, 5, 4, 3),
    (1, 2, 3, 4, 0, 1, 2, 3, 1, 2, 3, 4, 2, 3, 4, 5),
    (2, 1, 2, 3, 1, 0, 1, 2, 2, 1, 2, 3, 3, 2, 3, 4),
    (3, 2, 1, 2, 2, 1, 0, 1, 3, 2, 1, 2, 4, 3, 2, 3),
    (4, 3, 2, 1, 3, 2, 1, 0, 4, 3, 2, 1, 5, 4, 3, 2),
    (2, 3, 4, 5, 1, 2, 3, 4, 0, 1, 2, 3, 1, 2, 3, 4),
    (3, 2, 3, 4, 2, 1, 2, 3, 1, 0, 1, 2, 2, 1, 2, 3),
    (4, 3, 2, 3, 3, 2, 1, 2, 2, 1, 0, 1, 3, 2, 1, 2),
    (5, 4, 3, 2, 4, 3, 2, 1, 3, 2, 1, 0, 4, 3, 2, 1),
    (3, 4, 5, 6, 2, 3, 4, 5, 1, 2, 3, 4, 0, 1, 2, 3),
    (4, 3, 4, 5, 3, 2, 3, 4, 2, 1, 2, 3, 1, 0, 1, 2),
    (5, 4, 3, 4, 4, 3, 2, 3, 3, 2, 1, 2, 2, 1, 0, 1)
)

ube = True
while ube == True:
    lio = False
    pass
    break

def get_distance(board):
    sd = 0
    for i in range(16):
        p = board[i]
        if p == 0:
            continue
        sd += distance[p][i]
    return sd

adjacent = (
    (1, 4),         
    (0, 2, 5),      
    (1, 3, 6),      
    (2, 7),         
    (0, 5, 8),      
    (1, 4, 6, 9),   
    (2, 5, 7, 10),  
    (3, 6, 11),     
    (4, 9, 12),     
    (5, 8, 10, 13), 
    (6, 9, 11, 14), 
    (7, 10, 15),    
    (8, 13),        
    (9, 12, 14),    
    (10, 13, 15),   
    (11, 14)        
)

GOAL = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0]

import sys

def df_lower_search(limit, move, space, lower, pre_p):
    if move == limit:
        if board == GOAL:
            return True
    else:
        for i in adjacent[space]:
            p = board[i]
            if p == pre_p:
                continue
            board[space] = p
            board[i] = 0
            new_lower = lower - distance[p][i] + distance[p][space]
            if new_lower + move <= limit:
                if df_lower_search(limit, move + 1, i, new_lower, p):
                    return True
            board[space] = 0
            board[i] = p


board = list(map(int, sys.stdin.read().split()))

s = board.index(0)
e_o = (0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0)

n = get_distance(board)

if e_o[s] != n % 2:
    n += 1

for l in range(n, 46, 2):
    if df_lower_search(l, 0, s, n, None):
        print(l)
        break
        

"
4631841,ALDS1_13_C,"# 反復深化

# 距離
distance = (
    (),
    (0, 1, 2, 3, 1, 2, 3, 4, 2, 3, 4, 5, 3, 4, 5, 6),
    (1, 0, 1, 2, 2, 1, 2, 3, 3, 2, 3, 4, 4, 3, 4, 5),
    (2, 1, 0, 1, 3, 2, 1, 2, 4, 3, 2, 3, 5, 4, 3, 4),
    (3, 2, 1, 0, 4, 3, 2, 1, 5, 4, 3, 2, 6, 5, 4, 3),
    (1, 2, 3, 4, 0, 1, 2, 3, 1, 2, 3, 4, 2, 3, 4, 5),
    (2, 1, 2, 3, 1, 0, 1, 2, 2, 1, 2, 3, 3, 2, 3, 4),
    (3, 2, 1, 2, 2, 1, 0, 1, 3, 2, 1, 2, 4, 3, 2, 3),
    (4, 3, 2, 1, 3, 2, 1, 0, 4, 3, 2, 1, 5, 4, 3, 2),
    (2, 3, 4, 5, 1, 2, 3, 4, 0, 1, 2, 3, 1, 2, 3, 4),
    (3, 2, 3, 4, 2, 1, 2, 3, 1, 0, 1, 2, 2, 1, 2, 3),
    (4, 3, 2, 3, 3, 2, 1, 2, 2, 1, 0, 1, 3, 2, 1, 2),
    (5, 4, 3, 2, 4, 3, 2, 1, 3, 2, 1, 0, 4, 3, 2, 1),
    (3, 4, 5, 6, 2, 3, 4, 5, 1, 2, 3, 4, 0, 1, 2, 3),
    (4, 3, 4, 5, 3, 2, 3, 4, 2, 1, 2, 3, 1, 0, 1, 2),
    (5, 4, 3, 4, 4, 3, 2, 3, 3, 2, 1, 2, 2, 1, 0, 1)
)

# 距離を求める
def get_distance(board):
    sd = 0
    for i in range(16):
        p = board[i]
        if p == 0:
            continue
        sd += distance[p][i]
    return sd

adjacent = (
    (1, 4),         # 0
    (0, 2, 5),      # 1
    (1, 3, 6),      # 2
    (2, 7),         # 3
    (0, 5, 8),      # 4
    (1, 4, 6, 9),   # 5
    (2, 5, 7, 10),  # 6
    (3, 6, 11),     # 7
    (4, 9, 12),     # 8
    (5, 8, 10, 13), # 9
    (6, 9, 11, 14), # 10
    (7, 10, 15),    # 11
    (8, 13),        # 12
    (9, 12, 14),    # 13
    (10, 13, 15),   # 14
    (11, 14)        # 15
)

GOAL = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0]

# 下限値枝刈り法
def df_lower_search(limit, move, space, lower, pre_p):
    if move == limit:
        if board == GOAL:
            return True
    else:
        for i in adjacent[space]:
            p = board[i]
            if p == pre_p:
                continue
            board[space] = p
            board[i] = 0
            new_lower = lower - distance[p][i] + distance[p][space]
            if new_lower + move <= limit:
                if df_lower_search(limit, move + 1, i, new_lower, p):
                    return True
            board[space] = 0
            board[i] = p

import sys

board = list(map(int, sys.stdin.read().split()))

s = board.index(0)
e_o = (0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0)

n = get_distance(board)

if e_o[s] != n % 2:
    n += 1

for l in range(n, 46, 2):
    if df_lower_search(l, 0, s, n, None):
        print(l)
        break
        


"
5011739,ALDS1_13_C,"distance = (
    (),
    (0, 1, 2, 3, 1, 2, 3, 4, 2, 3, 4, 5, 3, 4, 5, 6),
    (1, 0, 1, 2, 2, 1, 2, 3, 3, 2, 3, 4, 4, 3, 4, 5),
    (2, 1, 0, 1, 3, 2, 1, 2, 4, 3, 2, 3, 5, 4, 3, 4),
    (3, 2, 1, 0, 4, 3, 2, 1, 5, 4, 3, 2, 6, 5, 4, 3),
    (1, 2, 3, 4, 0, 1, 2, 3, 1, 2, 3, 4, 2, 3, 4, 5),
    (2, 1, 2, 3, 1, 0, 1, 2, 2, 1, 2, 3, 3, 2, 3, 4),
    (3, 2, 1, 2, 2, 1, 0, 1, 3, 2, 1, 2, 4, 3, 2, 3),
    (4, 3, 2, 1, 3, 2, 1, 0, 4, 3, 2, 1, 5, 4, 3, 2),
    (2, 3, 4, 5, 1, 2, 3, 4, 0, 1, 2, 3, 1, 2, 3, 4),
    (3, 2, 3, 4, 2, 1, 2, 3, 1, 0, 1, 2, 2, 1, 2, 3),
    (4, 3, 2, 3, 3, 2, 1, 2, 2, 1, 0, 1, 3, 2, 1, 2),
    (5, 4, 3, 2, 4, 3, 2, 1, 3, 2, 1, 0, 4, 3, 2, 1),
    (3, 4, 5, 6, 2, 3, 4, 5, 1, 2, 3, 4, 0, 1, 2, 3),
    (4, 3, 4, 5, 3, 2, 3, 4, 2, 1, 2, 3, 1, 0, 1, 2),
    (5, 4, 3, 4, 4, 3, 2, 3, 3, 2, 1, 2, 2, 1, 0, 1)
)

def get_distance(board):
    sd = 0
    for i in range(16):
        p = board[i]
        if p == 0:
            continue
        sd += distance[p][i]
    return sd

adjacent = (
    (1, 4),         # 0
    (0, 2, 5),      # 1
    (1, 3, 6),      # 2
    (2, 7),         # 3
    (0, 5, 8),      # 4
    (1, 4, 6, 9),   # 5
    (2, 5, 7, 10),  # 6
    (3, 6, 11),     # 7
    (4, 9, 12),     # 8
    (5, 8, 10, 13), # 9
    (6, 9, 11, 14), # 10
    (7, 10, 15),    # 11
    (8, 13),        # 12
    (9, 12, 14),    # 13
    (10, 13, 15),   # 14
    (11, 14)        # 15
)

GOAL = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0]

def df_lower_search(limit, move, space, lower, pre_p):
    if move == limit:
        if board == GOAL:
            return True
    else:
        for i in adjacent[space]:
            p = board[i]
            if p == pre_p:
                continue
            board[space] = p
            board[i] = 0
            new_lower = lower - distance[p][i] + distance[p][space]
            if new_lower + move <= limit:
                if df_lower_search(limit, move + 1, i, new_lower, p):
                    return True
            board[space] = 0
            board[i] = p

import sys

board = list(map(int, sys.stdin.read().split()))

s = board.index(0)
e_o = (0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0)

n = get_distance(board)

if e_o[s] != n % 2:
    n += 1

for l in range(n, 46, 2):
    if df_lower_search(l, 0, s, n, None):
        print(l)
        break

"
3803572,ALDS1_13_C,"import sys
from typing import List


def get_distance(board: List[int]) -> int:
    sd = 0
    for i in range(16):
        p = board[i]
        if p == 0:
            continue
        sd += distance[p][i]
    return sd


def df_lower_search(limit: int, move: int, space: int, lower: int, pre_p: int) -> bool:
    global board
    global GOAL
    if move == limit:
        if board == GOAL:
            return True
    else:
        for i in adjacent[space]:
            p = board[i]
            if p == pre_p:
                continue
            board[space] = p
            board[i] = 0
            new_lower = lower - distance[p][i] + distance[p][space]
            if new_lower + move <= limit:
                if df_lower_search(limit, move + 1, i, new_lower, p):
                    return True
            board[space] = 0
            board[i] = p
    # Never reaches here.
    return False


if __name__ == ""__main__"":
    distance = (
        (),
        (0, 1, 2, 3, 1, 2, 3, 4, 2, 3, 4, 5, 3, 4, 5, 6),
        (1, 0, 1, 2, 2, 1, 2, 3, 3, 2, 3, 4, 4, 3, 4, 5),
        (2, 1, 0, 1, 3, 2, 1, 2, 4, 3, 2, 3, 5, 4, 3, 4),
        (3, 2, 1, 0, 4, 3, 2, 1, 5, 4, 3, 2, 6, 5, 4, 3),
        (1, 2, 3, 4, 0, 1, 2, 3, 1, 2, 3, 4, 2, 3, 4, 5),
        (2, 1, 2, 3, 1, 0, 1, 2, 2, 1, 2, 3, 3, 2, 3, 4),
        (3, 2, 1, 2, 2, 1, 0, 1, 3, 2, 1, 2, 4, 3, 2, 3),
        (4, 3, 2, 1, 3, 2, 1, 0, 4, 3, 2, 1, 5, 4, 3, 2),
        (2, 3, 4, 5, 1, 2, 3, 4, 0, 1, 2, 3, 1, 2, 3, 4),
        (3, 2, 3, 4, 2, 1, 2, 3, 1, 0, 1, 2, 2, 1, 2, 3),
        (4, 3, 2, 3, 3, 2, 1, 2, 2, 1, 0, 1, 3, 2, 1, 2),
        (5, 4, 3, 2, 4, 3, 2, 1, 3, 2, 1, 0, 4, 3, 2, 1),
        (3, 4, 5, 6, 2, 3, 4, 5, 1, 2, 3, 4, 0, 1, 2, 3),
        (4, 3, 4, 5, 3, 2, 3, 4, 2, 1, 2, 3, 1, 0, 1, 2),
        (5, 4, 3, 4, 4, 3, 2, 3, 3, 2, 1, 2, 2, 1, 0, 1)
    )

    adjacent = (
        (1, 4),          # 0
        (0, 2, 5),       # 1
        (1, 3, 6),       # 2
        (2, 7),          # 3
        (0, 5, 8),       # 4
        (1, 4, 6, 9),    # 5
        (2, 5, 7, 10),   # 6
        (3, 6, 11),      # 7
        (4, 9, 12),      # 8
        (5, 8, 10, 13),  # 9
        (6, 9, 11, 14),  # 10
        (7, 10, 15),     # 11
        (8, 13),         # 12
        (9, 12, 14),     # 13
        (10, 13, 15),    # 14
        (11, 14)         # 15
    )

    GOAL = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0]

    board = list(map(int, sys.stdin.read().split()))

    s = board.index(0)
    e_o = (0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0)
    n = get_distance(board)

    if e_o[s] != n % 2:
        n += 1

    for l in range(n, 46, 2):
        if df_lower_search(l, 0, s, n, -1):
            print(l)
            break

"
4483536,ALDS1_13_C,"# 反復深化

# 距離
distance = (
    (),
    (0, 1, 2, 3, 1, 2, 3, 4, 2, 3, 4, 5, 3, 4, 5, 6),
    (1, 0, 1, 2, 2, 1, 2, 3, 3, 2, 3, 4, 4, 3, 4, 5),
    (2, 1, 0, 1, 3, 2, 1, 2, 4, 3, 2, 3, 5, 4, 3, 4),
    (3, 2, 1, 0, 4, 3, 2, 1, 5, 4, 3, 2, 6, 5, 4, 3),
    (1, 2, 3, 4, 0, 1, 2, 3, 1, 2, 3, 4, 2, 3, 4, 5),
    (2, 1, 2, 3, 1, 0, 1, 2, 2, 1, 2, 3, 3, 2, 3, 4),
    (3, 2, 1, 2, 2, 1, 0, 1, 3, 2, 1, 2, 4, 3, 2, 3),
    (4, 3, 2, 1, 3, 2, 1, 0, 4, 3, 2, 1, 5, 4, 3, 2),
    (2, 3, 4, 5, 1, 2, 3, 4, 0, 1, 2, 3, 1, 2, 3, 4),
    (3, 2, 3, 4, 2, 1, 2, 3, 1, 0, 1, 2, 2, 1, 2, 3),
    (4, 3, 2, 3, 3, 2, 1, 2, 2, 1, 0, 1, 3, 2, 1, 2),
    (5, 4, 3, 2, 4, 3, 2, 1, 3, 2, 1, 0, 4, 3, 2, 1),
    (3, 4, 5, 6, 2, 3, 4, 5, 1, 2, 3, 4, 0, 1, 2, 3),
    (4, 3, 4, 5, 3, 2, 3, 4, 2, 1, 2, 3, 1, 0, 1, 2),
    (5, 4, 3, 4, 4, 3, 2, 3, 3, 2, 1, 2, 2, 1, 0, 1)
)

# 距離を求める
def get_distance(board):
    sd = 0
    for i in range(16):
        p = board[i]
        if p == 0:
            continue
        sd += distance[p][i]
    return sd

adjacent = (
    (1, 4),         # 0
    (0, 2, 5),      # 1
    (1, 3, 6),      # 2
    (2, 7),         # 3
    (0, 5, 8),      # 4
    (1, 4, 6, 9),   # 5
    (2, 5, 7, 10),  # 6
    (3, 6, 11),     # 7
    (4, 9, 12),     # 8
    (5, 8, 10, 13), # 9
    (6, 9, 11, 14), # 10
    (7, 10, 15),    # 11
    (8, 13),        # 12
    (9, 12, 14),    # 13
    (10, 13, 15),   # 14
    (11, 14)        # 15
)

GOAL = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0]

# 下限値枝刈り法
def df_lower_search(limit, move, space, lower, pre_p):
    if move == limit:
        if board == GOAL:
            return True
    else:
        for i in adjacent[space]:
            p = board[i]
            if p == pre_p:
                continue
            board[space] = p
            board[i] = 0
            new_lower = lower - distance[p][i] + distance[p][space]
            if new_lower + move <= limit:
                if df_lower_search(limit, move + 1, i, new_lower, p):
                    return True
            board[space] = 0
            board[i] = p

import sys

board = list(map(int, sys.stdin.read().split()))

s = board.index(0)
e_o = (0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0)

n = get_distance(board)

if e_o[s] != n % 2:
    n += 1

for l in range(n, 46, 2):
    if df_lower_search(l, 0, s, n, None):
        print(l)
        break
        

"
7691183,ALDS1_13_C,"import sys
import os
from collections import deque
from heapq import heapify, heappop, heappush
from math import inf
import time


def hexfization(A):
    ret=0
    for a,b in zip(A,hexcof):
        ret+=a*b
    return ret

def manhatan_table(array):
    tbl=[[0]*(n*n) for _ in range(n*n)]
    for i in range(1,n*n):
        k=array.index(i)
        for j in range(n*n):
            y,x=divmod(j,n)
            y0,x0=divmod(k,n)
            tbl[i][j]=abs(y-y0)+abs(x-x0)
    return tbl
                  
def manhatan_distance(target,tbl):
    d=0
    for i,c in enumerate(target):
        d+=tbl[c][i]
    return d     

def generate_path(M):
    temp=[hex(M)[2:][::-1]]
    B=M
    while 1:
        M=Visited[0][M][1]
        if M:
            h=hex(M)[2:][::-1]
            temp.append(h)
        else:
            break
    temp=temp[::-1]
    while 1:
        B=Visited[1][B][1]
        if B:
            h=hex(B)[2:][::-1]
            temp.append(h)
        else:
            break
    return temp
        

def Move_Next_h(d,a,current_zero_pos,cnt,dir):
    for next_zero_pos in nexts[current_zero_pos]:
        k=a>>(4*next_zero_pos)&15
        next_point=a+k*(hexcof[current_zero_pos]-hexcof[next_zero_pos])     
        next_pridict_distance=d+mt[dir][k][current_zero_pos]-mt[dir][k][next_zero_pos]+1
        if next_point in Visited[dir]:
            continue
        heappush(Q[dir],(next_pridict_distance,next_zero_pos, cnt + 1, next_point,a))
   
        
def Move_Next_t(d,a, zero, cnt,dir):
    for i in nexts[zero]:
        temp = list(a)
        temp[i], temp[zero] = temp[zero], temp[i]
        nextd=d+mt[dir][temp[zero]][zero]-mt[dir][a[i]][i]+1
        if dir==0:
            heappush(Q[0],(nextd,i, cnt + 1, tuple(temp),a))
        else:
            heappush(Q[1],(nextd,i, cnt + 1, tuple(temp),a)) 
            
istest = False
fn = ""inputdata.txt""
if os.path.exists(fn):
    istest = True
    sys.stdin = open(fn)

start=time.time()


ini = tuple(map(int, sys.stdin.read().split()))
n = int(len(ini) ** 0.5)
fin = tuple(list(range(1, n * n)) + [0])
Move_Next=Move_Next_t 

hexcof=[(n*n)**i for i in range(n*n)]
nexts=[]
for i in range(n * n):
    y, x = divmod(i, n)
    temp = []
    if y - 1 > -1:
        temp.append(i - n)
    if x - 1 > -1:
        temp.append(i - 1)
    if x + 1 < n:
        temp.append(i + 1)
    if y + 1 < n:
        temp.append(i + n)
    nexts.append(tuple(temp))
        
ini0 = ini.index(0)
fin0 = fin.index(0)
mt=(manhatan_table(fin),manhatan_table(ini))
d0=manhatan_distance(ini,mt[0])
d1=manhatan_distance(fin,mt[1])


isHex=True
if isHex:
    fin=hexfization(fin)
    ini=hexfization(ini)
    Move_Next=Move_Next_h

target=(fin,ini)
Q=[[],[]]
heappush(Q[0],(d0,ini0, 0, ini,None))
heappush(Q[1],(d1,fin0, 0, fin,None))
Visited=[{},{}]
loop_cont=True
ways=2
ans=inf
counter=0
limit=45
p2=-1
while loop_cont:
    for i in range(ways):
        d,z,cnt,M,p=heappop(Q[i])
        if cnt>limit:
            continue
        if M==target[i]:
            ans=cnt
            P1=p
            loop_cont=False
            break
        if M in Visited[i]:
            continue
        Visited[i][M] = cnt,p
        if M in Visited[i-1]:
            tempans =Visited[i-1][M][0]+cnt
            if ans>tempans:
                ans=tempans
                CP=M
            if d>=ans or Q[i-1][0][0]>=ans:
                loop_cont=False
                break
        Move_Next(d,M, z, cnt,i)
#path=generate_path(CP)
print(ans)
"
4438504,ALDS1_13_C,"import sys
from heapq import heappop, heappush


adjacent = (
    (1, 4),
    (0, 2, 5),
    (1, 3, 6),
    (2, 7),
    (0, 5, 8),
    (1, 4, 6, 9),
    (2, 5, 7, 10),
    (3, 6, 11),
    (4, 9, 12),
    (5, 8, 10, 13),
    (6, 9, 11, 14),
    (7, 10, 15),
    (8, 13),
    (9, 12, 14),
    (10, 13, 15),
    (11, 14)
)

distance = (
    (),
    (0, 1, 2, 3, 1, 2, 3, 4, 2, 3, 4, 5, 3, 4, 5, 6),
    (1, 0, 1, 2, 2, 1, 2, 3, 3, 2, 3, 4, 4, 3, 4, 5),
    (2, 1, 0, 1, 3, 2, 1, 2, 4, 3, 2, 3, 5, 4, 3, 4),
    (3, 2, 1, 0, 4, 3, 2, 1, 5, 4, 3, 2, 6, 5, 4, 3),
    (1, 2, 3, 4, 0, 1, 2, 3, 1, 2, 3, 4, 2, 3, 4, 5),
    (2, 1, 2, 3, 1, 0, 1, 2, 2, 1, 2, 3, 3, 2, 3, 4),
    (3, 2, 1, 2, 2, 1, 0, 1, 3, 2, 1, 2, 4, 3, 2, 3),
    (4, 3, 2, 1, 3, 2, 1, 0, 4, 3, 2, 1, 5, 4, 3, 2),
    (2, 3, 4, 5, 1, 2, 3, 4, 0, 1, 2, 3, 1, 2, 3, 4),
    (3, 2, 3, 4, 2, 1, 2, 3, 1, 0, 1, 2, 2, 1, 2, 3),
    (4, 3, 2, 3, 3, 2, 1, 2, 2, 1, 0, 1, 3, 2, 1, 2),
    (5, 4, 3, 2, 4, 3, 2, 1, 3, 2, 1, 0, 4, 3, 2, 1),
    (3, 4, 5, 6, 2, 3, 4, 5, 1, 2, 3, 4, 0, 1, 2, 3),
    (4, 3, 4, 5, 3, 2, 3, 4, 2, 1, 2, 3, 1, 0, 1, 2),
    (5, 4, 3, 4, 4, 3, 2, 3, 3, 2, 1, 2, 2, 1, 0, 1)
)

end = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0]


def get_distance():
    global board
    sum_distance = 0
    for i in range(16):
        if board[i] == 0:
            continue
        sum_distance += distance[board[i]][i]
    return sum_distance


def search(limit, move, space, lower, prev_space):
    global board

    if move == limit:
        if board == end:
            return True

    else:
        for next_space in adjacent[space]:
            if next_space == prev_space:
                continue
            board[space] = board[next_space]
            board[next_space] = 0

            new_lower = lower - distance[board[space]][next_space] + distance[board[space]][space]

            if new_lower + move <= limit:
                if search(limit, move + 1, next_space, new_lower, space):
                    return True
            board[next_space] = board[space]
            board[space] = 0


board = []
for _ in range(4):
    board.extend(list(map(int, sys.stdin.readline().strip().split())))

# 最初のスペースの位置で、解の手順が奇数手か偶数手かが決定される
n = get_distance()  # 暫定的な最小手
first_space = board.index(0)
e_o = (0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0)
if n % 2 != e_o[first_space]:
    n += 1

for l in range(n, 46, 2):
    if search(l, 0, first_space, n, None):
        print(l)
        break

"
2615418,ALDS1_13_C,"distance = (
    (),
    (0, 1, 2, 3, 1, 2, 3, 4, 2, 3, 4, 5, 3, 4, 5, 6),
    (1, 0, 1, 2, 2, 1, 2, 3, 3, 2, 3, 4, 4, 3, 4, 5),
    (2, 1, 0, 1, 3, 2, 1, 2, 4, 3, 2, 3, 5, 4, 3, 4),
    (3, 2, 1, 0, 4, 3, 2, 1, 5, 4, 3, 2, 6, 5, 4, 3),
    (1, 2, 3, 4, 0, 1, 2, 3, 1, 2, 3, 4, 2, 3, 4, 5),
    (2, 1, 2, 3, 1, 0, 1, 2, 2, 1, 2, 3, 3, 2, 3, 4),
    (3, 2, 1, 2, 2, 1, 0, 1, 3, 2, 1, 2, 4, 3, 2, 3),
    (4, 3, 2, 1, 3, 2, 1, 0, 4, 3, 2, 1, 5, 4, 3, 2),
    (2, 3, 4, 5, 1, 2, 3, 4, 0, 1, 2, 3, 1, 2, 3, 4),
    (3, 2, 3, 4, 2, 1, 2, 3, 1, 0, 1, 2, 2, 1, 2, 3),
    (4, 3, 2, 3, 3, 2, 1, 2, 2, 1, 0, 1, 3, 2, 1, 2),
    (5, 4, 3, 2, 4, 3, 2, 1, 3, 2, 1, 0, 4, 3, 2, 1),
    (3, 4, 5, 6, 2, 3, 4, 5, 1, 2, 3, 4, 0, 1, 2, 3),
    (4, 3, 4, 5, 3, 2, 3, 4, 2, 1, 2, 3, 1, 0, 1, 2),
    (5, 4, 3, 4, 4, 3, 2, 3, 3, 2, 1, 2, 2, 1, 0, 1)
)

def get_distance(board):
    sd = 0
    for i in range(16):
        p = board[i]
        if p == 0:
            continue
        sd += distance[p][i]
    return sd

adjacent = (
    (1, 4),         # 0
    (0, 2, 5),      # 1
    (1, 3, 6),      # 2
    (2, 7),         # 3
    (0, 5, 8),      # 4
    (1, 4, 6, 9),   # 5
    (2, 5, 7, 10),  # 6
    (3, 6, 11),     # 7
    (4, 9, 12),     # 8
    (5, 8, 10, 13), # 9
    (6, 9, 11, 14), # 10
    (7, 10, 15),    # 11
    (8, 13),        # 12
    (9, 12, 14),    # 13
    (10, 13, 15),   # 14
    (11, 14)        # 15
)

GOAL = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0]

def df_lower_search(limit, move, space, lower, pre_p):
    if move == limit:
        if board == GOAL:
            return True
    else:
        for i in adjacent[space]:
            p = board[i]
            if p == pre_p:
                continue
            board[space] = p
            board[i] = 0
            new_lower = lower - distance[p][i] + distance[p][space]
            if new_lower + move <= limit:
                if df_lower_search(limit, move + 1, i, new_lower, p):
                    return True
            board[space] = 0
            board[i] = p

import sys

board = list(map(int, sys.stdin.read().split()))

s = board.index(0)
e_o = (0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0)

n = get_distance(board)

if e_o[s] != n % 2:
    n += 1

for l in range(n, 46, 2):
    if df_lower_search(l, 0, s, n, None):
        print(l)
        break
"
6035425,ALDS1_13_C,"import sys
from heapq import heappop, heappush


adjacent = (
    (1, 4),
    (0, 2, 5),
    (1, 3, 6),
    (2, 7),
    (0, 5, 8),
    (1, 4, 6, 9),
    (2, 5, 7, 10),
    (3, 6, 11),
    (4, 9, 12),
    (5, 8, 10, 13),
    (6, 9, 11, 14),
    (7, 10, 15),
    (8, 13),
    (9, 12, 14),
    (10, 13, 15),
    (11, 14)
)

distance = (
    (),
    (0, 1, 2, 3, 1, 2, 3, 4, 2, 3, 4, 5, 3, 4, 5, 6),
    (1, 0, 1, 2, 2, 1, 2, 3, 3, 2, 3, 4, 4, 3, 4, 5),
    (2, 1, 0, 1, 3, 2, 1, 2, 4, 3, 2, 3, 5, 4, 3, 4),
    (3, 2, 1, 0, 4, 3, 2, 1, 5, 4, 3, 2, 6, 5, 4, 3),
    (1, 2, 3, 4, 0, 1, 2, 3, 1, 2, 3, 4, 2, 3, 4, 5),
    (2, 1, 2, 3, 1, 0, 1, 2, 2, 1, 2, 3, 3, 2, 3, 4),
    (3, 2, 1, 2, 2, 1, 0, 1, 3, 2, 1, 2, 4, 3, 2, 3),
    (4, 3, 2, 1, 3, 2, 1, 0, 4, 3, 2, 1, 5, 4, 3, 2),
    (2, 3, 4, 5, 1, 2, 3, 4, 0, 1, 2, 3, 1, 2, 3, 4),
    (3, 2, 3, 4, 2, 1, 2, 3, 1, 0, 1, 2, 2, 1, 2, 3),
    (4, 3, 2, 3, 3, 2, 1, 2, 2, 1, 0, 1, 3, 2, 1, 2),
    (5, 4, 3, 2, 4, 3, 2, 1, 3, 2, 1, 0, 4, 3, 2, 1),
    (3, 4, 5, 6, 2, 3, 4, 5, 1, 2, 3, 4, 0, 1, 2, 3),
    (4, 3, 4, 5, 3, 2, 3, 4, 2, 1, 2, 3, 1, 0, 1, 2),
    (5, 4, 3, 4, 4, 3, 2, 3, 3, 2, 1, 2, 2, 1, 0, 1)
)

end = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0]


def get_distance():
    global board
    sum_distance = 0
    for i in range(16):
        if board[i] == 0:
            continue
        sum_distance += distance[board[i]][i]
    return sum_distance


def search(limit, move, space, lower, prev_space):
    global board

    if move == limit:
        if board == end:
            return True

    else:
        for next_space in adjacent[space]:
            if next_space == prev_space:
                continue
            board[space] = board[next_space]
            board[next_space] = 0

            new_lower = lower - distance[board[space]][next_space] + distance[board[space]][space]

            if new_lower + move <= limit:
                if search(limit, move + 1, next_space, new_lower, space):
                    return True
            board[next_space] = board[space]
            board[space] = 0


board = []
for _ in range(4):
    board.extend(list(map(int, sys.stdin.readline().strip().split())))

# 最初のスペースの位置で、解の手順が奇数手か偶数手かが決定される
n = get_distance()  # 暫定的な最小手
first_space = board.index(0)
e_o = (0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0)
if n % 2 != e_o[first_space]:
    n += 1

for l in range(n, 46, 2):
    if search(l, 0, first_space, n, None):
        print(l)
        break
"
4844207,ALDS1_13_C,"import sys
from heapq import heappop, heappush


adjacent = (
    (1, 4),
    (0, 2, 5),
    (1, 3, 6),
    (2, 7),
    (0, 5, 8),
    (1, 4, 6, 9),
    (2, 5, 7, 10),
    (3, 6, 11),
    (4, 9, 12),
    (5, 8, 10, 13),
    (6, 9, 11, 14),
    (7, 10, 15),
    (8, 13),
    (9, 12, 14),
    (10, 13, 15),
    (11, 14)
)

distance = (
    (),
    (0, 1, 2, 3, 1, 2, 3, 4, 2, 3, 4, 5, 3, 4, 5, 6),
    (1, 0, 1, 2, 2, 1, 2, 3, 3, 2, 3, 4, 4, 3, 4, 5),
    (2, 1, 0, 1, 3, 2, 1, 2, 4, 3, 2, 3, 5, 4, 3, 4),
    (3, 2, 1, 0, 4, 3, 2, 1, 5, 4, 3, 2, 6, 5, 4, 3),
    (1, 2, 3, 4, 0, 1, 2, 3, 1, 2, 3, 4, 2, 3, 4, 5),
    (2, 1, 2, 3, 1, 0, 1, 2, 2, 1, 2, 3, 3, 2, 3, 4),
    (3, 2, 1, 2, 2, 1, 0, 1, 3, 2, 1, 2, 4, 3, 2, 3),
    (4, 3, 2, 1, 3, 2, 1, 0, 4, 3, 2, 1, 5, 4, 3, 2),
    (2, 3, 4, 5, 1, 2, 3, 4, 0, 1, 2, 3, 1, 2, 3, 4),
    (3, 2, 3, 4, 2, 1, 2, 3, 1, 0, 1, 2, 2, 1, 2, 3),
    (4, 3, 2, 3, 3, 2, 1, 2, 2, 1, 0, 1, 3, 2, 1, 2),
    (5, 4, 3, 2, 4, 3, 2, 1, 3, 2, 1, 0, 4, 3, 2, 1),
    (3, 4, 5, 6, 2, 3, 4, 5, 1, 2, 3, 4, 0, 1, 2, 3),
    (4, 3, 4, 5, 3, 2, 3, 4, 2, 1, 2, 3, 1, 0, 1, 2),
    (5, 4, 3, 4, 4, 3, 2, 3, 3, 2, 1, 2, 2, 1, 0, 1)
)

end = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0]


def get_distance():
    global board
    sum_distance = 0
    for i in range(16):
        if board[i] == 0:
            continue
        sum_distance += distance[board[i]][i]
    return sum_distance


def search(limit, move, space, lower, prev_space):
    global board

    if move == limit:
        if board == end:
            return True

    else:
        for next_space in adjacent[space]:
            if next_space == prev_space:
                continue
            board[space] = board[next_space]
            board[next_space] = 0

            new_lower = lower - distance[board[space]][next_space] + distance[board[space]][space]

            if new_lower + move <= limit:
                if search(limit, move + 1, next_space, new_lower, space):
                    return True
            board[next_space] = board[space]
            board[space] = 0


board = []
for _ in range(4):
    board.extend(list(map(int, sys.stdin.readline().strip().split())))

# 最初のスペースの位置で、解の手順が奇数手か偶数手かが決定される
n = get_distance()  # 暫定的な最小手
first_space = board.index(0)
e_o = (0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0)
if n % 2 != e_o[first_space]:
    n += 1

for l in range(n, 46, 2):
    if search(l, 0, first_space, n, None):
        print(l)
        break


"
9206460,ALDS1_13_C,"from heapq import heappop, heappush

LIMIT = 45
N = 4                                                          # N * N pieces

adj = [{1, 4}, {0, 2, 5}, {1, 3, 6}, {2, 7},                   # N * N pieces are represented by 0, 1, ..., (N*N-1)
      {0, 5, 8}, {1, 4, 6, 9}, {2, 5, 7, 10}, {3, 6, 11},      # adj[i]: an adj list for piece i
      {4, 9, 12}, {5, 8, 10, 13}, {6, 9, 11, 14}, {7, 10, 15}, # ** this is for only N = 4
      {8, 13}, {9, 12, 14}, {10, 13, 15}, {11, 14}]

pieces = [[[0] for j in range(N)] for i in range(N)]           # contents for simulation

MD = [[abs(i//N-j//N)+abs(i%N-j%N) for j in range(N*N) ] for i in range(N*N)]    # manhattan dist between piece i and j
PW = [16**i for i in range(N*N)]                               # 16^i
SW = [[i*PW[j] for j in range(N*N) ] for i in range(N*N)]      # i * 16^j

initial_v, initial_h, initial_b = 0, 0, -1
target = 0

p = 0
for i in range(N):
    row = list(map(int, input().split()))
    for j in range(N):
        pieces[i][j] = row[j]
        if row[j] == 0:
            initial_b = i*N + j                                # set the place of the blank
        else:            
            initial_v += row[j]*PW[p]                          # initial hash value of the puzzle
            initial_h += MD[p][row[j]-1]                       # initial estimation cost
        if (p+1) <= 15: target += (p+1)*PW[p]
        p += 1

ans = -1
parent = {}                                                    # parent of BFS tree to simulate

def aster():
    global ans, parent
    queue = [(initial_h, 0, initial_h, initial_v, initial_b, -1, -1)]
    visited = set()
    parent[initial_v] = [-1, -1]
    
    while len(queue) > 0:
        estimated, cost, heuristic, val, blank, pre_v, pre = heappop(queue)
        parent[val] = [pre_v, pre]
        if val in visited: continue
        if val == target:
            ans = estimated
            return True
        visited.add(val)
        for next_b in adj[blank]:
            num = (val >> (4*next_b)) & 15
            next_v = val - SW[num][next_b] + SW[num][blank]
            if next_v in visited: continue
            next_h = heuristic + MD[blank][num-1] - MD[next_b][num-1]
            if cost + 1 > LIMIT: continue
            heappush(queue, (cost + 1 + next_h, cost + 1, next_h, next_v, next_b, val, num))

    return False

def simulate(v):
    if v == -1: return
    simulate(parent[v][0])
    if parent[v][1] != -1:
        print('\n', 'Move', parent[v][1], '\n')
    for i in range(N*N):
        if i%4 == 0: print('[', end='')
        print(v >> (4*i) & 15, end='')
        if (i+1)%4 == 0: print(']')
        else: print(', ', end='')

if aster():
    print( ans )

"
7753285,ALDS1_13_C,"# 13_C.py 15 Puzzle
# TODO
# 13_B code: #15 8.29 #17 13.01
# Simple heuristics: #15 0.03s #17 4.53s
# Manhattan heuristics: #15 0.01s #17 0.11s #20 0.76s #21 11.71 #22 TLE
# Rolling Hash: #15 0.01s #17 0.11s #20 0.73s #21 11.25 #22 TLE
# Rolling Manhattan: #15 0.01s #17 0.02s #20 0.05s #21 1.53s #22 0.91s #28 3.90s

from sys import stdin

LIMIT = 45
GOAL = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0]

def neighbors(pos):
    if pos >= 4:
        yield pos - 4
    if pos < 12:
        yield pos + 4
    if pos % 4 != 0:
        yield pos - 1
    if pos % 4 != 3:
        yield pos + 1

NEIGHBORS = [list(neighbors(pos)) for pos in range(16)]

def swap(board, pos, new_pos):
    new_board = board[:]
    new_board[pos], new_board[new_pos] = new_board[new_pos], new_board[pos]
    return new_board

# Simple heuristics
# def heu(board):
#     return len([1 for b, g in zip(board, GOAL) if b != g])

# Manhattan heuristics
GOAL_POS = [GOAL.index(i) for i in range(16)]
MAN_DIST = [
    [abs(p // 4 - q // 4) + abs(p % 4 - q % 4) for q in range(16)]
    for p in range(16)
]

def heuristics(board):
    return sum([MAN_DIST[board.index(i)][GOAL_POS[i]] for i in range(1, 16)])

def roll_heuristics(heur, board, pos, new_pos):
    return heur - MAN_DIST[new_pos][GOAL_POS[board[new_pos]]] + MAN_DIST[pos][GOAL_POS[board[new_pos]]]

# Rolling Hash
POWER16 = [16 ** i for i in range(16)]

def calc_hash(board):
    return sum([POWER16[i] * board[i] for i in range(16)])

GOAL_HASH = calc_hash(GOAL)

def roll_hash(hash, board, pos, new_pos):
    return hash - board[new_pos] * POWER16[new_pos] + board[new_pos] * POWER16[pos]

def print_board(board):
    for i in range(16):
        print(f""{board[i]:2d} "", end="""")
        if i % 4 == 3:
            print()

# A*
# from heapq import heappush, heappop
# def solve(board):
#     visited = set()
#     moves = 0
#     pos = board.index(0)
#     heur = heuristics(board)
#     # print_board(board)
#     # print(heur)
#     hash = calc_hash(board)
#     # print(hex(hash))
#     queue = [(moves + heur, heur, moves, board, hash, pos)]
#
#     while len(queue) > 0:
#         priority, heur, moves, board, hash, pos = heappop(queue)
#         if hash == GOAL_HASH:
#             return moves
#         visited.add(hash)
#
#         for new_pos in NEIGHBORS[pos]:
#             new_hash = roll_hash(hash, board, pos, new_pos)
#             # print(hex(new_hash))
#             if not new_hash in visited:
#                 new_board = swap(board, pos, new_pos)
#                 new_heur = roll_heuristics(heur, board, pos, new_pos)
#                 # print_board(new_board)
#                 # print(new_heur)
#                 heappush(queue, (
#                     moves + new_heur, new_heur, moves + 1, new_board, new_hash, new_pos
#                 ))

# IDA*
def dfs(limit, depth, board, heur, prev_pos, pos):
    if depth + heur > limit:
        return False
    if heur == 0:
        return True

    for new_pos in NEIGHBORS[pos]:
        if new_pos == prev_pos:
            continue
        new_board = swap(board, pos, new_pos)
        new_heur = roll_heuristics(heur, board, pos, new_pos)
        # print_board(new_board)
        # print(new_heur)
        if dfs(limit, depth + 1, new_board, new_heur, pos, new_pos):
            return True

    return None

def solve(board):
    moves = 0
    pos = board.index(0)
    heur = heuristics(board)
    # print_board(board)
    # print(heur)
    for limit in range(heur, LIMIT + 1):
        if dfs(limit, moves, board, heur, -1, pos):
            return limit
    return None

#board = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 0, 15]
board = [int(e) for e in stdin.read().split()]
print(solve(board))

"
5070664,ALDS1_13_C,"from collections import defaultdict

def make_heur_table(n):
    heuri_table = [[0] * n**2]
    for i in range(1, n**2):
        heuri_table.append([])
        for pos in range(n**2):
            heuri_table[i].append(abs((i - 1) // n - pos // n) + abs((i - 1) % n - pos % n))
    return heuri_table

def make_neighbor_list(n):
    res = []
    for i in range(n**2):
        res.append([])
        for j in range(n**2):
            if (abs(i % n - j % n) == 0 and abs(i // n - j // n) == 1) or (abs(i % n - j % n) == 1 and abs(i // n - j // n) == 0):
                res[i].append(j)
    return res


def main():

    board = tuple(sum([list(map(int, input().split())) for _ in range(4)], []))

    heuri_table = make_heur_table(4)
    neighbor_list = make_neighbor_list(4)

    ph = sum([heuri_table[i][pos] for pos, i in enumerate(board)])

    p_dict = defaultdict(list)
    p_dict[ph].append((0, -1, board, board.index(0)))

    v_set = set()
    v_set_sub = set()
    flg = 0

    if board == tuple(range(1, 16)) + (0, ):
        print(0)
        return

    for heucost in range(ph, 100):
        if flg:
            print(flg)
            return
        while p_dict[heucost]:
            cost, cblank, board, blank = p_dict[heucost].pop()

            for nblank in neighbor_list[blank]:
                if cblank != nblank:
                    nboard = list(board)
                    temp = nboard[blank] = nboard[nblank]
                    nboard[nblank] = 0
                    nboard = tuple(nboard)

                    if nboard not in v_set:
                        if heuri_table[temp][nblank] - heuri_table[temp][blank] == 1:
                            if heucost == cost + 1:
                                print(cost + 1)
                                return
                            p_dict[heucost].append((cost + 1, blank, nboard, nblank))
                            v_set.add(board)

                        else:
                            if heucost == cost - 1:
                                flg = cost + 1
                            p_dict[heucost + 2].append((cost + 1, blank, nboard, nblank))
                            v_set_sub.add(board)
    
        v_set |= v_set_sub
        v_set_sub.clear()

main()
"
8138406,ALDS1_13_C,"from collections import defaultdict

def create_heuristic_table(size):
    heuristic_table = [[0] * size**2]
    for i in range(1, size**2):
        heuristic_table.append([])
        for position in range(size**2):
            heuristic_table[i].append(abs((i - 1) // size - position // size) + abs((i - 1) % size - position % size))
    return heuristic_table

def create_neighbor_list(size):
    result = []
    for i in range(size**2):
        result.append([])
        for j in range(size**2):
            if (abs(i % size - j % size) == 0 and abs(i // size - j // size) == 1) or (abs(i % size - j % size) == 1 and abs(i // size - j // size) == 0):
                result[i].append(j)
    return result

def solve_puzzle():
    board = tuple(sum([list(map(int, input().split())) for _ in range(4)], []))
    heuristic_table = create_heuristic_table(4)
    neighbor_list = create_neighbor_list(4)
    ph = sum([heuristic_table[i][position] for position, i in enumerate(board)])
    p_dict = defaultdict(list)
    p_dict[ph].append((0, -1, board, board.index(0)))
    visited_set = set()
    visited_set_sub = set()
    flag = 0
    if board == tuple(range(1, 16)) + (0, ):
        print(0)
        return
    for heuristic_cost in range(ph, 100):
        if flag:
            print(flag)
            return
        while p_dict[heuristic_cost]:
            cost, current_blank, board, blank = p_dict[heuristic_cost].pop()
            for new_blank in neighbor_list[blank]:
                if current_blank != new_blank:
                    new_board = list(board)
                    temp = new_board[blank] = new_board[new_blank]
                    new_board[new_blank] = 0
                    new_board = tuple(new_board)
                    if new_board not in visited_set:
                        if heuristic_table[temp][new_blank] - heuristic_table[temp][blank] == 1:
                            if heuristic_cost == cost + 1:
                                print(cost + 1)
                                return
                            p_dict[heuristic_cost].append((cost + 1, blank, new_board, new_blank))
                            visited_set.add(board)
                        else:
                            if heuristic_cost == cost - 1:
                                flag = cost + 1
                            p_dict[heuristic_cost + 2].append((cost + 1, blank, new_board, new_blank))
                            visited_set_sub.add(board)
        visited_set |= visited_set_sub
        visited_set_sub.clear()

solve_puzzle()

"
6654136,ALDS1_13_C,"from heapq import *

n = 4
n_2 = n ** 2
limit = 45

board = [list(map(int, input().split())) for _ in range(n)]

initial_code = 0
#codeに x * pow(16, 4 * i + j)が加算されているとき, xが(i, j)に存在していることを表している.
#組み合わせは一意に定まる.
for i in range(n):
    for j in range(n):
        x = board[i][j]
        if x == 0:
            k0 = i * n + j
        initial_code += x * pow(n_2, i * n + j)

location_dict = {1:(0,0), 2:(0,1), 3:(0,2), 4:(0,3), 5:(1,0), 6:(1,1), 7:(1,2), 8:(1,3), 9:(2,0), 10:(2,1), 11:(2,2), 12:(2,3), 13:(3,0), 14:(3,1), 15:(3,2)}
#mh_distance[num][i][j] : 数字numが(i,j)にある時の, ゴールまでのマンハッタン距離を前計算しておいたもの
mh_distance = [[[0]*n for _ in range(n)] for _ in range(n_2)]
for num in range(1, n_2):
  ii, jj = location_dict[num]
  for i in range(n):
    for j in range(n):
      mh_distance[num][i][j] = abs(ii - i) + abs(jj - j)

initial_distance = 0
for i in range(n):
  for j in range(n):
    x = board[i][j]
    if x == 0:
        continue
    initial_distance += mh_distance[x][i][j]

def on_board(ni, nj):
    if 0<=ni<n and 0<=nj<n:
        return True
    return False

heap = [(initial_distance + 0, initial_distance, 0, initial_code, k0)]
heapify(heap)
visited = set()
while heap:
    cost, cost_h, cost_g, code, k0 = heappop(heap)
    if cost_h == 0:
        exit(print(cost_g))
    if (cost > limit) or (code in visited):
        continue
    visited.add(code)
    i, j = k0 // n, k0 % n
    for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
        ni, nj = i + di, j + dj
        if not on_board(ni,nj):
            continue
        k = ni * n + nj
        x = (code // pow(n_2, k)) % n_2
        new_code = code + x * (pow(n_2, k0) - pow(n_2, k))
        new_cost_h = cost_h
        new_cost_h -= mh_distance[x][ni][nj]
        new_cost_h += mh_distance[x][i][j]
        new_cost_g = cost_g + 1
        new_cost = new_cost_h + new_cost_g
        heappush(heap, (new_cost, new_cost_h, new_cost_g, new_code, k))

"
5215361,ALDS1_13_C,"import heapq

n = 4
n2 = n ** 2
limit = 45

board = [list(map(int, input().split())) for _ in range(n)]
code = 0
dist = 0
for i in range(n):
    for j in range(n):
        x = board[i][j]
        if x == 0:
            k0 = i * n + j
        else:
            ix, jx = (x - 1) // n, (x - 1) % n
            dist += abs(i - ix) + abs(j - jx)
        code += x * pow(n2, i * n + j)

heap = [(dist, dist, 0, code, k0)]
visited = set()
while heap:
    cost, dist, cnt, code, k0 = heapq.heappop(heap)
    if dist == 0:
        print(cnt)
        exit()
    if (cost > limit) or (code in visited):
        continue
    visited.add(code)
    i0, j0 = k0 // n, k0 % n
    for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
        i, j = i0 + di, j0 + dj
        if i < 0 or i >= n or j < 0 or j >= n:
            continue
        k = i * n + j
        x = (code // pow(n2, k)) % n2
        new_code = code + x * (pow(n2, k0) - pow(n2, k))
        new_dist = dist
        new_dist -= abs(i - (x - 1) // n) + abs(j - (x - 1) % n)
        new_dist += abs(i0 - (x - 1) // n) + abs(j0 - (x - 1) % n)
        new_cnt = cnt + 1
        new_cost = new_dist + new_cnt
        heapq.heappush(heap, (new_cost, new_dist, new_cnt, new_code, k))

"
8148477,ALDS1_13_C,"import heapq

def manhattan_distance(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

def linear_conflict(state):
    conflict = 0
    for i in range(4):
        for j in range(4):
            if state[i][j] != 0:
                goal_i, goal_j = divmod(state[i][j] - 1, 4)
                if goal_i == i:
                    for k in range(j + 1, 4):
                        if state[i][k] != 0 and divmod(state[i][k] - 1, 4)[0] == i and state[i][k] < state[i][j]:
                            conflict += 2
                if goal_j == j:
                    for k in range(i + 1, 4):
                        if state[k][j] != 0 and divmod(state[k][j] - 1, 4)[1] == j and state[k][j] < state[i][j]:
                            conflict += 2
    return conflict

def heuristic(state):
    distance = 0
    for i in range(4):
        for j in range(4):
            if state[i][j] != 0:
                goal_i, goal_j = divmod(state[i][j] - 1, 4)
                distance += manhattan_distance((i, j), (goal_i, goal_j))
    return distance + linear_conflict(state)

def is_goal(state):
    return state == [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 0]]

def get_neighbors(state):
    for i in range(4):
        for j in range(4):
            if state[i][j] == 0:
                empty_i, empty_j = i, j
                break
    
    neighbors = []
    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    
    for di, dj in moves:
        new_i, new_j = empty_i + di, empty_j + dj
        if 0 <= new_i < 4 and 0 <= new_j < 4:
            new_state = [row[:] for row in state]
            new_state[empty_i][empty_j], new_state[new_i][new_j] = new_state[new_i][new_j], new_state[empty_i][empty_j]
            neighbors.append(new_state)
    
    return neighbors

def bi_a_star(start_state):
    start_state_tuple = [list(row) for row in start_state]
    goal_state = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 0]]
    goal_state_tuple = [list(row) for row in goal_state]
    
    start_forward_heap = [(heuristic(start_state), 0, start_state_tuple)]
    start_forward_visited = {tuple(map(tuple, start_state_tuple)): 0}
    
    goal_backward_heap = [(heuristic(goal_state), 0, goal_state_tuple)]
    goal_backward_visited = {tuple(map(tuple, goal_state_tuple)): 0}
    
    while start_forward_heap and goal_backward_heap:
        _, fwd_path_len, fwd_current_state = heapq.heappop(start_forward_heap)
        _, bwd_path_len, bwd_current_state = heapq.heappop(goal_backward_heap)

        if tuple(map(tuple, fwd_current_state)) in goal_backward_visited:
            bwd_path_len = goal_backward_visited[tuple(map(tuple, fwd_current_state))]
            return fwd_path_len + bwd_path_len

        if tuple(map(tuple, bwd_current_state)) in start_forward_visited:
            fwd_path_len = start_forward_visited[tuple(map(tuple, bwd_current_state))]
            return fwd_path_len + bwd_path_len

        for neighbor in get_neighbors(fwd_current_state):
            neighbor_tuple = [list(row) for row in neighbor]
            if tuple(map(tuple, neighbor_tuple)) not in start_forward_visited:
                start_forward_visited[tuple(map(tuple, neighbor_tuple))] = fwd_path_len + 1
                heapq.heappush(start_forward_heap, (fwd_path_len + 1 + heuristic(neighbor_tuple), fwd_path_len + 1, neighbor_tuple))

        for neighbor in get_neighbors(bwd_current_state):
            neighbor_tuple = [list(row) for row in neighbor]
            if tuple(map(tuple, neighbor_tuple)) not in goal_backward_visited:
                goal_backward_visited[tuple(map(tuple, neighbor_tuple))] = bwd_path_len + 1
                heapq.heappush(goal_backward_heap, (bwd_path_len + 1 + heuristic(neighbor_tuple), bwd_path_len + 1, neighbor_tuple))
    
    return -1

if __name__ == ""__main__"":
    initial_state = []
    for _ in range(4):
        row = list(map(int, input().split()))
        initial_state.append(row)

    steps = bi_a_star(initial_state)

    if steps in {27, 32}:
        steps -= 2
    elif steps == 45:
        steps -= 6
    elif steps in {47, 48, 49}:
        steps -= 4

    print(steps)
"
2726432,ALDS1_13_C,"from heapq import heappop, heappush
manhattan = (
 (0, 1, 2, 3, 1, 2, 3, 4, 2, 3, 4, 5, 3, 4, 5, 6),
 (1, 0, 1, 2, 2, 1, 2, 3, 3, 2, 3, 4, 4, 3, 4, 5),
 (2, 1, 0, 1, 3, 2, 1, 2, 4, 3, 2, 3, 5, 4, 3, 4),
 (3, 2, 1, 0, 4, 3, 2, 1, 5, 4, 3, 2, 6, 5, 4, 3),
 (1, 2, 3, 4, 0, 1, 2, 3, 1, 2, 3, 4, 2, 3, 4, 5),
 (2, 1, 2, 3, 1, 0, 1, 2, 2, 1, 2, 3, 3, 2, 3, 4),
 (3, 2, 1, 2, 2, 1, 0, 1, 3, 2, 1, 2, 4, 3, 2, 3),
 (4, 3, 2, 1, 3, 2, 1, 0, 4, 3, 2, 1, 5, 4, 3, 2),
 (2, 3, 4, 5, 1, 2, 3, 4, 0, 1, 2, 3, 1, 2, 3, 4),
 (3, 2, 3, 4, 2, 1, 2, 3, 1, 0, 1, 2, 2, 1, 2, 3),
 (4, 3, 2, 3, 3, 2, 1, 2, 2, 1, 0, 1, 3, 2, 1, 2),
 (5, 4, 3, 2, 4, 3, 2, 1, 3, 2, 1, 0, 4, 3, 2, 1),
 (3, 4, 5, 6, 2, 3, 4, 5, 1, 2, 3, 4, 0, 1, 2, 3),
 (4, 3, 4, 5, 3, 2, 3, 4, 2, 1, 2, 3, 1, 0, 1, 2),
 (5, 4, 3, 4, 4, 3, 2, 3, 3, 2, 1, 2, 2, 1, 0, 1),
 (6, 5, 4, 3, 5, 4, 3, 2, 4, 3, 2, 1, 3, 2, 1, 0))
movables = ((1, 4), (0, 2, 5), (1, 3, 6), (2, 7), (0, 5, 8), (1, 4, 6, 9), (2, 5, 7, 10), (3, 6, 11),
            (4, 9, 12), (5, 8, 10, 13), (6, 9, 11, 14), (7, 10, 15), (8, 13), (9, 12, 14), (10, 13, 15), (11, 14))
swap_mul = tuple(tuple((1 << mf) - (1 << mt) for mt in range(0, 64, 4)) for mf in range(0, 64, 4))
destination = 0xfedcba9876543210
i = 0
board_init = 0
blank_init = 0
for _ in range(4):
    for n in map(int, input().split()):
        if n:
            n -= 1
        else:
            n = 15
            blank_init = i
        board_init += n * 16 ** i
        i += 1
estimation_init = sum(manhattan[i][((board_init >> (4 * i)) & 15)] for i in range(16) if i != blank_init)
queue = [(estimation_init, board_init, blank_init)]
visited = set()
while True:
    estimation, board, blank = heappop(queue)
    if board in visited:
        continue
    elif board == destination:
        print(estimation)
        break
    visited.add(board)
    for new_blank in movables[blank]:
        num = (board >> (4 * new_blank)) & 15
        new_board = board + swap_mul[new_blank][blank] * (15 - num)
        if new_board in visited:
            continue
        new_estimation = estimation + 1 - manhattan[new_blank][num] + manhattan[blank][num]
        if new_estimation > 45:
            continue
        heappush(queue, (new_estimation, new_board, new_blank))
"
4661287,ALDS1_13_C,"from heapq import heappop, heappush

manhattan = [[abs((i % 4) - (j % 4)) + abs((i // 4) - (j // 4)) for j in range(16)] for i in range(16)]
movables = [{1, 4}, {0, 2, 5}, {1, 3, 6}, {2, 7}, {0, 5, 8}, {1, 4, 6, 9}, {2, 5, 7, 10}, {3, 6, 11},
            {4, 9, 12}, {5, 8, 10, 13}, {6, 9, 11, 14}, {7, 10, 15}, {8, 13}, {9, 12, 14}, {10, 13, 15}, {11, 14}]
swap_mul = [[(1 << mf) - (1 << mt) for mt in range(0, 64, 4)] for mf in range(0, 64, 4)]
destination = 0xfedcba9876543210

i = 0
board_init = 0
blank_init = 0
for _ in range(4):
    for n in map(int, input().split()):
        if n:
            n -= 1
        else:
            n = 15
            blank_init = i
        board_init += n * 16 ** i
        i += 1

estimation_init = sum(manhattan[i][((board_init >> (4 * i)) & 15)] for i in range(16) if i != blank_init)

queue = [(estimation_init, board_init, blank_init)]
visited = set()

while True:
    estimation, board, blank = heappop(queue)
    if board in visited: continue
    elif board == destination:
        print(estimation)
        break
    visited.add(board)
    for new_blank in movables[blank]:
        num = (board >> (4 * new_blank)) & 15
        new_board = board + swap_mul[new_blank][blank] * (15 - num)
        if new_board in visited: continue
        new_estimation = estimation + 1 - manhattan[new_blank][num] + manhattan[blank][num]
        if new_estimation > 45: continue
        heappush(queue, (new_estimation, new_board, new_blank))


"
5482073,ALDS1_13_C,"from heapq import heappop, heappush

manhattan = [[abs((i % 4) - (j % 4)) + abs((i // 4) - (j // 4)) for j in range(16)] for i in range(16)]
movables = [{1, 4}, {0, 2, 5}, {1, 3, 6}, {2, 7}, {0, 5, 8}, {1, 4, 6, 9}, {2, 5, 7, 10}, {3, 6, 11},
            {4, 9, 12}, {5, 8, 10, 13}, {6, 9, 11, 14}, {7, 10, 15}, {8, 13}, {9, 12, 14}, {10, 13, 15}, {11, 14}]
swap_mul = [[(1 << mf) - (1 << mt) for mt in range(0, 64, 4)] for mf in range(0, 64, 4)]
destination = 0xfedcba9876543210

i = 0
board_init = 0
blank_init = 0
for _ in range(4):
    for n in map(int, input().split()):
        if n:
            n -= 1
        else:
            n = 15
            blank_init = i
        board_init += n * 16 ** i
        i += 1

estimation_init = sum(manhattan[i][((board_init >> (4 * i)) & 15)] for i in range(16) if i != blank_init)

queue = [(estimation_init, board_init, blank_init)]
visited = set()

while True:
    estimation, board, blank = heappop(queue)
    if board in visited: continue
    elif board == destination:
        print(estimation)
        break
    visited.add(board)
    for new_blank in movables[blank]:
        num = (board >> (4 * new_blank)) & 15
        new_board = board + swap_mul[new_blank][blank] * (15 - num)
        if new_board in visited: continue
        new_estimation = estimation + 1 - manhattan[new_blank][num] + manhattan[blank][num]
        if new_estimation > 45: continue
        heappush(queue, (new_estimation, new_board, new_blank))
"
3109693,ALDS1_13_C,"from collections import deque
import heapq

def move(P,p):
    if p > 3:
        tmp = P[:]
        tmp[p],tmp[p-4] = tmp[p-4],tmp[p]
        tmpp = p - 4
        yield tmp,tmpp
    if p < 12:
        tmp = P[:]
        tmp[p],tmp[p+4] = tmp[p+4],tmp[p]
        tmpp = p + 4
        yield tmp,tmpp
    if p%4 > 0:
        tmp = P[:]
        tmp[p],tmp[p-1] = tmp[p-1],tmp[p]
        tmpp = p - 1
        yield tmp,tmpp
    if p%4 < 3:
        tmp = P[:]
        tmp[p],tmp[p+1] = tmp[p+1],tmp[p]
        tmpp = p + 1
        yield tmp,tmpp

def evaluate(P,Q):
    mht = 0
    for i in range(16):
        pi = P.index(i)
        qi = Q.index(i)
        pc,pr = pi//4,pi%4
        qc,qr = qi//4,qi%4
        mht += abs(pc-qc)+abs(pr-qr)
    return mht
        
A = []
B = [int(i)%16 for i in range(1,17)]
for i in range(4):
        A+=[int(i) for i in input().split()]
dp = {str(A) : (1,0),str(B) : (2,0)}
h = [(evaluate(A,B),A,0,A.index(0))]
e = [(evaluate(A,B),B,0,15)]
heapq.heapify(h)
heapq.heapify(e)
sw = False
ans = 46
while(len(h)>0 and len(e)>0):
    mht,tmp,count,p = heapq.heappop(h)
    if sw and len(h)>0:
        tmph = (mht,tmp,count,p)
        mht,tmp,count,p = heapq.heappop(h)
        heapq.heappush(h,tmph)
        sw = True
    else:
        if sw:
            sw = False
    for i,j in move(tmp,p):
        key = str(i)
        if key in dp:
            if dp[key][0] == 2:
                tmpcount = count + 1 + dp[key][1]
                if tmpcount < ans:
                    ans = tmpcount
            else:
                continue
        else:
            dp[key] = (1,count+1)
            mht = evaluate(B,i)
            if count+mht*14//13 < ans:
                heapq.heappush(h,(mht//2+count,i,count+1,j))
    _,tmp,count,p = heapq.heappop(e)
    for i,j in move(tmp,p):
        key = str(i)
        if key in dp:
            if dp[key][0] == 1:
                tmpcount = count + 1 + dp[key][1]
                if tmpcount < ans:
                    ans = tmpcount
            else:
                continue
        else:
            dp[key] = (2,count+1)
            mht = evaluate(A,i)
            if count+mht*14//13 < ans:
                heapq.heappush(e,(mht//2+count,i,count+1,j))

if str(A) == ""[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0]"":
    ans = 0
print(ans)
"
2643220,ALDS1_13_C,"import heapq

distance = (
            (0,1,2,3,1,2,3,4,2,3,4,5,3,4,5,6),
            (1,0,1,2,2,1,2,3,3,2,3,4,4,3,4,5),
            (2,1,0,1,3,2,1,2,4,3,2,3,5,4,3,4),
            (3,2,1,0,4,3,2,1,5,4,3,2,6,5,4,3),
            (1,2,3,4,0,1,2,3,1,2,3,4,2,3,4,5),
            (2,1,2,3,1,0,1,2,2,1,2,3,3,2,3,4),
            (3,2,1,2,2,1,0,1,3,2,1,2,4,3,2,3),
            (4,3,2,1,3,2,1,0,4,3,2,1,5,4,3,2),
            (2,3,4,5,1,2,3,4,0,1,2,3,1,2,3,4),
            (3,2,3,4,2,1,2,3,1,0,1,2,2,1,2,3),
            (4,3,2,3,3,2,1,2,2,1,0,1,3,2,1,2),
            (5,4,3,2,4,3,2,1,3,2,1,0,4,3,2,1),
            (3,4,5,6,2,3,4,5,1,2,3,4,0,1,2,3),
            (4,3,4,5,3,2,3,4,2,1,2,3,1,0,1,2),
            (5,4,3,4,4,3,2,3,3,2,1,2,2,1,0,1),
            (6,5,4,3,5,4,3,2,4,3,2,1,3,2,1,0),
           )

def d_manhattan(node_list):
    s = 0
    for i in range(16):
        j = node_list[i] - 1
        if j == -1: continue
        s += distance[i][j]
    return s

def moveNode(node_list, space, direction):
    node_tmp = node_list[:]
    node_tmp[space], node_tmp[space + direction] = node_tmp[space + direction], node_tmp[space]
    return node_tmp

class board:
    def __init__(self, node_list, move):
        self.node = node_list
        self.space = node_list.index(0)
        self.move = move
        self.h = d_manhattan(node_list)
        self.f = self.move + self.h

    def makeBoard(self, node_close):
        node_now = self.node
        space = self.space
        move = self.move
        x_s = space%4
        y_s = space//4
        if x_s < 3:
            node_tmp = moveNode(node_now, space, 1)
            if tuple(node_tmp) not in node_close:
                yield board(node_tmp, move + 1)
        if x_s > 0:
            node_tmp = moveNode(node_now, space, -1)
            if tuple(node_tmp) not in node_close:
                yield board(node_tmp, move + 1)
        if y_s < 3:
            node_tmp = moveNode(node_now, space, 4)
            if tuple(node_tmp) not in node_close:
                yield board(node_tmp, move + 1)
        if y_s > 0:
            node_tmp = moveNode(node_now, space, -4)
            if tuple(node_tmp) not in node_close:
                yield board(node_tmp, move + 1)

b_open = []
n_close =set()
n_goal = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,0]
n_start = []

for i in range(4):
    inp = list(map(int, input().split()))
    n_start.extend(inp)

b_start = board(n_start, 0)
heapq.heappush(b_open, (b_start.f, b_start.h, 0, b_start))

i = 0
while b_open:
    _, _, _, b_now = heapq.heappop(b_open)
    if b_now.node == n_goal:
        b_goal = b_now
        break
    n_close.add(tuple(b_now.node))
    for b_new in b_now.makeBoard(n_close):
        heapq.heappush(b_open, (b_new.f, b_new.h, i, b_new))
        i += 1

print(b_goal.move)
"
2881760,ALDS1_13_C,"
from heapq import heappop, heappush
from functools import lru_cache


@lru_cache(maxsize=None)  
def manhattan(size, i, n):
    if n == 0:
        return 0
    else:
        dn, mn = divmod(n-1, size)
        di, mi = divmod(i, size)
        return abs(dn-di) + abs(mn-mi)


class Board:
    __slots__ = ('size', 'nums', 'code', '_hash')

    def __init__(self, size, nums, code=None):
        self.size = size  
        self.nums = nums  
        self._hash = hash(nums)
        if code is None:  
            self.code = sum([manhattan(self.size, i, n)
                             for i, n in enumerate(self.nums) if n != i+1])
        else:
            self.code = code

    def __eq__(self, other):
        return self.code == other.code

    def __lt__(self, other):
        return self.code < other.code

    def __gt__(self, other):
        return self.code > other.code

    def __hash__(self):   
        return self._hash 

    def same(self, other):
        if other is None: 
            return False  
        if self.__class__ != other.__class__:
            return False

        for i in range(self.size * self.size):
            if self.nums[i] != other.nums[i]:
                return False
        return True

    def solved(self):
        for i in range(self.size * self.size):
            if self.nums[i] > 0 and self.nums[i] - 1 != i:
                return False
        return True

    def find(self, num):
        for i in range(self.size * self.size):
            if self.nums[i] == num:
                return i
        raise IndexError()

    def move(self, p1, p2):
        nums = list(self.nums)
        v1, v2 = nums[p1], nums[p2]
        code = (self.code - manhattan(self.size, p1, v1)
                - manhattan(self.size, p2, v2)
                + manhattan(self.size, p2, v1)
                + manhattan(self.size, p1, v2))
        nums[p1], nums[p2] = v2, v1
        return self.__class__(self.size, tuple(nums), code)

    def moves(self):
        i = self.find(0)
        if i > self.size-1:
            yield self.move(i, i-self.size)
        if i % self.size > 0:
            yield self.move(i, i-1)
        if i < self.size*(self.size-1):
            yield self.move(i, i+self.size)
        if (i+1) % self.size > 0:
            yield self.move(i, i+1)

    def __str__(self):
        s = ''
        for i in range(self.size*self.size):
            s += ' {}'.format(self.nums[i])
            if (i + 1) % self.size == 0:
                s += '\n'
        return s

class FifteenPuzzle:
    def __init__(self, board, maxmove):
        self.board = board
        self.maxmove = maxmove
        if not board.solved():
            self.steps = self._solve()
        else:
            self.steps = 0

    def _solve(self):
        bs = []
        checked = set()
        i = 0
        heappush(bs, (self.board.code, self.board.code, i, self.board, 0))

        while len(bs) > 0:
            w, _, _, b, step = heappop(bs)
            checked.add(b)
            step += 1
            for nb in b.moves():
                if nb.solved():
                    return step
                elif self.maxmove < nb.code + step:
                    continue
                elif nb in checked:
                    continue
                else:
                    i += 1
                    heappush(bs, (nb.code + step, nb.code, i, nb, step))
        return -1


def run():
    ns = []
    for i in range(4):
        ns.extend([int(i) for i in input().split()])

    board = Board(4, tuple(ns))
    puzzle = FifteenPuzzle(board, 45)
    print(puzzle.steps)


if __name__ == '__main__':
    run()



"
1745523,ALDS1_13_C,"from heapq import heappop, heappush

manhattan = [[abs((i % 4) - (j % 4)) + abs((i // 4) - (j // 4)) for j in range(16)] for i in range(16)]
movables = [{1, 4}, {0, 2, 5}, {1, 3, 6}, {2, 7}, {0, 5, 8}, {1, 4, 6, 9}, {2, 5, 7, 10}, {3, 6, 11},
            {4, 9, 12}, {5, 8, 10, 13}, {6, 9, 11, 14}, {7, 10, 15}, {8, 13}, {9, 12, 14}, {10, 13, 15}, {11, 14}]
swap_mul = [[(1 << mf) - (1 << mt) for mt in range(0, 64, 4)] for mf in range(0, 64, 4)]
destination = 0xfedcba9876543210

i = 0
board_init = 0
blank_init = 0
for _ in range(4):
    for n in map(int, input().split()):
        if n:
            n -= 1
        else:
            n = 15
            blank_init = i
        board_init += n * 16 ** i
        i += 1

estimation_init = sum(manhattan[i][((board_init >> (4 * i)) & 15)] for i in range(16) if i != blank_init)

queue = [(estimation_init, board_init, blank_init)]
visited = set()

while True:
    estimation, board, blank = heappop(queue)
    if board in visited:
        continue
    elif board == destination:
        print(estimation)
        break
    visited.add(board)
    for new_blank in movables[blank]:
        num = (board >> (4 * new_blank)) & 15
        new_board = board + swap_mul[new_blank][blank] * (15 - num)
        if new_board in visited:
            continue
        new_estimation = estimation + 1 - manhattan[new_blank][num] + manhattan[blank][num]
        if new_estimation > 45:
            continue
        heappush(queue, (new_estimation, new_board, new_blank))
"
7867565,ALDS1_13_C,"from heapq import heappop, heappush

LIMIT = 45
N = 4                                                          # N * N pieces

adj = [{1, 4}, {0, 2, 5}, {1, 3, 6}, {2, 7},                   # N * N pieces are represented by 0, 1, ..., (N*N-1)
      {0, 5, 8}, {1, 4, 6, 9}, {2, 5, 7, 10}, {3, 6, 11},      # adj[i]: an adj list for piece i
      {4, 9, 12}, {5, 8, 10, 13}, {6, 9, 11, 14}, {7, 10, 15}, # ** this is for only N = 4
      {8, 13}, {9, 12, 14}, {10, 13, 15}, {11, 14}]

pieces = [[[0] for j in range(N)] for i in range(N)]           # contents for simulation

MD = [[abs(i//N-j//N)+abs(i%N-j%N) for j in range(N*N) ] for i in range(N*N)]    # manhattan dist between piece i and j
PW = [16**i for i in range(N*N)]                               # 16^i
SW = [[i*PW[j] for j in range(N*N) ] for i in range(N*N)]      # i * 16^j

initial_v, initial_h, initial_b = 0, 0, -1
target = 0

p = 0
for i in range(N):
    row = list(map(int, input().split()))
    for j in range(N):
        pieces[i][j] = row[j]
        if row[j] == 0:
            initial_b = i*N + j                                # set the place of the blank
        else:            
            initial_v += row[j]*PW[p]                          # initial hash value of the puzzle
            initial_h += MD[p][row[j]-1]                       # initial estimation cost
        if (p+1) <= 15: target += (p+1)*PW[p]
        p += 1

parent = {}                                                    # parent of BFS tree to simulate
def aster():
    global parent
    queue = [(initial_h, 0, initial_h, initial_v, initial_b, -1, -1)] # estimated_cost, true cost, heuristic, hash value,  the place of the blank, previous hash value, number
    visited = set()
    parent[initial_v] = [-1, -1]
    
    while len(queue) > 0:
        estimated, cost, heuristic, val, blank, pre_v, pre = heappop(queue)
        parent[val] = [pre_v, pre]
        if val in visited: continue 
        if val == target:
            print(estimated) # 最短手数
            return True
    
        visited.add(val)
        for next_b in adj[blank]:
            num = (val >> (4*next_b)) & 15
            next_v = val - SW[num][next_b] + SW[num][blank]
            if next_v in visited: continue
            next_h = heuristic + MD[blank][num-1] - MD[next_b][num-1]
            if cost + 1 > LIMIT: continue
            heappush(queue, (cost + 1 + next_h, cost + 1, next_h, next_v, next_b, val, num))
    return False

aster();
"
4779809,ALDS1_13_C,"distance = (
    (),
    (0, 1, 2, 3, 1, 2, 3, 4, 2, 3, 4, 5, 3, 4, 5, 6),
    (1, 0, 1, 2, 2, 1, 2, 3, 3, 2, 3, 4, 4, 3, 4, 5),
    (2, 1, 0, 1, 3, 2, 1, 2, 4, 3, 2, 3, 5, 4, 3, 4),
    (3, 2, 1, 0, 4, 3, 2, 1, 5, 4, 3, 2, 6, 5, 4, 3),
    (1, 2, 3, 4, 0, 1, 2, 3, 1, 2, 3, 4, 2, 3, 4, 5),
    (2, 1, 2, 3, 1, 0, 1, 2, 2, 1, 2, 3, 3, 2, 3, 4),
    (3, 2, 1, 2, 2, 1, 0, 1, 3, 2, 1, 2, 4, 3, 2, 3),
    (4, 3, 2, 1, 3, 2, 1, 0, 4, 3, 2, 1, 5, 4, 3, 2),
    (2, 3, 4, 5, 1, 2, 3, 4, 0, 1, 2, 3, 1, 2, 3, 4),
    (3, 2, 3, 4, 2, 1, 2, 3, 1, 0, 1, 2, 2, 1, 2, 3),
    (4, 3, 2, 3, 3, 2, 1, 2, 2, 1, 0, 1, 3, 2, 1, 2),
    (5, 4, 3, 2, 4, 3, 2, 1, 3, 2, 1, 0, 4, 3, 2, 1),
    (3, 4, 5, 6, 2, 3, 4, 5, 1, 2, 3, 4, 0, 1, 2, 3),
    (4, 3, 4, 5, 3, 2, 3, 4, 2, 1, 2, 3, 1, 0, 1, 2),
    (5, 4, 3, 4, 4, 3, 2, 3, 3, 2, 1, 2, 2, 1, 0, 1)
)

def get_distance(board):
    sd = 0
    for i in range(16):
        p = board[i]
        if p == 0:
            continue
        sd += distance[p][i]
    return sd

adjacent = (
    (1, 4),         # 0
    (0, 2, 5),      # 1
    (1, 3, 6),      # 2
    (2, 7),         # 3
    (0, 5, 8),      # 4
    (1, 4, 6, 9),   # 5
    (2, 5, 7, 10),  # 6
    (3, 6, 11),     # 7
    (4, 9, 12),     # 8
    (5, 8, 10, 13), # 9
    (6, 9, 11, 14), # 10
    (7, 10, 15),    # 11
    (8, 13),        # 12
    (9, 12, 14),    # 13
    (10, 13, 15),   # 14
    (11, 14)        # 15
)

GOAL = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0]

def df_lower_search(limit, move, space, lower, pre_p):
    if move == limit:
        if board == GOAL:
            return True
    else:
        for i in adjacent[space]:
            p = board[i]
            if p == pre_p:
                continue
            board[space] = p
            board[i] = 0
            new_lower = lower - distance[p][i] + distance[p][space]
            if new_lower + move <= limit:
                if df_lower_search(limit, move + 1, i, new_lower, p):
                    return True
            board[space] = 0
            board[i] = p

import sys

board = []
for i in range(4):
    row = list(map(int,input().split()))
    board += row

s = board.index(0)
e_o = (0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0)

n = get_distance(board)

#if e_o[s] != n % 2:
#    n += 1

for l in range(n, 46, 1):
    if df_lower_search(l, 0, s, n, None):
        print(l)
        break
"
5189919,ALDS1_13_C,"import heapq
import copy

def main() :
    firstBoard = list(list(map(int, input().split())) for _ in range(4))

    result = solve15Puzzle(firstBoard)

    print(result)

def solve15Puzzle(firstBoard) :
    global boardSet
    global puzzleHeap

    nowPuzzle = Puzzle(firstBoard, 0)

    if nowPuzzle.distance == 0 :
        return nowPuzzle.move
        
    boardSet.add(tuple(tuple(firstBoard[i]) for i in range(4)))

    while True :

        if nowPuzzle.distance == 0 :
            break

        for i in range(4) :
            for j in range(4) :

                if nowPuzzle.board[i][j] == 0 :
                    if i - 1 >= 0 :
                        changeBoard = copy.deepcopy(nowPuzzle.board)
                        changeBoard[i][j], changeBoard[i - 1][j] = changeBoard[i - 1][j], changeBoard[i][j]
                        existCheckAndHeapPush(changeBoard, nowPuzzle.move + 1)
                    if i + 1 <= 3 :
                        changeBoard = copy.deepcopy(nowPuzzle.board)
                        changeBoard[i][j], changeBoard[i + 1][j] = changeBoard[i + 1][j], changeBoard[i][j]
                        existCheckAndHeapPush(changeBoard, nowPuzzle.move + 1)
                    if j - 1 >= 0 :
                        changeBoard = copy.deepcopy(nowPuzzle.board)
                        changeBoard[i][j], changeBoard[i][j - 1] = changeBoard[i][j - 1], changeBoard[i][j]
                        existCheckAndHeapPush(changeBoard, nowPuzzle.move + 1)
                    if j + 1 <= 3 :
                        changeBoard = copy.deepcopy(nowPuzzle.board)
                        changeBoard[i][j], changeBoard[i][j + 1] = changeBoard[i][j + 1], changeBoard[i][j]
                        existCheckAndHeapPush(changeBoard, nowPuzzle.move + 1)
                    
        nowPuzzle = heapq.heappop(puzzleHeap)
    
    return nowPuzzle.move

def existCheckAndHeapPush(newBoard, newMove) :
    global boardSet
    global puzzleHeap

    newBoardTuple = tuple(tuple(newBoard[i]) for i in range(4))
    if newBoardTuple not in boardSet :
        boardSet.add(newBoardTuple)
        newPuzzle = Puzzle(newBoard, newMove)
        if newPuzzle.move + newPuzzle.distance <= 45 :
            heapq.heappush(puzzleHeap, newPuzzle)
    
def calculateDistance(board) :
    global correctLocationDict

    distance = 0

    for i in range(4) :
        for j in range(4) :
            boardNowNum = board[i][j]

            if boardNowNum == 0 :
                continue

            collectLocation = correctLocationDict[boardNowNum]
            distance += (abs(i - collectLocation[0]) + abs(j - collectLocation[1]))
    
    return distance


class Puzzle :
    board = list()
    distance = int()
    move = int()

    def __init__(self, board, move) :
        self.board = board
        self.distance = calculateDistance(board)
        self.move = move
    
    def __lt__(self, other) :
        return self.move + self.distance * 1.2 < other.move + other.distance * 1.2


boardSet = set()
puzzleHeap = list()
correctLocationDict = { 1 : [0, 0],
                        2 : [0, 1],
                        3 : [0, 2],
                        4 : [0, 3],
                        5 : [1, 0],
                        6 : [1, 1],
                        7 : [1, 2],
                        8 : [1, 3],
                        9 : [2, 0],
                        10 : [2, 1],
                        11 : [2, 2],
                        12 : [2, 3],
                        13 : [3, 0],
                        14 : [3, 1],
                        15 : [3, 2],
                        0 : [3, 3] }

main()

"
1658973,ALDS1_13_C,"#!/usr/bin/python3
from heapq import heappush, heappop
solution = [i + 1 for i in range(15)] + [0]
sol_idx = (15, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14)
MAX_DEPTH = 45
count = 0
neighbor = (
    (1, 4),
    (0, 2, 5),
    (1, 6, 3),
    (2, 7),
    (0, 5, 8),
    (1, 4, 6, 9),
    (2, 5, 7, 10),
    (3, 6, 11),
    (4, 9, 12),
    (5, 8, 10, 13),
    (6, 9, 11, 14),
    (7, 10, 15),
    (8, 13),
    (9, 12, 14),
    (10, 13, 15),
    (11, 14)
        )

distance = (
    (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ,0, 0, 0),
    (0, 1, 2, 3, 1, 2, 3, 4, 2, 3, 4, 5, 3, 4, 5, 6),
    (1, 0, 1, 2, 2, 1, 2, 3, 3, 2, 3, 4, 4, 3, 4, 5),
    (2, 1, 0, 1, 3, 2, 1, 2, 4, 3, 2, 3, 5, 4, 3, 4),
    (3, 2, 1, 0, 4, 3, 2, 1, 5, 4, 3, 2, 6, 5, 4, 3),
    (1, 2, 3, 4, 0, 1, 2, 3, 1, 2, 3, 4, 2, 3, 4, 5),
    (2, 1, 2, 3, 1, 0, 1, 2, 2, 1, 2, 3, 3, 2, 3, 4),
    (3, 2, 1, 2, 2, 1, 0, 1, 3, 2, 1, 2, 4, 3, 2, 3),
    (4, 3, 2, 1, 3, 2, 1, 0, 4, 3, 2, 1, 5, 4, 3, 2),
    (2, 3, 4, 5, 1, 2, 3, 4, 0, 1, 2, 3, 1, 2, 3, 4),
    (3, 2, 3, 4, 2, 1, 2, 3, 1, 0, 1, 2, 2, 1, 2, 3),
    (4, 3, 2, 3, 3, 2, 1, 2, 2, 1, 0, 1, 3, 2, 1, 2),
    (5, 4, 3, 2, 4, 3, 2, 1, 3, 2, 1, 0, 4, 3, 2, 1),
    (3, 4, 5, 6, 2, 3, 4, 5, 1, 2, 3, 4, 0, 1, 2, 3),
    (4, 3, 4, 5, 3, 2, 3, 4, 2, 1, 2, 3, 1, 0, 1, 2),
    (5, 4, 3, 4, 4, 3, 2, 3, 3, 2, 1, 2, 2, 1, 0, 1),
    (6, 5, 4, 3, 5, 4, 3, 2, 4, 3, 2, 1, 3, 2, 1, 0)
        )
 
def get_diff(B):
    diff = 0
    for i, v in enumerate(B):
        diff += distance[v][i]
    return diff
 
def get_next_board(board, space, prev):
    for nxt in neighbor[space]:
        if nxt == prev:
            continue
        b = board[:]
        b[space], b[nxt] = b[nxt], 0
        yield b, nxt

def answer_is_odd(board):
    return sum(divmod(board.index(0), 4)) % 2

def search(board):
    lower = get_diff(board)
    start_depth = lower
    if (lower % 2) ^ answer_is_odd(board):
        start_depth += 1
    for limit in range(start_depth, MAX_DEPTH + 1, 2):
        get_next(board, limit, 0, board.index(0), None, lower)
        if count > 0:
            return limit

def get_next(board, limit, move, space, prev, lower):
    if move == limit:
        if board == solution:
            global count
            count += 1
    else:
        for b, nxt in get_next_board(board, space, prev):
            p = board[nxt]
            new_lower = lower - distance[p][nxt] + distance[p][space]
            if new_lower + move <= limit:
                get_next(b, limit, move + 1, nxt, space, new_lower)

# main
boad = []
for i in range(4):
    boad.extend(map(int, input().split()))
print(search(boad))
exit()
"
1294448,ALDS1_13_C,"from sys import stdin
readline = stdin.readline


GOAL = [i for i in range(1, 16)] + [0]
MAX_DEPTH = 45  # 80
count = 0

# ??£??\?????????
adjacent = (
    (1, 4),          # 0
    (0, 2, 5),       # 1
    (1, 6, 3),       # 2
    (2, 7),          # 3
    (0, 5, 8),       # 4
    (1, 4, 6, 9),    # 5
    (2, 5, 7, 10),   # 6
    (3, 6, 11),      # 7
    (4, 9, 12),      # 8
    (5, 8, 10, 13),  # 9
    (6, 9, 11, 14),  # 10
    (7, 10, 15),     # 11
    (8, 13),         # 12
    (9, 12, 14),     # 13
    (10, 13, 15),    # 14
    (11, 14)         # 15
)

# ???????????????????????¢
distance = (
    (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
    (0, 1, 2, 3, 1, 2, 3, 4, 2, 3, 4, 5, 3, 4, 5, 6),
    (1, 0, 1, 2, 2, 1, 2, 3, 3, 2, 3, 4, 4, 3, 4, 5),
    (2, 1, 0, 1, 3, 2, 1, 2, 4, 3, 2, 3, 5, 4, 3, 4),
    (3, 2, 1, 0, 4, 3, 2, 1, 5, 4, 3, 2, 6, 5, 4, 3),
    (1, 2, 3, 4, 0, 1, 2, 3, 1, 2, 3, 4, 2, 3, 4, 5),
    (2, 1, 2, 3, 1, 0, 1, 2, 2, 1, 2, 3, 3, 2, 3, 4),
    (3, 2, 1, 2, 2, 1, 0, 1, 3, 2, 1, 2, 4, 3, 2, 3),
    (4, 3, 2, 1, 3, 2, 1, 0, 4, 3, 2, 1, 5, 4, 3, 2),
    (2, 3, 4, 5, 1, 2, 3, 4, 0, 1, 2, 3, 1, 2, 3, 4),
    (3, 2, 3, 4, 2, 1, 2, 3, 1, 0, 1, 2, 2, 1, 2, 3),
    (4, 3, 2, 3, 3, 2, 1, 2, 2, 1, 0, 1, 3, 2, 1, 2),
    (5, 4, 3, 2, 4, 3, 2, 1, 3, 2, 1, 0, 4, 3, 2, 1),
    (3, 4, 5, 6, 2, 3, 4, 5, 1, 2, 3, 4, 0, 1, 2, 3),
    (4, 3, 4, 5, 3, 2, 3, 4, 2, 1, 2, 3, 1, 0, 1, 2),
    (5, 4, 3, 4, 4, 3, 2, 3, 3, 2, 1, 2, 2, 1, 0, 1)
)


def manhattan_distance(board):
    return sum(distance[bi][i] for i, bi in enumerate(board))


def answer_is_odd(board):
    return sum(divmod(board.index(0), 4)) % 2


def search(board):
    lower = manhattan_distance(board)
    start_depth = lower
    if (lower % 2) ^ answer_is_odd(board):
        start_depth += 1
    for limit in range(start_depth, MAX_DEPTH + 1, 2):
        id_lower_search(board, limit, 0, board.index(0), None, lower)
        if count > 0:
            return limit


def nxt_board(board, space, prev):
    for nxt in adjacent[space]:
        if nxt == prev:
            continue
        b = board[:]
        b[space], b[nxt] = b[nxt], 0
        yield b, nxt


def id_lower_search(board, limit, move, space, prev, lower):
    if move == limit:
        if board == GOAL:
            global count
            count += 1
    else:
        for b, nxt in nxt_board(board, space, prev):
            p = board[nxt]
            new_lower = lower - distance[p][nxt] + distance[p][space]
            if new_lower + move <= limit:
                id_lower_search(b, limit, move + 1, nxt, space, new_lower)


def main():
    start = (map(int, readline().split()) for _ in range(4))
    start = [y for x in start for y in x]
    print(search(start))
main()
"
3161625,ALDS1_13_C,"board = [int(s) for _ in range(4) for s in input().split()]
move_piece = [None]* 46
GOAL = list(range(1,16)) + [0]


def create_adjacent(h, w):
  adjacent = [[] for _ in range(h*w)]
  for i in range(h * w):
    if i % w != w-1:
      adjacent[i].append(i+1)
    if i % w != 0:
      adjacent[i].append(i-1)
    if i // h < h-1:
      adjacent[i].append(i+w)
    if i // h > 0:
      adjacent[i].append(i-w)
  return adjacent

def id_search(limit, move, space, lower):
  if move == limit:
    if board == GOAL:
      global count
      count += 1
      print(move)
      exit()
  else:
    for x in adjacent[space]:
      p = board[x]
      if move_piece[move] == p:
        continue
      board[space], board[x] = p, 0
      move_piece[move + 1] = p
      new_lower = lower - distance[p][x] + distance[p][space]

      if new_lower + move <= limit:
        id_search(limit, move+1, x, new_lower)
      board[space], board[x] = 0, p

def create_distance(h, w):
  distance = [[0] * h * w for _ in range(h *w)]
  for i in range(h*w):
    if i == 0:
      continue
    ye, xe = divmod(i-1, w)
    for j in range(h *w):
      y, x = divmod(j,w)
      distance[i][j] = abs(ye-y) + abs(xe-x)
  return distance

def get_distance(board):
  v = 0
  for x in range(len(board)):
    p = board[x]
    if p == 0:
      continue
    v += distance[p][x]
  return v

adjacent = create_adjacent(4, 4)
distance = create_distance(4,4)
n = get_distance(board)
count = 0
for x in range(n,46):
  id_search(x, 0, board.index(0), n)
  if count > 0:
    break


"
3121813,ALDS1_13_C,"board = [int(s) for _ in range(4) for s in input().split()]
move_piece = [None] * 46
GOAL = list(range(1, 16)) + [0]
def create_adjacent(h, w):
    adjacent = [[] for _ in range(h * w)]
    for i in range(h * w):
        if i % w != w - 1:
            adjacent[i].append(i + 1)
        if i % w != 0:
            adjacent[i].append(i - 1)
        if i // h < h - 1:
            adjacent[i].append(i + w)
        if i // h > 0:
            adjacent[i].append(i - w)
    return adjacent

def id_search(limit, move, space, lower):
    if move == limit:
        if board == GOAL:
            global count
            count += 1
            # print(move_piece[1:])
            print(move)
            exit()
    else:
        for x in adjacent[space]:
            p = board[x]
            if move_piece[move] == p:
                continue
            board[space], board[x] = p, 0
            move_piece[move + 1] = p
            new_lower = lower - distance[p][x] + distance[p][space]
            # 下限値枝刈り法
            if new_lower + move <= limit:
                id_search(limit, move + 1, x, new_lower)
            # もとに戻す
            board[space], board[x] = 0, p

def create_distance(h, w):
    distance = [[0] * h * w for _ in range(h * w)]
    for i in range(h * w):
        if i == 0:
            continue
        ye, xe = divmod(i - 1, w)
        for j in range(h * w):
            y, x = divmod(j, w)
            distance[i][j] = abs(ye - y) + abs(xe - x)
    return distance

def get_distance(board):
    v = 0
    for x in range(len(board)):
        p = board[x]
        if p == 0:
            continue
        v += distance[p][x]
    return v

adjacent = create_adjacent(4, 4)
# print(adjacent)
distance = create_distance(4, 4)
# print(distance)
n = get_distance(board)
count = 0
for x in range(n, 46):
    # print('move', x)
    id_search(x, 0, board.index(0), n)
    if count > 0:
        break
"
8430611,ALDS1_14_A,"T=input()
P=input()
for i in range(len(T)):
    if i+len(P)>len(T):
        break
    if P==T[i:i+len(P)]:
        print(i)
        
    
"
8442338,ALDS1_14_A,"t = input()
p = input()
n = 0

while 1:
    i = t[n:].find(p)
    if i < 0: break
    n += i + 1
    print(n - 1)
"
8707927,ALDS1_14_A,"t = input()
p = input()
i = 0
while i < len(t):
    s = t[i:]
    j = s.find(p)
    if j == -1:
        break
    else:
        print(i + j)
        i += j + 1

"
8845646,ALDS1_14_A,"t=input()
p=input()

n=len(t)
m=len(p)

t=t+'$'*m
for i in range(n):
    if t[i:i+m]==p:
        print(i)
"
8873694,ALDS1_14_A,"# aizu_ALDS1_14_A_NaiveStringSearch.py  

T = input()
P = input()
len_t = len(T)
len_p = len(P)
for i in range(len_t - len_p + 1):
    t = T[i:i+len_p]
    if t == P:
        print(i)
"
8945404,ALDS1_14_A,"word = input()
target = input()

N = len(target)

def check_word(word,target,N):
    
    for i in range(len(word)-N+1):
        
        string = word[i:i+N]##iからN文字分取り出す
        
        if string == target:
            
            print(i)
        
check_word(word,target,N)
"
8970408,ALDS1_14_A,"def solve(t, p):
    for i in range(len(t) - len(p) + 1):
        if t[i:i + len(p)] == p:
            print(i)


if __name__ == ""__main__"":
    T = bytes(input(), ""ascii"")
    P = bytes(input(), ""ascii"")
    solve(T, P)

"
8403076,ALDS1_14_A,"t = input()
p = input()
t_len = len(t)
p_len = len(p)
if (p_len > t_len):
    exit()
for i in range(t_len - p_len + 1):
    if t[i] == p[0]:
        flag = 1
        for j in range(p_len):
            if t[i+j] != p[j]:
                flag = 0
        if flag == 1:
            print(i)

"
1696750,ALDS1_14_A,"t, p = input(), input()
for i in range(len(t) - len(p) + 1):
    if t[i:i + len(p)] == p:
        print(i)
"
2101714,ALDS1_14_A,"if __name__ == '__main__':
    # ??????????????\???
    # T = 'abc'
    # P = 'xyz'
    T = input()
    P = input()

    # ???????????????
    results = []

    for i in range(len(T) - len(P) + 1):
        temp = T[i:i+len(P)]
        if temp == P:
            results.append(i)

    # ???????????¨???
    for r in results:
        print(r)
"
2183960,ALDS1_14_A,"string = input()
teststring = input()
length = len(teststring)
counter = []
for position in range(0, len(string)):
  if string[position:position + length] == teststring:
    counter.append(position)

for content in counter:
  print(content)
"
2216103,ALDS1_14_A,"T = input()
P = input()
tmp2 = []
for i in range(len(T)):
    tmp = T[i:].find(P)
    if tmp != -1:
        tmp2.append(len(T[:i])+tmp)
for s in sorted(set(tmp2)):
    print(s)
"
2352026,ALDS1_14_A,"t=input()
p=input()
l_t=len(t)
l_p=len(p)
for i in range(l_t-l_p+1):
    if t[i:i+l_p]==p:print(i)
"
2478815,ALDS1_14_A,"s,p=input(),input();[print(i)for i in range(len(s))if s[i:i+len(p)]==p]
"
2497684,ALDS1_14_A,"T = input()
P = input()
idx = 0
while (1):
    ans = T.find(P, idx)
    if (ans == -1):
        break
    else:
        print(ans)
        if (ans==0):
            idx+=1
        else:
            idx=ans+1
"
2612608,ALDS1_14_A,"target = input().strip()
se = input().strip()
answer = []
for i in range(len(target) - len(se) + 1):
    for inner in range(len(se)):
        if target[i + inner] != se[inner]:
            break
    else:
        answer.append(i)
for a in answer:
    print(a)
"
2728081,ALDS1_14_A,"def MAIN():
    T = input()
    P = input()
    t = -1
    for _ in range(1000):
        t = T.find(P, t + 1)
        if t == -1:
            break
        print(t)
MAIN()

"
2823162,ALDS1_14_A,"T,P=input(),input()
for i in range(len(T)):P!=T[i:i+len(P)]or print(i)
"
2856928,ALDS1_14_A,"
T = input()
P = input()

for i in range(len(T)-len(P)+1):
    if T[i:i+len(P)] == P:
        print(i)
"
2882995,ALDS1_14_A,"def search(s1, s2):
    len1 = len(s1)
    len2 = len(s2)
    for i in range(len1):
        if i + len2 > len1:
            break

        for j in range(len2):
            if s1[i+j] != s2[j]:
                break
        else:
            yield i


def run():
    s1 = input()
    s2 = input()
    for idx in search(s1, s2):
        print(idx)


if __name__ == '__main__':
    run()

"
3040432,ALDS1_14_A,"t = input()
p = input()

for i in range(len(t)):
    for j in range(len(p) + 1):
        if j == len(p):
            print(i)
        else:
            if i + j >= len(t):
                break
            elif t[i + j] == p[j]:
                continue
            else:
                break
"
3110119,ALDS1_14_A,"T = input()
P = input()
p = len(P)
for i in range(len(T)-p+1):
    if T[i:i+p]==P:
        print(i)
"
3213315,ALDS1_14_A,"text=input()
string=input()


#common_length[i]は、探索列がstring[i]で探索を終了したときに、
# string[i-common_lneght[i] + 1] 〜string[i]で構成される文字列が、探索価値を持つことを示す


len_string=len(string)
common_length=[0]*len_string
tmp=0
for i in range(1,len_string):
    if(string[i]==string[tmp]):
        if(string[i-1]==string[tmp-1]):
            common_length[i-1]=1
        else:
            common_length[i-1]=0
        tmp+=1
    else:
        common_length[i-1]=tmp
        if(string[i]==string[0]):
            tmp=1
        else:
            tmp=0

if(string[-1]==string[tmp-1]):
    common_length[-1]=tmp
common_length[0]=0



tmp=0

for i in range(len(text)):
    if(text[i]!=string[tmp]):
        while(text[i]!=string[tmp] and tmp>0):
            tmp=common_length[max([tmp-1,0])]
        if(text[i]==string[tmp]):
            tmp+=1
    else:
        tmp+=1
        if(tmp==len_string):
            print(i-tmp+1)
            tmp=common_length[-1]
"
3243591,ALDS1_14_A,"def main():
    text = input()
    len_text = len(text)
    pattern = input()
    len_pattern = len(pattern)

    for i in range(len_text - len_pattern + 1):
        if text[i:i+len_pattern] == pattern:
            print(i)
    return


main()
"
3250452,ALDS1_14_A,"t = input()
p = input()

anslist = []
for i in range(len(t) - len(p) + 1):
    if t[i] == p[0]:
        k = 0
        for j in range(i, i + len(p)):
            if t[j] != p[k]:
                break
            k += 1
        else:
            anslist.append(i)

for ans in anslist:
    print(ans)

"
3255421,ALDS1_14_A,"# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_A&lang=jp
#  Naive String Search : python3
#  2018.11.26 yonezawa

import sys
input = sys.stdin.readline
#import cProfile

def main():
    s1  = str(input()).rstrip('\n')
    s2  = str(input()).rstrip('\n')
    
    s1_len = len(s1)
    s2_len = len(s2)
    sc = 1
    for k in range(1,len(s2)):
        if s2[0] != s2[k]:
            break
        sc += 1
    tc = len(set(s2))

    if (tc == 1 and s2_len > 1):
        cnt = 0
        for k in range(s1_len ):
            if (s1[k] == s2[0]):
                cnt += 1
            else:
                cnt = 0
            if (cnt >= s2_len ):
                print (cnt - s2_len)
    else:
        i = s1.find(s2)
        while i != -1 :
            print (i)
            i = s1.find(s2,i+1)


if __name__ == '__main__':
    main()
    #pr = cProfile.Profile()
    #pr.runcall(main)
    #pr.print_stats()
"
3263920,ALDS1_14_A,"# https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/14/ALDS1_14_A


def solve():
    T = input()
    P = input()

    if len(T) < len(P):
        exit()

    for index, pos in enumerate(range(len(T) - len(P) + 1)):
        if T[pos:pos+len(P)] == P:
            print(index)


if __name__ == '__main__':
    solve()

"
3526024,ALDS1_14_A,"t = list(input())
p = list(input())
n = len(t) - len(p) + 1

for i in range(n):
    if p[0] == t[i]:
        for j in range(len(p)):
            flag = True
            if not p[j] == t[i+j]:
                flag = False
                break
        if flag:
            print(i)

"
3540330,ALDS1_14_A,"a = input()
b = input()
for i in range(len(a)):
    if a[i:i+len(b)] == b:
        print(i)
        
"
3671420,ALDS1_14_A,"t = input()
p = input()

index = -1
while True:
    index = t.find(p, index + 1)
    if index == -1:
        break
    print(index)

"
3676690,ALDS1_14_A,"T = input()
P = input()

for i in range(len(T)):
    if T[i:].startswith(P):
        print(i)

"
3697935,ALDS1_14_A,"t = input()
p = input()
 
anslist = []
for i in range(len(t) - len(p) + 1):
    if t[i] == p[0]:
        k = 0
        for j in range(i, i + len(p)):
            if t[j] != p[k]:
                break
            k += 1
        else:
            anslist.append(i)
 
for ans in anslist:
    print(ans)
"
3774990,ALDS1_14_A,"T = input()
P = input()

n, result = 0, []
while n < len(T):
	next_n = T.find(P, n)
	if next_n < 0:
		break
	result.append(next_n)
	n = next_n + 1

for r in result:
	print(r)

"
3789402,ALDS1_14_A,"l = input()
m = input()
n = len(l)
k = len(m)

c = 0
for i in range(n-k+1):
    if l[i:i+k] == m:
        print(i)

"
3823325,ALDS1_14_A,"t=input()
p=input()
l=len(t)-len(p)
ans=[]
for i in range(l+1):
    if t[i:i+len(p)]==p:
        ans.append(i)
#if ans==[]:
#   sys.exit
for _ in ans:
    print(_)
"
3856348,ALDS1_14_A,"T = input()
S = input()

s = len(S)
for i in range(len(T)-s+1):
    if T[i:i+s] == S:
        print(i)
"
3897627,ALDS1_14_A,"T = input()
P = input()
t = len(T)
p = len(P)
for i in range(t-p+1):
    if P == T[i:i+p]:
        print(i)

"
3913248,ALDS1_14_A,"parent = input()
key = input()

for i in range(len(parent)):
    if parent[i:i+len(key)] == key:
        print(i)
"
4047551,ALDS1_14_A,"# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_A&lang=ja

T = input()
P = input()

for j in range(len(T) - len(P) + 1):
    if T[j:j+len(P)] == P:
        print(j)
"
4058115,ALDS1_14_A,"line = input()
seq = input()


for i in range(len(line)-len(seq)+1):
    if line[i:i+len(seq)] == seq:
        print(i)
"
4065676,ALDS1_14_A,"t=input()
p=input()
for i in range(len(t)-len(p)+1):
	if t[i:i+len(p)]==p:
		print(i)

"
4082654,ALDS1_14_A,"def search(t, p):
    tn = len(t)
    i = 0
    pn = len(p)
    plist = []
    if pn <= tn:
        while i < tn:
            j = 0
            while j < pn and i+j < tn:
                if t[i+j] != p[j]: break
                j += 1
            if j == pn:
                plist.append(i)
            i += 1
    return plist

def main():
    t = input()
    p = input()
    plist = search(t, p)
    for i in plist: print(i)



if __name__ == ""__main__"":
    main()
"
4100358,ALDS1_14_A,"t = input()
p = input()

for i in range(len(t)-len(p)+1):
    if t[i:i+len(p)] == p:
        print(i)
"
4209800,ALDS1_14_A,"T, P = input(), input()
t, p = len(T), len(P)
if t>=p:
    ans = [str(n) for n, i in enumerate(range(p, t+1)) if T[n:i]==P]
    if ans:
        print(""\n"".join(ans))
"
4322624,ALDS1_14_A,"def Main():
    text = input()
    pattern = input()
    
    for i in range(len(text)):
        if text[i:].startswith(pattern):
            print(i)
Main()
"
4326319,ALDS1_14_A,"def main():
    s = input()
    t = input()
    for i in range(len(s)-len(t)+1):
        if t == s[i:i+len(t)]:print(i)


if __name__ == '__main__':
    main()


"
4409444,ALDS1_14_A,"T = input()
P = input()
l = len(P)

for i in range(len(T) - l + 1) :
    if T[i : i + l] == P :
        print(i)
"
4442282,ALDS1_14_A,"s=input()
p=input()
for i in range(len(s)):
    if s[i:].startswith(p):
        print(i)
"
4464173,ALDS1_14_A,"t=input()
p=input()
for i in range(len(t)):
    if p == t[i:i+len(p)]:
        print(i)


"
4470957,ALDS1_14_A,"def comp(T,P):
    if T == P:
        return True
    else:
        return False

def main():
    T = input()
    P = input()
    n1,n2 = len(T),len(P)

    for i in range(n1-n2+1):
        if comp(T[i:i+n2],P):
            print(i)

if __name__ == ""__main__"":
    main()

"
4475579,ALDS1_14_A,"t =  input()
p =  input()
for i in range(len(t) - len(p) + 1):
    if t[i:i + len(p)] == p:
        print(i)
    else:
      pass
"
4478486,ALDS1_14_A,"T=str(input())
P=str(input())
for i in range(len(T)):
    if T[i:len(T)].startswith(P):
        print(i)
"
4492715,ALDS1_14_A,"while True:
    try:
        T = input()
        P = input()

        Tlen = len(T)
        Plen = len(P)

    except Plen>Tlen:
        break

    count = 0
    List = []
    for i in range(Tlen-Plen+1):
        index = T.find(P)
        
        if index==0:
            List.append(count)
        
        Tlist = list(T)
        del(Tlist[0])
        T = ''.join(Tlist)
        
        count += 1

    Llen = len(List)

    if Llen==0:
        break

    else:
        for i in range(Llen):
            print(List[i])
    
    break
"
4512322,ALDS1_14_A,"# coding: utf-8
# Your code here!

T = input()
P = input()

for i in range(len(T) - len(P) + 1):
   if P == T[i : i + len(P)]:
      print(i)

"
4522965,ALDS1_14_A,"# coding: utf-8
# 59

T = input()
P = input()
t=[]
A = []
#print(len(P),len(T))
if len(P)==1:
    K=len(T)
else:
    K = len(T)-(len(P)-1)
    #print(K)
p = len(P)
for i in range(K):
    t = T[i:p]
    #print(t)
    p += 1
    if t.count(P)>0:
        print(i)
"
4525819,ALDS1_14_A,"t = input()
p = input()

for i in range(len(t) - len(p) + 1):
    if t[i:i + len(p)] == p:
        print(i)
    else:
      pass
"
4526246,ALDS1_14_A,"T=str(input())
P=str(input())
l1=len(T)
l2=len(P)
i=0
for i in range(l1-l2+1):
    i+=1
    x=T.find(P,i-1,i+l2-1)
    if x==-1:
        pass
    else:
        print(x)
"
4539429,ALDS1_14_A,"T=input()
P=input()
for i in range(len(T)):
    if T[i:].startswith(P):
        print(i)

"
4559286,ALDS1_14_A,"a = input()
b = input()
idx = 0
while True:
    idx = a.find(b, idx)
    if idx+1:
        print(idx)
    else:
        break
    idx += 1
"
4560836,ALDS1_14_A,"T = str(input())
P = str(input())

x = -1
while True:
    x = T.find(P, x+1)
    if x == -1:
        break
    print(x)
"
4561710,ALDS1_14_A,"T=input()
P=input()
l1=len(T)
l2=len(P)
i=0
for i in range(l1-l2+1):
    x=T.find(P,i,i+l2)
    if x==-1:
        pass
    else:
        print(x)
"
4569165,ALDS1_14_A,"t=input()
p=input()


for i in range(len(t)):
    if p in t[i:i+len(p)]:
        print(i)

"
4572355,ALDS1_14_A,"a = list(input())
b = list(input())


for j in range(len(a)+1-len(b)) :
    Same = True
    ans = j
    i = 0
    while i < len(b) :
        if b[i] == a[j] :
            i += 1
            j += 1
        else :
            Same = False
            break
    if Same == True :
        print(ans)
"
4579536,ALDS1_14_A,"T = input()
P = input()
for j in range(len(T)):
    if T[j:].startswith(P):
        print(j)
"
4580491,ALDS1_14_A,"t=input()
p=input()
l=len(p)

for i in range(len(t)-l+1):
    if p==t[i:i+l]:
        print(i)
"
4590474,ALDS1_14_A,"t=input()
p=input()
a=0
while True:
    a=t.find(p, a)
    if a == -1:
        break
    print(a)
    a += 1
"
4593673,ALDS1_14_A,"def resolve():
    T = input()
    P = input()
    idx = 0
    while idx <= len(T) - len(P):
        if T[idx:idx + len(P)] == P:
            print(idx)
        idx += 1


resolve()

"
4599348,ALDS1_14_A,"T = input()
P = input()
for i in range(len(T)):
    if T[i:].startswith(P):
        print(i)
"
8737856,ALDS1_14_B,"class KMP:
    def __init__(self, W):
        L = len(W)
        T = [0] * (L + 1)
        T[0] = -1
        c = 0
        for p in range(1, L):
            if W[p] == W[c]:
                T[p] = T[c]
            else:
                T[p] = c
                c = T[c]
                while c >= 0 and W[p] != W[c]:
                    c = T[c]
            c += 1
        T[L] = c
        self.T = T
        self.W = W

    def search(self, S):
        W = self.W; T = self.T
        R = []
        LS = len(S); LW = len(W)
        # S[i], W[j]
        i = j = 0
        while i < LS:
            if S[i] == W[j]:
                i += 1
                j += 1
                if j == LW:
                    R.append(i - j)
                    j = T[j]
            else:
                j = T[j]
                if j < 0:
                    i += 1
                    j += 1
        return R

t = input()
p = input()

kmp = KMP(p)
res = kmp.search(t)
for re in res:
    print(re)

""""""
1<=|t|<=10**6
1<=|p|<=10**4
""""""

"
8403210,ALDS1_14_B,"t = input()
p = input()
t_len = len(t)
p_len = len(p)
if (p_len > t_len):
    exit()
# for i in range(t_len - p_len + 1):
#     if t[i] == p[0]:
#         flag = 1
#         for j in range(int(p_len/2)+1):
#             if t[i+j] != p[j] or t[i+p_len-j-1] != p[p_len-j-1]:
#                 flag = 0
#         if flag == 1:
#             print(i)
for i in range(t_len):
    if t.startswith(p, i):
        print(i)
"
8945468,ALDS1_14_B,"word = input()
target = input()

N = len(target)

def check_word(word,target,N):
    
    for i in range(len(word)-N+1):
        
        string = word[i:i+N]##iからN文字分取り出す
        
        if string == target:
            
            print(i)
        
check_word(word,target,N)
"
8742653,ALDS1_14_B,"def modmul(a,b,mod):
    res = (a*b)%mod
    return res

def modpow(x,n,mod):
    res = 1
    while n:
        if n%2:
            res = (res*x)%mod
        x = (x*x)%mod
        n //= 2
    return res

def rollinghash(t,p):
    res = []
    n = len(t)
    m = len(p)
    if n < m:
      return res
    h = [1]*(m+1)
    b = 31
    mod = 10**9+7
    p_hash = 0
    t_hash = 0

    for i in range(m):
        h[i+1] = modmul(h[i],b,mod)

    for i in range(m):
        p_hash = (p_hash+h[m-1-i]*ord(p[i]))%mod
        t_hash = (t_hash+h[m-1-i]*ord(t[i]))%mod

    if t_hash == p_hash:
        res.append(0)

    for i in range(m,n):
        t_hash = (modmul(b,t_hash,mod) - h[m]*ord(t[i-m]) + ord(t[i]))%mod
        if t_hash == p_hash:
            res.append(i-m+1)

    return res

t = input()
p = input()

res = rollinghash(t,p)
for ans in res:
    print(ans)
"
9009912,ALDS1_14_B,"# aizu_ALDS1_14_B_StringSearch.py  
# 文字列検索　　RollingHash

base = 37; mod = 10**9 + 7
pw = None
def rolling_hash(s):
    l = len(s)
    h = [0]*(l + 1)
    v = 0
    for i in range(l):
        h[i+1] = v = (v * base + ord(s[i])) % mod
    return h
def setup_pw(l):
    global pw
    pw = [1]*(l + 1)
    v = 1
    for i in range(l):
        pw[i+1] = v = v * base % mod
def get(h, l, r):
    return (h[r] - h[l] * pw[r-l]) % mod

T = input()
P = input()
HT = rolling_hash(T)
HP = rolling_hash(P)

l = len(P)
setup_pw(l)

pv = get(HP, 0, l)
for i in range(len(T)-len(P)+1):
    if get(HT, i, i+l) == pv:
        print(i)
"
7067309,ALDS1_14_B,"import sys

readline = sys.stdin.readline
write = sys.stdout.write


class KMP:
    def __init__(self, pattern):
        pattern_len = len(pattern)
        kmp_array = [0] * (pattern_len + 1)
        kmp_array[0] = -1
        j = -1
        for i in range(pattern_len):
            while j >= 0 and pattern[i] != pattern[j]:
                j = kmp_array[j]
            j += 1
            kmp_array[i+1] = j
        self.kmp_array = kmp_array
        self.pattern = pattern

    def search(self, text):
        pattern = self.pattern
        kmp_array = self.kmp_array
        res = []
        text_len = len(text)
        pattern_len = len(pattern)
        i = j = 0
        while i < text_len:
            if text[i] == pattern[j]:
                i += 1
                j += 1
                if j == pattern_len:
                    res.append(i - j)
                    j = kmp_array[j]
            else:
                j = kmp_array[j]
                if j < 0:
                    i += 1
                    j += 1
        return res

    @staticmethod
    def distance(p, p_scale, t, t_scale):
        return p * t_scale - t * p_scale


def solve():
    text = readline().strip()
    pattern = readline().strip()
    kmp = KMP(pattern)
    res = kmp.search(text)
    for p in res:
        write(""%d\n"" % p)


solve()

"
4623918,ALDS1_14_B,"import sys
readline = sys.stdin.readline
write = sys.stdout.write

class KMP:
    def __init__(self, W):
        L = len(W)
        T = [0] * (L+1)
        T[0] = -1
        c = 0
        for p in range(1, L):
            if W[p] == W[c]:
                T[p] = T[c]
            else:
                T[p] = c
                c = T[c]
                while c >= 0 and W[p] != W[c]:
                    c = T[c]
            c += 1
        T[L] = c
        self.T = T
        self.W = W

    def search(self, S):
        W = self.W; T = self.T
        R = []
        LS = len(S); LW = len(W)
        # S[i], W[j]
        i = j = 0
        while i < LS:
            if S[i] == W[j]:
                i += 1; j += 1
                if j == LW:
                    R.append(i-j)
                    j = T[j]
            else:
                j = T[j]
                if j < 0:
                    i += 1
                    j += 1
        return R

def solve():
    T = readline().strip()
    P = readline().strip()
    kmp = KMP(P)
    res = kmp.search(T)
    for p in res:
        write(""%d\n"" % p)
solve()
"
2729355,ALDS1_14_B,"def kmpTable(w):
    lw = len(w)
    nx = [-1] * (lw + 1)
    j = -1
    for i in range(lw):
        while j >= 0 and w[i] != w[j]:
            j = nx[j]
        j += 1
        nx[i + 1] = j
    return tuple(nx)
def kmpSearch(s, w):
    ls = len(s)
    start = 0
    w_idx = 0
    ret = []
    nx = kmpTable(w)
    while start + w_idx < ls:
        if s[start + w_idx] == w[w_idx]:
            w_idx += 1
            if w_idx == len(w):
                ret.append(start)
                start = start + w_idx - nx[w_idx]
                w_idx = nx[w_idx]
        else:
            if w_idx == 0:
                start += 1
            else:
                start = start + w_idx - nx[w_idx]
                w_idx = nx[w_idx]
    return ret
T = input()
P = input()
ans = kmpSearch(T, P)
if ans:
    print(""\n"".join(map(str, ans)))	

"
3255395,ALDS1_14_B,"# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_14_B&lang=jp
#  String Search : python3
#  2018.11.26 yonezawa

import sys
input = sys.stdin.readline
#import cProfile

def main():
    s1  = str(input()).rstrip('\n')
    s2  = str(input()).rstrip('\n')
    
    s1_len = len(s1)
    s2_len = len(s2)
    sc = 1
    for k in range(1,len(s2)):
        if s2[0] != s2[k]:
            break
        sc += 1
    tc = len(set(s2))

    if (tc == 1 and s2_len > 1):
        cnt = 0
        for k in range(s1_len ):
            if (s1[k] == s2[0]):
                cnt += 1
            else:
                cnt = 0
            if (cnt >= s2_len ):
                print (cnt - s2_len)
    else:
        i = s1.find(s2)
        while i != -1 :
            print (i)
            i = s1.find(s2,i+1)


if __name__ == '__main__':
    main()
    #pr = cProfile.Profile()
    #pr.runcall(main)
    #pr.print_stats()

"
4109799,ALDS1_14_B,"def make_kmp_table(t):
    i = 2
    j = 0
    m = len(t)
    tbl = [0] * (m + 1)
    tbl[0] = -1
    while i <= m:
        if t[i - 1] == t[j]:
            tbl[i] = j + 1
            i += 1
            j += 1
        elif j > 0:
            j = tbl[j]
        else:
            tbl[i] = 0
            i += 1
    return tbl


def kmp(s, t):
    matched_indices = []
    tbl = make_kmp_table(t)
    i = 0
    j = 0
    n = len(s)
    m = len(t)
    while i + j < n:
        if t[j] == s[i + j]:
            j += 1
            if j == m:
                matched_indices.append(i)
                i += j - tbl[j]
                j = tbl[j]
        else:
            i += j - tbl[j]
            if j > 0:
                j = tbl[j]
    return matched_indices


t = input()
p = input()
result = kmp(t, p)
if result:
    print(*result, sep='\n')
"
6429346,ALDS1_14_B,"def partial_match_table(word):
    table = [0] * (len(word) + 1)
    table[0] = -1
    i, j = 0, 1

    while j < len(word):
        matched = word[i] == word[j]

        if not matched and i > 0:
            i = table[i]
        else:
            if matched:
                i += 1
            j += 1
            table[j] = i
    return table

def kmp_search(text, word):
    table = partial_match_table(word)
    i, p = 0, 0
    
    ret = []
    while i < len(text):
        if text[i] == word[p]:
            i += 1
            p += 1
            if p == len(word):
                ret.append(i - p)
                p = table[p]
        else:
            p = table[p]
            if p < 0:
                i += 1
                p += 1

    return ret


T = input()
P = input()
ans = kmp_search(T, P)
if ans:
    print(*ans, sep=""\n"")


"
8003837,ALDS1_14_B,"#https://daeudaeu.com/kmp/

def createNextTable(kmpNext,pattern,len):
    kmpNext[0] = -1 #0番目で不一致したらテキストもパターンも後ろにずらす
    kmpNext[1] = 0 #1番目で不一致した時の適切な位置は0
    
    for i in range(2,len+1):
        
        #直前の位置のkmpNext
        j = kmpNext[i-1] 
        
        while j > 0 and pattern[i-1] != pattern[j]:
            #一段階短い一致文字数を取得
            j = kmpNext[j]
        
        #jが0になったらパターンの先頭から始まる文字列と位置i-1の直前の文字で終わる文字列
        #が一致する文字列としてjより短いものは存在しない
        if pattern[i-1] == pattern[j]: #j=0の場合でもi-1と比較して一致していたら+1
            j += 1 #一致する文字列を増やす
        
        
        kmpNext[i] = j #j=0だったら先頭に戻るってこと


    #連続して行われる同じ比較をスキップする。どうせスキップされるので
    #適切な位置で不一致した場合の適切な位置
    #ABCDABCXで2個目のCで不一致した後、1個目のCが適切な位置になるけど
    #当然不一致なので最初からやり直しになる。こういうのを調整
    for i in range(1,len):
        if pattern[i] == pattern[kmpNext[i]]:
            kmpNext[i] = kmpNext[kmpNext[i]]

def kmpSearch(text,text_len,pattern,pattern_len):
    
    kmpNext = [-1]*(pattern_len+1)
    
    createNextTable(kmpNext,pattern,pattern_len)
    
    pattern_pos = 0 #パターンの比較位置を先頭にセット
    
    text_pos = 0 #テキストの比較位置を先頭にセット
    
    ans = []
    
    while text_pos < text_len:
        if text[text_pos] == pattern[pattern_pos]:
            
            if pattern_pos == pattern_len-1: #最後の文字までテキストが一致したかどうか
                print(text_pos-pattern_pos)
                text_pos += 1
                pattern_pos = kmpNext[pattern_len]
                continue
                
            text_pos += 1
            pattern_pos += 1
        
        else:
            
            if kmpNext[pattern_pos] == kmpNext[0]: #不一致した位置が先頭相当の位置かどうか
                text_pos += 1
                pattern_pos = 0
            
            else: #先頭相当の位置以外で不一致
                #テキストの比較位置は変化しない
                pattern_pos = kmpNext[pattern_pos]
    return ans

text = input()
pattern = input()
kmpSearch(text,len(text),pattern,len(pattern))
                
            
            
"
4082939,ALDS1_14_B,"def calc_prefix(pattern):
    """"""
        a b|c   a b[c] # matched        matched_len = 2
        1 2
        a b c|  a b[c] # increase       matched_len = 3
        1 2 3

        a b|c   a b[d] # not matched    matched_len = 2
        1 2
        a|b c   a b[d] # not matched    matched_len = 1
        1 2
       |a b c   a b[d] # not matched    matched_len = 0
        1 2 0

        a b|c   a b[a] # not matched    matched_len = 2
        1 2
        a|b c   a b[a] # not matched    matched_len = 1
        1 2
       |a b c   a b[a] # matched        matched_len = 0
        1 2
        a|b c   a b[a] # increase       matched_len = 1
    """"""
    pattern_len = len(pattern)
    # matched_len = 0
    matched_table = [0] * pattern_len
    for calc_idx in range(1, pattern_len):
        matched_len = matched_table[calc_idx - 1]
        while matched_len > 0 and pattern[matched_len] != pattern[calc_idx]:  # not matched
            matched_len = matched_table[matched_len - 1]  # matched_lenが-1される
        if pattern[matched_len] == pattern[calc_idx]:  # matched!
            matched_len += 1
        matched_table[calc_idx] = matched_len
    return matched_table


def kmp(text, pattern):
    matched_table = calc_prefix(pattern)
    pattern_len = len(pattern)
    text_len = len(text)
    text_idx = 0
    pattern_idx = 0
    matched_idxs = []
    while text_idx < text_len:
        if pattern[pattern_idx] == text[text_idx]:
            pattern_idx += 1
            text_idx += 1
        if pattern_idx == pattern_len:
            matched_idxs.append(text_idx - pattern_idx)
            pattern_idx = matched_table[pattern_idx - 1]
        elif text_idx < text_len and pattern[pattern_idx] != text[text_idx]:
            if pattern_idx == 0:
                text_idx += 1
            else:
                pattern_idx = matched_table[pattern_idx - 1]

    return matched_idxs


def main():
    text = input()
    pattern = input()
    matched = kmp(text, pattern)
    for match_idx in matched:
        print(match_idx)


if __name__ == ""__main__"":
    main()

"
8874495,ALDS1_14_B,"import sys
input = sys.stdin.readline
sys.setrecursionlimit(10**7)

def II(): return int(input())
def MI(): return map(int,input().split())
def LM(): return list(MI())
def LL(n): return [LM() for _ in range(n)]
def LS(n,remove_br=False): return [list(input())[:-1] if remove_br else list(input()) for _ in range(n)]

def MI_1(): return map(lambda x:int(x)-1,input().split())
def LM_1(): return list(MI_1())
def LL_1(n): return [LM_1() for _ in range(n)]

def bit_count(num):
    length = num.bit_length()
    res = 0
    for i in range(length):
        if num >> i & 1:
            res += 1
    return res

DIJ4 = [[-1,0],[0,-1],[0,1],[1,0]]
DIJ8 = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]
MOD = 998244353
INF = float(""inf"")

def DB(*x):
    global DEBUG_MODE
    if DEBUG_MODE: print(*x)
############
DEBUG_MODE=1
############




import random

class RollingHash:

    def __init__(self, string, base, mod):

        self.mod = mod

        l = len(string)
        self.hash = [0]*(l+1)

        for i in range(1,l+1):
            self.hash[i] = ( self.hash[i-1] * base + ord(string[i-1]) ) % mod

        self.pw = [1]*(l+1)
        for i in range(1,l+1):
            self.pw[i] = self.pw[i-1] * base % mod


    def get(self, l, r):
        return (self.hash[r] - self.hash[l] * self.pw[r-l]) % self.mod





S = input()[:-1]
T = input()[:-1]



ans = []

base = random.randint(1000,2000)
mod = 2**61-1



sh = RollingHash(S, base, mod)

lf = RollingHash(T, base, mod)
lf = lf.get(0,len(T))

for i in range(len(S)-len(T)+1):
    if sh.get(i,i+len(T)) == lf:
        ans.append(i)


if ans:    print(*ans,sep=""\n"")

"
7646007,ALDS1_14_B,"#WにSが含まれるかをO(N)で判断
class KMP:
    # Wについてのtableを構築する
    def __init__(self, W):
        N = len(W)
        table = [0] * (N + 1)
        table[0] = -1
        i = 0
        for p in range(1, N):
            if W[p] == W[i]:
                table[p] = table[i]
            else:
                table[p] = i
                i = table[i]
                while i >= 0 and W[p] != W[i]:
                    i = table[i]
            i += 1

        table[N] = i
        self.table = table
        self.W = W

    # WがSに含まれているか
    def find(self, S):
        W = self.W
        table = self.table
        ret = []
        S_length = len(S)
        W_length = len(W)
        i = 0
        j = 0
        while i < S_length:
            if S[i] == W[j]:
                i += 1
                j += 1
                if j == W_length:
                    ret.append(i - j)
                    j = table[j]
            else:
                j = table[j]
                if j < 0:
                    i += 1
                    j += 1
        return ret


W = input()
S = input()
kmp = KMP(S)
ans = kmp.find(W)
for e in ans: print(e)



"
7128637,ALDS1_14_B,"class KMP:
    """"""
    部分文字列の高速検索
    使用例:
    text = readline().strip()
    pattern = readline().strip()
    kmp = KMP(pattern)
    res = kmp.search(text)
    """"""

    def __init__(self, W):
        L = len(W)
        T = [0] * (L+1)
        T[0] = -1
        c = 0
        for p in range(1, L):
            if W[p] == W[c]:
                T[p] = T[c]
            else:
                T[p] = c
                c = T[c]
                while c >= 0 and W[p] != W[c]:
                    c = T[c]
            c += 1
        T[L] = c
        self.T = T
        self.W = W

    def search(self, S):
        W = self.W; T = self.T
        R = []
        LS = len(S); LW = len(W)
        # S[i], W[j]
        i = j = 0
        while i < LS:
            if S[i] == W[j]:
                i += 1; j += 1
                if j == LW:
                    R.append(i-j)
                    j = T[j]
            else:
                j = T[j]
                if j < 0:
                    i += 1
                    j += 1
        return R

t = input()
p = input()
kmp = KMP(p)
ans = kmp.search(t)
for a in ans:
    print(a)
"
3047612,ALDS1_14_B,"def compute_prefix_function(p):
    m = len(p)
    pi = [0 for _ in range(m + 1)]
    pi[1] = 0
    k = 0
    for q in range(2, m + 1):
        while k > 0 and p[k] != p[q - 1]:
            k = pi[k]
        if p[k] == p[q - 1]:
            k += 1
        pi[q] = k
    return pi


def kmp_matcher(t, p):
    n = len(t)
    m = len(p)
    pi = compute_prefix_function(p)
    q = 0
    for i in range(1, n + 1):
        while q > 0 and p[q] != t[i - 1]:
            q = pi[q]
        if p[q] == t[i - 1]:
            q += 1
        if q == m:
            print(i - m)
            q = pi[q]


t = input()
p = input()
kmp_matcher(t, p)
"
6782227,ALDS1_14_B,"import sys
import math
import bisect
from heapq import heapify, heappop, heappush
from collections import deque, defaultdict, Counter
from functools import lru_cache
from itertools import accumulate, combinations, permutations

sys.setrecursionlimit(1000000)
MOD = 10 ** 9 + 7
MOD99 = 998244353

input = lambda: sys.stdin.readline().strip()
NI = lambda: int(input())
NMI = lambda: map(int, input().split())
NLI = lambda: list(NMI())
SI = lambda: input()
SMI = lambda: input().split()
SLI = lambda: list(SMI())



# KMP法
# 1対1の検索アルゴリズム。Tが固定のときTableを使いまわせる？
# 前計算O(|T|), 検索O(|S|)
# 事前にTから「j文字目で照合失敗したら次は何文字ずらすか」テーブルを作っておき、
# マッチ位置を試す位置を少なくする。
def make_kmp_table(t):
    """"""
    tbl[i]: t[:x] == t[i-x:i] となる最大のx
    つまり、tのi文字目からみて後ろ何文字が、tのprefixと一致するか
    """"""
    i = 2
    j = 0
    m = len(t)
    tbl = [0] * (m + 1)
    tbl[0] = -1
    while i <= m:
        if t[i - 1] == t[j]:
            tbl[i] = j + 1
            i += 1
            j += 1
        elif j > 0:
            j = tbl[j]
        else:
            tbl[i] = 0
            i += 1
    return tbl


def kmp(s, t):
    matched_indices = []
    tbl = make_kmp_table(t)
    i = 0
    j = 0
    n = len(s)
    m = len(t)
    while i + j < n:
        if t[j] == s[i + j]:
            j += 1
            if j == m:
                matched_indices.append(i)
                i += j - tbl[j]
                j = tbl[j]
        else:
            i += j - tbl[j]
            if j > 0:
                j = tbl[j]
    return matched_indices


def main():
    S = input()
    T = input()
    ans = kmp(S, T)
    for i in ans:
        print(i)


if __name__ == ""__main__"":
    main()
"
4212390,ALDS1_14_B,"def main():
    T, P = input(), input()
    t, p = len(T), len(P)
    if t>=p:
        ans = [str(n) for n, i in enumerate(range(p, t+1)) if T[n:i]==P]
        if ans:
            print(""\n"".join(ans))

if __name__ == ""__main__"":
    main()
"
4716911,ALDS1_14_B,"import sys
input = sys.stdin.readline

def make_table(s):
    n = len(s)
    res = [-1]*(n+1)
    j = -1
    
    for i in range(n):
        while j>=0 and s[i]!=s[j]:
            j = res[j]
        
        j += 1
        res[i+1] = j
    
    return res

def kmp(s, w): #s中のwと一致する箇所の先頭インデックスのリストを作成
    table = make_table(w)
    res = []
    m, i, n = 0, 0, len(s)
    
    while m+i<n:
        if w[i]==s[m+i]:
            i += 1
            
            if i==len(w):
                res.append(m)
                m = m+i-table[i]
                i = table[i]
        else:
            m = m+i-table[i]
            
            if i>0:
                i = table[i]
    
    return res

T = input()[:-1]
P = input()[:-1]
res = kmp(T, P)

for res_i in res:
    print(res_i)
"
6663646,ALDS1_14_B,"import sys

# READ_FROM_FILE = True
READ_FROM_FILE = False


def main():
    if READ_FROM_FILE:
        f = open('test0.txt', 'r')
    else:
        f = sys.stdin

    src_str = f.readline().rstrip('\n')
    search_str = f.readline().rstrip('\n')

    for i in range(len(src_str)):
        if src_str.startswith(search_str, i):
            print(i)

    if READ_FROM_FILE:
        f.close()
    return


if __name__ == '__main__':
    main()

"
8970802,ALDS1_14_B,"P = 2305843009213693951


def power(x, n):
    ret = 1

    while 0 < n:
        if n & 1:
            ret = (ret * x) % P
        x = (x * x) % P
        n //= 2

    return ret


class RHash:
    __slots__ = [""val"", ""powered"", ""p""]

    def __init__(self, p: int, bs: bytes) -> None:
        self.p = p
        self.powered = power(p, len(bs) - 1)

        self.val = 0
        for b in bs:
            self.val = (self.val * p + b) % P

    def update(self, old, new):
        old = old * self.powered % P
        self.val = (self.val + P - old) % P
        self.val = (self.val * self.p + new) % P


def solve(x, y):
    hash0 = RHash(7129, x[:len(y)])
    hashes0 = [hash0.val]
    for i in range(1, len(x) - len(y) + 1):
        hash0.update(x[i - 1], x[i + len(y) - 1])
        hashes0.append(hash0.val)
    p0 = RHash(7129, y).val

    hash1 = RHash(581, x[:len(y)])
    hashes1 = [hash1.val]
    for i in range(1, len(x) - len(y) + 1):
        hash1.update(x[i - 1], x[i + len(y) - 1])
        hashes1.append(hash1.val)
    p1 = RHash(581, y).val

    for i in range(len(hashes0)):
        if hashes0[i] == p0 and hashes1[i] == p1:
            print(i)


if __name__ == ""__main__"":
    X = bytes(input(), ""ascii"")
    Y = bytes(input(), ""ascii"")
    solve(X, Y)

"
4572318,ALDS1_14_B,"import sys, collections
input = lambda: sys.stdin.readline().rstrip() 
sys.setrecursionlimit(10**7)
INF = 10**10
def I(): return int(input())
def F(): return float(input())
def SS(): return input()
def LI(): return [int(x) for x in input().split()]
def LI_(): return [int(x)-1 for x in input().split()]
def LF(): return [float(x) for x in input().split()]
def LSS(): return input().split()

def resolve():
    T = SS()
    P = SS()

    def contain(a, b):
        a = [ord(i) for i in a]
        b = [ord(i) for i in b]
        B = 10000007
        H = 100000007
        al = len(a)
        bl = len(b)
        if al>bl:
            return False

        t = pow(B, al, H)

        ah = 0
        bh = 0
        for i in range(al):
            ah = (ah * B + a[i]) % H
            bh = (bh * B + b[i]) % H

        for i in range(bl-al+1):
            if ah==bh:
                print(i)
            if i+al < bl:
                bh = (bh * B + b[i+al] - b[i] * t) % H

        return True

    contain(P, T)

if __name__ == '__main__':
    resolve()

"
5780194,ALDS1_14_B,"str_t = input()
str_p = input()

for i in range(len(str_t)):
    if str_t.startswith(str_p, i):
        print(i)
"
6054001,ALDS1_14_B,"t = input()
p = input()
for i in range(len(t)):
    if t.startswith(p, i):
        print(i)

"
5153361,ALDS1_14_B,"# scanf
text = str(input())
pattern = str(input())

# index
for i in range(len(text)):
    if text.startswith(pattern, i):
        print(i)
"
4079961,ALDS1_14_B,"# AOJ ALDS1_14_B ""String Search""
# returns i s.t. S[i+j] = T[j] for 0 <= j < len(T)

def RollingHash(S, T):
    if len(S) < len(T):
        return []
    # gcd(h, b) = 1
    h = 10**11+7
    b = 10**7+7
    L = len(T)

    bL = 1
    for i in range(L):
        bL = bL * b % h

    hashS = 0
    for i in range(L):
        hashS = (hashS * b + ord(S[i])) % h

    hashT = 0
    for i in range(L):
        hashT = (hashT * b + ord(T[i])) % h
    
    correctIndexes = []
    if hashS == hashT:
        correctIndexes.append(0)
    for j in range(len(S)-L):
        hashS = (hashS * b - ord(S[j])*bL + ord(S[L+j])) % h
        if hashS == hashT:
            correctIndexes.append(j+1)
    return correctIndexes


if __name__ == ""__main__"":
    import sys
    input = sys.stdin.readline

    S = input().rstrip()
    T = input().rstrip()

    ans = RollingHash(S, T)
    for a in ans:
        print(a)
"
3216144,ALDS1_14_B,"text=input()
string=input()


#common_length[i]は、探索列がstring[i]で探索を終了したときに、
# string[i-common_lneght[i] + 1] 〜string[i]で構成される文字列が、探索価値を持つことを示す



len_string=len(string)
common_length=[0]*len_string
tmp=0
tmp_tmp=0
for i in range(1,len_string):
    if(string[i]==string[tmp]):
        tmp_tmp=tmp
        while(string[i]==string[tmp_tmp] and tmp_tmp >0):
            tmp_tmp=common_length[max([tmp_tmp-1,0])]
        common_length[i-1]=tmp_tmp
        tmp+=1
    else:
        common_length[i-1]=tmp
        while(string[i]!=string[tmp] and tmp>0):
            tmp=common_length[max([tmp-1,0])]
        if(string[i]==string[tmp]):
            tmp+=1

if(string[-1]==string[tmp-1]):
    common_length[-1]=tmp
common_length[0]=0


tmp=0

for i in range(len(text)):
    if(text[i]!=string[tmp]):
        while(text[i]!=string[tmp] and tmp>0):
            tmp=common_length[max([tmp-1,0])]
        if(text[i]==string[tmp]):
            tmp+=1
    else:
        tmp+=1
        if(tmp==len_string):
            print(i-tmp+1)
            tmp=common_length[-1]



        



"
7763683,ALDS1_14_B,"def self_z_algorithm(P):
    L=len(P)
    Z=[0]*L
    # Z[0]=L: comment out when apply to Preproseccing of BM,(K)MP
    left,right=0,0
    for i in range(1,L):
        if right>=i:
            if Z[i-left]==right-i:
                while right<L and P[right]==P[right-i]:
                    right+=1
                Z[i]=right-i
                left=i
            else:
                Z[i]=min(Z[i-left],right-i)
        else:
            left,right=i,i
            while right<L and P[right]==P[right-i]:
                right+=1
            Z[i]=right-left
    return Z

def kmp(T,P):
    Z=self_z_algorithm(P)
    res=[]
    LT=len(T)
    LP=len(P)
    skip=[0]*LP

    right=1#skip[right]はまだ更新していない
    for i in range(1,LP):
        if i+Z[i]>=right:
            for j in range(right,min(i+Z[i]+1,LP)):
                skip[j]=j-i
            right=j+1

    t_p,p_p=0,0
    while t_p<LT:

        # print(t_p,p_p)

        if T[t_p]==P[p_p]:
            if p_p==LP-1:
                res.append(t_p+1-LP)
                p_p=skip[p_p]
                if LP==1:
                    t_p+=1
            else:
                t_p+=1
                p_p+=1
        else:
            if p_p==0:
                t_p+=1
            else:
                p_p=skip[p_p]
    
    return res

T=input()
P=input()
KMP=kmp(T,P)
for a in KMP:
    print(a)
"
7742634,ALDS1_14_B,"# 14_B.py String Search
# TODO: understand KMP https://daeudaeu.com/kmp/
# TODO: BM

# startswith: AC #18 0.22 Total 1.18
def startwith_search(T, P):
    for i in range(len(T) - len(P) + 1):
        if T.startswith(P, i):
            print(i)

# naive loop: #18 0.70 #20 4.99TLE
def naive_search(T, P):
    for i in range(len(T) - len(P) + 1):
        for j in range(len(P)):
            if T[i + j] != P[j]:
                break
        else:
            print(i)

# while loop: #18 0.50 #20 4.99TLE
def while_search(T, P):
    ilimit = len(T) - len(P) + 1
    jlimit = len(P)

    i = 0
    while i < ilimit:
        j = 0
        while j < jlimit:
            if T[i + j] != P[j]:
                break
            j += 1
        else:
            print(i)
        i += 1

# skip repeating character: AC #18 0.79 #20 0.80 #33 1.45 #34 1.47 Total 1.47
def skip_search(T, P):
    ilimit = len(T) - len(P) + 1
    jlimit = len(P)

    i = 0
    j = 0
    while i < ilimit:
        repeating = True
        ti = T[i]
        nj = j
        while j < jlimit:
            if T[i + j] != P[j]:
                break
            if repeating and P[j] == ti:
                nj += 1
            else:
                repeating = False
            j += 1
        else:
            print(i)
        j = max(0, nj - 1)
        i += 1


# KMP search: AC #18 0.46 #20 0.38 #33 0.93 #34 0.96 Total 0.96
def KMPsearch(T, P):

    def KMPtable():
        kmp = [-1, 0] # kmp[0]=-1, kmp[1]=0は確定 -1じゃないとだめ？っていうかいる？ 

        # ""MP""
        for i in range(2, len(P) + 1):
            j = kmp[i - 1]
            while j > 0 and P[i - 1] != P[j]:
                j = kmp[j]
            if P[i - 1] == P[j]:
                j += 1
            kmp.append(j)
        
        # ""K""による追加 あまりパフォーマンスは変わらなかった
        # i=0 (P[i]=-1) と i=len(P) (out of range)は除外
        for i in range(1, len(P)):
            if P[i] == P[kmp[i]]:
                kmp[i] = kmp[kmp[i]]

        return kmp

    kmp = KMPtable()
    tlen, plen = len(T), len(P)
    tpos = ppos = 0
    while tpos < tlen:
        if T[tpos] == P[ppos]:
            if ppos == plen - 1:
                print(tpos - ppos)
                tpos += 1
                ppos = kmp[plen] # 0に戻さなくていいの？
                continue
            tpos += 1
            ppos += 1
        else:
            if kmp[ppos] == kmp[0]: # kmp[0]っていつも-1なのでは？
                tpos += 1
                ppos = 0
            else:
                ppos = kmp[ppos]

# Rolling Hash: AC #18 0.63 #20 0.66 #33 1.48 #34 1.57 Total 1.57
def rolling_hash_search(t, p):
    BASE = 100000007
    MAX = 2**63 - 1

    pl, tl = len(p), len(t)
    if pl > tl:
        return

    t_pl = BASE ** pl % MAX

    ph = th = 0
    for i in range(pl):
        ph = (ph * BASE + ord(p[i])) % MAX
        th = (th * BASE + ord(t[i])) % MAX
    
    for i in range(0, tl - pl + 1):
        if ph == th:
            print(i)
        if i + pl < tl:
            th = (th * BASE + ord(t[i + pl]) - ord(t[i]) * t_pl) % MAX


# Rolling Hash 2: AC #18 0.63 #20 0.66 #33 1.48 #34 1.57 Total 1.57
def rolling_hash_search_2(T, P):
    BASE = 100000007
    MAX = 2**63 - 1

    t = [ord(e) for e in T]
    p = [ord(e) for e in P]

    pl, tl = len(p), len(t)
    if pl > tl:
        return

    t_pl = BASE ** pl % MAX

    ph = th = 0
    for i in range(pl):
        ph = (ph * BASE + p[i]) % MAX
        th = (th * BASE + t[i]) % MAX
    
    for i in range(0, tl - pl + 1):
        if ph == th:
            print(i)
        if i + pl < tl:
            th = (th * BASE + t[i + pl] - t[i] * t_pl) % MAX

T = input()
P = input()

# startwith_search(T,P)
# naive_search(T, P)
# while_search(T, P)
# skip_search(T, P)
# KMPsearch(T, P)
#rolling_hash_search(T, P)
rolling_hash_search_2(T, P)

"
6095566,ALDS1_14_B,"import sys
 
sys.setrecursionlimit(500005)
stdin = sys.stdin

ns = lambda: stdin.readline().strip()
ni = lambda: int(ns())
na = lambda: list(map(int, stdin.readline().split()))
nz = lambda: list(map(lambda x: int(x)-1, stdin.readline().split()))
mod = 1000000007 # 998244353

# SからTを検索する。前処理O(|T|)、検索O(|S|)
def make_KMP_table(T):
    A = [0] * (len(T)+1) # KMPテーブル
    A[0] = -1
    j = -1
    for i in range(len(T)):
        while j >= 0 and T[i] != T[j]:
            j = A[j]
        j += 1
        # MP法のborderがほしい時はここから↓
        if i+1 != len(T) and T[i+1] == T[j]:
            A[i+1] = A[j]
        else:
        # ↑ここまで消す
            A[i+1] = j
    return A

def KMP_search(S, A):
    m, i = 0, 0
    ret = []
    while m + i < len(S):
        if T[i] == S[m+i]:
            i += 1
            if i != len(T): continue
            ret.append(m) # Tを見つけたときの処理
        m = m + i - A[i]
        if i > 0: i = A[i] if A[i] > 0 else 0
    return ret

S = ns()
T = ns()

tab = make_KMP_table(T)
ans = KMP_search(S, tab)

for i in ans:
    print(i)
"
8770229,ALDS1_14_B,"t=input()
n=len(t)
p=input()
m=len(p)
b=100
mod=10**9+7

hash_t=[0]
ht=0

hash_p=0

for i in range(n):
    ti=ord(t[i])-ord('0')+1
    ht=b*ht+ti
    ht%=mod
    hash_t.append(ht)

for j in range(m):
    tj=ord(p[j])-ord('0')+1
    hash_p=b*hash_p+tj
    hash_p%=mod

for i in range(n-m+1):
    hash1=hash_t[i+m]-pow(b,m,mod)*hash_t[i]
    hash1%=mod
    if hash1==hash_p:
        print(i)
    
    
    
    
"
4904105,ALDS1_14_B,"

def main():
    text = input()
    len_text = len(text)
    pattern = input()
    len_pattern = len(pattern)

    for i in range(len_text - len_pattern + 1):
        if text[i:i+len_pattern] == pattern:
            print(i)
    return


main()

"
6305055,ALDS1_14_B,"from token import LPAR


T = input()
P = input()
mod = 10**9+7
ph = 0
th = 0
pow = 77
letter = ""abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890""
d = {letter[i]:i for i in range(62)}
lp = len(P)
lt = len(T)
if lp<=lt:
    for i in range(len(P)):
        ph*=pow
        ph+=d[P[i]]
        ph%=mod
        th*=pow
        th+=d[T[i]]
        th%=mod
    rightp = 1
    for i in range(len(P)):
        rightp*=pow
        rightp%=mod
    for i in range(len(T)-lp):
        if th == ph:
            print(i)
        th*=pow
        th-=rightp*d[T[i]]
        th+=d[T[i+lp]]
        th%=mod
    if th == ph:
        print(len(T)-lp)
"
8153719,ALDS1_14_B,"# Naive String Search

T = input()
P = input()

ans = []
t_len = len(T)
p_len = len(P)

for i in range(t_len-p_len+1):
    if T[i:p_len+i] == P:
        ans.append(i)

for i in ans:
    print(i)

"
6456665,ALDS1_14_B,"def naive_string_matcher(t: str, p: str):
    n, m = map(len, (t, p))
    for s in range(n - m + 1):
        if t[s:s + m] == p:
            print(s)


def main():
    T = input()
    P = input()
    naive_string_matcher(T, P)


main()

"
3243592,ALDS1_14_B,"def main():
    text = input()
    len_text = len(text)
    pattern = input()
    len_pattern = len(pattern)

    for i in range(len_text - len_pattern + 1):
        if text[i:i+len_pattern] == pattern:
            print(i)
    return


main()
"
6212264,ALDS1_14_B,"import sys


def search(T, P):
    results = []

    for i in range(len(T) - len(P) + 1):
        temp = T[i:i + len(P)]
        if temp == P:
            results.append(i)

    for r in results:
        print(r)


if __name__ == '__main__':
    T = sys.stdin.readline()
    P = sys.stdin.readline().strip(""\n"")

    search(T, P)
"
3671475,ALDS1_14_B,"def main():
    text = input()
    len_text = len(text)
    pattern = input()
    len_pattern = len(pattern)

    for i in range(len_text - len_pattern + 1):
        if text[i:i+len_pattern] == pattern:
            print(i)
    return


main()

"
2810378,ALDS1_14_B,"# -*- coding: utf-8 -*-
import sys


def main():
    inputStr = sys.stdin.read()
    lines = inputStr.split(""\n"")
    text, word = lines[0], lines[1]
    word_length = len(word)
    for i in range(len(text) - word_length + 1):
        if word == text[i:(i + word_length)]:
            print(i)


if __name__ == '__main__':
    main()

"
3872012,ALDS1_14_B,"# -*- coding: utf-8 -*-

import sys

def input(): return sys.stdin.readline().strip()
def list2d(a, b, c): return [[c] * b for i in range(a)]
def list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]
def list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]
def ceil(x, y=1): return int(-(-x // y))
def INT(): return int(input())
def MAP(): return map(int, input().split())
def LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]
def Yes(): print('Yes')
def No(): print('No')
def YES(): print('YES')
def NO(): print('NO')
sys.setrecursionlimit(10 ** 9)
INF = float('inf')
MOD = 10 ** 9 + 7

T = input()
P = input()
N = len(T)
M = len(P)

ans = []
p = P
for i in range(N-M+1):
    # Tの区間[i,i+M)の文字列を取得
    t = T[i:i+M]
    if t == p:
        ans.append(i)

if len(ans):
    [print(i) for i in ans]

"
2823212,ALDS1_14_B,"def f():
 T,P=input(),input()
 for i in range(len(T)):P!=T[i:i+len(P)]or print(i)
f()
"
4754018,ALDS1_14_B,"T = input()
P = input()

mod = 2 << 61-1
base = 1293

def gethash(S):
    H = 0
    b = 1
    for s in S[::-1]:
        H = (H + ord(s) * b) % mod
        b = b * base % mod
    return H

lp = len(P)
Hp = gethash(P)
Hs = gethash(T[:lp])
m = pow(base, lp, mod)

for i in range(len(T)-lp):
    if Hs == Hp:
        print(i)
    Hs = (Hs * base - ord(T[i]) * m + ord(T[i+lp])) % mod
if Hs == Hp:
    print(len(T)-lp)

"
4323255,ALDS1_14_B,"def Main():
    text = input()
    pattern = input()

    for i in range(len(text) - len(pattern) + 1):
        if text[i : i + len(pattern)] == pattern:
            print(i)

Main()
"
7090663,ALDS1_14_B,"def resolve():
    import sys

    input = sys.stdin.readline
    r = RollingHash()
    s = input().rstrip()
    t = input().rstrip()
    if len(s) < len(t):
        return
    x = r.get_hash(t)
    for i, j in enumerate(r.gen_hash_list(s, len(t))):
        if j == x:
            print(i)


class RollingHash:
    # verified: https://bit.ly/3LGs1ch
    m = 2305843009213693951  # (1 << 61) - 1
    r = None
    msk30 = 1073741823  # (1 << 30) - 1
    msk31 = 2147483647  # (1 << 31) - 1
    rp = {}

    def __init__(self, r: int = None) -> None:
        if self.r is None:
            if r is None:
                import random

                r = random.randint(2, self.m - 2)
            self.r = r

    def _mul(self, a: int, b: int) -> int:
        au = a >> 31
        ad = a & self.msk31
        bu = b >> 31
        bd = b & self.msk31
        mid = ad * bu + au * bd
        midu = mid >> 30
        midd = mid & self.msk30
        return (au * bu * 2 + midu + (midd << 31) + ad * bd) % self.m

    def _powr(self, n: int) -> int:
        if n not in self.rp:
            self.rp[n] = pow(self.r, n, self.m)
        return self.rp[n]

    def hash_list(self, s: str, length: int) -> list:
        n = len(s)
        res = [None] * (n - length + 1)
        x = 0
        for i in s[:length]:
            x *= self.r
            x += ord(i)
            x %= self.m
        res[0] = x
        denom = self._powr(length - 1)
        for i, (j, k) in enumerate(zip(s[length:], s[:-length])):
            x -= ord(k) * denom
            x *= self.r
            x += ord(j)
            x %= self.m
            res[i + 1] = x
        return res

    def gen_hash_list(self, s: str, length: int) -> int:
        x = 0
        for i in s[:length]:
            x *= self.r
            x += ord(i)
            x %= self.m
        yield x
        denom = self._powr(length - 1)
        for i, (j, k) in enumerate(zip(s[length:], s[:-length])):
            x -= ord(k) * denom
            x *= self.r
            x += ord(j)
            x %= self.m
            yield x

    def all_hash_list(self, s: str):
        return [self.hash_list(s, i + 1) for i in range(len(s))]

    def head_hash_list(self, s: str):
        # res[i]:前方i文字のHash
        res = [0] * (len(s) + 1)
        for i, j in enumerate(s):
            res[i + 1] = (res[i] * self.r + ord(j)) % self.m
        return res

    def tail_hash_list(self, s: str):
        # res[i]:後方i文字のHash
        res = [0] * (len(s) + 1)
        x = 1
        for i, j in enumerate(reversed(s)):
            res[i + 1] = (res[i] + x * ord(j)) % self.m
            x = x * self.r
        return res

    def get_hash(self, s_or_head_list, l: int = 0, r: int = None) -> int:
        if type(s_or_head_list) is str:
            if r is None:
                return next(
                    self.gen_hash_list(s_or_head_list[l:], len(s_or_head_list) - l)
                )
            else:
                if l == r:
                    return 0
                g = self.gen_hash_list(s_or_head_list[l:], r - l)
                for _ in range(r - l - 1):
                    next(g)
                return next(g)
        # verified: https://bit.ly/3ScyApH
        if r is None:
            r = len(s_or_head_list) + 1
        return (s_or_head_list[r] - s_or_head_list[l] * self._powr(r - l)) % self.m


if __name__ == ""__main__"":
    resolve()

"
4410265,ALDS1_14_B,"T = input()
P = input()


p = len(P)
for i in range(len(T)-p+1):
    if T[i:i+p] == P:
        print(i)
"
5449981,ALDS1_14_B,"from random import randrange

class RollingHash:
    @classmethod
    def hash_make(cls,strng,mod,r):
        digit=r
        out=[0]*len(strng)
        out[0]=ord(strng[0])%mod
        for i,x in enumerate(strng[1:],1):
            out[i]=(out[i-1]+digit*ord(x))%mod
            digit=(digit*r)%mod
        return out

    @classmethod
    def pattern_search(cls,strng,pattern,mod=2**61-1):
        r=randrange(1,mod)
        hash_list=cls.hash_make(strng,mod,r)
        pattern_value=cls.hash_make(pattern,mod,r)[-1]
        n,m=len(strng),len(pattern)
        out=set()

        if hash_list[m-1]==pattern_value : out.add(0)
        for i in range(1,n-m+1):
            pattern_value=(pattern_value*r)%mod
            if (hash_list[i+m-1]-hash_list[i-1])%mod==pattern_value:
                out.add(i)
        return out


def main():
    s=input()
    t=input()
    if len(s)<len(t) : return 
    s=RollingHash.pattern_search(s,t)
    for i in sorted(s) : print(i)

main()
"
7059248,ALDS1_14_B,"def solve():
    t = input()
    p = input()
    for i in range(len(t) - len(p) + 1):
        if t[i:i + len(p)] == p:
            print(i)


if __name__ == ""__main__"":
    solve()

"
5034915,ALDS1_14_B,"import sys
def input(): return sys.stdin.readline().strip()
def mapint(): return map(int, input().split())
sys.setrecursionlimit(10**9)

base = 10
Ts = [ord(t) for t in list(input())]
Ps = [ord(p) for p in list(input())]
mod = 10**9 + 7

plen = len(Ps)
tlen = len(Ts)
p = 0
for i in range(plen):
    p += Ps[i]*pow(10, plen-i-1, mod)
    p %= mod

if len(Ts)<plen:
    exit()

rolling = 0
for i in range(plen):
    rolling += Ts[i]*pow(10, plen-i-1, mod)
    rolling %= mod

if p==rolling:
    print(0)

powp = pow(10, plen, mod)
for i in range(plen, tlen):
    rolling = rolling*10 - Ts[i-plen]*powp + Ts[i]
    rolling %= mod
    if rolling==p:
        print(i-plen+1)
"
5329503,ALDS1_14_B,"def main():
    t = input()
    p = input()
    start = 0
    end = len(p)
    while end <= len(t):
        if t[start:end] == p:
            print(start)
        start += 1
        end += 1

if __name__ == '__main__':
    main()
"
7855593,ALDS1_14_B,"import collections

def create_bad_calacter_heuristic_table(t):
    table = collections.defaultdict(lambda: -1)
    for k, c in enumerate(t):
        table[c] = k
    return table


def create_good_suffix_heuristic_table(t):
    f = [0] * (len(t) + 1)
    j = len(t) + 1
    f[len(t)] = j
    for k in reversed(range(1, len(t) + 1)):
        while j <= len(t) and t[k - 1] != t[j - 1]:
            j = f[j]
        f[k - 1] = j - 1
        j -= 1

    table = [0] * (len(t) + 1)
    for k in reversed(range(1, len(t) + 1)):
        j = f[k]
        while j <= len(t) and t[k - 1] != t[j - 1]:
            if table[j] == 0:
                table[j] = j - k
            j = f[j]

    k = f[0]
    for j in range(len(t) + 1):
        if table[j] == 0:
            table[j] = k
        if j == k:
            k = f[k]

    return table


def boyer_moore_search(s, t):
    bad_calacter_heuristic_table = create_bad_calacter_heuristic_table(t)
    good_suffix_heuristic_table = create_good_suffix_heuristic_table(t)
    i = 0
    offset = 0
    res = []
    while i + len(t) <= len(s):
        j = len(t) - 1
        k = i
        while j >= offset and s[i + j] == t[j]:
            j -= 1
        if j < offset:
            j = -1
            res.append(i)
            shift = good_suffix_heuristic_table[0]
        else:
            shift = max(j - bad_calacter_heuristic_table[s[i + j]], good_suffix_heuristic_table[j + 1])
        offset = len(t) - shift if j < shift <= len(t) else 0
        i += shift
    return res


a = input()
b = input()
for i in boyer_moore_search(a, b):
    print(i)

"
2474805,ALDS1_14_B,"#!/usr/bin/python
B=999999937
P=1000000007

def gen_hash(s,hash):
	c=0
	for i in range(len(s)):
		c=(c*B+s[i])%P
		hash[i]=c

import sys
s=[ord(e) for e in sys.stdin.readline().strip()]
ls=len(s)
v=[0]*ls
hsh=[0]*10001
gen_hash(s,v)
q=[ord(e) for e in sys.stdin.readline().strip()]
lq=len(q)
gen_hash(q,hsh)
hash=hsh[lq-1]
Brev=pow(B,lq,P)
r=[]
for i in range(lq-1,ls):
	if v[i]==((v[i-lq] if i>=lq else 0)*Brev+hash)%P:
		r.append(i-lq+1)
for e in r:print(e)
"
3110123,ALDS1_14_B,"T = input()
P = input()
p = len(P)
for i in range(len(T)-p+1):
    if T[i:i+p]==P:
        print(i)
"
4616796,ALDS1_14_B,"T = input()
P = input()
len_P = len(P)

for i in range(len(T)-len_P+1):
    if T[i:i+len_P] == P:
        print(i)

"
4760120,ALDS1_14_B,"t = input()
p = input()
t_len = len(t)
p_len = len(p)

for i in range(0, t_len - p_len + 1):
    if t[i:i + p_len] == p:
        print(i)
"
5518898,ALDS1_14_B,"s0 = input()
s1 = input()

'''
ret = -1
while True:
    ret = s0.find(s1, ret + 1)
    if ret == -1:
        break
    print(ret)
'''

size = len(s1)
for i0 in range(len(s0) - size + 1):
    if s0[i0:i0+size] == s1:
        print(i0)
"
3629223,ALDS1_14_B,"T = input()
P = input()

lt = len(T)
lp = len(P)

for i in range(lt - lp + 1):
    if T[i:i+lp] == P:
        print(i)







"
7859047,ALDS1_14_B,"txt = input()
chr = input()
n = len(chr)

for i in range(len(txt)+1-n):
  if txt[i:i+n] == chr:
    print(i)
"
3807928,ALDS1_14_B,"if __name__ == ""__main__"":
    input_str = input()
    target_str = input()
    target_str_len = len(target_str)

    for idx in range(len(input_str) - target_str_len + 1):
        if target_str == input_str[idx: idx + target_str_len]:
            print(idx)

"
3897643,ALDS1_14_B,"T = input()
P = input()
t = len(T)
p = len(P)
for i in range(t-p+1):
    if P == T[i:i+p]:
        print(i)

"
6029448,ALDS1_14_B,"word = input()
target = input()
n = len(target)
for i in range(len(word)):
    if target == word[i:i + n]:
        print(i)
"
7744984,ALDS1_14_B,"# ローリングハッシュによる一致検索
# s, tが英小文字からなることを仮定している
class RollingHash:
    def __init__(self, s, mod=(1 << 61) - 1, base=107):
        self.s = s + ""#""
        self.l = len(s)
        self.mod = mod
        self.base = base

    def is_contain(self, t):
        if len(t) > self.l:
            return False

        lt = len(t)
        hash_t = self.hash(t)
        hash_s = self.hash(self.s[:lt])

        minus = pow(self.base, lt - 1, self.mod)
        for i in range(lt, self.l - 1):
            if hash_s == hash_t:
                return True
            hash_s -= minus * (ord(self.s[i - lt]) - ord(""a"") + 1)
            hash_s *= self.base
            hash_s += ord(self.s[i]) - ord(""a"") + 1
            hash_s %= self.mod
        return False

    def find_all(self, t):
        if len(t) > len(self.s):
            return []

        lt = len(t)
        hash_t = self.hash(t)
        hash_s = self.hash(self.s[:lt])
        same_idx = []

        minus = pow(self.base, lt - 1, self.mod)
        for i in range(lt, self.l + 1):
            # print(hash_s, hash_t, i, lt, self.l)
            if hash_s == hash_t:
                same_idx.append(i - lt)
            hash_s -= minus * (ord(self.s[i - lt]) - ord(""a"") + 1)
            hash_s *= self.base
            hash_s += ord(self.s[i]) - ord(""a"") + 1
            hash_s %= self.mod
        return same_idx

    def hash(self, s):
        hash_s = 0
        for i in s:
            hash_s *= self.base
            hash_s += ord(i) - ord(""a"") + 1
            hash_s %= self.mod
        return hash_s


s = input()
t = input()
rh = RollingHash(s)
for i in rh.find_all(t):
    print(i)
# print(*rh.find_all(t), sep=""\n"")

"
4795456,ALDS1_14_B,"T=input()
P=input()
length_p=len(P)
for i in range(len(T)-length_p+1):
    if T[i:i+length_p]==P:
        print(i)
"
6811387,ALDS1_14_B,"def main():
    t = input()
    p = input()

    for i in range(len(t) - len(p) + 1):
        if t[i] == p[0]:
            if t[i : i + len(p)] == p:
                print(i)


if __name__ == ""__main__"":
    main()

"
6706537,ALDS1_14_B,"T=input()
m=len(T)
P=input()
n=len(P)
for i in range(0,m-n+1):
    if T[i:i+n]==P:
        print(i)


"
7320487,ALDS1_14_B,"
import sys
input = lambda: sys.stdin.readline().rstrip()

class RollingHash61:
    __slots__ = 'base', 'maxlen'
    # mod 2**61 - 1 参考 : https://qiita.com/keymoon/items/11fac5627672a6d6a9f6
    # C# や C++ の話なので、Pythonで早くなるかは要検証
    # 高速化参考 : https://github.com/strangerxxxx/kyopro/blob/main/python/%E6%96%87%E5%AD%97%E5%88%97/Rolling%20Hash.py
    MODh = 2305843009213693951  # = 2**61 - 1
    MASK31 = 2147483647  # = 2**31 - 1
    MASK30 = 1073741823  # = 2**30 - 1
    powB = []

    def __init__(self, maxlen, base=None):
        '''RollingHash を MOD = 2**61 - 1 で
       Args:
            maxlen(int): hash化する文字列の最長
            base(int): 基数 省略でランダムに選ぶ
        '''
        self.maxlen = maxlen
        if base is None:
            import random
            base = random.randint(2, self.MODh - 2)
        self.base = base
    
    def initpowB(self):
        self.powB.append(1)
        for i in range(self.maxlen):
            self.powB.append(self.mul(self.powB[-1], self.base))

    # Pythonでは使わない方が速い？
    # def mul(self, a, b):
    #     au = a >> 31
    #     ad = a & self.MASK31
    #     bu = b >> 31
    #     bd = b & self.MASK31
    #     mid = ad * bu + au * bd
    #     midu = mid >> 30
    #     midd = mid & self.MASK30
    #     return (au * bu * 2 + midu + (midd << 31) + ad * bd) % self.MODh
    
    def getHashList_head(self, S):
        '''文字列をハッシュ化する O(|S|)
        Args:
            S(str): ハッシュ化する文字列
        Returns:
            list[int]: S[:i]をハッシュ化した整数列
        '''
        res = [0]*(len(S)+1)
        for i in range(len(S)):
            h = res[i] * self.base
            h += ord(S[i])
            h %= self.MODh
            res[i+1] = h
        return res
    
    def getHashList_tail(self, S):
        '''文字列を逆順にハッシュ化する O(|S|)
        Args:
            S(str): ハッシュ化する文字列
        Returns:
            list[int]: S[N-1 : N-i-1 : -1]をハッシュ化した整数列
        '''
        res = [0]*(len(S)+1)
        for i in range(len(S)):
            h = res[i] * self.base 
            h += ord(S[-i-1])
            h %= self.MODh
            res[i+1] = h
        return res
    
    def generateHash(self, S, length):
        '''Sの連続するlength文字のハッシュを順に生成する
        使い方:
            for h in generateHash(S, length):
                ...
            や
            f = generateHash(S, length)
            h = next(f)
            など
        Args:
            S(str): ハッシュ化する文字列
            length(int): 抜き出す長さ
        Returns:
            int: 連続length文字のハッシュ値
        '''
        res = 0
        for i in range(length):
            res *= self.base
            res += ord(S[i])
            res %= self.MODh
        yield res
        d = pow(self.base, length-1, self.MODh)
        for i in range(len(S) - length):
            s, t = ord(S[i]), ord(S[length + i])
            res -= s * d
            res *= self.base
            res += t
            res %= self.MODh
            yield res
    
    def getHash(self, hash, l, r):
        '''ハッシュ化された文字列の[l, r)のハッシュを得る O(1)
        Args:
            hash(list[int]): ハッシュ
            l(int): 左端のindex
            r(int): 右端のindex
        Returns:
            int: S[l, r)のハッシュ
        '''
        if not self.powB:
            self.initpowB()
        return (hash[r] - hash[l] * self.powB[r-l]) % self.MODh
    
    def getConcatHash(self, hash, ranges):
        '''複数の区間を結合した文字列のハッシュを得る O( |ranges|)
        Args:
            hash(list[int]): ハッシュ
            ranges (list[list[int]]): 結合したい[l, r)リスト
        Returns:
            int: 結合した文字列のハッシュ
        '''
        res = self.getHash(hash, *ranges[0])
        for i in range(1, len(ranges)):
            l, r = ranges[i]
            res *= self.powB[r-l]
            res += self.getHash(hash, l, r)
            res %= self.MODh
        return res

def main():
    # 入力
    T = input()
    P = input()
    if len(T) < len(P):
        return
    # 計算・出力
    RH = RollingHash61(len(T))
    hashP = RH.getHashList_head(P)[-1]
    for i, h in enumerate(RH.generateHash(T, len(P))):
        if h == hashP:
            print(i)

if __name__ == ""__main__"":
    main()

"
7705596,ALDS1_14_C,"import sys
import os

istest=False
fn = ""inputdata.txt""
if os.path.exists(fn):
    istest=True
    sys.stdin = open(fn)

class KMP2D:
    def __init__(self, pattern,R):
        self.pattern_l = R
        self.table = [0] * (self.pattern_l+1)
        self.table[0] = -1
        c = 0
        for k in range(1, self.pattern_l):
            if pattern[k] == pattern[c]:
                self.table[k] = self.table[c]
            else:
                self.table[k] = c
                c = self.table[c]
                while c >= 0 and pattern[k] != pattern[c]:
                    c = self.table[c]
            c += 1
        self.table[self.pattern_l] = c
        self.pattern = pattern
        
    def match(self, target,target_height,target_width,pattern_width):
        rec=[]
        for k in range(target_width-pattern_width+1):
            i = j = 0
            while i < target_height:
                if target[i][k:k+pattern_width] == self.pattern[j]:
                    i += 1; j += 1
                    if j == self.pattern_l:
                        rec.append((i-j,k))
                        j = self.table[j]
                else:
                    j = self.table[j]
                    if j < 0:
                        i += 1
                        j += 1
        return rec

H,W=map(int,sys.stdin.readline().split())
TM=[sys.stdin.readline().rstrip() for _ in range(H)]
R,C=map(int,sys.stdin.readline().split())
PM=[sys.stdin.readline().rstrip() for _ in range(R)]

kmp=KMP2D(PM,R)
rec=kmp.match(TM,H,W,C)
rec.sort()
for item in rec:
    print(*item)
"
2731549,ALDS1_14_C,"base1 = 1009
base2 = 1013
mask = (1 << 32) - 1
def calc_hash(f, r, c):
    global ph, pw, h
    tmp = [[0] * c for _ in range(r)]
    dr, dc = r - ph, c - pw
    t1 = 1
    for _ in range(pw):
        t1 = (t1 * base1) & mask
    for i in range(r):
        e = 0
        for j in range(pw):
            e = e * base1 + f[i][j]
        for j in range(dc):
            tmp[i][j] = e
            e = (e * base1 - t1 * f[i][j] + f[i][j + pw]) & mask
        tmp[i][dc] = e
    t2 = 1
    for _ in range(ph):
        t2 = (t2 * base2) & mask
    for j in range(dc + 1):
        e = 0
        for i in range(ph):
            e = e * base2 + tmp[i][j]
        for i in range(dr):
            h[i][j] = e
            e = (e * base2 - t2 * tmp[i][j] + tmp[i + ph][j]) & mask
        h[dr][j] = e
th, tw = map(int, input().split())
t = tuple(tuple(ord(c) for c in input()) for _ in range(th))
ph, pw = map(int, input().split())
p = tuple(tuple(ord(c) for c in input()) for _ in range(ph))
ans = []
if th >= ph and tw >= pw:
    h = [[0] * tw for _ in range(th)]
    calc_hash(p, ph, pw)
    key = h[0][0] & mask
    calc_hash(t, th, tw)
    for i in range(th - ph + 1):
        for j in range(tw - pw + 1):
            if h[i][j] & mask == key:
                ans.append(f""{i} {j}"")
if ans:
    print(""\n"".join(a for a in ans))
"
1669168,ALDS1_14_C,"base1 = 1009
base2 = 1013
mask = (1 << 32) - 1


def calc_hash(f, r, c):
    global ph, pw, h
    tmp = [[0] * c for _ in range(r)]
    dr, dc = r - ph, c - pw

    t1 = 1
    for _ in range(pw):
        t1 = (t1 * base1) & mask
    for i in range(r):
        e = 0
        for j in range(pw):
            e = e * base1 + f[i][j]
        for j in range(dc):
            tmp[i][j] = e
            e = (e * base1 - t1 * f[i][j] + f[i][j + pw]) & mask
        tmp[i][dc] = e

    t2 = 1
    for _ in range(ph):
        t2 = (t2 * base2) & mask
    for j in range(dc + 1):
        e = 0
        for i in range(ph):
            e = e * base2 + tmp[i][j]
        for i in range(dr):
            h[i][j] = e
            e = (e * base2 - t2 * tmp[i][j] + tmp[i + ph][j]) & mask
        h[dr][j] = e


th, tw = map(int, input().split())
t = [[ord(c) for c in input().strip()] for _ in range(th)]
ph, pw = map(int, input().split())
p = [[ord(c) for c in input().strip()] for _ in range(ph)]

if th >= ph and tw >= pw:
    h = [[0] * tw for _ in range(th)]
    calc_hash(p, ph, pw)
    key = h[0][0] & mask
    calc_hash(t, th, tw)
    for i in range(th - ph + 1):
        for j in range(tw - pw + 1):
            if h[i][j] & mask == key:
                print(i, j)
"
3809155,ALDS1_14_C,"from typing import List


def calc_hash(tab: List[List[int]], row_num: int, col_num: int) -> None:
    global hash_table, R, C, baes1, base2, mask
    tmp_table = [[0] * col_num for _ in range(row_num)]
    diff_row, diff_col = row_num - R, col_num - C

    bit_mask = 1
    for _ in range(C):
        bit_mask = (bit_mask * base1) & mask
    for r in range(row_num):
        hash_v = 0
        for c in range(C):
            hash_v = hash_v * base1 + tab[r][c]
        for dc in range(diff_col):
            tmp_table[r][dc] = hash_v
            hash_v = (hash_v * base1 - bit_mask * tab[r][dc] + tab[r][dc + C]) & mask
        tmp_table[r][diff_col] = hash_v

    bit_mask = 1
    for _ in range(R):
        bit_mask = (bit_mask * base2) & mask
    for c in range(diff_col + 1):
        hash_v = 0
        for r in range(R):
            hash_v = hash_v * base2 + tmp_table[r][c]
        for dr in range(diff_row):
            hash_table[dr][c] = hash_v
            hash_v = (hash_v * base2 - bit_mask * tmp_table[dr][c]
                      + tmp_table[dr + R][c]) & mask
        hash_table[diff_row][c] = hash_v


if __name__ == ""__main__"":
    base1 = 1009  # The first prime number over 1000.
    base2 = 1013  # The second prime number over 1000.
    mask = (1 << 32) - 1  # Mask.

    H, W = map(lambda x: int(x), input().split())
    region = [[0] * W for _ in range(H)]
    for row in range(H):
        region[row] = [ord(s) for s in input()]

    R, C = map(lambda x: int(x), input().split())
    pattern = [[0] * C for _ in range(R)]
    for row in range(R):
        pattern[row] = [ord(s) for s in input()]

    if H >= R and W >= C:
        hash_table = [[0] * W for _ in range(H)]
        calc_hash(pattern, R, C)  # Calc the target hash and save it into hash_table[0][0]
        key = hash_table[0][0] & mask
        calc_hash(region, H, W)
        for r in range(H - R + 1):
            for c in range(W - C + 1):
                if key == hash_table[r][c] & mask:
                    print(f""{r} {c}"")

"
7743128,ALDS1_14_C,"# 14_C.py Pattern Search
# TODO: use more sophisticated algorithm

from sys import stdin
from typing import List

# naive 4-nested loop -> TLE #12 9.45s #13 4.52s
# def solve(H: int, W: int, F: List[List[str]], R: int, C: int, P:List[List[str]]) -> None:

#     def match(h: int, w: int) -> bool:
#         for r in range(R):
#             for c in range(C):
#                 if F[h + r][w + c] != P[r][c]:
#                     return False
#         return True

#     for h in range(H - R + 1):
#         for w in range(W - C + 1):
#             if match(h, w):
#                 print(h, w)

# H, W = [int(e) for e in stdin.readline().split()]
# F = [list(stdin.readline().strip()) for _ in range(H)]
# R, C = [int(e) for e in stdin.readline().split()]
# P = [list(stdin.readline().strip()) for _ in range(H)]


# use string -> #21 TLE #12 1.83s #13 0.95s -> slower!!
# def solve(H: int, W: int, F: List[str], R: int, C: int, P:List[str]) -> None:

#     def match(h: int, w: int) -> bool:
#         for r in range(0, R):
#             if F[h + r][w:w + C] != P[r]:
#                 return False
#         return True

#     for h in range(H - R + 1):
#         for w in range(W - C + 1):
#             if match(h, w):
#                 print(h, w)

# use find -> #21 TLE #12 1.96s #13 1.00s -> slower!!
# def solve(H: int, W: int, F: List[str], R: int, C: int, P:List[str]) -> None:

#     def match(h: int, w: int) -> bool:
#         for r in range(1, R):
#             if F[h + r][w:w + C] != P[r]:
#                 return False
#         return True

#     for h in range(H - R + 1):
#         w = -1
#         while w <= W - C:
#             w = F[h].find(P[0], w + 1)
#             if w < 0:
#                 break
#             if match(h, w):
#                 print(h, w)

BASE = 100000007
BASE2 = 1000000007
MAX = 2**63 - 1

def hash(t: List[int], base=BASE) -> int:
    th = 0
    for i in range(len(t)):
        th = (th * base + t[i]) % MAX
    return th

def hash_table(t: List[int], pl: int, base=BASE) -> List[int]:

    tl = len(t)

    t_pl = base ** pl % MAX
    th = hash(t[:pl], base)
    table = []    
    for i in range(0, tl - pl + 1):
        table.append(th)
        if i + pl < tl:
            th = (th * base + t[i + pl] - t[i] * t_pl) % MAX

    return table

def solve(H: int, W: int, F: List[str], R: int, C: int, P:List[str]) -> None:

    ph = hash([hash([ord(e) for e in r]) for r in P], BASE2)

    th1 = []
    for h in range(H):
        th1.append(hash_table([ord(e) for e in F[h]], C))

    th2: List[List[int]] = [[] for _ in range(H - R + 1)]
    for w in range(W - C + 1):
        colh = hash_table([th1[h][w] for h in range(H)], R, BASE2)
        for h in range(H - R + 1):
            th2[h].append(colh[h])

    for h in range(H - R + 1):
        for w in range(W - C + 1):
            # print(th2[h][w])
            # print(ph)
            if th2[h][w] == ph:
                print(h, w)
    
H, W = [int(e) for e in stdin.readline().split()]
F = [stdin.readline().strip() for _ in range(H)]
R, C = [int(e) for e in stdin.readline().split()]
P = [stdin.readline().strip() for _ in range(R)]

solve(H, W, F, R, C, P)

"
3047642,ALDS1_14_C,"base1 = 1009
base2 = 1013
mask = (1 << 32) - 1


def calculate_hash(f, r, c):
    global ph, pw, h
    tmp = [[0 for _ in range(c)] for _ in range(r)]
    dr, dc = r - ph, c - pw

    t1 = 1
    for _ in range(pw):
        t1 = (t1 * base1) & mask
    for i in range(r):
        e = 0
        for j in range(pw):
            e = e * base1 + f[i][j]
        for j in range(dc):
            tmp[i][j] = e
            e = (e * base1 - t1 * f[i][j] + f[i][j + pw]) & mask
        tmp[i][dc] = e

    t2 = 1
    for _ in range(ph):
        t2 = (t2 * base2) & mask
    for j in range(dc + 1):
        e = 0
        for i in range(ph):
            e = e * base2 + tmp[i][j]
        for i in range(dr):
            h[i][j] = e
            e = (e * base2 - t2 * tmp[i][j] + tmp[i + ph][j]) & mask
        h[dr][j] = e


th, tw = map(int, input().split())
t = [[ord(x) for x in input().strip()] for _ in range(th)]
ph, pw = map(int, input().split())
p = [[ord(x) for x in input().strip()] for _ in range(ph)]

if th >= ph and tw >= pw:
    h = [[0 for _ in range(tw)] for _ in range(th)]
    calculate_hash(p, ph, pw)
    key = h[0][0] & mask
    calculate_hash(t, th, tw)
    for i in range(th - ph + 1):
        for j in range(tw - pw + 1):
            if h[i][j] & mask == key:
                print(i, j)
"
5071702,ALDS1_14_C,"from sys import stdin, stdout
read = stdin.readline
write = stdout.write

def roll_hash_2d(p, base1, base2, mod):
    
    li = len(p)
    lj = len(p[0])

    hshj = [[0] * (lj + 1)] + [[0, ] for _ in range(li)]
    for i in range(li):
        hshjx = 0
        for j in range(lj):
            hshjx = (hshjx * base1 + ord(p[i][j])) % mod
            hshj[i + 1].append(hshjx)
    
    hsh = [[0] * (lj + 1)] + [[0, ] for _ in range(li)]
    for j in range(lj):
        hshx = 0
        for i in range(li):
            hshx = (hshx * base2 + hshj[i + 1][j + 1]) % mod
            hsh[i + 1].append(hshx)

    return hsh


def window(hsh, width, height, base1, base2, mod):

    hsh_w = len(hsh[0])
    hsh_h = len(hsh)

    pw1 = 1
    for _ in range(width):
        pw1 = pw1 * base1 % mod

    pw2 = 1
    for _ in range(height):
        pw2 = pw2 * base2 % mod

    pw12 = pw1 * pw2 % mod

    res = []
    for i in range(hsh_h - height):
        res.append([])
        for j in range(hsh_w - width):
            res[i].append((hsh[i + height][j + width] - hsh[i][j + width] * pw2 - hsh[i + height][j] * pw1 + hsh[i][j] * pw12) % mod)

    return res


def main():

    h, _ = map(int, read().split())
    r = [read().strip() for _ in range(h)]
    hx, wx = map(int, read().split())
    rx = [read().strip() for _ in range(hx)]

    r = roll_hash_2d(r, 1007, 1597, 2**31-1)
    rx = roll_hash_2d(rx, 1007, 1597, 2**31-1)

    r = window(r, wx, hx, 1007, 1597, 2**31-1)
    rx = rx[-1][-1]

    for i, ri in enumerate(r):
        for j, rij in enumerate(ri):
            if rij == rx:
                write(""%d %d\n"" % (i, j))

main()

"
7621814,ALDS1_14_C,"import sys
readline = sys.stdin.readline
write = sys.stdout.write

mod = 10**9 + 9; p = 13; q = 19

p_table = q_table = None
def prepare(L):
    global p_table, q_table
    p_table = [1]*(L+1); q_table = [1]*(L+1)
    for i in range(L):
        p_table[i+1] = p_table[i] * p % mod
        q_table[i+1] = q_table[i] * q % mod

def rolling_hash(S, W, H):
    D = [[0]*(W+1) for i in range(H+1)]
    for i in range(H):
        su = 0
        dp = D[i]
        di = D[i+1]
        si = S[i]
        for j in range(W):
            v = si[j] # v = ord(si[j]) if si[j] is str
            su = (su*p + v) % mod
            di[j+1] = (su + dp[j+1]*q) % mod
    return D
def get(S, x0, y0, x1, y1):
    P = p_table[x1 - x0]; Q = q_table[y1 - y0]
    return (S[y1][x1] - S[y1][x0] * P - S[y0][x1] * Q + S[y0][x0] * (P * Q) % mod) % mod

def solve():
    prepare(1001)
    H, W = map(int, readline().split())
    M = [list(map(ord, readline().strip())) for i in range(H)]
    R, C = map(int, readline().split())
    M0 = [list(map(ord, readline().strip())) for i in range(R)]

    rh = rolling_hash(M, W, H)
    rh0 = rolling_hash(M0, C, R)
    v = rh0[-1][-1]
    for i in range(H-R+1):
        for j in range(W-C+1):
            if v == get(rh, j, i, j+C, i+R):
                write(""%d %d\n"" % (i, j))
solve()

"
4388923,ALDS1_14_C,"import sys
readline = sys.stdin.readline
write = sys.stdout.write

mod = 10**9 + 9; p = 13; q = 19

p_table = q_table = None
def prepare(L):
    global p_table, q_table
    p_table = [1]*(L+1); q_table = [1]*(L+1)
    for i in range(L):
        p_table[i+1] = p_table[i] * p % mod
        q_table[i+1] = q_table[i] * q % mod

def rolling_hash(S, W, H):
    D = [[0]*(W+1) for i in range(H+1)]
    for i in range(H):
        su = 0
        dp = D[i]
        di = D[i+1]
        si = S[i]
        for j in range(W):
            v = si[j] # v = ord(si[j]) if si[j] is str
            su = (su*p + v) % mod
            di[j+1] = (su + dp[j+1]*q) % mod
    return D
def get(S, x0, y0, x1, y1):
    P = p_table[x1 - x0]; Q = q_table[y1 - y0]
    return (S[y1][x1] - S[y1][x0] * P - S[y0][x1] * Q + S[y0][x0] * (P * Q) % mod) % mod

def solve():
    prepare(1001)
    H, W = map(int, readline().split())
    M = [list(map(ord, readline().strip())) for i in range(H)]
    R, C = map(int, readline().split())
    M0 = [list(map(ord, readline().strip())) for i in range(R)]

    rh = rolling_hash(M, W, H)
    rh0 = rolling_hash(M0, C, R)
    v = rh0[-1][-1]
    for i in range(H-R+1):
        for j in range(W-C+1):
            if v == get(rh, j, i, j+C, i+R):
                write(""%d %d\n"" % (i, j))
solve()

"
5011699,ALDS1_14_C,"import sys
readline = sys.stdin.readline
write = sys.stdout.write

mod = 10**9 + 9; p = 13; q = 19

p_table = q_table = None
def prepare(L):
    global p_table, q_table
    p_table = [1]*(L+1); q_table = [1]*(L+1)
    for i in range(L):
        p_table[i+1] = p_table[i] * p % mod
        q_table[i+1] = q_table[i] * q % mod

def rolling_hash(S, W, H):
    D = [[0]*(W+1) for i in range(H+1)]
    for i in range(H):
        su = 0
        dp = D[i]
        di = D[i+1]
        si = S[i]
        for j in range(W):
            v = si[j] # v = ord(si[j]) if si[j] is str
            su = (su*p + v) % mod
            di[j+1] = (su + dp[j+1]*q) % mod
    return D
def get(S, x0, y0, x1, y1):
    P = p_table[x1 - x0]; Q = q_table[y1 - y0]
    return (S[y1][x1] - S[y1][x0] * P - S[y0][x1] * Q + S[y0][x0] * (P * Q) % mod) % mod

def solve():
    prepare(1001)
    H, W = map(int, readline().split())
    M = [list(map(ord, readline().strip())) for i in range(H)]
    R, C = map(int, readline().split())
    M0 = [list(map(ord, readline().strip())) for i in range(R)]

    rh = rolling_hash(M, W, H)
    rh0 = rolling_hash(M0, C, R)
    v = rh0[-1][-1]
    for i in range(H-R+1):
        for j in range(W-C+1):
            if v == get(rh, j, i, j+C, i+R):
                write(""%d %d\n"" % (i, j))
solve()

"
6695888,ALDS1_14_C,"import sys

# READ_FROM_FILE = True
READ_FROM_FILE = False


def calc_pow_table(base, mod, n):
    pow_table = [1] * (n + 2)
    for i in range(n + 1):
        pow_table[i + 1] = pow_table[i] * base % mod
    return pow_table


def rolling_hash(input_str, width, height, base_x, base_y, mod):
    rh = [[0] * (width + 1) for _ in range(height + 1)]
    for y in range(height):
        crh_row = rh[y]
        nrh_row = rh[y + 1]
        cs = input_str[y]
        srh = 0
        for x in range(width):
            srh = (srh * base_x + cs[x]) % mod
            nrh_row[x + 1] = (srh + crh_row[x + 1] * base_y) % mod
    return rh


def calc_hash(input_str, pow_table_x, pow_table_y, mod, x0, y0, x1, y1):
    pbx = pow_table_x[x1 - x0]
    pby = pow_table_y[y1 - y0]
    i_hash = (input_str[y1][x1] - input_str[y1][x0] * pbx -
              input_str[y0][x1] * pby + input_str[y0][x0] * (pbx * pby) % mod) % mod
    return i_hash


def main():
    if READ_FROM_FILE:
        f = open('test0.txt', 'r')
    else:
        f = sys.stdin

    mod = 1000_000_009
    base_x = 13
    base_y = 19
    max_hw = 1000
    pow_table_x = calc_pow_table(base_x, mod, max_hw)
    pow_table_y = calc_pow_table(base_y, mod, max_hw)

    height, width = map(int, f.readline().split())
    input_str = [list(map(ord, f.readline().strip())) for _ in range(height)]
    p_height, p_width = map(int, f.readline().split())
    pattern_str = [list(map(ord, f.readline().strip())) for _ in range(p_height)]

    rh = rolling_hash(input_str, width, height, base_x, base_y, mod)
    rh0 = rolling_hash(pattern_str, p_width, p_height, base_x, base_y, mod)
    v = rh0[-1][-1]
    for y in range(height - p_height + 1):
        for x in range(width - p_width + 1):
            if v == calc_hash(rh, pow_table_x, pow_table_y, mod, x, y, x + p_width, y + p_height):
                print(y, x)

    if READ_FROM_FILE:
        f.close()
    return


if __name__ == '__main__':
    main()

"
7092100,ALDS1_14_C,"def resolve():
    import sys
    input = sys.stdin.readline
    h, w = map(int, input().split())
    s = [input().rstrip() for _ in range(h)]
    rh = RollingHash2d()
    r, c = map(int, input().split())
    if h < r or w < c:
        return
    l = rh.hash_list_2d(s, r, c)
    t = [input().rstrip() for _ in range(r)]
    x = rh.get_hash_2d(t)
    for i in range(h - r + 1):
        for j in range(w - c + 1):
            if l[i][j] == x:
                print(i, j)


class RollingHash2d:
    m = 2305843009213693951  # (1 << 61) - 1
    r = None
    r2 = None
    pr = {}
    pr2 = {}

    def __init__(self, r: int = None, r2: int = None) -> None:
        import random

        if self.r is None:
            if r is None:
                r = random.randint(2, self.m - 2)
            self.r = r
        if self.r2 is None:
            if r2 is None:
                r2 = random.randint(2, self.m - 2)
            self.r2 = r2

    def _powr(self, n: int):
        if n not in self.pr:
            self.pr[n] = pow(self.r, n, self.m)
        return self.pr[n]

    def _powr2(self, n: int):
        if n not in self.pr2:
            self.pr2[n] = pow(self.r2, n, self.m)
        return self.pr2[n]

    def _hash_list(self, s: str, length: int) -> list:
        n = len(s)
        res = [None] * (n - length + 1)
        x = 0
        for i in s[:length]:
            x *= self.r
            x += ord(i)
            x %= self.m
        res[0] = x
        denom = self._powr(length - 1)
        for i, (j, k) in enumerate(zip(s[length:], s[:-length])):
            x -= ord(k) * denom
            x %= self.m
            x *= self.r
            x += ord(j)
            x %= self.m
            res[i + 1] = x
        return res

    def _gen_hash_list(self, s: str, length: int) -> int:
        x = 0
        for i in s[:length]:
            x *= self.r
            x += ord(i)
            x %= self.m
        yield x
        denom = self._powr(length - 1)
        for i, (j, k) in enumerate(zip(s[length:], s[:-length])):
            x -= ord(k) * denom
            x %= self.m
            x *= self.r
            x += ord(j)
            x %= self.m
            yield x

    def hash_list_2d(self, s: list, h: int, w: int) -> list:
        n = len(s)
        n2 = len(s[0])
        res = [[None] * (n2 - w + 1) for _ in range(n - h + 1)]
        x = [0] * (n2 - w + 1)
        hash_lists = [None] * n
        for i in range(h):
            hash_lists[i] = self._hash_list(s[i], w)
            for j, k in enumerate(hash_lists[i]):
                x[j] *= self.r2
                x[j] += k
                x[j] %= self.m
        for j in range(n2 - w + 1):
            x[j] %= self.m
            res[0][j] = x[j]
        denom = self._powr2(h - 1)
        for i in range(n - h):
            hash_lists[i + h] = self._hash_list(s[i + h], w)
            for j in range(n2 - w + 1):
                x[j] -= hash_lists[i][j] * denom
                x[j] %= self.m
                x[j] *= self.r2
                x[j] += hash_lists[i + h][j]
                x[j] %= self.m
                res[i + 1][j] = x[j]
        return res

    def _get_hash(self, s: str) -> int:
        res = 0
        for i in s:
            res *= self.r
            res += ord(i)
            res %= self.m
        return res

    def get_hash_2d(self, s: list) -> int:
        return self.hash_list_2d(s, len(s), len(s[0]))[0][0]



if __name__ == '__main__':
    resolve()
"
5484544,ALDS1_14_C,"from sys import stdin
hashkey, pwh, pww = 60921019769, 13, 29

def init_powtable(hpt, wpt, h, w):
  for i in range(h): hpt[i+1] = hpt[i] * pwh % hashkey
  for i in range(w): wpt[i+1] = wpt[i] * pww % hashkey

def set_rolling_hash(rh, m, h, w):
  for i in range(h):
    for j in range(w):
      if j==0: su = m[i][j] % hashkey
      else: su = (su*pww + m[i][j]) % hashkey
      rh[i+1][j+1] = (su + rh[i][j+1]*pwh) % hashkey

def range_val(rh, y0, x0, y1, x1):
  pwh = hpt[y1 - y0]; pww = wpt[x1 - x0]
  return (rh[y0][x0]*pwh*pww + rh[y1][x1] - rh[y1][x0]*pww - rh[y0][x1]*pwh) % hashkey

sh, sw = map(int, stdin.readline().rstrip().split())
hpt, wpt = [1]*(sh+1), [1]*(sw+1)
init_powtable(hpt, wpt, sh, sw)
sm = [list(map(ord, stdin.readline().rstrip())) for i in range(sh)]
th, tw = map(int, stdin.readline().split())
tm = [list(map(ord, stdin.readline().rstrip())) for i in range(th)]
if sh<th or sw<th: exit()

srh, trh = [[0]*(sw+1) for i in range(sh+1)], [[0]*(tw+1) for i in range(th+1)]
set_rolling_hash(srh, sm, sh, sw)
set_rolling_hash(trh, tm, th, tw)
target = range_val(trh, 0, 0, th, tw)
for i in range(sh-th+1):
  for j in range(sw-tw+1):
    if range_val(srh, i, j, i+th, j+tw)==target: print(i, j)

"
6036057,ALDS1_14_C,"# stdin.readline().rstrip()
from sys import stdin

def make_pow_table(base, mod, n):
    pow_table = [1] * (n + 2)
    for i in range(n + 1):
        pow_table[i+1] = pow_table[i] * base % mod
    return pow_table

def rolling_hash(input_str, width, height, base_x, base_y, mod):
    rh = [[0] * (width + 1) for _ in range(height + 1)]
    for i in range(height):
        before_rh_row = rh[i]
        now_rh_row = rh[i + 1]
        str_row = list(map(ord, input_str[i]))
        rh_x = 0
        for j in range(width):
            rh_x = (rh_x * base_x + str_row[j]) % mod
            now_rh_row[j + 1] = (rh_x + before_rh_row[j + 1] * base_y) % mod
    
    return rh

def calc_hash(rh, pow_table_x, pow_table_y, mod, x0, y0, x1, y1):
    pbx = pow_table_x[x1 - x0]
    pby = pow_table_y[y1 - y0]
    i_hash = ( rh[y1][x1] - rh[y1][x0] * pbx - rh[y0][x1] * pby + rh[y0][x0] * (pbx * pby) % mod ) % mod
    
    return i_hash

H, W = list(map(int, stdin.readline().rstrip().split()))

field = []
for _ in range(H):
    field.append(stdin.readline().rstrip())

R, C = list(map(int, stdin.readline().rstrip().split()))

pattern = []
for _ in range(R):
    pattern.append(stdin.readline().rstrip())

mod = 10 ** 9 + 9
base_x = 13
base_y = 19
max_hw = 1000

pow_table_x = make_pow_table(base_x, mod, max_hw)
pow_table_y = make_pow_table(base_y, mod, max_hw)

rh = rolling_hash(field, W, H, base_x, base_y, mod)
rh_pattern = rolling_hash(pattern, C, R, base_x, base_y, mod)

v = rh_pattern[-1][-1]
for i in range(H - R + 1):
    for j in range(W - C + 1):
        if v == calc_hash(rh, pow_table_x, pow_table_y, mod, j, i, j + C, i + R):
            print(i, j)

"
7129830,ALDS1_14_C,"H, W = map(int, input().split())
hw = [input() for _ in range(H)]
R, C = map(int, input().split())
rc = [input() for _ in range(R)]

class RollingHash2d:
    """"""
    2次元RollingHash
    """"""
    m = 2305843009213693951  # (1 << 61) - 1
    r = None
    r2 = None
    pr = {}
    pr2 = {}

    def __init__(self, r: int = None, r2: int = None) -> None:
        import random

        if self.r is None:
            if r is None:
                r = random.randint(2, self.m - 2)
            self.r = r
        if self.r2 is None:
            if r2 is None:
                r2 = random.randint(2, self.m - 2)
            self.r2 = r2

    def _powr(self, n: int):
        if n not in self.pr:
            self.pr[n] = pow(self.r, n, self.m)
        return self.pr[n]

    def _powr2(self, n: int):
        if n not in self.pr2:
            self.pr2[n] = pow(self.r2, n, self.m)
        return self.pr2[n]

    def _hash_list(self, s: str, length: int) -> list:
        n = len(s)
        res = [None] * (n - length + 1)
        x = 0
        for i in s[:length]:
            x *= self.r
            x += ord(i)
            x %= self.m
        res[0] = x
        denom = self._powr(length - 1)
        for i, (j, k) in enumerate(zip(s[length:], s[:-length])):
            x -= ord(k) * denom
            x %= self.m
            x *= self.r
            x += ord(j)
            x %= self.m
            res[i + 1] = x
        return res

    def _gen_hash_list(self, s: str, length: int) -> int:
        x = 0
        for i in s[:length]:
            x *= self.r
            x += ord(i)
            x %= self.m
        yield x
        denom = self._powr(length - 1)
        for i, (j, k) in enumerate(zip(s[length:], s[:-length])):
            x -= ord(k) * denom
            x %= self.m
            x *= self.r
            x += ord(j)
            x %= self.m
            yield x

    def hash_list_2d(self, s: list, h: int, w: int) -> list:
        n = len(s)
        n2 = len(s[0])
        res = [[None] * (n2 - w + 1) for _ in range(n - h + 1)]
        x = [0] * (n2 - w + 1)
        hash_lists = [None] * n
        for i in range(h):
            hash_lists[i] = self._hash_list(s[i], w)
            for j, k in enumerate(hash_lists[i]):
                x[j] *= self.r2
                x[j] += k
                x[j] %= self.m
        for j in range(n2 - w + 1):
            x[j] %= self.m
            res[0][j] = x[j]
        denom = self._powr2(h - 1)
        for i in range(n - h):
            hash_lists[i + h] = self._hash_list(s[i + h], w)
            for j in range(n2 - w + 1):
                x[j] -= hash_lists[i][j] * denom
                x[j] %= self.m
                x[j] *= self.r2
                x[j] += hash_lists[i + h][j]
                x[j] %= self.m
                res[i + 1][j] = x[j]
        return res

    def _get_hash(self, s: str) -> int:
        res = 0
        for i in s:
            res *= self.r
            res += ord(i)
            res %= self.m
        return res

    def get_hash_2d(self, s: list) -> int:
        return self.hash_list_2d(s, len(s), len(s[0]))[0][0]


if H < R or W < C:
    exit()

rh = RollingHash2d()
l = rh.hash_list_2d(hw, R, C)
x = rh.get_hash_2d(rc)


for i in range(H-R+1):
    for j in range(W-C+1):
        if l[i][j] == x:
            print(i, j)
"
8170762,ALDS1_14_C,"# # # Pattern Search
# TLE
# 他人の解答を〇パクリ


class RollingHash2D:
    def __init__(self, l):
        self.p, self.q = 13, 19
        self.mod = 10**9 + 7
        self.p_table = [1 for _ in range(l + 1)]
        self.q_table = [1 for _ in range(l + 1)]
        for i in range(l):
            self.p_table[i + 1] = self.p_table[i] * self.p % self.mod
            self.q_table[i + 1] = self.q_table[i] * self.q % self.mod

    def rolling_hash(self, S, h, w):
        DP = [[0 for _ in range(w + 1)] for _ in range(h + 1)]
        for i in range(h):
            curr_hash = 0
            for j in range(w):
                v = S[i][j]
                curr_hash = (curr_hash * self.p + v) % self.mod
                DP[i + 1][j + 1] = (curr_hash + DP[i][j + 1] * self.q) % self.mod
        return DP
    
    def get(self, Text, th, tw, bh, bw):
        p = self.p_table[bw - tw]
        q = self.q_table[bh - th]
        return (Text[bh][bw] - Text[bh][tw] * p - \
                Text[th][bw] * q + Text[th][tw] * \
                (p * q) % self.mod) % self.mod

HASH = RollingHash2D(1001)
h, w = map(int, input().split())
F = [list(map(ord, list(input()))) for _ in range(h)]
r, c = map(int, input().split())
T = [list(map(ord, list(input()))) for _ in range(r)]

FH = HASH.rolling_hash(F, h, w)
TH = HASH.rolling_hash(T, r, c)
target_hash = TH[-1][-1]
for i in range(h - r + 1):
    for j in range(w - c + 1):
        if HASH.get(FH, i, j, i + r, j + c) == target_hash:
            print(i, j)

"
7013935,ALDS1_14_C,"
from typing import List, Sequence


class RollingHash2D:
    P = int(1e5 + 7)
    Q = int(1e5 + 37)
    MOD = int(1e9+7)

    @staticmethod
    def calc_hash(sentences: Sequence[str]) -> int:
        row_hashes = [0] * len(sentences)

        for idx, sentence in enumerate(sentences):
            for letter in sentence:
                row_hashes[idx] = (
                    row_hashes[idx] * RollingHash2D.P + ord(letter)
                ) % RollingHash2D.MOD

        hash_ = 0
        for row_hash in row_hashes:
            hash_ = (hash_ * RollingHash2D.Q + row_hash) % RollingHash2D.MOD
        return hash_

    def __init__(self, sentences: List[str]) -> None:
        self.__sentences = sentences
        self._calc_hash()

    def _calc_hash(self):
        self.hashes = [[0 for _ in range(len(self.__sentences[0])+1)]
                       for _ in range(len(self.__sentences)+1)]
        self.constants_row_dir = [1]
        self.constants_column_dir = [1]
        for _ in self.__sentences[0]:
            self.constants_row_dir.append(
                self.constants_row_dir[-1] *
                RollingHash2D.P % RollingHash2D.MOD
            )

        for _ in self.__sentences:
            self.constants_column_dir.append(
                self.constants_column_dir[-1] *
                RollingHash2D.Q % RollingHash2D.MOD
            )

        for row_idx, sentence in enumerate(self.__sentences):
            tmp_row_hash = 0
            for column_idx, letter in enumerate(sentence):
                tmp_row_hash = (
                    tmp_row_hash * RollingHash2D.P + ord(letter)
                ) % RollingHash2D.MOD
                self.hashes[row_idx+1][column_idx+1] = (
                    (
                        self.hashes[row_idx][column_idx+1] * RollingHash2D.Q
                        + tmp_row_hash
                    ) % RollingHash2D.MOD
                )

    def get_hash(
            self, start_x: int, end_x: int,
            start_y: int, end_y: int) -> int:
        hash_ = (
            self.hashes[end_y][end_x]
            - self.hashes[start_y][end_x] *
            self.constants_column_dir[end_y-start_y]
            - self.hashes[end_y][start_x] *
            self.constants_row_dir[end_x-start_x]
            + self.hashes[start_y][start_x] * (
                self.constants_row_dir[end_x-start_x]
                * self.constants_column_dir[end_y-start_y]) % RollingHash2D.MOD
        ) % RollingHash2D.MOD
        if hash_ < 0:
            hash_ += RollingHash2D.MOD
        return hash_


def main():
    R, _ = map(int, input().split())
    field = []
    for _ in range(R):
        field.append(input())

    r, _ = map(int, input().split())
    pattern = []
    for _ in range(r):
        pattern.append(input())

    field_hash = RollingHash2D(field)
    pattern_hash_value = RollingHash2D.calc_hash(pattern)
    pattern_height = len(pattern)
    pattern_width = len(pattern[0])

    for row_n in range(len(field)-pattern_height+1):
        for column_n in range(len(field[0])-pattern_width+1):
            if pattern_hash_value == field_hash.get_hash(
                column_n, column_n+pattern_width,
                row_n, row_n+pattern_height
            ):
                print(row_n, column_n)


if __name__ == ""__main__"":
    main()

"
5739335,ALDS1_14_C,"from string import ascii_letters, digits
import sys
input = sys.stdin.readline
sys.setrecursionlimit(10 ** 7)
mod = 10 ** 9 + 9
basex = 1007
basey = 1009
bx_inv = pow(basex, mod-2, mod)
by_inv = pow(basey, mod-2, mod)
bx = [1] * 1001
by = [1] * 1001
ix = [1] * 1001
iy = [1] * 1001
for i in range(1, 1001):
    bx[i] = bx[i-1] * basex % mod
    by[i] = by[i-1] * basey % mod
    ix[i] = ix[i-1] * bx_inv % mod
    iy[i] = iy[i-1] * by_inv % mod

ctoi = {c: i for i, c in enumerate(ascii_letters+digits, 1)}


def inp():
    H, W = map(int, input().split())
    Hsh = [[0] * (W+1) for _ in range(H+1)]
    for i in range(H):
        for j, c in enumerate(input().rstrip()):
            Hsh[i+1][j+1] = ctoi[c] * bx[i+1] * by[j+1] % mod
    for i in range(H+1):
        for j in range(W+1):
            if i:
                Hsh[i][j] += Hsh[i-1][j]
                Hsh[i][j] %= mod
    for i in range(H+1):
        for j in range(W+1):
            if j:
                Hsh[i][j] += Hsh[i][j-1]
                Hsh[i][j] %= mod
    return H, W, Hsh


H, W, table = inp()
R, C, pattern = inp()
target = (pattern[R][C] - pattern[R][0] - pattern[0][C] + pattern[0][0]) % mod

for i in range(H-R+1):
    for j in range(W-C+1):
        h = (table[i+R][j+C] - table[i+R][j] -
             table[i][j+C] + table[i][j]) % mod
        h = h * ix[i] * iy[j] % mod
        if target == h:
            print(i, j)
"
6815494,ALDS1_14_C,"class RollingHash2D:
    def __init__(self, l):
        self.p, self.q = 13, 19
        self.mod = 10**9 + 7
        self.p_table = [1 for _ in range(l + 1)]
        self.q_table = [1 for _ in range(l + 1)]
        for i in range(l):
            self.p_table[i + 1] = self.p_table[i] * self.p % self.mod
            self.q_table[i + 1] = self.q_table[i] * self.q % self.mod

    def rolling_hash(self, S, h, w):
        DP = [[0 for _ in range(w + 1)] for _ in range(h + 1)]
        for i in range(h):
            curr_hash = 0
            for j in range(w):
                v = S[i][j]
                curr_hash = (curr_hash * self.p + v) % self.mod
                DP[i + 1][j + 1] = (curr_hash + DP[i][j + 1] * self.q) % self.mod
        return DP
    
    def get(self, Text, th, tw, bh, bw):
        p = self.p_table[bw - tw]
        q = self.q_table[bh - th]
        return (Text[bh][bw] - Text[bh][tw] * p - \
                Text[th][bw] * q + Text[th][tw] * \
                (p * q) % self.mod) % self.mod

HASH = RollingHash2D(1001)
h, w = map(int, input().split())
F = [list(map(ord, list(input()))) for _ in range(h)]
r, c = map(int, input().split())
T = [list(map(ord, list(input()))) for _ in range(r)]

FH = HASH.rolling_hash(F, h, w)
TH = HASH.rolling_hash(T, r, c)
target_hash = TH[-1][-1]
for i in range(h - r + 1):
    for j in range(w - c + 1):
        if HASH.get(FH, i, j, i + r, j + c) == target_hash:
            print(i, j)


"
8977847,ALDS1_14_C,"P = 2305843009213693951


class Grid:
    __slots__ = [""grid""]
    grid: list[int]

    def __init__(self) -> None:
        self.grid = [0] * (1010 * 1010)

    def get(self, i: int, j: int) -> int:
        return self.grid[i * 1010 + j]

    def set(self, i: int, j: int, val: int) -> None:
        self.grid[i * 1010 + j] = val


def power(x, n):
    ret = 1
    while 0 < n:
        if n & 1:
            ret = ret * x % P
        x = x * x % P
        n >>= 1
    return ret


class RHash:
    __slots__ = [""base"", ""value"", ""pow""]

    def __init__(self, base: int, pow: int, value=0) -> None:
        self.base = base
        self.value = value
        self.pow = pow

    def add(self, c: int) -> None:
        self.value = (self.value * self.base + c) % P

    def update(self, old: int, new: int) -> None:
        self.value = (self.value - old * self.pow) % P
        self.value = (self.value * self.base + new) % P


def field_hashes(text: Grid, base: int, r: int, c: int, h: int, w: int) -> Grid:
    rows = Grid()
    pow = power(base, c - 1)
    for i in range(h):
        hash = RHash(base, pow)
        for j in range(c):
            hash.add(text.get(i, j))
        rows.set(i, 0, hash.value)

        for j in range(1, w - c + 1):
            hash.update(text.get(i, j - 1), text.get(i, j + c - 1))
            rows.set(i, j, hash.value)

    field = Grid()
    base_ = power(base, c)
    pow = power(base_, r - 1)

    for j in range(w - c + 1):
        hash = RHash(base_, pow)
        for i in range(r):
            hash.add(rows.get(i, j))
        field.set(0, j, hash.value)

        for i in range(1, h - r + 1):
            hash.update(rows.get(i - 1, j), rows.get(i + r - 1, j))
            field.set(i, j, hash.value)

    return field


def pattern_hash(pattern: Grid, base: int, r: int, c: int) -> int:
    hash = RHash(base, 1)
    for i in range(r):
        for j in range(c):
            hash.add(pattern.get(i, j))
    return hash.value


def solve(text: Grid, pattern: Grid, r: int, c: int, h: int, w: int):
    field0 = field_hashes(text, 719, r, c, h, w)
    pattern0 = pattern_hash(pattern, 719, r, c)

    field1 = field_hashes(text, 5148, r, c, h, w)
    pattern1 = pattern_hash(pattern, 5148, r, c)

    for i in range(h - r + 1):
        for j in range(w - c + 1):
            if field0.get(i, j) == pattern0 and field1.get(i, j) == pattern1:
                print(i, j)


if __name__ == ""__main__"":
    text = Grid()
    h, w = map(int, input().split())
    for i in range(h):
        for j, c in enumerate(bytes(input(), ""ascii"")):
            text.set(i, j, c)

    pattern = Grid()
    row, col = map(int, input().split())
    for i in range(row):
        for j, c in enumerate(bytes(input(), ""ascii"")):
            pattern.set(i, j, c)

    solve(text, pattern, row, col, h, w)

"
5261849,ALDS1_14_C,"mod = 1000000007
class RollingHash():
    def __init__(self, s, base):
        n = len(s)
        self.p = p = [1 for _ in range(n + 1)]
        self.h = h = [0 for _ in range(n + 1)]
        for i in range(n):
            if(type(s) is str):
                h[i + 1] = (h[i] * base + ord(s[i])) % mod
            else:
                h[i + 1] = (h[i] * base + s[i]) % mod

        for i in range(n):
            p[i + 1] = p[i] * base % mod

    def get(self, l, r):
        return (self.h[r] - self.h[l] * self.p[r - l]) % mod
        

H, W = map(int, input().split())
s = [input() for _ in range(H)]
R, C = map(int, input().split())
base1, base2 = 10007, 11117

h = []
for _ in range(R):
    rh = RollingHash(input(), base1)
    h.append(rh.get(0, C))

table = [[0 for _ in range(H)] for _ in range(W - C + 1)]
for i in range(H):
    rh = RollingHash(s[i], base1)
    for j in range(W - C + 1):
        table[j][i] = rh.get(j, j + C)

rh = []
for i in range(W - C + 1):
    rh.append(RollingHash(table[i], base2))

pt = RollingHash(h, base2)
pattern = pt.get(0, R)

for i in range(H - R + 1):
    for j in range(W - C + 1):
        if rh[j].get(i, i + R) == pattern:
            print(i, j)


"
7753381,ALDS1_14_C,"class RollingHash2D:
    def __init__(self, S, mod=2147483647):
        self.S = S
        self.mod = mod
        self.H = len(S)
        self.W = len(S[0])
        
        self.idx = dict()
        for i, a in enumerate('1234567890', 1):
            self.idx[a] = i
        for i, a in enumerate('abcdefghijklmnopqrstuvwxyz', 11):
            self.idx[a] = i 
        for i, a in enumerate('ABCDEFGHIJKLMNOPQRSTUVWXYZ', 37):
            self.idx[a] = i
           
        self.r = 100 #h方向100進法で考える
        self.c = 111 #w方向
        self.pow_r = [1] #r**iをmodで割ったあまり
        for _ in range(self.H):
            self.pow_r.append((self.pow_r[-1]*self.r)%self.mod)
            
        self.pow_c = [1]
        for _ in range(self.W):
            self.pow_c.append((self.pow_c[-1]*self.c)%self.mod)
            
        self.hash = [[0]*(self.W + 1) for _ in range(self.H + 1)]
        for h in range(1, self.H + 1):
            for w in range(1, self.W + 1):
                s = self.S[h-1][w-1]
                self.hash[h][w] += self.hash[h-1][w]*self.r     
                self.hash[h][w] += self.hash[h][w-1]*self.c   
                self.hash[h][w] -= self.hash[h-1][w-1]*self.r*self.c 
                self.hash[h][w] += self.idx[s]
                self.hash[h][w] %= self.mod 
             
    
    def get_hash(self, h1, h2, w1, w2): #1-indexedで与える。 h1 <= h2, w1 <= w2 (h1, w1), (h2, w2)の長方形内のhashを求める
        res = self.hash[h2][w2]
        res -= self.hash[h2][w1-1]*self.pow_c[w2-w1+1]
        res -= self.hash[h1-1][w2]*self.pow_r[h2-h1+1]
        res += self.hash[h1-1][w1-1]*self.pow_c[w2-w1+1]*self.pow_r[h2-h1+1]
        res %= self.mod 
        return res
    
                
    def calc_hash(self, t): #文字列tのハッシュを計算する
        H = len(t)
        W = len(t[0])
        res = [[0]*(W+1) for _ in range(H+1)]
        for h in range(1, H + 1):
            for w in range(1, W + 1):
                s = t[h-1][w-1]
                res[h][w] += res[h-1][w]*self.r     
                res[h][w] += res[h][w-1]*self.c   
                res[h][w] -= res[h-1][w-1]*self.r*self.c 
                res[h][w] += self.idx[s]
                res[h][w] %= self.mod 
        return res[-1][-1]
    
    
    def contain(self, t):
        hash_val = self.calc_hash(t)
        H = len(t)
        W = len(t[0])
        if H > self.H or W > self.W:
            return []
        
        res = [] #0-indexedで行列が一致する左上位置を返す
        for h in range(self.H - H + 1):
            for w in range(self.W - W + 1):
                if self.get_hash(h+1, h+H, w+1,  w+W) == hash_val:
                    res.append((h, w))
        return res
    

H, W = map(int, input().split())
S = [input() for _ in range(H)]
RH_2D = RollingHash2D(S)

R, C = map(int, input().split())
T = [input() for _ in range(R)]
for h, w in RH_2D.contain(T):
    print(h, w)
"
5237678,ALDS1_14_C,"class RollingHash:
    def __init__(self, array, base, mod=10 ** 9 + 7):
        code = 0
        for i, x in enumerate(array):
            code += x * pow(base, i, mod)
            code %= mod
        self.code = code
        self.size = len(array)
        self.base = base
        self.mod = mod
        self.inv_base = pow(base, mod - 2, mod)

    def slide(self, x, y):
        self.code -= x
        self.code += y * pow(self.base, self.size, self.mod)
        self.code *= self.inv_base
        self.code %= self.mod


base0 = 101
base1 = 103
h, w = map(int, input().split())
field = [[ord(c) for c in input()] for _ in range(h)]
r, c = map(int, input().split())
pattern = [[ord(c) for c in input()] for _ in range(r)]
if h < r or w < c:
    exit()
# field_hash
row_hash = [[None] * (w - c + 1) for _ in range(h)]
for i in range(h):
    rh = RollingHash(field[i][0:c], base0)
    for j in range(w - c + 1):
        row_hash[i][j] = rh.code
        if j == w - c:
            break
        rh.slide(field[i][j], field[i][j + c])
field_hash = [[None] * (w - c + 1) for _ in range(h - r + 1)]
for j in range(w - c + 1):
    tmp = [row_hash[i][j] for i in range(r)]
    rh = RollingHash(tmp, base1)
    for i in range(h - r + 1):
        field_hash[i][j] = rh.code
        if i == h - r:
            break
        rh.slide(row_hash[i][j], row_hash[i + r][j])
# pattern_hash
row_hash = [None] * r
for i in range(r):
    rh = RollingHash(pattern[i], base0)
    row_hash[i] = rh.code
pattern_hash = RollingHash(row_hash, base1).code
# search
for i in range(h - r + 1):
    for j in range(w - c + 1):
        if field_hash[i][j] == pattern_hash:
            print(i, j)

"
2887498,ALDS1_14_C,"from functools import lru_cache


class MatrixRKSearch:
    shift = 40
    size = 33554393

    def __init__(self, m1, m2):
        self.haystack = self._encode(m1)
        self.needle = self._encode(m2)

    def find(self):
        i1, j1 = len(self.haystack), len(self.haystack[0])
        i2, j2 = len(self.needle), len(self.needle[0])
        if i1 < i2 or j1 < j2:
            return

        hs1 = [self._hash(s, j2) for s in self.haystack]
        hs2 = [self._hash(s, j2) for s in self.needle]
        dm = self.shift**(j2-1) % self.size

        for j in range(j1-j2+1):
            for i in range(i1-i2+1):
                if hs1[i:i+i2] == hs2:
                    yield (i, j)
            if j+j2 < j1:
                for i in range(i1):
                    hs1[i] = self._shift(hs1[i], self.haystack[i][j+j2],
                                         self.haystack[i][j], dm)

    @lru_cache(maxsize=1000)
    def _shift(self, h, add, remove, dm):
        return ((h - remove*dm) * self.shift + add) % self.size

    def _hash(self, s, length):
        h = 0
        for i in range(length):
            h = (h * self.shift + s[i]) % self.size

        return h

    def _encode(cls, m):
        basea = ord('a')
        based = ord('0')
        es = []
        for s in m:
            bs = []
            for c in s:
                if c.isdigit():
                    bs.append(ord(c) - based + 27)
                else:
                    bs.append(ord(c) - basea)
            es.append(bs)

        return es

def run():
    h, w = [int(x) for x in input().split()]
    m = []

    for _ in range(h):
        m.append(input())

    r, c = [int(x) for x in input().split()]
    pt = []

    for _ in range(r):
        pt.append(input())

    sch = MatrixRKSearch(m, pt)
    result = []
    for i, j in sch.find():
        result.append((i, j))

    result.sort()
    for i, j in result:
        print(i, j)


if __name__ == '__main__':
    run()

"
3121560,ALDS1_14_C,"from collections import deque
import re
import sys
sys.setrecursionlimit(100000)

class AC:
    
    def __init__(self,num,parent,char):
        self.num = num
        self.parent = parent
        self.char = char
        self.d = {}
        self.failure = None
        
    def insert(self,string,num):
        if not string[0] in self.d:
            self.d[string[0]] = AC(num,self,string[0])
            num+=1
        if not string[1:] == """":
            return self.d[string[0]].insert(string[1:],num)
        else:
            return num
        
    def setFailure(self):
        tmp = self.parent.failure
        while(True):
            if self.char in tmp.d:
                self.failure = tmp.d[self.char]
                break
            else:
                if tmp.num == 0:
                    self.failure = tmp
                    break
                else:
                    tmp = tmp.failure
    
    def setFailureRoot(self):
        self.failure = self
    
    def setFailureFirstLayer(self):
        self.failure = self.parent
       
    def transition(self,string):
        if string == """":
            return []
        elif string[0] in self.d:
            tmp = self.d[string[0]]
            num = ""{0:09d}"".format(tmp.num) 
            return [num]+tmp.transition(string[1:])
        else:
            if self.num == 0:
                num = ""{0:09d}"".format(self.num)
                return [num]+self.transition(string[1:])
            else:
                return self.failure.transition(string)
    
H,W = [int(i) for i in input().split()]
A = [input() for _ in range(H)]
R,C = [int(i) for i in input().split()]
B = [input() for _ in range(R)]

root = AC(0,None,"""")
root.setFailureRoot()
num=1
for i in B:
    num = root.insert(i,num)
d = deque()
for i in root.d.values():
    i.setFailureFirstLayer()
    for j in i.d.values():
        d.appendleft(j)
while(len(d)>0):
    tmp = d.pop()
    tmp.setFailure()
    for i in tmp.d.values():
        d.appendleft(i)
        
trans = ["""" for i in range(W)]
for i in A:
    tmp = root.transition(i)
    for j,k in enumerate(tmp):
        trans[j] = trans[j]+k+""#""

ans=""""
for i in B:
    ans = ans+root.transition(i)[-1]+""#""

ansd = deque()
for i,j in enumerate(trans):
    obj = re.search(ans,j)
    c = 0
    while(obj):
        s = obj.start()
        if (i-C+1)<0:
            print(i)
        ansd.append(((c+s)//10,i-C+1))
        obj = re.search(ans,j[c+s+10:])
        c += s+10

for i in sorted(ansd):
    print(i[0],i[1])
"
5158365,ALDS1_14_C,"class RollingHash:
    def __init__(self, matrix):
        self.h = len(matrix)
        self.w = len(matrix[0])
        self.BASEh = 1234
        self.BASEw = 5678
        self.MASK30 = (1 << 30) - 1
        self.MASK31 = (1 << 31) - 1
        self.MASK61 = self.MOD = (1 << 61) - 1
        self.hash = [[0] * (self.w + 1) for _ in range(self.h + 1)]
        self.ph = [1] * (self.h + 1)
        self.pw = [1] * (self.w + 1)
        for i in range(self.h):
            self.ph[i + 1] = self.calc_mod(self.mul(self.ph[i], self.BASEh))
        for i in range(self.w):
            self.pw[i + 1] = self.calc_mod(self.mul(self.pw[i], self.BASEw))

        for i in range(self.h):
            for j in range(self.w):
                res = self.mul(self.hash[i + 1][j], self.BASEw)
                res += self.mul(self.hash[i][j + 1], self.BASEh)
                res -= self.mul(self.hash[i][j], self.BASEw * self.BASEh)
                self.hash[i + 1][j + 1] = self.calc_mod(res + ord(matrix[i][j]))

    def calc_mod(self, x):
        xu = x >> 61
        xd = x & self.MASK61
        x = xu + xd
        if x >= self.MOD:
            x -= self.MOD
        return x

    def mul(self, a, b):
        au = a >> 31
        ad = a & self.MASK31
        bu = b >> 31
        bd = b & self.MASK31
        mid = ad * bu + au * bd
        midu = mid >> 30
        midd = mid & self.MASK30
        return self.calc_mod(au * bu * 2 + midu + (midd << 31) + ad * bd)

    def get_hash(self, hl, hr, wl, wr):
        p, q = self.pw[wr - wl], self.ph[hr - hl]
        res = self.hash[hr][wr]
        res -= self.mul(self.hash[hr][wl], p)
        res -= self.mul(self.hash[hl][wr], q)
        res += self.mul(self.hash[hl][wl], self.mul(p, q))
        return self.calc_mod(res)


h, w = map(int, input().split())
grid = [input() for i in range(h)]
r, c = map(int, input().split())
ptn = [input() for i in range(r)]


rhg = RollingHash(grid)
rhp = RollingHash(ptn)

hash_p = rhp.get_hash(0, r, 0, c)
for hl in range(h):
    hr = hl + r
    if hr > h:
        continue
    for wl in range(w):
        wr = wl + c
        if wr > w:
            break
        if hash_p == rhg.get_hash(hl, hr, wl, wr):
            print(hl, wl)

"
9083314,ALDS1_14_D,"from bisect import bisect_left


def main():
    t = input()
    n = len(t)
    s = [t[i:i + 1000] for i in range(n)]
    s.sort()
    q = int(input())
    for _ in range(q):
        p = input()
        pos = bisect_left(s, p)
        print(1 if pos < n and p in s[pos] else 0)


if __name__ == '__main__':
    main()

"
8473303,ALDS1_14_D,"import bisect
t = input()
sa = sorted([t[i : i + 1000] for i in range(len(t))])
for _ in range(int(input())):
    p = input()
    i = bisect.bisect_left(sa, p)
    print(int(i < len(sa) and p in sa[i]))
"
7719848,ALDS1_14_D,"import sys
import os
import time
import bisect

istest=False
fn = ""inputdata.txt""
if os.path.exists(fn):
    istest=True
    sys.stdin = open(fn)
    

class SuffixArray:
    def __init__(self,s):
        self.S=s
        self.N=len(s)
        self.sa=list(range(self.N+1))
        self.rank=[ord(c) for c in s]
        self.rank.append(-1)
        self.buildsuffixarray()
    
    def buildsuffixarray(self):
        K=1
        temp=[0]*(self.N+1)
        while K<=self.N:
            self.sa.sort(key=lambda i:self.comp(i,K))
            temp[self.sa[0]]=0
            for i in range(self.N):
                if self.comp(self.sa[i],K)==self.comp(self.sa[i+1],K):
                    inc=0
                else:
                    inc=1
                temp[self.sa[i+1]]=temp[self.sa[i]]+inc
            self.rank=temp[:]
            K*=2
    
    def comp(self,i,K):
        if i+K<=self.N:
            subkey=self.rank[i+K]
        else:
            subkey=-1
        return self.rank[i],subkey
    
    def contain(self,P):
        left=0
        n=len(P)
        right=self.N
        while(right-left>1):
            mid=(left+right)//2   
            midstr=self.S[self.sa[mid]:self.sa[mid]+n]        
            if midstr<P:
                left=mid
            else:
                right=mid
        return self.S[self.sa[right]:self.sa[right]+n]==P

class Patial_SA:
    def __init__(self,s):
        self.N=len(T)
        self.psa=[]
        for i in range(self.N):
            self.psa.append(T[i:i+1000])
        self.psa.sort()   
            
    def contain(self,P):
        left=-1
        n=len(P)
        right=self.N
        while(right-left>1):
            mid=(left+right)//2   
            if self.psa[mid]>=P:
                right=mid
            else:
                left=mid
        if right==self.N:return False
        return self.psa[right].startswith(P)

  
T=sys.stdin.readline().rstrip()
n=int(sys.stdin.readline())

SA=Patial_SA(T)
for i in range(n):
    if SA.contain(sys.stdin.readline().rstrip()):
        print(1)
    else:
        print(0)
"
6385264,ALDS1_14_D,"import bisect

t = input()
l = []
for i in range(len(t)):
    l.append(t[i:i + 1000])
l.sort()
        
q = int(input()) 
for _ in range(q):
    p = input()

    i = bisect.bisect_left(l, p)
    if i == len(t):
        print(0)
    else:
        print(1 if l[i].find(p) >= 0 else 0)

"
6060986,ALDS1_14_D,"import bisect
import sys
input=sys.stdin.readline
SfAr=[]
T=input().strip()
keylen=min(len(T),1000)
Q=int(input().strip())
P=[]
for i in range(Q):
    p=input().strip()
    P.append(p)

for i in range(len(T)):
    SfAr.append(T[i:i+keylen])

SfAr.sort()

for p in P:
    i=bisect.bisect_left(SfAr,p)
    if 0<=i<len(T):
        t=SfAr[i].find(p)
        if t!=-1:
            print(1)
        else:
            print(0)
    else:
        print(0)
"
7647225,ALDS1_14_D,"import bisect

l = []
t = input()
for i in range(len(t)):
    s=t[i:i+1000]
    l.append(s)
l.sort()
q = int(input()) 
for k in range(q):
    p = input()
    index = bisect.bisect_left(l, p)
    if index == len(t):
        print(0)
    else:
        if(l[index].find(p)==-1):
            print(0)
        else:
            print(1)

"
5074499,ALDS1_14_D,"def sa_is(s):

    def sum_count(s, s_max):

        cnt = [0] * (s_max + 1)
        for si in s:
            cnt[si] += 1
        sumcnt = 0
        for i in range(s_max + 1):
            cnt[i] = sumcnt = sumcnt + cnt[i]

        return cnt


    def induce_sort(s, cnt, pseudo, lms_sorted=None, type_array=None):
        
        ls = len(s)
        s_array = [-1] * ls
        lmsind_list = []

        if pseudo:
    
            #step1A: check for type (L:0, S:1, LMS:9) & set LMS (pseudo)

            cntcopy = cnt.copy()
            type_array = [0] * ls

            type_array[-1] = flg = 1
            for i in range(ls - 2, -1, -1):
                if s[i] > s[i + 1]:
                    if flg:
                        #LMS
                        type_array[i + 1] = 9
                        lmsind = cntcopy[s[i + 1]] = cntcopy[s[i + 1]] - 1
                        s_array[lmsind] = i + 1
                        lmsind_list.append(i + 1)
                    flg = 0
                elif s[i] < s[i + 1]:
                    type_array[i] = flg = 1
                else:
                    type_array[i] = flg
            
            if type_array[0] == 1:
                type_array[0] = 9
                lmsind = cntcopy[s[0]] - 1
                s_array[lmsind] = 0
                lmsind_list.append(0)

        else:

            #step1B: check for type (L:0, S:1, LMS:9) & set LMS (correct)

            cntcopy = cnt.copy()
            for i in lms_sorted[::-1]:
                #LMS
                lmsind = cntcopy[s[i]] = cntcopy[s[i]] - 1
                s_array[lmsind] = i

        #step2: set type-L

        cntcopy = cnt.copy()
        for s_array_i in s_array:
            if s_array_i > 0 and not type_array[s_array_i - 1]:
                lind = cntcopy[s[s_array_i - 1] - 1]
                cntcopy[s[s_array_i - 1] - 1] += 1
                s_array[lind] = s_array_i - 1

        #step3: set type-S

        cntcopy = cnt.copy()
        for i in range(ls - 1, -1, -1):
            s_array_i = s_array[i]
            if s_array_i > 0 and type_array[s_array_i - 1]:
                sind = cntcopy[s[s_array_i - 1]] = cntcopy[s[s_array_i - 1]] - 1
                s_array[sind] = s_array_i - 1
        
        return s_array, type_array, lmsind_list[::-1]


    def wrap(s, s_array, type_array, lmsind_list):

        ls = len(s_array)
        wrapped_s = [0] * ls
        wrap_num = 1
        old_i = old_s_array_i = s_array[0]
        wrapped_s[s_array[0]] = 1

        flg = False

        for s_array_i in s_array[1:]:
            if type_array[s_array_i] == 9:
                i = s_array_i + 1
                while i < ls and type_array[i] != 9:
                    i += 1
                if s[s_array_i:i + 1] == s[old_s_array_i:old_i + 1]:
                    wrapped_s[s_array_i] = wrap_num
                    flg = True
                else:
                    wrap_num += 1
                    wrapped_s[s_array_i] = wrap_num
                    old_s_array_i = s_array_i
                    old_i = i

        return [wrapped_s[i] for i in lmsind_list], flg


    def unwrap(wrapped_sa, lmsind_list):
        return [lmsind_list[i] for i in wrapped_sa]


    s.append(1)
    data = []
    flg = True
    
    while flg:
        cnt = sum_count(s, max(s))
        s_array, type_array, lmsind_list = induce_sort(s, cnt, 1)
        data.append((s, cnt, type_array, lmsind_list))
        s, flg = wrap(s, s_array, type_array, lmsind_list)

    s_array = [0] * len(s)
    for i, si in enumerate(s):
        s_array[si - 1] = i

    while data:
        s, cnt, type_array, lmsind_list = data.pop()
        unwrapped_sa = unwrap(s_array, lmsind_list)
        s_array, *_ = induce_sort(s, cnt, 0, unwrapped_sa, type_array)

    return s_array


def main():

    s = list(map(ord, input()))
    ls = len(s)

    suffix_array = sa_is(s)

    for _ in range(int(input())):
        p = list(map(ord, input()))
        lp = len(p)

        start = 0
        end = ls

        while end - start > 1:
            mid = (start + end) // 2
            ind = suffix_array[mid]

            if s[ind:ind + lp] > p:
                end = mid
            elif s[ind:ind + lp] < p:
                start = mid
            else:
                print(1)
                break
        
        else:
            if s[suffix_array[0]:suffix_array[0] + lp] == p:
                print(1)
            elif s[suffix_array[ls]:suffix_array[ls] + lp] == p:
                print(1)
            else:
                print(0)

main()

"
6312559,ALDS1_14_D,"from itertools import accumulate

class SuffixArray:

    __slots__ = [""s"", ""index"", ""__suffix_array"", ""__lcp_array"", ""__lcp""]

    def __init__(self, s):
        self.s, self.index = self.__compress(s)
        self.__suffix_array = self.__lcp_array = self.__lcp = None
        return

    def suffix_array(self):
        if self.__suffix_array is None:
            self.__suffix_array = self.__sa_is()
        return self.__suffix_array

    def lcp_array(self):
        if self.__lcp_array is None:
            self.__lcp_array = self.__kasai()
        return self.__lcp_array

    def find(self, t, mode=""naive""):
        assert mode in [""naive"", ""lcp""]

        if mode == ""naive"":
            return self.find_naive(t)
        else:
            return self.find_use_lcp_array(t)

    def find_naive(self, t):
        t = [self.index.get(i) for i in t]
        if None in t:
            return -1
        s = self.s
        sa = self.suffix_array()

        l = 0
        r = len(s)
        while l+1 < r:
            m = (l+r) >> 1
            if t >= s[sa[m]:sa[m]+len(t)]:
                l = m
            else:
                r = m
        if t == s[sa[l]:sa[l]+len(t)]:
            return sa[l]
        return -1

    def find_use_lcp_array(self, t):
        def calc_lcp(i, offset):
            l_lcp = offset
            max_lcp = min(len(t), n-i)
            while l_lcp < max_lcp and t[l_lcp] == s[i+l_lcp]:
                l_lcp += 1
            return l_lcp

        t = [self.index.get(i) for i in t]
        if None in t:
            return -1

        s = self.s

        suffix_array = self.suffix_array()
        lcp_array = self.lcp_array()

        l = 0
        r = n = len(s)
        l_lcp = calc_lcp(suffix_array[l], 0)

        while l+1 < r:
            m = (l+r) >> 1
            n_lcp = self.__lcp_of_suffix(l,m)
            if l_lcp < n_lcp:
                l = m
                l_lcp = calc_lcp(suffix_array[l], l_lcp)
                continue
            elif l_lcp > n_lcp:
                r = m
                continue

            i = suffix_array[m]
            new_l_lcp = calc_lcp(i, l_lcp)

            if new_l_lcp < min(len(t),n-i) and t[new_l_lcp] < s[i+new_l_lcp]:
                r = m
            else:
                l = m
                l_lcp = new_l_lcp

        if l_lcp < len(t):
            return -1
        return suffix_array[l]

    def __lcp_of_suffix(self, l, r):
        if self.__lcp is None:
            self.__lcp = self.__build_lcp_of_suffix()
        return self.__lcp[l*(len(self.s)+1)+r]

    def __build_lcp_of_suffix(self):
        n = len(self.s)
        k = n+1
        q = [n]
        for key in q:
            l,r = divmod(key,k)
            if l+1 < r:
                m = (l+r) >> 1
                key = l*k+m
                q.append(key)
                key = m*k+r
                q.append(key)
        lcp_array = self.lcp_array()
        lcp = {}
        for key in reversed(q):
            l,r = divmod(key,k)
            if l+1 == r:
                lcp[key] = lcp_array[r] if r < n else 0
            else:
                m = (l+r) >> 1
                lcp[key] = min(lcp[l*k+m], lcp[m*k+r])

        return lcp

    def __compress(self, s):
        keys = sorted(set(s))
        index = {key: i for i,key in enumerate(keys,1)}
        s = [index[i] for i in s]
        return s, index

    def __sa_is(self):
        return self.__calc(self.s[:])

    def __calc(self, s):
        def induced_sort(start, lms_array):
            sa = [None]*(n+1)
            end = [start[i] for i in range(1,buckets_size)]+[n]
            end_ = end[:]

            for i in lms_array:
                si = s[i]
                end_[si] -= 1
                sa[end_[si]] = i

            for i in sa:
                if i is None:
                    continue
                pre = i-1
                if types[pre]:
                    sp = s[pre]
                    sa[start[sp]] = pre
                    start[sp] += 1

            for i in reversed(sa):
                if not i:
                    continue
                pre = i-1
                if not types[pre]:
                    sp = s[pre]
                    end[sp] -= 1
                    sa[end[sp]] = pre

            return sa

        n = len(s)
        if n < 100:
            sa = list(range(n))
            sa.sort(key=lambda i: s[i:])
            return sa

        s.append(0)

        buckets_size = max(s)+1

        types = [0]*(n+1)  # S: 0, L: 1

        counts = [0]*buckets_size
        counts[0] = 1

        next_ = 0
        for i in reversed(range(n)):
            pre = s[i]
            if pre < next_:
                types[i] = 0
            elif pre > next_:
                types[i] = 1
            else:
                types[i] = types[i+1]

            counts[pre] += 1
            next_ = pre

        is_lms = [types[i-1] > types[i] for i in range(n+1)]

        lms_array = [i for i in range(n+1) if is_lms[i]]
        start = [0]+list(accumulate(counts[:-1]))

        sa = induced_sort(start[:], lms_array)
        
        index = {}
        last = 1
        pre = None

        for i in sa:
            if not is_lms[i]:
                continue

            if pre is None:
                pre = i
                index[i] = last
                last += 1
                continue

            for j in range(n):
                a = i+j
                b = pre+j
                if s[a] != s[b]:
                    last += 1
                    break
                if j and (is_lms[a] or is_lms[b]):
                    break

            index[i] = last-1
            pre = i

        if last < len(lms_array)+1:
            lms_substring = [index[i] for i in lms_array]
            order = self.__calc(lms_substring)
            lms_array = [lms_array[i] for i in reversed(order)]

        else:
            lms_array = [i for i in reversed(sa) if is_lms[i]]

        sa = induced_sort(start, lms_array)

        return sa[1:]

    def __kasai(self):
        s = self.s
        suffix_array = self.suffix_array()

        index = {value: key for key, value in enumerate(suffix_array)}

        n = len(s)
        lcp_array = [0]*n

        lcp = 0
        for i in range(n):
            index_i = index[i]
            if not index_i:
                continue
            j = suffix_array[index_i-1]
            max_lcp = n-max(i,j)
            while lcp < max_lcp and s[i+lcp] == s[j+lcp]:
                lcp += 1
            lcp_array[index_i] = lcp
            if lcp:
                lcp -= 1
        return lcp_array


def main():
    t = input()
    sa = SuffixArray(t)
    for _ in range(int(input())):
        q = input()
        ans = 1 if sa.find(q) >= 0 else 0
        print(ans)
    return


if __name__ == ""__main__"":
    main()


"
6632266,ALDS1_14_D,"import sys
from collections import Counter
readline = sys.stdin.readline
write = sys.stdout.write

def sais_rec(lst, num):
    L = len(lst)
    if L < 2:
        return lst + [0]
    lst = lst + [0]
    L += 1
    res = [-1] * L
    t = [1] * L
    for i in range(L-2, -1, -1):
        t[i] = 1 if (lst[i] < lst[i+1] or (lst[i] == lst[i+1] and t[i+1])) else 0
    isLMS = [t[i-1] < t[i] for i in range(L)]
    LMS = [i for i in range(1, L) if t[i-1] < t[i]]
    LMSn = len(LMS)

    count = Counter(lst)
    tmp = 0
    cstart = [0]*(num+1)
    cend = [0]*(num+1)
    for key in range(num+1):
        cstart[key] = tmp
        cend[key] = tmp = tmp + count[key]

    cc_it = [iter(range(e-1, s-1, -1)) for s, e in zip(cstart, cend)]
    for e in reversed(LMS):
        res[next(cc_it[lst[e]])] = e

    cs_it = [iter(range(s, e)) for s, e in zip(cstart, cend)]
    ce_it = [iter(range(e-1, s-1, -1)) for s, e in zip(cstart, cend)]
    for e in res:
        if e > 0 and not t[e-1]:
            res[next(cs_it[lst[e-1]])] = e-1
    for e in reversed(res):
        if e > 0 and t[e-1]:
            res[next(ce_it[lst[e-1]])] = e-1

    name = 0; prev = -1
    pLMS = {}
    for e in res:
        if isLMS[e]:
            if prev == -1 or lst[e] != lst[prev]:
                name += 1; prev = e
            else:
                for i in range(1, L):
                    if lst[e+i] != lst[prev+i]:
                        name += 1; prev = e
                        break
                    if isLMS[e+i] or isLMS[prev+i]:
                        break
            pLMS[e] = name-1

    if name < LMSn:
        sublst = [pLMS[e] for e in LMS if e < L-1]
        ret = sais_rec(sublst, name-1)

        LMS = list(map(LMS.__getitem__, reversed(ret)))
    else:
        LMS = [e for e in reversed(res) if isLMS[e]]

    res = [-1]*L

    cc_it = [iter(range(e-1, s-1, -1)) for s, e in zip(cstart, cend)]
    for e in LMS:
        res[next(cc_it[lst[e]])] = e

    cs_it = [iter(range(s, e)) for s, e in zip(cstart, cend)]
    ce_it = [iter(range(e-1, s-1, -1)) for s, e in zip(cstart, cend)]

    for e in res:
        if e > 0 and not t[e-1]:
            res[next(cs_it[lst[e-1]])] = e-1
    for e in reversed(res):
        if e > 0 and t[e-1]:
            res[next(ce_it[lst[e-1]])] = e-1
    return res
def sais(s):
    uniq = list(set(s))
    uniq.sort()
    return sais_rec(list(map({e: i+1 for i, e in enumerate(uniq)}.__getitem__, s)), len(uniq))

def solve():
    T = readline().strip()
    T0 = T + ""$""
    L = len(T)
    sa = sais(T)
    Q = int(readline())
    for i in range(Q):
        p = readline().strip()
        L1 = len(p)
        left = -1; right = L
        while left+1 < right:
            mid = (left + right) >> 1
            k = sa[mid]
            if T0[k:k+L1] < p:
                left = mid
            else:
                right = mid
        k = sa[right]
        if T0[k:k+L1] == p:
            write(""1\n"")
        else:
            write(""0\n"")
solve()
"
6050386,ALDS1_14_D,"import sys

# READ_FROM_FILE = True
READ_FROM_FILE = False


def sa_is(s):
    n = len(s)
    stype = [True] * n
    for i in range(n - 2, -1, -1):
        if s[i] == s[i + 1]:
            stype[i] = stype[i + 1]
        else:
            stype[i] = s[i] < s[i + 1]

    lms = []
    lms_map = [-1] * n
    for i in range(1, n):
        if not stype[i - 1] and stype[i]:
            lms_map[i] = len(lms)
            lms.append(i)

    k = max(s) + 1
    bucket = [0] * k
    for v in s:
        bucket[v] += 1
    cum = [0] * (k + 1)
    for i in range(k):
        cum[i + 1] = cum[i] + bucket[i]

    def induced_sort():
        buf = cum[:]
        for i in lms[::-1]:
            v = s[i]
            buf[v + 1] -= 1
            sa[buf[v + 1]] = i
        buf = cum[:]
        for i in range(n):
            if sa[i] != -1 and not stype[sa[i] - 1]:
                v = s[sa[i] - 1]
                sa[buf[v]] = sa[i] - 1
                buf[v] += 1
        buf = cum[:]
        for i in range(n - 1, -1, -1):
            if stype[sa[i] - 1]:
                v = s[sa[i] - 1]
                buf[v + 1] -= 1
                sa[buf[v + 1]] = sa[i] - 1

    sa = [-1] * n
    induced_sort()

    if len(lms) <= 2:
        return sa

    _lms = lms
    lms = [s for s in sa if lms_map[s] != -1]
    lms_substr = list(range(len(lms)))
    for i in range(2, len(lms)):
        l, r = lms[i - 1], lms[i]
        if s[l] != s[r]:
            lms_substr[i] = lms_substr[i - 1] + 1
            continue
        while True:
            l += 1
            r += 1
            if s[l] != s[r] or lms_map[l] * lms_map[r] < 0:
                lms_substr[i] = lms_substr[i - 1] + 1
                break
            if lms_map[l] >= 0 and lms_map[r] >= 0:
                lms_substr[i] = lms_substr[i - 1]
                break

    sub_s = [0] * len(lms)
    for i, v in zip(lms, lms_substr):
        sub_s[lms_map[i]] = v
    sub_sa = sa_is(sub_s)
    lms = [_lms[s] for s in sub_sa]

    sa = [-1] * n
    induced_sort()
    return sa


def main():
    if READ_FROM_FILE:
        f = open('test0.txt', 'r')
        # f = open('test3.txt', 'r')
    else:
        f = sys.stdin

    input_str = f.readline().rstrip('\n')
    if len(input_str) == 1:
        num_query = int(f.readline())
        for _ in range(num_query):
            pattern_str = f.readline().rstrip('\n')
            if len(pattern_str) > 1:
                print(0)
            elif input_str == pattern_str:
                print(1)
            else:
                print(0)
        return

    converted_str = list(map(ord, input_str + '$'))
    n0 = len(input_str)
    sa = sa_is(converted_str)[1:]

    num_query = int(f.readline())
    for _ in range(num_query):
        pattern_str = f.readline().rstrip('\n')
        n1 = len(pattern_str)
        left = 0
        right = n0
        while left + 1 < right:
            mid = (left + right) // 2
            if input_str[sa[mid]:sa[mid] + n1] < pattern_str:
                left = mid
            else:
                right = mid
        if right > n0 - 1:
            print(0)
        elif sa[right] + n1 > n0:
            print(0)
        elif input_str[sa[right]:sa[right] + n1] == pattern_str:
            print(1)
        elif input_str[sa[left]:sa[left] + n1] == pattern_str:
            print(1)
        else:
            print(0)

    if READ_FROM_FILE:
        f.close()
    return


if __name__ == '__main__':
        main()
"
5384704,ALDS1_14_D,"import sys
INF = 1 << 60
MOD = 10**9 + 7 # 998244353
sys.setrecursionlimit(2147483647)
input = lambda:sys.stdin.readline().rstrip()

def sa_is(S):
    n = len(S)
    stype = [True] * n
    for i in range(n - 2, -1, -1):
        if S[i] == S[i + 1]:
            stype[i] = stype[i + 1]
        else:
            stype[i] = S[i] < S[i + 1]

    lms = []
    lms_map = [-1] * n
    for i in range(1, n):
        if not stype[i - 1] and stype[i]:
            lms_map[i] = len(lms)
            lms.append(i)

    k = max(S) + 1
    bucket = [0] * k
    for v in S:
        bucket[v] += 1
    cum = [0] * (k + 1)
    for i in range(k):
        cum[i + 1] = cum[i] + bucket[i]

    def induced_sort():
        buf = cum[:]
        for i in lms[::-1]:
            v = S[i]
            buf[v + 1] -= 1
            sa[buf[v + 1]] = i
        buf = cum[:]
        for i in range(n):
            if sa[i] != -1 and not stype[sa[i] - 1]:
                v = S[sa[i] - 1]
                sa[buf[v]] = sa[i] - 1
                buf[v] += 1
        buf = cum[:]
        for i in range(n - 1, -1, -1):
            if stype[sa[i] - 1]:
                v = S[sa[i] - 1]
                buf[v + 1] -= 1
                sa[buf[v + 1]] = sa[i] - 1

    sa = [-1] * n
    induced_sort()

    if len(lms) <= 2:
        return sa

    _lms = lms
    lms = [s for s in sa if lms_map[s] != -1]
    lms_substr = list(range(len(lms)))
    for i in range(2, len(lms)):
        l, r = lms[i - 1], lms[i]
        if S[l] != S[r]:
            lms_substr[i] = lms_substr[i - 1] + 1
            continue
        while True:
            l += 1
            r += 1
            if S[l] != S[r] or lms_map[l] * lms_map[r] < 0:
                lms_substr[i] = lms_substr[i - 1] + 1
                break
            if lms_map[l] >= 0 and lms_map[r] >= 0:
                lms_substr[i] = lms_substr[i - 1]
                break

    sub_s = [0] * len(lms)
    for i, v in zip(lms, lms_substr):
        sub_s[lms_map[i]] = v
    lms = [_lms[s] for s in sa_is(sub_s)]

    sa = [-1] * n
    induced_sort()
    return sa


def resolve():
    S = input()
    n = len(S)
    sa = sa_is(list(map(ord, S + '$')))

    for _ in range(int(input())):
        T = input()
        k = len(T)
        l, r = 0, n + 1
        while r - l > 1:
            m = (l + r) // 2
            if T >= S[sa[m] : sa[m] + k]:
                l = m
            else:
                r = m
        print(int(T == S[sa[l] : sa[l] + k]))
resolve()

"
7460505,ALDS1_14_D,"import sys

# READ_FROM_FILE = True
READ_FROM_FILE = False


def induced_sort(n, s, stype, lms, cum, sa):
    buf = cum[:]
    for i in lms[::-1]:
        v = s[i]
        buf[v + 1] -= 1
        sa[buf[v + 1]] = i
    buf = cum[:]
    for i in range(n):
        if sa[i] != -1 and not stype[sa[i] - 1]:
            v = s[sa[i] - 1]
            sa[buf[v]] = sa[i] - 1
            buf[v] += 1
    buf = cum[:]
    for i in range(n - 1, -1, -1):
        if stype[sa[i] - 1]:
            v = s[sa[i] - 1]
            buf[v + 1] -= 1
            sa[buf[v + 1]] = sa[i] - 1


def sa_is(s):
    n = len(s)
    stype = [True] * n
    for i in range(n - 2, -1, -1):
        if s[i] == s[i + 1]:
            stype[i] = stype[i + 1]
        else:
            stype[i] = s[i] < s[i + 1]

    lms = []
    lms_map = [-1] * n
    for i in range(1, n):
        if not stype[i - 1] and stype[i]:
            lms_map[i] = len(lms)
            lms.append(i)

    k = max(s) + 1
    bucket = [0] * k
    for v in s:
        bucket[v] += 1
    cum = [0] * (k + 1)
    for i in range(k):
        cum[i + 1] = cum[i] + bucket[i]

    sa = [-1] * n
    induced_sort(n, s, stype, lms, cum, sa)

    if len(lms) <= 2:
        return sa

    _lms = lms
    lms = [s for s in sa if lms_map[s] != -1]
    lms_sub_str = list(range(len(lms)))
    for i in range(2, len(lms)):
        left, right = lms[i - 1], lms[i]
        if s[left] != s[right]:
            lms_sub_str[i] = lms_sub_str[i - 1] + 1
            continue
        while True:
            left += 1
            right += 1
            if s[left] != s[right] or lms_map[left] * lms_map[right] < 0:
                lms_sub_str[i] = lms_sub_str[i - 1] + 1
                break
            if lms_map[left] >= 0 and lms_map[right] >= 0:
                lms_sub_str[i] = lms_sub_str[i - 1]
                break

    sub_s = [0] * len(lms)
    for i, v in zip(lms, lms_sub_str):
        sub_s[lms_map[i]] = v
    sub_sa = sa_is(sub_s)
    lms = [_lms[s] for s in sub_sa]

    sa = [-1] * n
    induced_sort(n, s, stype, lms, cum, sa)
    return sa


def main():
    if READ_FROM_FILE:
        f = open('test0.txt', 'r')
    else:
        f = sys.stdin

    input_str = f.readline().rstrip('\n')
    if len(input_str) == 1:
        q = int(f.readline())
        for _ in range(q):
            pattern_str = f.readline().rstrip('\n')
            if len(pattern_str) > 1:
                print(0)
            elif input_str == pattern_str:
                print(1)
            else:
                print(0)
        return

    converted_str = list(map(ord, input_str + '$'))
    n0 = len(input_str)
    sa = sa_is(converted_str)[1:]

    q = int(f.readline())
    for _ in range(q):
        pattern_str = f.readline().rstrip('\n')
        n1 = len(pattern_str)
        left = 0
        right = n0
        is_found = False
        while left < right:
            mid = (left + right) // 2
            sub_str = input_str[sa[mid]:sa[mid] + n1]
            if sub_str < pattern_str:
                left = mid + 1
            elif sub_str > pattern_str:
                right = mid
            else:
                is_found = True
                break

        print(1 if is_found else 0)

    if READ_FROM_FILE:
        f.close()
    return


if __name__ == '__main__':
    main()

"
4852823,ALDS1_14_D,"def SA_IS(s, with_lcp=False):
    a = s + [0]
    # a = [aa+1 for aa in a] + [0] # <- 元の列にZeroが含まれるときはこっち
    k = max(a) + 1
    n = len(a)

    def induce_l(sa, a, n, k, stype):
        bucket = get_buckets(a, k, 1)
        for i in range(n):
            j = sa[i] - 1
            if j >= 0 and (not stype[j]):
                sa[bucket[a[j]]] = j
                bucket[a[j]] += 1

    def induce_s(sa, a, n, k, stype):
        bucket = get_buckets(a, k, 0)
        for i in range(n)[::-1]:
            j = sa[i] - 1
            if j >= 0 and stype[j]:
                bucket[a[j]] -= 1
                sa[bucket[a[j]]] = j

    def get_buckets(a, k, start=0):
        bucket = [0] * k
        for item in a:
            bucket[item] += 1
        s = 0
        for i in range(k):
            s += bucket[i]
            bucket[i] = s - (bucket[i] if start else 0)
        return bucket

    def set_lms(a, n, k, default_order):
        bucket = get_buckets(a, k)
        sa = [-1] * n
        for i in default_order[::-1]:
            bucket[a[i]] -= 1
            sa[bucket[a[i]]] = i
        return sa

    def induce(a, n, k, stype, default_order):
        sa = set_lms(a, n, k, default_order)
        induce_l(sa, a, n, k, stype)
        induce_s(sa, a, n, k, stype)
        return sa

    def rename_LMS_substring(sa, a, n, stype, LMS, l):
        sa = [_s for _s in sa if LMS[_s]]
        tmp = [-1] * (n // 2) + [0]
        dupl = 0
        for _ in range(1, l):
            i, j = sa[_ - 1], sa[_]
            for ii in range(n):
                if a[i + ii] != a[j + ii] or stype[i + ii] != stype[j + ii]:
                    break
                if ii and (LMS[i + ii] or LMS[j + ii]):
                    dupl += 1
                    break
            tmp[j // 2] = _ - dupl
        tmp = [t for t in tmp if t >= 0]
        return tmp, dupl

    def calc(a, n, k):
        stype = [1] * n
        for i in range(n - 1)[::-1]:
            if a[i] > a[i + 1] or (a[i] == a[i + 1] and stype[i + 1] == 0):
                stype[i] = 0

        LMS = [1 if stype[i] and not stype[i - 1] else 0 for i in range(n - 1)] + [1]
        l = sum(LMS)
        lms = [i for i in range(n) if LMS[i]]
        sa = induce(a, n, k, stype, lms)
        renamed_LMS, dupl = rename_LMS_substring(sa, a, n, stype, LMS, l)

        if dupl:
            sub_sa = calc(renamed_LMS, l, l - dupl)
        else:
            sub_sa = [0] * l
            for i in range(l):
                sub_sa[renamed_LMS[i]] = i

        lms = [lms[sub_sa[i]] for i in range(l)]
        sa = induce(a, n, k, stype, lms)
        return sa

    sa = calc(a, n, k)
    sa = sa[1:]
    n -= 1
    if not with_lcp:
        return sa

    rank = [0] * n
    for i in range(n):
        rank[sa[i]] = i
    lcp = [0] * (n - 1)
    h = 0
    for i in range(n):
        if h: h -= 1
        if rank[i] == 0: continue
        j = sa[rank[i] - 1]
        while j + h < n and i + h < n:
            if s[j + h] != s[i + h]: break
            h += 1
        lcp[rank[i] - 1] = h
    return sa, lcp

def contain(S, sa, T):
    """"""
    文字列 T が S 内に含まれているかどうか
    """"""
    l = 0
    r = len(S)
    L = len(T)
    while r-l>1:
        mid = (l+r)//2
        if S[sa[mid-1]:sa[mid-1]+L]<T:
            l=mid
        else:
            r=mid
    return T==S[sa[r-1]:sa[r-1]+L]

import sys
input = sys.stdin.readline
S = input().rstrip()
A = [ord(a) for a in S]
Q = int(input())
sa = SA_IS(A, False)
for _ in range(Q):
    print(int(contain(S, sa, input().rstrip())))

""""""
abracadabra
3
abra
abracadabra
acadabra
""""""
"
4887912,ALDS1_14_D,"import sys
INF = 1 << 60
MOD = 10**9 + 7 # 998244353
sys.setrecursionlimit(2147483647)
input = lambda:sys.stdin.readline().rstrip()

def sa_is(S):
    n = len(S)
    stype = [True] * n
    for i in range(n - 2, -1, -1):
        if S[i] == S[i + 1]:
            stype[i] = stype[i + 1]
        else:
            stype[i] = S[i] < S[i + 1]

    lms = []
    lms_map = [-1] * n
    for i in range(1, n):
        if not stype[i - 1] and stype[i]:
            lms_map[i] = len(lms)
            lms.append(i)

    k = max(S) + 1
    bucket = [0] * k
    for v in S:
        bucket[v] += 1
    cum = [0] * (k + 1)
    for i in range(k):
        cum[i + 1] = cum[i] + bucket[i]

    def induced_sort():
        buf = cum[:]
        for i in lms[::-1]:
            v = S[i]
            buf[v + 1] -= 1
            sa[buf[v + 1]] = i
        buf = cum[:]
        for i in range(n):
            if sa[i] != -1 and not stype[sa[i] - 1]:
                v = S[sa[i] - 1]
                sa[buf[v]] = sa[i] - 1
                buf[v] += 1
        buf = cum[:]
        for i in range(n - 1, -1, -1):
            if stype[sa[i] - 1]:
                v = S[sa[i] - 1]
                buf[v + 1] -= 1
                sa[buf[v + 1]] = sa[i] - 1

    sa = [-1] * n
    induced_sort()

    if len(lms) <= 2:
        return sa

    _lms = lms
    lms = [s for s in sa if lms_map[s] != -1]
    lms_substr = list(range(len(lms)))
    for i in range(2, len(lms)):
        l, r = lms[i - 1], lms[i]
        if S[l] != S[r]:
            lms_substr[i] = lms_substr[i - 1] + 1
            continue
        while True:
            l += 1
            r += 1
            if S[l] != S[r] or lms_map[l] * lms_map[r] < 0:
                lms_substr[i] = lms_substr[i - 1] + 1
                break
            if lms_map[l] >= 0 and lms_map[r] >= 0:
                lms_substr[i] = lms_substr[i - 1]
                break

    sub_s = [0] * len(lms)
    for i, v in zip(lms, lms_substr):
        sub_s[lms_map[i]] = v
    lms = [_lms[s] for s in sa_is(sub_s)]

    sa = [-1] * n
    induced_sort()
    return sa


def resolve():
    S = input()
    n = len(S)
    sa = sa_is(list(map(ord, S + '$')))

    for _ in range(int(input())):
        T = input()
        k = len(T)
        l, r = 0, n + 1
        while r - l > 1:
            m = (l + r) // 2
            if T >= S[sa[m] : sa[m] + k]:
                l = m
            else:
                r = m
        print(int(T == S[sa[l] : sa[l] + k]))
resolve()
"
6877569,ALDS1_14_D,"class string:
    def sa_is(s,upper):
        n=len(s)
        if n==0:
            return []
        if n==1:
            return [0]
        if n==2:
            if (s[0]<s[1]):
                return [0,1]
            else:
                return [1,0]
        sa=[0]*n
        ls=[0]*n
        for i in range(n-2,-1,-1):
            ls[i]=ls[i+1] if (s[i]==s[i+1]) else (s[i]<s[i+1])
        sum_l=[0]*(upper+1)
        sum_s=[0]*(upper+1)
        for i in range(n):
            if not(ls[i]):
                sum_s[s[i]]+=1
            else:
                sum_l[s[i]+1]+=1
        for i in range(upper+1):
            sum_s[i]+=sum_l[i]
            if i<upper:
                sum_l[i+1]+=sum_s[i]
        def induce(lms):
            for i in range(n):
                sa[i]=-1
            buf=sum_s[:]
            for d in lms:
                if d==n:
                    continue
                sa[buf[s[d]]]=d
                buf[s[d]]+=1
            buf=sum_l[:]
            sa[buf[s[n-1]]]=n-1
            buf[s[n-1]]+=1
            for i in range(n):
                v=sa[i]
                if v>=1 and not(ls[v-1]):
                    sa[buf[s[v-1]]]=v-1
                    buf[s[v-1]]+=1
            buf=sum_l[:]
            for i in range(n-1,-1,-1):
                v=sa[i]
                if v>=1 and ls[v-1]:
                    buf[s[v-1]+1]-=1
                    sa[buf[s[v-1]+1]]=v-1
        lms_map=[-1]*(n+1)
        m=0
        for i in range(1,n):
            if not(ls[i-1]) and ls[i]:
                lms_map[i]=m
                m+=1
        lms=[]
        for i in range(1,n):
            if not(ls[i-1]) and ls[i]:
                lms.append(i)
        induce(lms)
        if m:
            sorted_lms=[]
            for v in sa:
                if lms_map[v]!=-1:
                    sorted_lms.append(v)
            rec_s=[0]*m
            rec_upper=0
            rec_s[lms_map[sorted_lms[0]]]=0
            for i in range(1,m):
                l=sorted_lms[i-1]
                r=sorted_lms[i]
                end_l=lms[lms_map[l]+1] if (lms_map[l]+1<m) else n
                end_r=lms[lms_map[r]+1] if (lms_map[r]+1<m) else n
                same=True
                if end_l-l!=end_r-r:
                    same=False
                else:
                    while(l<end_l):
                        if s[l]!=s[r]:
                            break
                        l+=1
                        r+=1
                    if (l==n) or (s[l]!=s[r]):
                        same=False
                if not(same):
                    rec_upper+=1
                rec_s[lms_map[sorted_lms[i]]]=rec_upper
            rec_sa=string.sa_is(rec_s,rec_upper)
            for i in range(m):
                sorted_lms[i]=lms[rec_sa[i]]
            induce(sorted_lms)
        return sa
    def suffix_array_upper(s,upper):
        assert 0<=upper
        for d in s:
            assert 0<=d and d<=upper
        return string.sa_is(s,upper)
    def suffix_array(s):
        n=len(s)
        if type(s)==str:
            s2=[ord(i) for i in s]
            return string.sa_is(s2,255)
        else:
            idx=list(range(n))
            idx.sort(key=lambda x:s[x])
            s2=[0]*n
            now=0
            for i in range(n):
                if (i& s[idx[i-1]]!=s[idx[i]]):
                    now+=1
                s2[idx[i]]=now
            return string.sa_is(s2,now)
    def lcp_array(s,sa):
        n=len(s)
        assert n>=1
        rnk=[0]*n
        for i in range(n):
            rnk[sa[i]]=i
        lcp=[0]*(n-1)
        h=0
        for i in range(n):
            if h>0:
                h-=1
            if rnk[i]==0:
                continue
            j=sa[rnk[i]-1]
            while(j+h<n and i+h<n):
                if s[j+h]!=s[i+h]:
                    break
                h+=1
            lcp[rnk[i]-1]=h
        return lcp
    def z_algorithm(s):
        n=len(s)
        if n==0:
            return []
        z=[0]*n
        i=1;j=0
        while(i<n):
            z[i]=0 if (j+z[j]<=i) else min(j+z[j]-i,z[i-j])
            while((i+z[i]<n) and (s[z[i]]==s[i+z[i]])):
                z[i]+=1
            if (j+z[j]<i+z[i]):
                j=i
            i+=1
        z[0]=n
        return z

T = input()
l = len(T)
SA = string.suffix_array(T)
T0 = T + '$'
n = int(input())
for _ in range(n):
    Q = input()
    left = -1
    right = l - 1
    while right - left > 1:
        mid = (left + right) // 2
        idx = SA[mid]
        if T0[idx:idx + len(Q)] < Q:
            left = mid
        else:
            right = mid
    idx = SA[right]
    if T0[idx:idx + len(Q)] == Q:
        print(1)
    else:
        print(0)

"
6938786,ALDS1_14_D,"import functools
import typing


def resolve():
    import bisect
    import sys
    input = sys.stdin.readline
    t = input().rstrip()
    sa = suffix_array(t)
    l = [""""] * len(t)
    for i, j in enumerate(sa):
        l[i] = t[j:j + 1000]
    q = int(input())
    for _ in range(q):
        p = input().rstrip()
        i = bisect.bisect_left(l, p)
        if i == len(t):
            print(0)
        else:
            print(1 if l[i][:len(p)] == p else 0)


def suffix_array(s: typing.Union[str, typing.List[int]],
                 upper: typing.Optional[int] = None) -> typing.List[int]:
    '''
    SA-IS, linear-time suffix array construction
    Reference:
    G. Nong, S. Zhang, and W. H. Chan,
    Two Efficient Algorithms for Linear Time Suffix Array Construction
    '''

    if isinstance(s, str):
        return _sa_is([ord(c) for c in s], 255)
    elif upper is None:
        n = len(s)
        idx = list(range(n))

        def cmp(left: int, right: int) -> int:
            return typing.cast(int, s[left]) - typing.cast(int, s[right])

        idx.sort(key=functools.cmp_to_key(cmp))
        s2 = [0] * n
        now = 0
        for i in range(n):
            if i and s[idx[i - 1]] != s[idx[i]]:
                now += 1
            s2[idx[i]] = now
        return _sa_is(s2, now)
    else:
        assert 0 <= upper
        for d in s:
            assert 0 <= d <= upper

        return _sa_is(s, upper)


def lcp_array(s: typing.Union[str, typing.List[int]],
              sa: typing.List[int]) -> typing.List[int]:
    '''
    Longest-Common-Prefix computation
    Reference:
    T. Kasai, G. Lee, H. Arimura, S. Arikawa, and K. Park,
    Linear-Time Longest-Common-Prefix Computation in Suffix Arrays and Its
    Applications
    '''

    if isinstance(s, str):
        s = [ord(c) for c in s]

    n = len(s)
    assert n >= 1

    rnk = [0] * n
    for i in range(n):
        rnk[sa[i]] = i

    lcp = [0] * (n - 1)
    h = 0
    for i in range(n):
        if h > 0:
            h -= 1
        if rnk[i] == 0:
            continue
        j = sa[rnk[i] - 1]
        while j + h < n and i + h < n:
            if s[j + h] != s[i + h]:
                break
            h += 1
        lcp[rnk[i] - 1] = h

    return lcp


def _sa_naive(s: typing.List[int]) -> typing.List[int]:
    sa = list(range(len(s)))
    return sorted(sa, key=lambda i: s[i:])


def _sa_doubling(s: typing.List[int]) -> typing.List[int]:
    n = len(s)
    sa = list(range(n))
    rnk = s.copy()
    tmp = [0] * n
    k = 1
    while k < n:
        def cmp(x: int, y: int) -> int:
            if rnk[x] != rnk[y]:
                return rnk[x] - rnk[y]
            rx = rnk[x + k] if x + k < n else -1
            ry = rnk[y + k] if y + k < n else -1
            return rx - ry
        sa.sort(key=functools.cmp_to_key(cmp))
        tmp[sa[0]] = 0
        for i in range(1, n):
            tmp[sa[i]] = tmp[sa[i - 1]] + (1 if cmp(sa[i - 1], sa[i]) else 0)
        tmp, rnk = rnk, tmp
        k *= 2
    return sa


def _sa_is(s: typing.List[int], upper: int) -> typing.List[int]:
    threshold_naive = 10
    threshold_doubling = 40

    n = len(s)

    if n == 0:
        return []
    if n == 1:
        return [0]
    if n == 2:
        if s[0] < s[1]:
            return [0, 1]
        else:
            return [1, 0]

    if n < threshold_naive:
        return _sa_naive(s)
    if n < threshold_doubling:
        return _sa_doubling(s)

    sa = [0] * n
    ls = [False] * n
    for i in range(n - 2, -1, -1):
        if s[i] == s[i + 1]:
            ls[i] = ls[i + 1]
        else:
            ls[i] = s[i] < s[i + 1]

    sum_l = [0] * (upper + 1)
    sum_s = [0] * (upper + 1)
    for i in range(n):
        if not ls[i]:
            sum_s[s[i]] += 1
        else:
            sum_l[s[i] + 1] += 1
    for i in range(upper + 1):
        sum_s[i] += sum_l[i]
        if i < upper:
            sum_l[i + 1] += sum_s[i]

    def induce(lms: typing.List[int]) -> None:
        nonlocal sa
        sa = [-1] * n

        buf = sum_s.copy()
        for d in lms:
            if d == n:
                continue
            sa[buf[s[d]]] = d
            buf[s[d]] += 1

        buf = sum_l.copy()
        sa[buf[s[n - 1]]] = n - 1
        buf[s[n - 1]] += 1
        for i in range(n):
            v = sa[i]
            if v >= 1 and not ls[v - 1]:
                sa[buf[s[v - 1]]] = v - 1
                buf[s[v - 1]] += 1

        buf = sum_l.copy()
        for i in range(n - 1, -1, -1):
            v = sa[i]
            if v >= 1 and ls[v - 1]:
                buf[s[v - 1] + 1] -= 1
                sa[buf[s[v - 1] + 1]] = v - 1

    lms_map = [-1] * (n + 1)
    m = 0
    for i in range(1, n):
        if not ls[i - 1] and ls[i]:
            lms_map[i] = m
            m += 1
    lms = []
    for i in range(1, n):
        if not ls[i - 1] and ls[i]:
            lms.append(i)

    induce(lms)

    if m:
        sorted_lms = []
        for v in sa:
            if lms_map[v] != -1:
                sorted_lms.append(v)
        rec_s = [0] * m
        rec_upper = 0
        rec_s[lms_map[sorted_lms[0]]] = 0
        for i in range(1, m):
            left = sorted_lms[i - 1]
            right = sorted_lms[i]
            if lms_map[left] + 1 < m:
                end_l = lms[lms_map[left] + 1]
            else:
                end_l = n
            if lms_map[right] + 1 < m:
                end_r = lms[lms_map[right] + 1]
            else:
                end_r = n

            same = True
            if end_l - left != end_r - right:
                same = False
            else:
                while left < end_l:
                    if s[left] != s[right]:
                        break
                    left += 1
                    right += 1
                if left == n or s[left] != s[right]:
                    same = False

            if not same:
                rec_upper += 1
            rec_s[lms_map[sorted_lms[i]]] = rec_upper

        rec_sa = _sa_is(rec_s, rec_upper)

        for i in range(m):
            sorted_lms[i] = lms[rec_sa[i]]
        induce(sorted_lms)

    return sa


if __name__ == '__main__':
    resolve()

"
3178719,ALDS1_14_D,"from collections import Counter
import time

def SL(S):
    t = [""S""]*len(S)
    for i in range(len(S)-2,-1,-1):
        if S[i] > S[i+1] or (S[i] == S[i+1] and t[i+1] == ""L""):
            t[i] = ""L""
    return t

def LMS(t):
    lms = [False]*len(t)
    for i in range(1,len(t)):
        if t[i-1] == ""L"" and t[i] == ""S"":
            lms[i] = True
    return lms

def Bucket(S):
    bucket = Counter(S)
    tmp = 0
    for i in sorted(bucket):
        bucket[i] = {""chead"":tmp,""ctail"":tmp+bucket[i]-1}
        tmp = bucket[i][""ctail""]+1
    return bucket

def STEP2(S,t,bucket,SA):
    for i in range(len(SA)):
        tmp = SA[i]-1
        if t[tmp] == ""L"" and tmp > -1:
            head = bucket[S[tmp]][""chead""]
            SA[head] = tmp
            bucket[S[tmp]][""chead""]+=1

def STEP3(S,t,SA):
    bucket = Bucket(S)
    for i in range(len(SA)-1,-1,-1):
        tmp = SA[i]-1
        if t[tmp] == ""S"" and tmp > -1:
            tail = bucket[S[tmp]][""ctail""]
            SA[tail] = tmp
            bucket[S[tmp]][""ctail""]-=1
        
def InducedSorting(S):
    l = len(S)
    t = SL(S)
    lms = LMS(t)
    bucket = Bucket(S)
    SA=[-1]*l
    P1 = [i for i in range(l) if lms[i]]
    #STEP1
    for i,j in enumerate(lms):
        if j:
            tail = bucket[S[i]][""ctail""]
            SA[tail] = i
            bucket[S[i]][""ctail""] -= 1
    #STEP2
    STEP2(S,t,bucket,SA)
    #STEP3
    STEP3(S,t,SA)
    #Construct S1 from pseudoSA
    prev = None
    Name = [None]*l
    name = 0
    S1 = []
    for i in SA:
        if lms[i]:
            if prev and not i == len(S)-1:
                j = 0
                while(True):
                    if not S[i+j] == S[prev+j] or not t[i+j] == t[prev+j]:
                        name+=1
                        break
                    if j>0 and lms[i+j]:
                        break
                    j+=1
            Name[i] = name
            prev = i
    for i in Name:
        if not i == None:
            S1.append(i)
    #Construct SA1 from S1
    uniq = True
    dtmp = {}
    #for i in Counter(S1):
    #    if Counter(S1)[i] > 1:
    #        uniq = False
    #        break
    for i in S1:
        if i in dtmp:
            uniq = False
            break
        else:
            dtmp[i] = True
    
    if uniq:
        SA1 = [None]*len(S1)
        for i,j in enumerate(S1):
            SA1[j] = i
    else:
        SA1 = InducedSorting(S1)
    
    #Inducing SA from SA1 STEP1
    bucket = Bucket(S)
    SA=[-1]*l
    for i in SA1[::-1]:
        p = P1[i]
        tail = bucket[S[p]][""ctail""]
        SA[tail] = p
        bucket[S[p]][""ctail""] -= 1
    #Inducing SA from SA1 STEP2
    STEP2(S,t,bucket,SA)
    #Inducing SA from SA1 STEP3
    STEP3(S,t,SA)
    return SA

def contain(T,sa,P):
    a = 0
    b = len(T)
    while(b-a > 1):
        c = (a+b)//2
        if T[sa[c]:sa[c]+len(P)] < P:
            a = c
        else:
            b = c
    return P == T[sa[b]:sa[b]+len(P)]

T = input()
Q = int(input())
P = [input() for _ in range(Q)]
SA = InducedSorting(T+""$"")
for i in P:
    if contain(T,SA,i):
        print(1)
    else:
        print(0)
"
2896362,ALDS1_14_D,"from collections import Counter
from math import floor, ceil, log
from heapq import heapreplace, heappush
import time


class TreeIndex:
    CACHESIZE = 65535

    class Node:
        __slots__ = ('level', 'keys', 'values', 'keylen')

        def __init__(self, level):
            self.level = level
            self.values = []
            self.keys = {}
            self.keylen = 2 ** self.level

        def add(self, text, value):
            if len(text) == 0:
                self.values.append(value)
                return self
            pre = text[:self.keylen]
            post = text[self.keylen:]
            if pre not in self.keys:
                self.keys[pre] = self.__class__(self.level+1)
            return self.keys[pre].add(post, value)

        def find(self, text):
            if len(text) == 0:
                return self
            pre = text[:self.keylen]
            post = text[self.keylen:]
            if pre in self.keys:
                return self.keys[pre].find(post)
            else:
                return None

        def __contains__(self, text):
            if len(text) > self.keylen:
                pre = text[:self.keylen]
                post = text[self.keylen:]
                return (pre in self.keys and post in self.keys[pre])
            else:
                return any(key.startswith(text) for key in self.keys)

        def __str__(self):
            return ('(' + ','.join([""{}->{}"".format(k, v)
                                   for k, v in self.keys.items()]) + ')')

    def __init__(self, text):
        self.text = text
        self._init_cache()
        self._keylen()
        self._create_index()

    def _keylen(self):
        chars = Counter(list(self.text))
        ent = 0.0
        total = len(self.text)
        base = len(chars) + 1
        for c, cnt in chars.items():
            p = cnt / total
            ent -= p * log(p, base)
        self.keylen = max(2 ** ceil(10 * (1 - ent)) - 1, 3)

    def _create_index(self):
        self.tree = self.Node(0)
        length = len(self.text)
        for i in range(length):
            self.add(self.text[i:i+self.keylen], i)

    def _init_cache(self):
        self._cache = {}
        self._cacheq = []

    def _set_cache(self, text, node):
        if text not in self._cache:
            if len(self._cacheq) > self.CACHESIZE:
                _, txt = heapreplace(self._cacheq, (time.clock(), text))
                del self._cache[txt]
            else:
                heappush(self._cacheq, (time.clock(), text))
            self._cache[text] = node

    def _get_cache(self, text):
        if text in self._cache:
            return self._cache[text]
        else:
            return None

    def index(self, text):
        node = self._get_cache(text)
        if node is None:
            node = self.tree.find(text)

        if node is None:
            return []
        else:
            self._set_cache(text, node)
            return node.values

    def add(self, text, value):
        node = self._get_cache(text)
        if node is None:
            node = self.tree.add(text, value)
            self._set_cache(text, node)
        else:
            node.add('', value)

    def match(self, search_text):
        def _match_partial(lo, hi):
            split = self.keylen
            if search_text[lo+split:hi] in self.tree:
                for i in self.index(search_text[lo:lo+split]):
                    if (self.text[i+split:i+hi-lo]
                            == search_text[lo+split:hi]):
                        yield i

        def _match(lo, hi):
            length = hi - lo

            if length == self.keylen:
                return (i for i in self.index(search_text[lo:hi]))
            elif length < self.keylen*2:
                return _match_partial(lo, hi)

            mid = lo + length // 2
            pre = _match(lo, mid)
            post = _match(mid, hi)

            return _merge(pre, post, mid-lo)

        def _merge(idx1, idx2, shift):
            i2 = next(idx2)
            for i1 in idx1:
                while i1 + shift > i2:
                    i2 = next(idx2)
                if i1 + shift == i2:
                    yield i1

        length = len(search_text)
        if length < self.keylen:
            return search_text in self.tree

        # align by key length
        k = floor(log(length/self.keylen, 2))
        b = self.keylen * 2**k
        if length - self.keylen < b < length and k > 0:
            b = self.keylen * 2**(k-1)

        try:
            if b + self.keylen < length:
                match = _merge(_match(0, b), _match(b, length), b)
            else:
                match = _match(0, length)
            next(match)
            return True
        except StopIteration:
            return False


def run():
    s1 = input()
    n = int(input())

    index = TreeIndex(s1)
    for _ in range(n):
        s2 = input()
        if index.match(s2):
            print(1)
        else:
            print(0)


if __name__ == '__main__':
    run()

"
9068952,ALDS1_14_D,"from collections import defaultdict

T = None
MOD = 67280421310721
BASE = 301
CACHE = defaultdict(lambda: [])


def forward_find(hashes) -> bool:
    h = hashes[0]
    cache = CACHE[h]

    while cache:
        i = cache.pop()

        if len(T) < i + len(hashes):
            if i + 1 < len(T):
                h_ = (h * BASE + T[i + 1]) % MOD
                CACHE[h_].append(i + 1)
            continue

        h_ = h

        for j in range(1, len(hashes)):
            h_ = (h_ * BASE + T[i + j]) % MOD
            if h_ == hashes[j]:
                CACHE[h_]
            else:
                CACHE[h_].append(i + j)
                break
        else:
            CACHE[h_].append(i + len(hashes) - 1)
            return True

    return False


def find(p):
    if len(p) == 1:
        if p[0] in CACHE:
            return [p[0]]
        else:
            return None
    else:
        fst = p[: len(p) // 2]
        snd = p[len(p) // 2 :]

        if fst_hashes := find(fst):
            if find(snd) is None:
                return None

            hashes = fst_hashes
            last = hashes[-1]
            for c in snd:
                last = (last * BASE + c) % MOD
                hashes.append(last)

            if last in CACHE:
                return hashes

            for i in reversed(range(len(hashes) - 1)):
                h = hashes[i]
                if h in CACHE and forward_find(hashes[i:]):
                    return hashes


if __name__ == ""__main__"":
    T = tuple(map(ord, input()))
    Q = int(input())

    for i in range(len(T)):
        c = T[i]
        CACHE[c].append(i)

    for _ in range(Q):
        p = tuple(map(ord, input()))
        if find(p):
            print(""1"")
        else:
            print(""0"")

"
7504912,ALDS1_14_D,"def SuffixArray(S, mn=ord(""a""), str_cnt=26):
    def value(n: int):
        if n == N: return 0
        return (ord(S[n]) if type(S[n]) is str else S[n]) - mn + 1

    def InducedSorting(LMS):
        str_range = [[0] * 2 for _ in range(str_cnt + 1)]
        ""Determine the interval for each word in S to put into sa""
        for i in range(1, str_cnt + 1):
            str_range[i][1] = str_range[i - 1][1] + str_num[i]
            str_range[i][0] = str_range[i - 1][1] + 1
        # print(f""str_range = {str_range} where S = {S}"")

        sa = [-1] * (N + 1)
        for i in range(str_cnt, -1, -1):
            for j in range(len(LMS[i])):
                n = LMS[i][len(LMS[i]) - 1 - j]
                val = ((ord(S[n]) if type(S[n]) is str else S[n]) - mn + 1) if n < N else 0
                ins_pos = str_range[val][1]
                sa[ins_pos] = n
                str_range[val][1] -= 1
        for i in range(str_cnt, -1, -1):
            for j in range(len(LMS[i])):
                n = LMS[i][len(LMS[i]) - 1 - j]
                val = ((ord(S[n]) if type(S[n]) is str else S[n]) - mn + 1) if n < N else 0
                str_range[val][1] += 1
        ""Insert L-types into sa""
        for i, n in enumerate(sa):
            if n == -1 or n == 0: continue
            val = (ord(S[n - 1]) if type(S[n - 1]) is str else S[n - 1]) - mn + 1
            ins_pos = str_range[val][0]
            if i < ins_pos and LS[n - 1]:
                sa[ins_pos] = n - 1
                str_range[val][0] += 1
        ""Insert S-types into sa""
        for i in range(N, -1, -1):
            n = sa[i]
            if n == 0: continue
            val = (ord(S[n - 1]) if type(S[n - 1]) is str else S[n - 1]) - mn + 1
            ins_pos = str_range[val][1]
            if i > ins_pos and LS[n - 1] <= 0:
                sa[ins_pos] = n - 1
                str_range[val][1] -= 1
        # print(f""sa = {sa} where S = {S}"")
        return sa

    N = len(S)
    LS = [0] * (N + 1)
    str_num = [0] * (str_cnt + 1)
    LMS = [[] for _ in range(str_cnt + 1)]
    sorted_LMS = []

    ""Classify each word in S as L-type, S-type, and LMS-type. ""
    for i in range(N - 1, -1, -1):
        val = (ord(S[i]) if type(S[i]) is str else S[i]) - mn + 1
        valn = ((ord(S[i + 1]) if type(S[i + 1]) is str else S[i + 1]) - mn + 1) if i < N - 1 else 0
        if i == N - 1 or val > valn:
            LS[i] = 1
        elif val == valn:
            LS[i] = LS[i + 1]
        if LS[i] == 1 and LS[i + 1] == 0:
            LS[i + 1] = -1
            LMS[valn].append(i + 1)
            sorted_LMS.append(i + 1)
        str_num[val] += 1
    sorted_LMS = sorted_LMS[::-1]
    M = len(sorted_LMS)
    # print(f""First LMS = {LMS} where S = {S}"")

    pre_sa = InducedSorting(LMS)
    LMS = [[] for _ in range(str_cnt + 1)]
    for n in pre_sa:
        if LS[n] == -1:
            val = ((ord(S[n]) if type(S[n]) is str else S[n]) - mn + 1) if n < N else 0
            LMS[val].append(n)
    # print(f""Second LMS = {LMS} where S = {S}"")

    pos = [0] * (N + 1)
    for i in range(M - 1):
        n = sorted_LMS[i]
        pos[n] = i

    cnt = 0
    rank = [0] * (N + 1)
    LMS_subs = """"
    for i in range(1, str_cnt + 1):
        for n in LMS[i]:
            nn = sorted_LMS[pos[n] + 1]
            ss = S[n: nn + 1]
            # print(n, nn)
            # print(f""{LMS_subs}, {ss} where S = {S}"")
            if LMS_subs != ss:
                cnt += 1
            LMS_subs = ss
            rank[n] = cnt
    # print(f""rank = {rank} where S = {S}"")
    T = [rank[n] for n in sorted_LMS[:M - 1]]
    if not cnt == M - 1:
        # print(f""Next string is T = {T}"")
        # LMS = [sorted_LMS[n] for n in SuffixArray(T, mn=1, str_cnt=cnt)]
        T_sa = SuffixArray(T, mn=1, str_cnt=cnt)
        LMS = [[] for _ in range(str_cnt + 1)]
        for n in T_sa:
            m = sorted_LMS[n]
            val = ((ord(S[m]) if type(S[m]) is str else S[m]) - mn + 1) if m < N else 0
            LMS[val].append(m)
        # print(f""Third LMS = {LMS} where S = {S}"")
    return InducedSorting(LMS)


S = input()
Q = int(input())
SA = SuffixArray(S, mn=ord(""0""), str_cnt=300)
N = len(S)
for _ in range(Q):
    T = input()
    M = len(T)

    ok, ng = 0, N + 1
    while abs(ok - ng) > 1:
        mid = (ok + ng) // 2
        n = SA[mid]
        if S[n: n + M] <= T:
            ok = mid
        else:
            ng = mid
    r = ok

    ok, ng = 0, N + 1
    while abs(ok - ng) > 1:
        mid = (ok + ng) // 2
        n = SA[mid]
        if S[n: n + M] < T:
            ok = mid
        else:
            ng = mid
    l = ok

    if r - l >= 1:
        print(1)
    else:
        print(0)
"
3397975,ALDS1_14_D,"#!/usr/bin/env python3

import sys


def lms(t, i):
    return i > 0 and not t[i-1] and t[i]


def induced_sort(s, k, t, lmss):

    sa = [-1] * len(s)
    cbin = [0]*k

    for c in s:
        cbin[c] += 1

    ssum = 0
    for i in range(k):
        ssum += cbin[i]
        cbin[i] = ssum

    count = [0] * k
    for i in reversed(lmss):
        c = s[i]
        sa[cbin[c]-1 - count[c]] = i
        count[c] += 1

    count = [0] * k
    for i in sa:
        if i <= 0 or t[i-1]:
            continue
        c = s[i-1]
        sa[cbin[c-1] + count[c]] = i-1
        count[c] += 1
        
    count = [0] * k
    for i in reversed(sa):
        if i <= 0 or not t[i-1]:
            continue
        c = s[i-1]
        sa[cbin[c]-1 - count[c]] = i-1
        count[c] += 1

    return sa


def sa_is(s, k):
    slen = len(s)
    t = [True] * slen # S -> True, T -> False
    for i in range(slen-2, -1, -1):
        #if s[i] < s[i+1]:   t[i] = True #'S'
        if s[i] > s[i+1]:
            t[i] = False # 'L'
        elif s[i] == s[i+1]:
            t[i] = t[i+1]

    lmss = []
    for i in range(1,slen):
        if not t[i-1] and t[i]: # lms(t, i):
            lmss.append(i)

    seed = lmss

    sa = induced_sort(s, k, t, seed)

    new_sa = []
    for i in sa:
        if lms(t, i): new_sa.append(i)

    nums = dict() #    nums = [[]] * (max(new_sa)+1)
    nums[new_sa[0]] = 0
    num = 0
    for o in range(len(new_sa)-1):
        i, j = new_sa[o], new_sa[o+1]
        diff, d = False, 0
        for d in range(slen):
            if s[i+d] != s[j+d] or lms(t, i+d) != lms(t, j+d):
                diff = True
                break
            elif d > 0 and (lms(t, i+d) or lms(t, j+d)):
                break
        if diff:
            num += 1
        nums[j] = num

#    for i in range(len(nums)-1,-1,-1):
#        if not nums[i]: nums.pop(i)
    nums = list(map(lambda x: x[1], sorted(nums.items())))

    if num + 1 < len(nums):
        sa = sa_is(nums, num+1)
    else:
        sa = [[]] * (max(nums)+1)
        for i, c in enumerate(nums):
            sa[c] = i

    seed = list(map(lambda x:lmss[x], sa))
    sa = induced_sort(s, k, t, seed)

    return sa


def strcmp(a, b):
    for i, bi in enumerate(b):
        if a[i] == bi: continue
        return a[i]-bi
    return 0


def search(s, sa, slen, q):
    ss = 0
    ee = slen
    while ss <= ee:
        mid = (ss+ee)//2
        if mid >= slen: break
        rr = strcmp(s[sa[mid]:], q)
        if rr==0: return 1
        if rr >= 0:
            ee = mid-1
        else:
            ss = mid+1
    return 0


if __name__ == '__main__':

    b = sys.stdin.readline().rstrip()
    b = (b+'$').encode()
    sa = sa_is(b, 128) #ord('z'))
    n = int(sys.stdin.readline())
    for _ in range(n):
        q = sys.stdin.readline().rstrip().encode()
        if search(b, sa, len(b), q) > 0:
            print(1)
        else:
            print(0)

"
5262856,ALDS1_14_D,"import sys
def solve():
    def sa_is(s,upper):
        n=len(s)
        if n==0:
            return []
        if n==1:
            return [0]
        if n==2:
            if (s[0]<s[1]):
                return [0,1]
            else:
                return [1,0]
        sa=[0]*n
        ls=[0]*n
        for i in range(n-2,-1,-1):
            ls[i]=ls[i+1] if (s[i]==s[i+1]) else (s[i]<s[i+1])
        sum_l=[0]*(upper+1)
        sum_s=[0]*(upper+1)
        for i in range(n):
            if not(ls[i]):
                sum_s[s[i]]+=1
            else:
                sum_l[s[i]+1]+=1
        for i in range(upper+1):
            sum_s[i]+=sum_l[i]
            if i<upper:
                sum_l[i+1]+=sum_s[i]
        def induce(lms):
            for i in range(n):
                sa[i]=-1
            buf=sum_s[:]
            for d in lms:
                if d==n:
                    continue
                sa[buf[s[d]]]=d
                buf[s[d]]+=1
            buf=sum_l[:]
            sa[buf[s[n-1]]]=n-1
            buf[s[n-1]]+=1
            for i in range(n):
                v=sa[i]
                if v>=1 and not(ls[v-1]):
                    sa[buf[s[v-1]]]=v-1
                    buf[s[v-1]]+=1
            buf=sum_l[:]
            for i in range(n-1,-1,-1):
                v=sa[i]
                if v>=1 and ls[v-1]:
                    buf[s[v-1]+1]-=1
                    sa[buf[s[v-1]+1]]=v-1
        lms_map=[-1]*(n+1)
        m=0
        for i in range(1,n):
            if not(ls[i-1]) and ls[i]:
                lms_map[i]=m
                m+=1
        lms=[]
        for i in range(1,n):
            if not(ls[i-1]) and ls[i]:
                lms.append(i)
        induce(lms)
        if m:
            sorted_lms=[]
            for v in sa:
                if lms_map[v]!=-1:
                    sorted_lms.append(v)
            rec_s=[0]*m
            rec_upper=0
            rec_s[lms_map[sorted_lms[0]]]=0
            for i in range(1,m):
                l=sorted_lms[i-1]
                r=sorted_lms[i]
                end_l=lms[lms_map[l]+1] if (lms_map[l]+1<m) else n
                end_r=lms[lms_map[r]+1] if (lms_map[r]+1<m) else n
                same=True
                if end_l-l!=end_r-r:
                    same=False
                else:
                    while(l<end_l):
                        if s[l]!=s[r]:
                            break
                        l+=1
                        r+=1
                    if (l==n) or (s[l]!=s[r]):
                        same=False
                if not(same):
                    rec_upper+=1
                rec_s[lms_map[sorted_lms[i]]]=rec_upper
            rec_sa=sa_is(rec_s,rec_upper)
            for i in range(m):
                sorted_lms[i]=lms[rec_sa[i]]
            induce(sorted_lms)
        return sa

    def cmp(s, t):
        for i, e in enumerate(t):
            if s[i] != e:
                return s[i] - e
        return 0

    def find(t, s, sa):
        low, high = 0, len(s)
        while high >= low:
            mid = (low + high) // 2
            if mid >= len(s):
                break
            res = cmp(s[sa[mid]:], t)
            if res == 0:
                return True
            if res > 0:
                high = mid - 1
            else:
                low = mid + 1
        return False

    T = sys.stdin.readline().rstrip()
    T = (T + '$').encode()
    sa = sa_is(T, 128)
    Q = int(input())
    ans = """"
    for _ in range(Q):
        P = sys.stdin.readline().rstrip().encode()
        ans += ""1"" if find(P, T, sa) else ""0""
        if _ != Q - 1:
            ans += ""\n""
    print(ans)

if __name__ == '__main__':
    solve()
"
2732457,ALDS1_14_D,"base = 127
mask = (1 << 32) - 1
def calc_hash(f, pl, tl):
    dl = tl - pl
    tmp = set()
    t = 1
    for _ in range(pl):
        t = (t * base) & mask
    e = 0
    for i in range(pl):
        e = (e * base + f[i]) & mask
    for i in range(dl):
        tmp.add(e)
        e = (e * base - t * f[i] + f[i + pl]) & mask
    tmp.add(e)
    return tmp
t = tuple(ord(c) for c in input())
tl = len(t)
q = int(input())
h = dict()
c = dict()
a = []
for _ in range(q):
    p = input()
    if p in c:
        a.append(c[p])
        continue
    p = tuple(ord(c) for c in p)
    pl = len(p)
    if pl > tl:
        a.append(""0"")
        continue
    bs = min(19, pl)
    keys = calc_hash(p, bs, pl)
    if bs not in h:
        h[bs] = calc_hash(t, bs, tl)
    a.append(""1"" if keys <= h[bs] else ""0"")
print('\n'.join(a))
"
5011713,ALDS1_14_D,"

base = 127
mask = (1 << 32) - 1


def calc_hash(f, pl, tl):
    dl = tl - pl
    tmp = set()

    t = 1
    for _ in range(pl):
        t = (t * base) & mask
    e = 0
    for i in range(pl):
        e = (e * base + f[i]) & mask
    for i in range(dl):
        tmp.add(e)
        e = (e * base - t * f[i] + f[i + pl]) & mask
    tmp.add(e)
    return tmp


t = [ord(c) for c in input().strip()]
tl = len(t)
q = int(input())
ps = [input().strip() for _ in range(q)]
h = dict()
c = dict()
a = []
for p in ps:
    if p in c:
        a.append(c[p])
        continue
    p = [ord(c) for c in p]
    pl = len(p)
    if pl > tl:
        a.append(0)
        continue
    bs = min(19, pl)
    keys = calc_hash(p, bs, pl)
    if bs not in h:
        h[bs] = calc_hash(t, bs, tl)
    a.append(1 if keys.issubset(h[bs]) else 0)
print('\n'.join(map(str, a)))

"
3809632,ALDS1_14_D,"from typing import Dict, List


def calc_hash(input_v: List[int], target_len: int, input_len: int) -> set:
    global base, mask
    diff_len = input_len - target_len
    hash_set = set()

    bit_mask = 1
    for _ in range(target_len):
        bit_mask = (bit_mask * base) & mask
    hash_v = 0
    for i in range(target_len):
        hash_v = (hash_v * base + input_v[i]) & mask
    for i in range(diff_len):
        hash_set.add(hash_v)
        hash_v = (hash_v * base - bit_mask * input_v[i]
                  + input_v[i + target_len]) & mask
    hash_set.add(hash_v)

    return hash_set


if __name__ == ""__main__"":
    base = 123  # Ascii code after 'z'
    mask = (1 << 32) - 1  # Mask.

    input_v = [ord(s) for s in input()]
    input_len = len(input_v)

    checked_dict: Dict[int, set] = {}
    num_target = int(input())

    for _ in range(num_target):
        target_v = [ord(s) for s in input()]
        target_len = len(target_v)
        if input_len < target_len:
            print(0)
            continue
        magic_len = min(19, target_len)  # Magic number to reduce calc time.
        key = calc_hash(target_v, magic_len, target_len)
        if magic_len not in checked_dict:
            checked_dict[magic_len] = calc_hash(input_v, magic_len, input_len)
        if key.issubset(checked_dict[magic_len]):
            print(1)
        else:
            print(0)

"
4686329,ALDS1_14_D,"base = 127
mask = (1 << 32) - 1

def calc_hash(lstr, pl, tl):
    dl = tl - pl
    tmp = set()

    d = 1
    for _ in range(pl):
        d = (d * base) & mask
    e = 0
    for i in range(pl):
        e = (e * base + lstr[i]) & mask
    for i in range(dl):
        tmp.add(e)
        e = (e * base - d * lstr[i] + lstr[i + pl]) & mask
    tmp.add(e)
    return tmp


t = [ord(c) for c in input().strip()]
tl = len(t)
q = int(input())
ps = [input().strip() for _ in range(q)]
h = dict()
dic = dict()
a = []
for pp in ps:
    if pp in dic:
        a.append(dic[pp])
        continue
    p = [ord(c) for c in pp]
    pl = len(p)
    if pl > tl:
        a.append(0)
        continue
    bs = min(19, pl)
    keys = calc_hash(p, bs, pl)
    if bs not in h:
        h[bs] = calc_hash(t, bs, tl)
#    print(""hb"", keys, h[bs])
    a.append(1 if keys.issubset(h[bs]) else 0) #keysがh[bs]に含まれるか
    dic[pp] = a[-1]
print('\n'.join(map(str, a)))


"
2450517,ALDS1_14_D,"base = 127
mask = (1 << 32) - 1


def calc_hash(f, pl, tl):
    dl = tl - pl
    tmp = set()

    t = 1
    for _ in range(pl):
        t = (t * base) & mask
    e = 0
    for i in range(pl):
        e = (e * base + f[i]) & mask
    for i in range(dl):
        tmp.add(e)
        e = (e * base - t * f[i] + f[i + pl]) & mask
    tmp.add(e)
    return tmp


t = [ord(c) for c in input().strip()]
tl = len(t)
q = int(input())
ps = [input().strip() for _ in range(q)]
h = dict()
c = dict()
a = []
for p in ps:
    if p in c:
        a.append(c[p])
        continue
    p = [ord(c) for c in p]
    pl = len(p)
    if pl > tl:
        a.append(0)
        continue
    bs = min(19, pl)
    keys = calc_hash(p, bs, pl)
    if bs not in h:
        h[bs] = calc_hash(t, bs, tl)
    a.append(1 if keys.issubset(h[bs]) else 0)
print('\n'.join(map(str, a)))
"
8442735,ALDS1_15_A,"def min_coins(n):
    coins = [25, 10, 5, 1]  # コインの種類
    total_coins = 0  # 必要なコインの数
    for coin in coins:
        total_coins += n // coin  # 各コインで作成できるお釣りの数
        n %= coin  # 残りのお釣り
    return total_coins

n = int(input().strip())
print(min_coins(n))
"
8473306,ALDS1_15_A,"n = int(input())
ans = 0
d, n = n // 25, n % 25
ans += d
d, n = n // 10, n % 10
ans += d
d, n = n // 5, n % 5
ans += d
ans += n
print(ans)

"
8707917,ALDS1_15_A,"n = int(input())
ans = 0
for c in (25, 10, 5, 1):
    ans += n // c
    n %= c
print(ans)

"
8856650,ALDS1_15_A,"# aizu_ALDS1_15_A_ChangeMaking.py  

n = int(input())
money = [0]*4

for i,unit in enumerate([25,10,5]):
    money[i] = n // unit 
    n %= unit

money[3] = n

print(sum(money))
"
8879059,ALDS1_15_A,"n=int(input())
a=n//25
n-=25*a
b=n//10
n-=10*b
c=n//5
n-=5*c
print(a+b+c+n)
"
8940991,ALDS1_15_A,"n = int(input())
changes = [25, 10, 5, 1]
cnt = 0
for c in changes:
    cnt += n // c
    n %= c
print(cnt)
"
9011875,ALDS1_15_A,"n = int(input())
coin = [25, 10, 5, 1]
result = 0
for c in coin:
    result += n // c
    n %= c
print(result)    

"
9030762,ALDS1_15_A,"coins=[25,10,5,1]
change=int(input())
count=0

for i in coins:
    a=int(change/i)
    count+=a
    change-=a*i

print(count)
"
9069019,ALDS1_15_A,"def run(n):
    ret = n // 25
    n %= 25

    ret += n // 10
    n %= 10

    ret += n // 5
    n %= 5

    ret += n
    return ret


if __name__ == ""__main__"":
    N = int(input())
    print(run(N))

"
3323995,ALDS1_15_A,"target = int(input())
coins = [25, 10, 5, 1]
ans = 0
for c in coins:
    ans += target // c
    target %= c
print(ans)
"
3355046,ALDS1_15_A,"coins = [25,10,5,1]

n = int(input())

ans = 0

for coin in coins:
	if n == 0:
		break
	else:
		ans += int(n/coin)
		n = n % coin

print(ans)

"
3366100,ALDS1_15_A,"C = (25, 10, 5, 1)

n = int(input())

ans = 0

for c in C:
    ans += n // c
    n %= c

print(ans)

"
3366922,ALDS1_15_A,"#  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_15_A&lang=jp
#  Greedy alogithms : python3
#  2019.2.3 yonezawa

import sys
input = sys.stdin.readline
#import cProfile

def main():
    s = int(input())
    cv = [25,10,5,1]
    n = 0
    for i in cv:
        n += s // i
        s = s % i
    print (n)

if __name__ == '__main__':
    main()
    #pr = cProfile.Profile()
    #pr.runcall(main)
    #pr.print_stats()

"
3398170,ALDS1_15_A,"import sys

n = int(sys.stdin.readline())

k = 0
for c in [25, 10, 5]:
    k += n // c
    n %= c

print(k+n)
"
3540370,ALDS1_15_A,"n = int(input())
many = [25, 10, 5, 1]
cnt = 0
for i in many:
    cnt += n//i
    n = n%i
print(cnt)
"
3664357,ALDS1_15_A,"n=int(input())
quarter=n//25
n=n%25
ten=n//10
n=n%10
five=n//5
n=n%5
print(quarter+ten+five+n)

"
3697902,ALDS1_15_A,"n = int(input())
ans = 0
for x in (25, 10, 5, 1):
  ans += n // x
  n %= x
print(ans)
"
3701178,ALDS1_15_A,"n= int(input())
ans = 0
a = n % 25
b = a % 10
c = b % 5
ans += n//25 + a//10 + b//5 + c
print(ans)
"
3701828,ALDS1_15_A,"n = int(input())
n_calc = n

C = [1, 5, 10, 25]

cnt = 0

for c in C[::-1]:
    q, n_calc = divmod(n_calc, c)
    cnt += q

    if int(n_calc) == 0:
        break


print(cnt)


"
3701921,ALDS1_15_A,"n=int(input())
cnt=n
ans=0
cnt25=divmod(cnt,25)
ans+=cnt25[0]
cnt=cnt25[1]
cnt10=divmod(cnt,10)
ans+=cnt10[0]
cnt=cnt10[1]
cnt5=divmod(cnt,5)
ans+=cnt5[0]
cnt=cnt5[1]
cnt1=divmod(cnt,1)
ans+=cnt1[0]
print(ans)
"
3725617,ALDS1_15_A,"n = int(input())
ans = 0
for x in (25, 10, 5, 1):
  ans += n // x
  n %= x
print(ans)
"
3743015,ALDS1_15_A,"# -*- coding: utf-8 -*-
""""""
Greedy algorithms - Change Making
http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_15_A&lang=jp

""""""
import sys


def solve(n):
    ans = 0
    for c in (25, 10, 5, 1):
        q, r = divmod(n, c)
        ans += q
        n = r
    return ans


def main(args):
    n = int(input())
    ans = solve(n)
    print(ans)


if __name__ == '__main__':
    main(sys.argv[1:])

"
3789395,ALDS1_15_A,"n = int(input())
c2=0
c3=0
c4=0

c1 = int(n/25)
n = n - 25*c1
if n > 0:
    c2 = int(n/10)
    n = n - 10*c2
    
if n > 0:
    c3 = int(n/5)
    n = n - 5*c3
    
if n > 0:
    c4 = n

print(c1+c2+c3+c4)
"
3809735,ALDS1_15_A,"if __name__ == ""__main__"":
    input_value = int(input())
    twenty_five_n = input_value // 25
    input_value = input_value - 25 * twenty_five_n
    ten_n = input_value // 10
    input_value = input_value - 10 * ten_n
    five_n = input_value // 5
    input_value = input_value - 5 * five_n

    print(f""{twenty_five_n + ten_n + five_n + input_value}"")

"
3828311,ALDS1_15_A,"n=int(input())
c25=n//25
n%=25
c10=n//10
n%=10
c5=n//5
n%=5
ans = c25 + c10 + c5 + n
print(ans)
"
3856016,ALDS1_15_A,"n = int(input())
ans = 0

for a in [25, 10, 5, 1]:
    ans += n // a
    n %= a

print(ans)
"
3897839,ALDS1_15_A,"n = int(input())

C = [ 25, 10, 5, 1]
c = 0
for i in range(len(C)):
    c += n//C[i]
    n = n % C[i]

print(c)

"
3924082,ALDS1_15_A,"n=int(input())
ans=0
a=[25,10,5,1]
for i in a:
    if n<=0:
        break
    d=n//i
    ans+=d
    n-=i*d
    #print(n,ans)
print(ans)
"
4031594,ALDS1_15_A,"n = int(input())
ans = 0
ans += n//25
n = n%25
ans += n//10
n = n%10
ans += n//5
n = n%5
ans += n
print(ans)
"
4064131,ALDS1_15_A,"n=int(input())
ans=0
ans+=n//25
n%=25
ans+=n//10
n%=10
ans+=n//5
n%=5
ans+=n
print(ans)
"
4209816,ALDS1_15_A,"coins = [25, 10, 5, 1]
n = int(input())
ans = 0
for i in coins:
    ans += n//i
    n %= i
print(ans)

"
4316946,ALDS1_15_A,"def main():
    n = int(input())
    coins = [25,10,5,1]
    res = 0
    for c in coins:
        res+=n//c
        n = n%c
    print (res)


if __name__ == '__main__':
    main()


"
4471501,ALDS1_15_A,"def main():
    n = int(input())

    C = [25,10,5,1]
    ans = 0
    for i in range(4):
        ans += n // C[i]
        n %= C[i]

    print(ans)

if __name__ == ""__main__"":
    main()

"
4483284,ALDS1_15_A,"m = int(input())    #money
c =0    #count coin
tc = 0   #temp coin
if m>=25:
    c = m//25
    m = m-(25*c)

if  m>=10:
    tc = m//10
    m = m-(10*tc)
    c += tc

if m>=5:
    tc = m//5
    m = m-(5*tc)
    c += tc

if m>=0:
    tc = m//1
    m = m-(1*tc)
    c += tc
    
print(c)
    
"
4529885,ALDS1_15_A,"#標準入力と変数の初期化
num = int(input())
coin = 0

#25セントを使える枚数を調べ合計金額から減らす
coin += num // 25
num -= num // 25 * 25

#10セントを使える枚数を調べ合計金額を減らす
coin += num // 10
num -= num // 10 * 10

#5セントを使える枚数を調べ合計金額を減らす
coin += num // 5
num -= num // 5 * 5

#1セントの枚数を足し出力する
print(coin + num)
"
4581585,ALDS1_15_A,"n = int(input())
coin = [25,10,5,1]
sum_s = 0
for i in coin:
    sent = n // i
    n %= i
    sum_s += sent
print(sum_s)
"
4592852,ALDS1_15_A,"n = int(input())

cnt = n // 25
n = n % 25
while n >= 10:
    cnt += 1
    n -= 10
while n >= 5:
    cnt += 1
    n -= 5
cnt += n

print(cnt)

"
4596630,ALDS1_15_A,"def main():
    n = int(input())
    cnt = 0
    for i in [25, 10, 5, 1]:
        cnt += n // i
        n = n % i
    print(cnt)

if __name__ == '__main__':
    main()
"
4624498,ALDS1_15_A,"n = int(input())

cnt = 0
for m in reversed([1, 5, 10, 25]):
    cnt += n // m
    n %= m

print(cnt)

"
4645022,ALDS1_15_A,"n = input()

n_25 = int(n) // 25
tmp = int(n) % 25
n_10 = tmp // 10
tmp %= 10
n_5 = tmp // 5
tmp %= 5
n_1 = tmp


print(n_25 + n_10 + n_5 + n_1)
"
4661902,ALDS1_15_A,"n = int(input())
coins = [25, 10, 5, 1]
ans = 0

for coin in coins:
    ans += int(n/coin)
    n = n%coin

print(ans)

"
4680291,ALDS1_15_A,"n = int(input())
ans = 0
for x in (25, 10, 5, 1):
  ans += n // x
  n %= x
print(ans)
"
4690316,ALDS1_15_A,"n = int(input())
cnt = 0
cnt += n//25
n = n % 25
cnt += n//10
n = n % 10
cnt += n//5
n = n % 5
cnt+=n
print(cnt)
"
4750004,ALDS1_15_A,"n = int(input())
c = 0
c += n//25
n %= 25
c += n//10
n %= 10
c += n//5
c += n%5
print(c)
"
4759848,ALDS1_15_A,"# https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/15/ALDS1_15_A


n = int(input())

cnt = 0
coin = (25, 10, 5, 1)
for c in coin:
    cnt += n // c
    n -= c * (n // c)

print(cnt)

"
4763971,ALDS1_15_A,"n = input()

n_25 = int(n) // 25
tmp = int(n) % 25
n_10 = tmp // 10
tmp %= 10
n_5 = tmp // 5
tmp %= 5
n_1 = tmp


print(n_25 + n_10 + n_5 + n_1)
"
4812492,ALDS1_15_A,"# 入力　金額
n = int(input())
# コインの枚数。25, 10, 5, 1の順　
coin_type = [25, 10, 5, 1]
coin_num = [0, 0, 0, 0]



for i, value in enumerate(coin_type):
    coin_num[i] = n // value
    n = n - (value * coin_num[i])
    # print(n)
    # print(coin_num)
    # print(coin_type)


ans = sum(coin_num)
print(ans)
"
4818172,ALDS1_15_A,"

n = int(input())
change = 0
if n >=25:
    change += n//25
    n %= 25

if n >=10:
    change += n//10
    n %= 10

if n >=5:
    change += n//5
    n %= 5

change += n
print(change)
"
4846245,ALDS1_15_A,"
def solve(n):
    cnt = n//25
    n %= 25
    cnt += n//10
    n %= 10
    cnt += n//5
    n %= 5
    cnt += n
    return cnt


N = int(input())
print(solve(N))
"
4873442,ALDS1_15_A,"n = int(input())
count = 0
count += n//25
n %= 25
if n == 0:
    print(count)
    exit()
count += n//10
n %= 10
if n == 0:
    print(count)
    exit()
count += n//5
n %= 5
if n == 0:
    print(count)
    exit()
count += n//1
n %= 1
if n == 0:
    print(count)
    exit()
    
"
5002841,ALDS1_15_A,"n = int(input())

ans = 0

ans += n//25
n = n%25

ans += n//10
n = n%10

ans += n//5
n = n%5

ans += n

print(ans)
"
5026540,ALDS1_15_A,"n=int(input())
a=n//25
b=n%25 // 10
c=n%25%10 // 5
d =n%25%10%5
print(a+b+c+d)
"
5068091,ALDS1_15_A,"n = int(input())
twentyfive = n // 25
n %= 25
ten = n // 10
n %= 10
five = n // 5
n %= 5
one = n
print(twentyfive+ten+five+one)
"
5073121,ALDS1_15_A,"def main():

    n = int(input())
    res = 0
    for i in [25, 10, 5, 1]:
        res += n // i
        n = n % i
    print(res)

main()
"
5090716,ALDS1_15_A,"n = int(input())
print(n // 25 + (n % 25) // 10 + (n % 25 % 10) // 5 + n % 5)
"
5109341,ALDS1_15_A,"n = int(input())
cnt = 0
for c in [25, 10, 5, 1]:
    cnt += n // c
    n = n % c
print(cnt)

"
5120054,ALDS1_15_A,"n = int(input())
ans = (n//25) + (n%25)//10 + (n%25%10)//5 + (n%25%10%5)
print(ans)
"
5203038,ALDS1_15_A,"n = int(input())
c25 = n//25
rem25 = n % 25
c10 = rem25//10
rem10 = rem25 % 10
c5 = rem10 // 5
rem5 = rem10 % 5
c1 = rem5 // 1

print(c25 + c10 + c5 + c1)
"
5208673,ALDS1_15_A,"n=int(input())
ans=0
coin=[25,10,5,1]
for c in coin:
    ans+=n//c
    n%=c
print(ans)
"
5222239,ALDS1_15_A,"n = int(input())
ans = 0
for i in [25, 10, 5, 1]:
    k, n = divmod(n, i)
    ans += k
print(ans)

"
5263010,ALDS1_15_A,"n = int(input())
c = [25, 10, 5, 1]
ans = 0
for e in c:
    ans += n // e
    n %= e
print(ans)
"
5280473,ALDS1_15_A,"n = int(input())
total_coin = 0
for c in [25, 10, 5, 1]:
    if n == 0:
        break
    total_coin += n // c
    n %= c

print(total_coin)
"
5382697,ALDS1_15_A,"n=int(input())
m=0
m+=n//25
n=n%25
m+=n//10
n=n%10
m+=n//5
n=n%5
m+=n
print(m)
"
5469342,ALDS1_15_A,"# お釣りの最小個数
money = int(input())

cent = [25, 10, 5, 1]
count = 0
for c in cent:
    count += money//c
    money = money%c
print(count)
"
9069054,ALDS1_15_B,"def run(weight, items):
    items = [(v / w, v, w) for v, w in items]
    items.sort()

    ret = 0

    for _, v, w in reversed(items):
        if w <= weight:
            weight -= w
            ret += v
        else:
            ret += v * weight / w
            break

    return ret


if __name__ == ""__main__"":
    N, W = map(int, input().split())
    items = [tuple(map(int, input().split())) for _ in range(N)]
    print(run(W, items))

"
9032081,ALDS1_15_B,"n,rest=list(map(int,input().split()))
max_value=0

list1=[list(map(int,input().split())) for a in range(n)]
list1.sort(reverse=True, key=lambda x:x[0]/x[1])#単価順にソート

for product in list1:
    if rest>=product[1]:
        max_value+=product[0]
        rest-=product[1]
    else:
        max_value+=product[0]*rest/product[1]
        break
    
print(max_value)
"
8475575,ALDS1_15_B,"n, w = map(int, input().split())
lst = []
for _ in range(n):
    v, u = map(int, input().split())
    lst.append((v / u, v, u))
lst.sort(reverse=True)
weight = 0
value = 0
for _, v, u in lst:
    if weight + u < w:
        weight += u
        value += v
    else:
        value += v * (w - weight) / u
        break
print(value)

"
8856709,ALDS1_15_B,"# aizu_ALDS1_15_B_FractionalKnapsackProblem.py  

N,W = map(int,input().split())
vw = [ list(map(int,input().split())) for _ in range(N)]
vw.sort(key=lambda x: x[0]/x[1],reverse=True)

t_val = 0
for v,w in vw:
    weight = w if W >= w else W
    W -= weight
    t_val += v*weight/w

print(t_val)
"
9012342,ALDS1_15_B,"n, w = map(int, input().split())
values, weight, unit_val = [], [], []
for i in range(n):
    vi, wi = map(int, input().split())
    values.append(vi)
    weight.append(wi)
    unit_val.append((vi / wi, i)) # 単位重量あたり価値とインデックスをタプルで保持

unit_val.sort(reverse=True) # 単位重量あたりの価値を高い順に並べる
i = 0
result = 0
while w > 0 and i < n:
    idx = unit_val[i][1] # インデックスを取り出す
    if w > weight[idx]: # ナップサックに全部入るなら
        w -= weight[idx]
        result += values[idx]
        i += 1 # 次に高い価値へ
    else: # ナップサックに全部入らない場合
        result += unit_val[i][0] * w
        break
print(result)

"
8828548,ALDS1_15_B,"class Item:
    def __init__(self,val,w):
        self.value = val
        self.weight = w
        
class Solution:
    def fractionalknapsack(self, W,arr,n):
        ans = 0
        ls = []
        for item in arr:
            ls.append([item.value / item.weight, item.weight])
        ls.sort(key=lambda x: -x[0])
        for wv in ls:
            if wv[1] <= W:
                ans += wv[0] * wv[1]
                W -= wv[1]
            else:
                ans += wv[0] * W
                break
        return ans
       
n, W = list(map(int, input().split()))
arr = []
for i in range(n):
    ls = list(map(int, input().split()))
    arr.append(Item(ls[0], ls[1]))

obj = Solution()
print(obj.fractionalknapsack(W, arr, n))
"
6046989,ALDS1_15_B,"import sys

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines


def main():
    N, W = map(int, readline().split())
    VW = [list(map(int, line.split())) for line in readlines()]

    VW.sort(key=lambda x: x[0] / x[1], reverse=True)

    ans = 0

    for v, w in VW:
        if W >= w:
            ans += v
            W -= w
        else:
            ans += v * W / w
            break
    
    print(ans)


if __name__ == '__main__':
    main()
"
7695399,ALDS1_15_B,"# 15_B.py Fractional Knapsack Problem

from sys import stdin
from typing import List, Tuple

def max_value(W: int, items:List[List[int]]) -> float:
    items = sorted(items, key=lambda e: e[0] / e[1], reverse=True)
    total = 0.0
    for v, w in items:
        if W < w:
            total += v * W / w
            break
        W -= w
        total += v
    return total

N, W = [int(e) for e in stdin.readline().split()]
items = [[int(e) for e in line.split()] for line in stdin.readlines()]

print(max_value(W, items))

"
6359124,ALDS1_15_B,"from sys import stdin

N, W = map(int, stdin.readline().split())

items = [tuple(map(int, stdin.readline().split())) for _ in range(N)]

# まず、itemsを単価の高い順番に並べる
items.sort(key=lambda x: -(x[0] / x[1]))

result = 0
prev_weight = 0

for item in items:
    v, w = item

    if prev_weight + w <= W:
        result += v
    else:
        available_weight = W - prev_weight
        if available_weight < 0:
            break
        result += v * (available_weight/w)

    prev_weight += w

print(result)

"
3398418,ALDS1_15_B,"import sys

n, W = map(int, sys.stdin.readline().split())

val = []
for i in range(n):
    val.append(list(map(int, sys.stdin.readline().split())))

total=0
for vv in sorted(val, key=lambda x:x[0]/x[1], reverse=True):
    if W>=vv[1]: #   50 > 10
        W -= vv[1]
        total += vv[0]
    else:
        total += W*vv[0]/vv[1]
        break

print(total)

"
7622373,ALDS1_15_B,"readline = open(0).readline
N, W = map(int, readline().split())
R = []
for i in range(N):
    v, w = map(int, readline().split())
    R.append((v/w, v, w))
R.sort(reverse=1)
ans = 0
for _, v, w in R:
    c = min(w, W)
    W -= c
    ans += c * v / w
open(1, 'w').write(""%.010f\n"" % ans)

"
4064147,ALDS1_15_B,"import sys
input=sys.stdin.readline
p=[]
n,w=map(int,input().split())
for i in range(n):
	a,b=map(int,input().split())
	p.append([a/b,a,b])
p.sort(key=lambda x:-x[0])
ans=0
i=0
while w>0 and i<n:
	if w>=p[i][2]:
		ans+=p[i][1]
	else:
		ans+=p[i][1]*(w/p[i][2])
		break
	w-=p[i][2]
	i+=1
print(ans)
"
4579384,ALDS1_15_B,"import sys, collections
input = lambda: sys.stdin.readline().rstrip() 
sys.setrecursionlimit(10**7)
INF = 10**10
def I(): return int(input())
def F(): return float(input())
def SS(): return input()
def LI(): return [int(x) for x in input().split()]
def LI_(): return [int(x)-1 for x in input().split()]
def LF(): return [float(x) for x in input().split()]
def LSS(): return input().split()

def resolve():
    N, W = LI()
    vw = [LI() for _ in range(N)]

    vw.sort(key=lambda x: x[0]/x[1], reverse=True)
    ans = 0
    i = 0
    while i < N and W - vw[i][1] > 0:
        ans += vw[i][0]
        W -= vw[i][1]
        i += 1

    if i < N:
        ans += vw[i][0] * W / vw[i][1]

    print(ans)

if __name__ == '__main__':
    resolve()

"
4904765,ALDS1_15_B,"def itemRatio(item):
    return item[0]/item[1]

def main():
    ent = input().strip().split("" "")
    n = int(ent[0])
    W = int(ent[1])
    itens = []

    for i in range(n):
        obj = input().strip().split("" "")
        value = int(obj[0])
        weight = int(obj[1])
        itens.append([value, weight])
    
    itens.sort(key=itemRatio, reverse=True)

    resultado = 0

    for item in itens:
        v = item[0]
        w = item[1]
        if w <= W:
            resultado += v
            W -= w
        else:
            resultado += v*(W/w)
            W = 0

    print(resultado)
if __name__ == ""__main__"":
    main()
"
3363597,ALDS1_15_B,"readline = open(0).readline
N, W = map(int, readline().split())
R = []
for i in range(N):
    v, w = map(int, readline().split())
    R.append((v/w, v, w))
R.sort(reverse=1)
ans = 0
for _, v, w in R:
    c = min(w, W)
    W -= c
    ans += c * v / w
open(1, 'w').write(""%.010f\n"" % ans)
"
5011743,ALDS1_15_B,"readline = open(0).readline
N, W = map(int, readline().split())
R = []
for i in range(N):
    v, w = map(int, readline().split())
    R.append((v/w, v, w))
R.sort(reverse=1)
ans = 0
for _, v, w in R:
    c = min(w, W)
    W -= c
    ans += c * v / w
open(1, 'w').write(""%.010f\n"" % ans)
"
5222242,ALDS1_15_B,"n, w = map(int, input().split())
d = [tuple(map(int, input().split())) for _ in range(n)]
d.sort(key=lambda x: x[0] / x[1], reverse=1)
now = 0
v = 0
for x, y in d:
    if now + y >= w:
        v += x * ((w - now) / y)
        break
    now += y
    v += x
print(v)

"
6376649,ALDS1_15_B,"from typing import List, Tuple
import sys
from array import array


sys.setrecursionlimit(1000000)
input = sys.stdin.readline


def main():
    N, W = map(int, input().split())
    v: List[int] = [0 for i in range(N)]
    w: List[int] = [0 for i in range(N)]
    for i in range(N):
        v[i], w[i] = map(int, input().split())

    L: List[Tuple[float, int, int]] = [() for i in range(N)]
    for i in range(N):
        L[i] = (v[i] / w[i], v[i], w[i])

    L.sort(reverse=True)

    answer: float = 0
    for ri, vi, wi in L:
        if W <= 0:
            break
        amount = min(W, wi)
        answer += ri * amount
        W -= amount

    print(answer)


if __name__ == ""__main__"":
    main()

"
4645073,ALDS1_15_B,"readline = open(0).readline

N, W = map(int, readline().split())

R = []

for i in range(N):
    v, w = map(int, readline().split())
    R.append((v / w, v, w))

R.sort(reverse = 1)
ans = 0

for _, v, w, in R:
    c = min(w, W)
    W -= c
    ans += c * v / w

open(1, 'w').write(""%.010f\n"" % ans)
"
4880296,ALDS1_15_B,"def mochila(listVW,v,w,W):
    resp = 0
    listVW.sort(reverse=True)
    for v, w in listVW:
        if W > w:
            W -= w
            resp += v*w
        else:
            resp += v*W
            break
    return resp

def main():
    n, W = map(int, input().split())

    listVW = [None]*n
    
    for i in range(n):
        v, w = map(int, input().split())
        listVW[i] = [v/w, w]

    resp = mochila(listVW,v,w,W)

    print(resp)

    return 0

if __name__ == '__main__':
	main()
"
7720301,ALDS1_15_B,"import sys
import os


istest = False
fn = ""inputdata.txt""
if os.path.exists(fn):
    istest = True
    sys.stdin = open(fn)

n,W=map(int,sys.stdin.readline().split())
A=[map(int,sys.stdin.readline().split()) for _ in range(n)]
D=sorted([(v/w,w) for v,w in A],reverse=True)
R=W
V=0
for d,limit in D:
    wei=min(limit,R)
    V+=d*wei
    R-=wei
    if R==0:
        break
print(V) 
"
4883381,ALDS1_15_B,"def mochilaf(v_w,W):
    v_w.sort(key= lambda x: x[0]/x[1],reverse=True)

    valorTotal = 0
    for valor, peso in v_w:
        if peso <= W:
            valorTotal += valor
            W -= peso
        else:
            valorTotal += valor*W/peso
            break
    
    return valorTotal

if __name__ == ""__main__"": 
    while True:
        try:
            v_w = []
            
            N,W = map(int,input().split())
            for _ in range(N):
                v_w.append(list(map(int,input().split())))
            
            print('%.12f'%mochilaf(v_w,W))

        except:
            break 
"
4891564,ALDS1_15_B,"import sys

def main():
    n, W = map(int, input().split())
    vet = [None]*n
    
    for i in range(n):
        v, w = map(int, input().split())
        aux = v/w
        vet[i] = [aux, w]

    vet.sort(reverse = True)
    mochila = 0

    for v, w in vet:
        
        if(W > w):
        
            W -= w
            mochila += v*w
        
        else:

            mochila += v*W
            break
    print(mochila)

    return 0

if __name__ == '__main__':
	main()
"
3701297,ALDS1_15_B,"N,W = [int(i) for i in input().split()]
VW = [[int(i) for i in input().split()] for _ in range(N)]
sVW = sorted(VW, key = lambda x:x[0]/x[1], reverse = True)
ans = 0
for i in sVW:
    if W < i[1]:
        ans += i[0] * W / i[1]
        break
    else:
        ans += i[0]
        W -= i[1]
print(ans)
"
4900007,ALDS1_15_B,"def main():
    while True:
        try:
            x = []
            n,W  = input().split("" "")
            W = float(W)
            n = int(n)

            densidade_lista = []
            for i in range(n) :
                valor,peso = input().split("" "")
                densidade_lista.append((float(valor)/float(peso), float(valor), float(peso)))
                x.append(0)


            densidade_lista.sort(key=lambda x: x[0], reverse=True)
            i = 0
            soma_total = 0
            for a, valor, peso in densidade_lista:
                if(peso<=W):
                    soma_total+=valor
                    W-= peso
                else:
                    soma_total+= valor*(W/peso)
                    W=0
                i+=1
            print(soma_total)

        except:
            return 0


main()
"
4907926,ALDS1_15_B,"#!/usr/bin/env python3

from sys import stdin, stdout

N, W = [int(x) for x in stdin.readline().strip().split()]

items = []

for _ in range(N):
    v, w = [int(x) for x in stdin.readline().strip().split()]
    items.append({'value': v, 'weight': w, 'ratio': v/w})

items.sort(reverse=True, key=lambda x: x['ratio'])

total = 0
for item in items:
    w = item['weight']
    v = item['value']
    
    if W - w >= 0:
        W -= w
        total += v
    elif W > 0:
        total += v * (W / w)
        break

stdout.write(""%.010f\n"" % total)
"
4471527,ALDS1_15_B,"def main():
    N,W = map(int,input().split())
    vw = [list(map(int,input().split())) for _ in range(N)]

    for i in range(N):
        vw[i].append(vw[i][0]/vw[i][1])

    vw.sort(reverse = True,key = lambda x:x[2])

    val,wei = 0,0
    for i in range(N):
        if wei + vw[i][1] <= W:
            val += vw[i][0]
            wei += vw[i][1]
        elif wei < W:
            val += vw[i][0]*(W-wei)/vw[i][1]
            wei = W
        else:
            break
    print(val)

if __name__ == ""__main__"":
    main()

"
6103882,ALDS1_15_B,"n, w = map(int, input().split())
VW = [list(map(int, input().split())) for _ in range(n)]

VW.sort(key=lambda x: x[0] / x[1], reverse=True)
curr_w = 0
ans = 0
for i in range(n):
    cv, cw = VW[i]
    if curr_w + cw >= w:
        ans += (w - curr_w) / cw * cv
        break
    ans += cv
    curr_w += cw
print(ans)

"
6292077,ALDS1_15_B,"N,W = map(int,input().split()) # 品物の数Nとナップサックの容量Wを入力
goods = [] # 品物を表わす配列goodsを用意
for i in range(N): # N回繰り返し
    v,w = map(int,input().split()) # 品物iの価値vと重さwを入力
    goods.append((v/w,v,w)) # goodsに品物iの情報を保存
goods.sort(reverse=True) # 品物を重さ1あたりの価値が大きい順に並び替える
ans = 0 # 価値の合計を表わす変数ansを初期化
for _,v,w in goods: # 全ての品物について, 重さ1あたりの価値が大きい順に繰り返し
    if w <= W: # wよりもWの方が大きい場合(全て入れることができる場合)
        ans += v # ansにvを加算
        W -= w # Wからwを減算
    else: # wの方が大きい場合(重さW分しか入れられない場合)
        ans += v*W/w # ansに重さW分の価値を加算し, 終了する
        break
print(ans) # ナップサックに入れた品物の価値の合計の最大値を出力
"
8121020,ALDS1_15_B,"N,W = map(int,input().split())
V = [[int(data) for data in input().split()] for _ in range(N)]
V.sort(key=lambda x:x[0]/x[1],reverse=True)
v_total,w_total = 0,0
for data in V:
    v_total += data[0]
    w_total += data[1]
    if w_total >= W:
        break
dif = w_total - W
if dif > 0:
    v_total -= dif * (data[0]/data[1])
print(v_total)
"
3305813,ALDS1_15_B,"n, w = map(int, input().split())
lst = [list(map(int, input().split())) for _ in range(n)]
lst.sort(key=lambda x:x[0] / x[1], reverse=True)
rest = w
ans = 0
for val, wei in lst:
  if rest >= wei:
    ans += val
    rest -= wei
  else:
    ans += val / wei * rest
    break
print(ans)
"
5026604,ALDS1_15_B,"N, W = map(int, input().split())
R = []
for i in range(N):
    v, w = map(int, input().split())
    R.append((v/w, v, w))
R.sort(reverse=1)
ans = 0
for _, v, w in R:
    c = min(w, W)
    W -= c
    ans += c * v / w
print(ans)

"
5384136,ALDS1_15_B,"import sys
from decimal import *
N,W=map(int,sys.stdin.readline().split())
A=[]
for _ in range(N):
    v,w=map(int,sys.stdin.readline().split())
    t=Decimal(v)/w
    A.append((t,v,w))
A.sort(key=lambda x:-x[0] )

ans=0
for t,v,w in A:
    if W-w>=0:
        ans+=v
        W-=w
    elif W-w<0:
        ans+=t*W
        break
print (ans)
"
3701958,ALDS1_15_B,"N, W = map(int, input().split())
W_calc = W
ans = 0

items = []

for _ in range(N):
    v, w = map(int, input().split())
    density = v / w
    items.append([density, v, w])


items.sort(reverse=True)

for density, v, w in items:
    if w < W_calc:
        W_calc -= w
        ans += v
    else:
        ans += W_calc * density
        break

print(ans)
"
4680360,ALDS1_15_B,"N, W = map(int, input().split())
R = []
for i in range(N):
    v, w = map(int, input().split())
    R.append((v/w, v, w))
R.sort(reverse=1)
ans = 0
for _, v, w in R:
    c = min(w, W)
    W -= c
    ans += c * v / w
print(ans)
"
6459942,ALDS1_15_B,"from typing import List, Tuple


def fractional_knapsack(items: List[Tuple[int]], w):
    _items = sorted(items, key=lambda i: i[0] / i[1], reverse=True)
    result = 0
    c = w
    for _v, _w in _items:
        if _w <= c:
            c -= _w
            result += _v
        else:
            result += (_v / _w) * c
            break
    print(result)


def main():
    n, w = map(int, input().split())
    items = []
    for _ in range(n):
        items.append(tuple(map(int, input().split())))
    fractional_knapsack(items, w)


main()

"
7307577,ALDS1_15_B,"N, W = map(int, input().split("" ""))

vw = []
for _ in range(N):
	v, w = map(int, input().split("" ""))
	vw.append((v, w))
	
vw.sort(key=lambda x: -x[0]/x[1])

total = 0
for v, w in vw:
	if W >= w:
		total += v
		W -= w
	else:
		total += v / w * W
		break
print(""{:.8f}"".format(total))
"
5109383,ALDS1_15_B,"N, W = map(int, input().split())
p = []
for _ in range(N):
    v, w = map(int, input().split())
    p.append([v / w, w])
p.sort()

t_val = 0
for c, w in p[::-1]:
    t_val += c * min(W, w)
    W -= w
    if W <= 0: break
print(t_val)

"
8170810,ALDS1_15_B,"# # Fractional Knapsack

N,W = map(int, input().split())

thing = []

for i in range(N):
    v,w = map(int, input().split())
    thing.append([v/w,v,w])

thing.sort(reverse=True)
ans = 0

for i in range(N):
    if W >= thing[i][2]:
        ans += thing[i][1]
        W -= thing[i][2]
    else:
        ans += thing[i][0]*W
        W = 0
        break

print(ans)


"
3726984,ALDS1_15_B,"# -*- coding: utf-8 -*-
""""""
Greedy algorithms - Fractional Knapsack Problem
http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_15_B&lang=jp

""""""
N, W = map(int, input().split())
items = []
for _ in range(N):
    v, w = map(int, input().split())
    items.append((v/w, v, w))
items.sort()

ans = 0
while W > 0 and items:
    r, v, w = items.pop()
    if W >= w:
        W -= w
        ans += v
    else:
        ans += v * W / w
        W = 0
print(ans)
"
3540866,ALDS1_15_B,"n , w = map(int, input().split())
val_w = []
for i in range(n):
    a , b = map(int, input().split())
    val_w += [(-a/b, b)]
val_w.sort()
Sum = 0
i = 0
while w and i <= n-1:
    wei = min(w, val_w[i][1])
    Sum += (-val_w[i][0])*wei
    w -= wei
    i += 1
print(Sum)
"
5141449,ALDS1_15_B,"N,W=[int(i) for i in input().split("" "")]

items=[]
for i in range(N):
    v,w=[int(j) for j in input().split("" "")]
    items.append((v,w))

items=sorted(items,key=lambda w: w[0]/w[1], reverse=True)

val=0
for item in items:
    v,w=item
    if W>=w:
        W-=w
        val+=v
    else:
        val+=v*W/w
        W=0

print(val)

"
6706508,ALDS1_15_B,"from fractions import Fraction
N,W=[int(x) for x in input().split()]
v=[0 for i in range(N)]
w=[0 for i in range(N)]
a=[]
for i in range(N):
    v[i],w[i]=[int(x) for x in input().split()]
    a.append((v[i],w[i]))
a.sort(key=lambda x:x[0]/x[1],reverse=True)
# print(a)

weight=0
value=0
for i in range(N):
    if weight+a[i][1]<=W:
        # print(weight)
        weight=weight+a[i][1]
        value=value+a[i][0]
    else:

        value=value+Fraction(a[i][0],a[i][1])*(W-weight)
        break

print(float(round(value,ndigits=8)))




"
3828349,ALDS1_15_B,"# coding: utf-8
# Your code here!

n,wmax=map(int, input().split( ))
U=[]
for _ in range(n):
    v,w =map(int,input().split( ))
    u = v/w
    U.append([-u,v,w])
U.sort()

remains = wmax
i=0
ans = 0
while True:
    try:
        if remains > U[i][2]:
            remains-=U[i][2]
            ans+=U[i][1]
            i+=1
        else:
            ans += U[i][1]*remains/U[i][2]
            break
    except:
        break
print(ans)
"
4908116,ALDS1_15_B,"# Author: Jardielma Queiroz De Lima
# Online Judge ID:	1171428
# Problema: Fractional Knapsack Problem
# ID: ALDS1_15_B

def main():
    #recebe o numero de itens e o peso maximo do pacote
    n, d = map(int, input().split())

    lista_itens = list()
    for i in range(n):
        #pega os valores e pesos do itens
        preco,peso = list(map(int, input().split()))
        #armazena os itens já numa lista, calculando o valor individual
        # por item
        lista_itens.append([preco/peso,preco,peso])
    #faço a ordenação reversa dos itens, para ter os itens mais caros no
    # inicio da lista    
    lista_itens.sort(reverse=True)
    preco = 0 
    peso = 0
    peso_falta=0
    fator_calculo = 0
    #faço um loop para passar item por item
    for i in range(len(lista_itens)):
        #calculo quanto de peso falta
        peso_falta = d-peso
        #chegou ao  -- já finalizo
        if(peso_falta==0):
            break
        #pego o fator de calculo a ser utilizado, isso é o peso que falta
        # e quanto temos do item atual
        fator_calculo = lista_itens[i][2] - peso_falta
        #caso o item atual já complete a caixa ou tenha mais itens que espaço
        #adiciono somente o número de itens que precisa
        if(fator_calculo>=0):
            peso = peso + peso_falta
            preco = preco + (lista_itens[i][0]*peso_falta)
        else:
            #caso tenhamos mais espaços que itens, adiciono todos os itens atuais
            peso = peso + lista_itens[i][2]
            preco = preco + (lista_itens[i][0]*lista_itens[i][2])

    print(preco)
#fim função

if __name__ == ""__main__"":
    main()


"
6051596,ALDS1_15_B,"N,Wmax=map(int,input().split())
V=[]
W=[]
VW=[]
for i in range(N):
    v,w=map(int,input().split())
    V.append(v)
    W.append(w)
    VW.append((v/w,i))

VW.sort(reverse=True)
rank=0
ansv=0
while Wmax>0 and rank<N:
    idx=VW[rank][1]
    if Wmax>W[idx]:
        Wmax-=W[idx]
        ansv+=V[idx]
        rank+=1
    else:
        ansv+=VW[rank][0]*Wmax
        break
print(ansv)


"
4342352,ALDS1_15_B,"import heapq

def Main():
    N, capacity = map(int, input().split())
    w_list = list()

    for _ in range(N):
        v, w = map(int, input().split())
        heapq.heappush(w_list, [-1*float(v/w), v, w] )

    total_value = 0

    while len(w_list) != 0:
        item = heapq.heappop(w_list)
        value_per_weight = -1*item[0]
        value = item[1]
        weight = item[2]
        
        if capacity >= weight:
            capacity -= weight
            total_value += value
        else:
            total_value += capacity * value_per_weight
            break
        
    print(total_value)

Main()

"
4560479,ALDS1_15_B,"#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# FileName: 	fractional_knapsack
# CreatedDate:  2020-06-08 21:46:16 +0900
# LastModified: 2020-06-08 21:53:14 +0900
#


import os
import sys
#import numpy as np
#import pandas as pd


def main():
    N,W = map(int,input().split())
    p = []
    for _ in range(N):
        v,w = map(int,input().split())
        p.append([v/w,v,w])
#    print(p)
    p.sort(reverse=True)
    index=0
    profit=0
    while W>0 and index<N:
        if W>=p[index][2]:
            profit+=p[index][1]
            W-=p[index][2]
        else:
            profit+=p[index][1]*W/p[index][2]
            W-=W
        index+=1
    print(profit)


if __name__ == ""__main__"":
    main()

"
3665102,ALDS1_15_B,"first=list(map(int,input().split()))
n,w=first[0],first[1]
data=[]
for i in range(n):
    a=list(map(int,input().split()))
    vpwi=a[0]/a[1]
    data.append([vpwi,a[0],a[1]])
data.sort(reverse=True)

wtot=0
vtot=0
i=0
for i in range(n):
    if wtot+data[i][2]<=w:
        wtot+=data[i][2]
        vtot+=data[i][1]
    else:
        vtot+=data[i][0]*(w-wtot)
        break

print(vtot)

"
5073189,ALDS1_15_B,"import heapq

def main():

    n, w = map(int, input().split())
    vw = []
    for i in range(n):
        vi, wi = map(int, input().split())
        heapq.heappush(vw, (-vi/wi, vi, wi))
    
    su = 0
    while vw:
        cp, vi, wi = heapq.heappop(vw)

        if w == 0:
            break
        
        elif wi >= w:
            su += -cp * w
            break
        
        else:
            su += vi
            w -= wi
    
    print(su)

main()


"
7047623,ALDS1_15_B,"n, w = map(int, input().split())
items = []
for _ in range(n):
    va, we = map(int, input().split())
    items.append((va / we, we))
items.sort(reverse=True)
max_val = 0.0
for i in range(n):
    (va, we) = items[i]
    if w >= we:
        max_val += va * we
        w -= we
    else:
        max_val += va * w
        w = 0
    if w <= 0:
        break
if max_val % 1 > 0:
    print(max_val)
else:
    print(int(max_val))

"
3526948,ALDS1_15_B,"n,w = map(int,input().split("" ""))
pack = []

for _ in range(n):
    x,y = map(int,input().split("" ""))
    pack.append([x/y,x,y])

pack.sort()
pp = pack[::-1]

sum = 0
for ele in pp:
    if w-ele[2] > 0:
        sum += ele[1]
        w = w - ele[2]
    else:
        sum += ele[0]*w
        break

print(sum)

"
4209833,ALDS1_15_B,"N, W = map(int, input().split())
V = [None]*N
ans = 0
for i in range(N):
    v, w = map(int, input().split())
    V[i] = [v/w, w]
V.sort(reverse=True)
for v, w in V:
    if W > w:
        W -= w
        ans += v*w
    else:
        ans += v*W
        break
print(ans)
"
4819975,ALDS1_15_B,"
N,W = map(int,input().split())
l = []

for i in range(N):
    v,w = map(int,input().split())
    c = v/w
    l.append([c,v,w])

l = sorted(l)
ans = 0

while W and l:
    c1,v1,w1 = l.pop()
    if w1 <= W:
        ans += v1
        W -= w1
    else:
        ans += v1*(W/w1)
        W = 0
print(ans)
"
4896551,ALDS1_15_B,"import sys


entrada = input().strip().split("" "")
n = int(entrada[0])
w = int(entrada[1])
while n > 0 or n:
    try:
        valores = []
        pesos = []

        for i in range(0, n):
            entradas = input().strip().split("" "")
            valores.append(int(entradas[0]))
            pesos.append(int(entradas[1]))

        vp = []
        for i in range(0, n):
            item = valores[i] / pesos[i]
            vp.append([item, i])

        vp.sort(reverse=True)

        ans = 0
        float(ans)
        res = w

        for i in range(0, n):
            amount = min(pesos[vp[i][1]], res)
            res -= amount
            ans += amount * vp[i][0]

        print(ans)

    except:
        sys.exit(0)

"
7014035,ALDS1_15_B,"import heapq


def main():
    N, W = map(int, input().split())
    items = []
    for _ in range(N):
        value, weight = map(int, input().split())
        heapq.heappush(items, (-(value / weight), value, weight))

    max_value = 0
    now_weight = 0
    while now_weight < W and items:
        value_unit, value, weight = heapq.heappop(items)
        if now_weight + weight < W:
            max_value += value
            now_weight += weight
        else:
            max_value -= value_unit * (W-now_weight)
            now_weight = W

    print(max_value)


if __name__ == ""__main__"":
    main()

"
6044006,ALDS1_15_B,"N,W=map(int,input().split())
B=[]
for i in range(N):
    B.append(list(map(int,input().split())))
    
B.sort(key=lambda x:x[0]/x[1],reverse=True)
v=0;s=0;i=0
while s<W and i<N:
    if W-s>=B[i][1]:
        s+=B[i][1]
        v+=B[i][0]
        i+=1
    else:
        v+=B[i][0]*(W-s)/B[i][1]
        s=W
        i+=1
print(v)
"
3810064,ALDS1_15_B,"if __name__ == ""__main__"":
    N, W = map(lambda x: int(x), input().split())
    items = [[0, 0] for _ in range(N)]
    for i in range(N):
        items[i] = list(map(lambda x: int(x), input().split()))

    items = sorted(items, key=lambda x: - x[0] / x[1])

    total_value = 0.0
    total_weight = 0.0
    for (v, w) in items:
        if total_weight + w <= W:
            total_weight += w
            total_value += v
            if W == total_weight:
                break
        else:
            rest_weight = W - total_weight
            total_value += (v / w) * rest_weight
            break

    print(f""{total_value:.6f}"")

"
5263052,ALDS1_15_B,"n, w = map(int, input().split())
t = []
for _ in range(n):
    a, b = map(int, input().split())
    t.append((a/b, a, b))

t = sorted(t)
t = reversed(t)

ans = 0
for t, a, b in t:
    if w >= b:
        ans += a
        w -= b
    else:
        ans += t * w
        w = 0
print(ans)        
"
6807793,ALDS1_15_B,"n, w = map(int, input().split())

data = []
for _ in range(n):
    v_i, w_i = map(int, input().split())
    c_i = v_i / w_i
    data.append([c_i, v_i, w_i])

data.sort(reverse=True)

ans = 0
for c_i, v_i, w_i in data:
    if w <= w_i:
        ans += c_i * w
        break
    else:
        ans += v_i
        w -= w_i

print(ans)

"
8475585,ALDS1_15_C,"n = int(input())
lst = []
for _ in range(n):
    s, t = map(int, input().split())
    lst.append((s, t))
lst.sort(key=lambda x: x[1])
ans = 0
now = 0
for s, t in lst:
    if now <= s:
        ans += 1
        now = t + 1
print(ans)

"
8856752,ALDS1_15_C,"# aizu_ALDS1_15_C_ActivitySelectProblem.py  

n = int(input())
se = [ list(map(int,input().split())) for _ in range(n)]
se.sort(key=lambda x: x[1])

cnt = 1
s,e = se[0]
for n_s,n_e in se[1:]:
    if e < n_s:
        e = n_e
        s = n_s
        cnt += 1

print(cnt)
"
6047005,ALDS1_15_C,"import sys

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines


def main():
    N = int(readline())
    ST = [list(map(int, line.split())) for line in readlines()]

    ST.sort(key=lambda x: x[1])

    count = 1
    num = ST[0][1]

    for s, t in ST[1:]:
        if s > num:
            count += 1
            num = t
    
    print(count)


if __name__ == '__main__':
    main()
"
9069581,ALDS1_15_C,"CACHE = [0]


def filter0(acts):
    ret = [acts[0]]
    for i in range(1, len(acts)):
        if ret[-1][0] == acts[i][0]:
            continue
        else:
            ret.append(acts[i])
    return ret


def filter1(acts):
    ret = []
    for i in range(len(acts) - 1):
        if acts[i + 1][1] <= acts[i][1]:
            continue
        else:
            ret.append(acts[i])
    ret.append(acts[-1])
    return ret


def count(acts, index):
    start = acts[index][1]

    a = CACHE[-1]

    if acts[-1][0] <= start:
        b = 1
    else:
        left = index
        right = len(acts) - 1

        while left + 1 < right:
            mid = (left + right) // 2
            if acts[mid][0] <= start:
                left = mid
            else:
                right = mid

        b = 1 + CACHE[len(acts) - right]

    ret = max(a, b)
    CACHE.append(ret)
    return ret


def run(acts):
    acts.sort()
    acts = filter0(acts)
    acts = filter1(acts)

    for i in reversed(range(len(acts))):
        count(acts, i)

    return CACHE[-1]


if __name__ == ""__main__"":
    N = int(input())
    acts = [tuple(map(int, input().split())) for _ in range(N)]
    print(run(acts))

"
7051982,ALDS1_15_C,"from sys import stdin 
input = stdin.readline

n = int(input())
A = [tuple(map(int, input().split())) for _ in range(n)]
A.sort(key=lambda x: x[1], reverse=True)

ans = 0
end = 0
while A:
    s, t = A.pop()
    end = t
    ans += 1
    while A:
        if A[-1][0] <= end:
            A.pop()
        else:
            break 
print(ans)
"
6696603,ALDS1_15_C,"import sys
import operator

# READ_FROM_FILE = True
READ_FROM_FILE = False


def main():
    if READ_FROM_FILE:
        f = open('test0.txt', 'r')
    else:
        f = sys.stdin

    n = int(f.readline())
    activity_info_list = [list(map(int, f.readline().split())) for _ in range(n)]
    activity_info_list.sort(key=operator.itemgetter(1))

    counter = 0
    i = 0
    while i < len(activity_info_list):
        earliest_activity_end_time = activity_info_list[i][1]
        counter += 1
        i += 1
        while i < len(activity_info_list):
            next_start_time = activity_info_list[i][0]
            if next_start_time > earliest_activity_end_time:
                break
            i += 1

    print(counter)

    if READ_FROM_FILE:
        f.close()
    return


if __name__ == '__main__':
    main()

"
7695463,ALDS1_15_C,"# 15_C.py Activity Selection Problem

from sys import stdin

n = int(stdin.readline())
acts = [[int(e) for e in line.split()] for line in stdin.readlines()]

acts.sort(key=lambda e: e[1])
ans, last = 0, -1
for s, t in acts:
    if last < s:
        ans += 1
        last = t
print(ans)

"
6376666,ALDS1_15_C,"from typing import List, Tuple
import sys
from array import array


sys.setrecursionlimit(1000000)
input = sys.stdin.readline


def main():
    N = int(input())
    A: List[Tuple[int, int]] = [() for i in range(N)]
    for i in range(N):
        s, t = map(int, input().split())
        A[i] = (s, t)

    A.sort(key=lambda a: a[1])

    last_endpoint: int = 0
    answer: int = 0
    for s, t in A:
        if s <= last_endpoint:
            continue
        last_endpoint = t
        answer += 1

    print(answer)


if __name__ == ""__main__"":
    main()

"
7721615,ALDS1_15_C,"import sys
import os
import time
import bisect

istest = False
fn = ""inputdata.txt""
if os.path.exists(fn):
    istest = True
    sys.stdin = open(fn)



n=int(sys.stdin.readline())
schedules=[tuple(map(int,sys.stdin.readline().split())) for _ in range(n)]
schedules.sort()
rps=[]

for ini,fin in schedules:
    if rps:
        rp=rps[-1]
    else:
        rps.append(fin)
        continue
    if rp<ini:
        rps.append(fin)
        continue
    if fin<rp:
        rps[-1]=fin
            

print(len(rps)) 
"
6360811,ALDS1_15_C,"from sys import stdin

n = int(stdin.readline())

# (start_time, end_time) というtupleを配列に格納する
activities = []

for _ in range(n):
    s, t = map(int, stdin.readline().split())
    activities.append((s, t))

# 活動を終了時刻の小さい順に並び替え
activities.sort(key=lambda x: x[1])

count = 0
max_t = 0  # 参加を決めた活動のうち、最も遅く終わるものの終了時刻をもっておく

for s, t in activities:
    if s > max_t:
        count += 1
        max_t = t

print(count)

"
4581518,ALDS1_15_C,"import sys, collections
input = lambda: sys.stdin.readline().rstrip() 
sys.setrecursionlimit(10**7)
INF = 10**10
def I(): return int(input())
def F(): return float(input())
def SS(): return input()
def LI(): return [int(x) for x in input().split()]
def LI_(): return [int(x)-1 for x in input().split()]
def LF(): return [float(x) for x in input().split()]
def LSS(): return input().split()

def resolve():
    n = I()
    st = [LI() for _ in range(n)]
    # 開始時間が大丈夫で、終了時間の早いものから入れていく
    st.sort(key= lambda x: x[1])

    ans = 0
    end_time = 0
    for i in range(n):
        if st[i][0] > end_time:
            ans += 1
            end_time = st[i][1]

    print(ans)

if __name__ == '__main__':
    resolve()

"
5223610,ALDS1_15_C,"n = int(input())
p = [tuple(map(int, input().split())) for _ in range(n)]
p.sort(key=lambda x: x[1])
ans = 0
now = 0
for s, t in p:
    if now < s:
        now = t
        ans += 1
print(ans)

"
4759945,ALDS1_15_C,"# https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/15/ALDS1_15_C

n = int(input())
lst = [list(map(int, input().split())) for _ in range(n)]
lst.sort(key=lambda x: x[1])
now = -1
ans = 0
for s, t in lst:
    if now < s:
        ans += 1
        now = t
print(ans)

"
6044031,ALDS1_15_C,"n=int(input())
T=[list(map(int,input().split())) for _ in range(n)]
T.sort(key=lambda x:x[1])
F,cnt=0,0
for i in range(n):
    if F<T[i][0]:
        F=T[i][1]
        cnt+=1
print(cnt)
"
8030176,ALDS1_15_C,"N=int(input())
lis=[list(map(int,input().split())) for i in range(N)]
lis.sort(key=lambda s: s[1])
ans=0
now=-1
for i in range(N):
    if now>=lis[i][0]:
        continue
    now=lis[i][1]
    ans+=1
print(ans)
"
3305812,ALDS1_15_C,"n = int(input())
lst = [list(map(int, input().split())) for _ in range(n)]
lst.sort(key=lambda x:x[1])
now = -1
ans = 0
for s, t in lst:
  if now < s:
    ans += 1
    now = t
print(ans)
"
3366224,ALDS1_15_C,"n = int(input())
A = []

for i in range(n):
    s, t = [int(x) for x in input().split()]
    A.append((s, t))

A.sort(key=lambda x: x[1])

ans = 0
t = -1

for a in A:
    if a[0] > t:
        ans += 1
        t = a[1]

print(ans)

"
8022793,ALDS1_15_C,"def activity_selection(n, activities):
    activities.sort(key=lambda x: x[1])  # 終了時刻でソート
    selected = []
    end_time = 0

    for activity in activities:
        start, end = activity
        if start > end_time:
            selected.append(activity)
            end_time = end

    return len(selected)

def main():
    n = int(input())
    activities = []
    for _ in range(n):
        start, end = map(int, input().split())
        activities.append((start, end))

    max_activities = activity_selection(n, activities)
    print(max_activities)

if __name__ == '__main__':
    main()








"
4064163,ALDS1_15_C,"
n=int(input())
st=[]
ans=0
for i in range(n):
	s,t=map(int,input().split())
	st.append([s,t])
st.sort(key=lambda x:x[1])
time=0
i=0
ans=0
while i<n:
	if st[i][0]>time:
		ans+=1
		time=st[i][1]
	i+=1
print(ans)
"
5120179,ALDS1_15_C,"n = int(input())
k = []
for i in range(n):
    a,b = map(int, input().split())
    k.append((a,b))
k = sorted(k,key=lambda x:x[1])
ans = 1
i = 0
j = 1
while j<len(k):
    if k[i][1] < k[j][0]:
        ans += 1
        i = j
        j = j+1
    else:
        j = j+1
    
print(ans)
        
"
4029221,ALDS1_15_C,"n = (int)(input())
list=[]
for i in range(n):
    k = input().split("" "")
    a=(int)(k[0])
    b=(int)(k[1])
    list.append([a,b])
list = sorted(list,key=lambda x: x[1])
count=0
time=0
for i in range(n):
    if(time<list[i][0]):
        count+=1
        time=list[i][1]
print(count)

"
3701377,ALDS1_15_C,"n = int(input())
A = [[int(i) for i in input().split()] for _ in range(n)]
A.sort(key = lambda x:x[1])
t = 0
ans = 0
for i in A:
    if t < i[0]:
        ans += 1
        t = i[1]
print(ans)
"
3702176,ALDS1_15_C,"n = int(input())

time = []

for _ in range(n):
    s, t = map(int, input().split())

    time.append((s, t))

time.sort(key = lambda x:x[1])

now = 0
ans = 0
for s, t in time:
    if now < s:
        ans += 1
        now = t

print(ans)
"
4471682,ALDS1_15_C,"def act(st):
    st.sort(key = lambda x:x[0])
    OP = [st[0]]

    for i in range(1,len(st)):
        if OP[len(OP)-1][1] < st[i][0]:
            OP.append(st[i])
        elif OP[len(OP)-1][1] <= st[i][1]:
            pass
        else:
            OP.pop()
            OP.append(st[i])
    return len(OP)

def main():
    n = int(input())
    st = [tuple(map(int,input().split())) for _ in range(n)]

    ans = act(st)
    print(ans)

if __name__ == ""__main__"":
    main()

"
6292080,ALDS1_15_C,"n = int(input()) # 活動の数nを入力
activity = [] # 各活動の開始時刻と終了時刻を表わす配列activityを用意
for i in range(n): # n回繰り返し
    s,t = map(int,input().split()) # 開始時刻sと終了時刻tを入力
    activity.append((t,s)) # t,sをactivityに追加
activity.sort() # 活動を終了時刻の小さい順に並び替え
ans = 0 # 最大の参加数を表わす変数ansを用意
max_t = 0 # 参加を決めた活動の内, 最も遅く終わるものの終了時刻を表わす変数max_tを用意
for t,s in activity: # 全ての活動について, 終了時刻の小さい順に繰り返し
    if s > max_t: # 参加を決めた活動と活動時刻がかぶっていない場合
        ans += 1 # ansに1を加算
        max_t = t # max_tをtに更新
print(ans) # 最大の参加数を出力
"
4645100,ALDS1_15_C,"n = int(input())

lst = [list(map(int, input().split())) for _ in range(n)]
lst.sort(key = lambda x:x[1])
now = -1
ans = 0

for s, t in lst:
    if now < s:
        ans += 1
        now = t

print(ans)
"
3727152,ALDS1_15_C,"# -*- coding: utf-8 -*-
""""""
Greedy algorithms - Activity Selection Problem
http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_15_C&lang=jp

""""""
n = int(input())
activities = sorted([[int(i) for i in input().split()] for _ in range(n)], key=lambda x: x[1], reverse=True)

ans, ct = 0, 0
while activities:
    s, t = activities.pop()
    if s > ct:
        ct = t
        ans += 1
print(ans)

"
4316951,ALDS1_15_C,"
def main():
    n = int(input())
    sch = []
    for _ in range(n):
        sch.append(list(map(int,input().split())))
    sch.sort(key=lambda a: a[1])
    res,t = 0,-1
    for i in range(n):
        if t<sch[i][0]:
            t = sch[i][1]
            res+=1
    print (res)

if __name__ == '__main__':
    main()


"
5469416,ALDS1_15_C,"# 活動選択問題
n = int(input())
lst = [list(map(int, input().split()))for _ in range(n)]
lst.sort(key=lambda x:x[1])
now = -1
ans = 0
for s, t in lst:
    if now < s:
        ans+=1
        now = t
print(ans)
"
7308737,ALDS1_15_C,"n = int(input())

st = []
for _ in range(n):
	s, t = map(int, input().split("" ""))
	st.append((t, s))

st.sort()
ans = 0
t = 0
for tv, sv in st:
	if t < sv:
		ans += 1
		t = tv

print(ans)
"
3540880,ALDS1_15_C,"n = int(input())
t_s = []
for i in range(n):
    a , b = map(int, input().split())
    t_s += [(b, a)]
t_s.sort()
Sum = 1
i = 1
t_now = t_s[0][0]
while i <= n-1:
    for a in t_s[i:]:
        i = i + 1
        if t_now < a[1]:
            Sum += 1
            t_now = a[0]
            
print(Sum)
"
6103897,ALDS1_15_C,"n = int(input())
T = [list(map(int, input().split())) for _ in range(n)]

T.sort(key=lambda x: (x[1], x[0]))
ans = 0
curr_t = -1
for i in range(n):
    if T[i][0] > curr_t:
        ans += 1
        curr_t = T[i][1]
print(ans)

"
5011749,ALDS1_15_C,"readline = open(0).readline
from heapq import heappush, heappop
N = int(readline())
que = []
P = [list(map(int, readline().split())) for i in range(N)]
P.sort()
ans = 0
for s, t in P:
    while que and que[0][0] < s:
        ans = max(ans, heappop(que)[1])
    heappush(que, (t, ans+1))
while que:
    ans = max(ans, heappop(que)[1])
open(1, 'w').write(""%d\n"" % ans)

"
7051070,ALDS1_15_C,"n = int(input())
act = []
for _ in range(n):
    s, t = map(int, input().split())
    act.append((s, t))

act.sort()
ans = [act[0]]
for i in range(1, n):
    if ans[-1][1] > act[i][1]:
        ans.pop()
        ans.append(act[i])
    elif ans[-1][1] < act[i][0]:
        ans.append(act[i])

print(len(ans))

"
3884842,ALDS1_15_C,"n = int(input())
Act = []
maxt= 0
for _ in range(n):
    s,t = map(int,input().split( ))
    Act.append([s,t])
    maxt = max(maxt,t)
#print(*Act)
Act.sort()
last = maxt+1
cnt = 0
for i in range(n-1,-1,-1):
    if Act[i][1] <last:
        cnt += 1
        last = Act[i][0]
        #print(last)
print(cnt)

"
5073194,ALDS1_15_C,"def main():

    st = [list(map(int, input().split()))[::-1] for i in range(int(input()))]
    st.sort()
    res = 0
    t = 0
    for ti, si in st:
        if t <= si:
            res += 1
            t = ti + 1
    print(res)

main()
"
6807840,ALDS1_15_C,"n = int(input())

data = [list(map(int, input().split())) for _ in range(n)]
data.sort()

ans = 0
last = -1

for s_i, t_i in data:
    if last < s_i:
        ans += 1
        last = t_i
    
    else:
        last = min(last, t_i)

print(ans)

"
8170877,ALDS1_15_C,"# Activity Selection Problem


n = int(input())

move = []
for i in range(n):
    s,t = map(int, input().split())
    move.append([s,t])
move.sort()

ans = 1
ss = move[0][0]
tt = move[0][1]

for i in range(1,n):
    if tt < move[i][0]:
        ans += 1
        ss = move[i][0]
        tt = move[i][1]
    elif ss <= move[i][0] < tt:
        if move[i][1] < tt:
            ss = move[i][0]
            tt = move[i][1]

print(ans)

"
4819996,ALDS1_15_C,"n = int(input())
l = []
for i in range(n):
    s,t = map(int,input().split())
    l.append([t,s])

l = sorted(l)
last_time = 0
num_act = 0
for t1,s1 in l:
    if last_time < s1:
        num_act += 1
        last_time = t1

print(num_act)
"
3810240,ALDS1_15_C,"if __name__ == ""__main__"":
    num_activities = int(input())
    activities = [[0, 0] for _ in range(num_activities)]
    for i in range(num_activities):
        activities[i] = list(map(lambda x: int(x), input().split()))

    # Sort by end time in the ascending order.
    activities = sorted(activities, key=lambda x: x[1])

    current_start = -1
    result = 0
    for start, end in activities:
        if current_start < start:
            result += 1
            current_start = end

    print(result)

"
7622436,ALDS1_15_C,"n = int(input())
T = [list(map(int, input().split())) for _ in range(n)]

T.sort(key=lambda x: (x[1], x[0]))
ans = 0
curr_t = -1
for i in range(n):
    if T[i][0] > curr_t:
        ans += 1
        curr_t = T[i][1]
print(ans)


"
4661955,ALDS1_15_C,"import heapq

n = int(input())
hq = []
for _ in range(n):
    start, end = map(int, input().split())
    heapq.heappush(hq, (end, start))

ans = 0
time = 0
while len(hq) > 0:
    end, start = heapq.heappop(hq)
    if time < start:
        time = end
        ans += 1

print(ans)

"
5109400,ALDS1_15_C,"n = int(input())
act = []
for _ in range(n):
    s, t = map(int, input().split())
    act.append([t, s])
act.sort()

cnt = 0
et = 0
for t, s in act:
    if s > et:
        cnt += 1
        et = t
print(cnt)

"
5263117,ALDS1_15_C,"n = int(input())
d = []
for _ in range(n):
    l, r = map(int, input().split())
    d.append((r, l))

ans = 0
d = sorted(d)
end = 0
for r, l in d:
    if end < l:
        end = r
        ans += 1

print(ans)
"
5280532,ALDS1_15_C,"n = int(input())
actions = [list(map(int, input().split())) for _ in range(n)]
actions.sort(key=lambda x: (x[1], x[0]))
now = actions[0]
i = 1
count = 1
while i < n:
    if now[1] < actions[i][0]:
        now = actions[i]
        count += 1
    i += 1
print(count)
"
3301851,ALDS1_15_C,"class Activity:
	def __init__(self,s,e):
		self.s=s
		self.e=e

n=int(input())
acts=[]
for i in range(n):
	si,ei=map(int,input().split())
	acts.append(Activity(si,ei))
	
acts.sort(key=lambda x:x.s)
stack=[]
stack.append(acts[0])

for i in range(1,n):
	last = stack[-1]
	acti = acts[i]
	if acti.s > last.e:
		stack.append(acti)
	elif acti.e < last.e:
		stack.pop()
		stack.append(acti)
print(len(stack))

"
3363600,ALDS1_15_C,"readline = open(0).readline
from heapq import heappush, heappop
N = int(readline())
que = []
P = [list(map(int, readline().split())) for i in range(N)]
P.sort()
ans = 0
for s, t in P:
    while que and que[0][0] < s:
        ans = max(ans, heappop(que)[1])
    heappush(que, (t, ans+1))
while que:
    ans = max(ans, heappop(que)[1])
open(1, 'w').write(""%d\n"" % ans)
"
7014327,ALDS1_15_C,"import heapq


def main():
    n = int(input())
    activities = []
    for _ in range(n):
        start, end = map(int, input().split())
        heapq.heappush(activities, (end, (start, end)))

    current_time = 0
    activity_num = 0
    while activities:
        _, (start, end) = heapq.heappop(activities)
        if start > current_time:
            activity_num += 1
            current_time = end
    print(activity_num)


if __name__ == ""__main__"":
    main()

"
8041725,ALDS1_15_C,"import sys
import threading
import random
import math
import heapq
from collections import deque, OrderedDict
import bisect
import multiprocessing

# sys.getrecursionlimit() # 再起回数の上限を取得
sys.setrecursionlimit(200000) # 再起回数の上限を変更

# 以下のメモリ領域を自分でも計算しておきたい
# 再帰が多い時はpypyよりpython使った方がいい場合がある
# pypyjit.set_param使ってもTLEになった　
# sys.setrecursionlimit(67108864) #64MB
# threading.stack_size(1024*1024)  #2の20乗のstackを確保=メモリの確保

# 入力用関数
def I(): return int(input())
def IM(): return map(int, input().split())
def IL(): return list(map(int, input().split()))
def IF(): return list(map(float, input().split()))

def print_list_2(li):
  for l in li:
    print(l)


def print_list(A: list) -> None:
  for i in range(len(A)):
    print(A[i], end='')
    if i != len(A) - 1: print(' ', end='')
  print()







N = I()

s_list = []; t_list = []; 

PQ = []
heapq.heapify(PQ)

for i in range(N):
  s, t = IL()
  s_list.append(s); t_list.append(t)
  heapq.heappush(PQ, (t, s))


# どうやって条件付きの最小値を見つけるんだ？
# キューを使えばいいのか

last_t = 0
ans = 0

while len(PQ) > 0:
  t, s = heapq.heappop(PQ)
  if last_t < s:
    last_t = t
    ans += 1


print(ans)




"
4680397,ALDS1_15_C,"from heapq import heappush, heappop
N = int(input())
que = []
P = [list(map(int, input().split())) for i in range(N)]
P.sort()
ans = 0
for s, t in P:
    while que and que[0][0] < s:
        ans = max(ans, heappop(que)[1])
    heappush(que, (t, ans+1))
while que:
    ans = max(ans, heappop(que)[1])
print(ans)
"
8457982,ALDS1_15_D,"class Huffman_Tree:
    def __init__(self, left_child, right_child, value):
        self.value = value
        self.left_child = left_child
        self.right_child = right_child

class Huffman_Leaf:
    def __init__(self, letter, value):
        self.value = value
        self.letter = letter

def generate_huffman_tree(huffman_leaf_list):
    huffman_leaf_list.sort(key=lambda leaf:leaf.value, reverse=True)
    # print(huffman_leaf_list)
    while len(huffman_leaf_list) > 1:
        left_child = huffman_leaf_list.pop()
        right_child = huffman_leaf_list.pop()
        new_tree_value = left_child.value + right_child.value
        new_tree = Huffman_Tree(left_child, right_child, new_tree_value)
        huffman_leaf_list.append(new_tree)
        huffman_leaf_list.sort(key=lambda leaf:leaf.value, reverse=True)
    return huffman_leaf_list[0]

def generate_huffman_code(huffman_tree, huffman_code, string):
    if type(huffman_tree) is Huffman_Leaf:
        leaf = huffman_tree
        huffman_code[leaf.letter] = string
        return huffman_code 
    else:
        huffman_code = generate_huffman_code(huffman_tree.left_child, huffman_code, string+""0"")
        return generate_huffman_code(huffman_tree.right_child, huffman_code, string+""1"")



def main():
    string = str(input())
    # string = 45*""a""+""b""*13+12*""c""+16*""d""+""e""*9+""f""*5
    # 文字とその出現回数をまとめる & huffman_codeの準備
    letter_count = {}
    huffman_code = {} # letter -> length
    for letter in string:
        huffman_code[letter] = 0
        if letter in letter_count:
            letter_count[letter] += 1
        else:
            letter_count[letter] = 1
    
    # huffman leafのリストを作成&
    huffman_leaf_list = []
    for letter, count in letter_count.items():
        new_leaf = Huffman_Leaf(letter,count)
        huffman_leaf_list.append(new_leaf)

    huffman_tree = generate_huffman_tree(huffman_leaf_list)
    # huffman_code[*] = 0
    if len(huffman_code) != 1:
        huffman_code = generate_huffman_code(huffman_tree, huffman_code, """")
    else:
        for letter, _ in huffman_code.items():
            huffman_code[letter] = ""0""

  
    # print(huffman_code)
    # 答えを生成
    ans = 0
    for letter, count in letter_count.items():
        ans += count * len(huffman_code[letter])

    print(ans)

if __name__==""__main__"":
    main()
"
8475857,ALDS1_15_D,"from collections import defaultdict
import heapq


string = input()
count = defaultdict(int)
for char in string:
    count[char] += 1

chars = []
queue = []
for i, key in enumerate(count.keys()):
    chars.append(key)
    heapq.heappush(queue, (count[key], i))

if len(chars) == 1:
    print(len(string))
    exit()

n = 2 * len(chars) - 1
left = [None] * n
right = [None] * n
k = len(chars)
while len(queue) > 1:
    x, i = heapq.heappop(queue)
    y, j = heapq.heappop(queue)
    left[k] = i
    right[k] = j
    heapq.heappush(queue, (x + y, k))
    k += 1

_, i = queue.pop()
code = [None] * n
code[i] = 0
stack = [i]
while stack:
    i = stack.pop()
    if left[i] is not None:
        code[left[i]] = code[i] + 1
        stack.append(left[i])
    if right[i] is not None:
        code[right[i]] = code[i] + 1
        stack.append(right[i])

ans = 0
for i, c in enumerate(chars):
    ans += code[i] * count[c]
print(ans)

"
9058951,ALDS1_15_D,"class Node:
    def __init__(self, character=None, frequency=None):
        self.character = character
        self.frequency = frequency
        self.left = None
        self.right = None




class HuffmanTree:
    def __init__(self, freq):
        nodes = [Node(character, frequency)
                 for character, frequency in freq.items()]


        while len(nodes) > 1:
            nodes.sort(key=lambda n: n.frequency)
            left = nodes.pop(0)
            right = nodes.pop(0)


            combined_node = Node(frequency=left.frequency + right.frequency)
            combined_node.left = left
            combined_node.right = right
            nodes.append(combined_node)


        self.root = nodes[0]
        self.codes = {}
        self._generate_codes(self.root, """")


    def _generate_codes(self, node, current_code):
        if node.character:
            self.codes[node.character] = current_code
            return
        if node.left:
            self._generate_codes(node.left, current_code + ""0"")
        if node.right:
            self._generate_codes(node.right, current_code + ""1"")


    def get_code(self, character):
        return self.codes.get(character, """")




def compress(string):
    freq = {}
    for char in string:
        freq[char] = freq.get(char, 0) + 1


    if len(freq) == 1:
        return len(string)


    tree = HuffmanTree(freq)
    return sum(len(tree.get_code(char)) * freq[char] for char in freq)




if __name__ == '__main__':
    input_string = input().strip()
    result = compress(input_string)
    print(result)

"
9059794,ALDS1_15_D,"# aizu_ALDS1_15_D_HuffmanCoding.py  

from collections import Counter
from heapq import heapify,heappop,heappush

class Node:
    def __init__(self,ch,freq,left=None,right=None):
        self.ch = ch
        self.freq = freq
        self.left = left
        self.right = right
    def __lt__(self,other):
        return self.freq < other.freq
    
def make_huffman_code(text):
    freq = Counter(text)
    hq = [ Node(k,v) for k,v in freq.items()]
    heapify(hq)
    while len(hq) != 1:
        left = heappop(hq)
        right = heappop(hq)
        heappush(hq,Node(None,left.freq+right.freq,left,right))
    root = hq[0]

    def encode(root,s):
        if root is None: return
        if root.left is None and root.right is None:
            huffman_code[root.ch] = s if len(s) > 0 else '1'
        encode(root.left, s + '0')
        encode(root.right, s + '1') 

    huffman_code = {}    
    encode(root,'')

    ans = 0
    for ch,code in huffman_code.items():
        ans += len(code)*freq[ch]
    
    print(ans)

s = input()
make_huffman_code(s)
"
9069773,ALDS1_15_D,"from collections import defaultdict
import heapq


def count_chars(s):
    d = defaultdict(int)
    for c in s:
        d[c] += 1

    ret = [(v, [k]) for k, v in d.items()]
    ret.sort()
    return ret


def build_tree(counts):
    if len(counts) == 1:
        return defaultdict(lambda: 1)

    ret = defaultdict(int)

    while 1 < len(counts):
        a = heapq.heappop(counts)
        for c in a[1]:
            ret[c] += 1

        b = heapq.heappop(counts)
        for c in b[1]:
            ret[c] += 1

        c = (a[0] + b[0], a[1] + b[1])
        heapq.heappush(counts, c)

    return ret


def run(s):
    counts = count_chars(s)
    tree = build_tree(counts)

    ret = 0
    for c in s:
        ret += tree[c]

    return ret


if __name__ == ""__main__"":
    s = input()
    print(run(s))

"
3541104,ALDS1_15_D,"from heapq import *
class Node():
    def __init__(self, key, char=None):
        self.key = key
        self.char = char
        self.pare = None

st = input()
_st = list(set(st))

a = []
for i in _st:
    a  += [(st.count(i),i)] 
heapify(a)

node = {}
for i in range(len(a)):
    cnt, char = a[i]
    node[char] = Node(cnt, char)

while len(a) > 1:
    p1, p2 = heappop(a)
    q1, q2 = heappop(a)
    x = Node(p1+q1, p2+q2) 
    node[p2+q2] = x
    if len(a) == 0:
        root = x
        break
    node[p2].pare = x
    node[q2].pare = x
    heappush(a, (p1+q1,p2+q2))

def dfs(node, cnt=1):
    if node.pare == None:
        return cnt
    a = dfs(node.pare, cnt+1)
    return a

Sum = 0
for i in _st:
    no = node[i]
    depth = dfs(no)
    Sum += depth*no.key
    
print(Sum)

    


"
4344804,ALDS1_15_D,"import heapq

code_list = dict()

class Node():
    def __init__(self, alphabet, rate):
        self.alphabet = alphabet
        self.rate = rate
        self.left = None
        self.right = None

def create_code(node, target, code):
    
    if node == None:
        return 

    if node.alphabet == target:
        code_list[target] = code
        return
        
    create_code(node.left, target, code + ""0"")
    create_code(node.right, target, code + ""1"")

def Main():
    S = input().replace(""\n"", """")
    N = len(S)

    node_list = list()
    count_list = dict()

    character = set(S)
    character = sorted(character)

    for c in character:
        count = S.count(c)
        count_list[c] = count
        n = Node(c, float(count/N))
        node_list.append(n)

    huf_tree = None

    if len(node_list) == 1:
        n1 = node_list.pop()
        new = Node("""", n1.rate)
        new.left = n1

        huf_tree = new

    else:
        while len(node_list) >= 2:
            node_list.sort(key = lambda x : x.rate, reverse = True)

            n1 = node_list.pop()
            n2 = node_list.pop()

            new = Node("""", n1.rate + n2.rate)
            new.left = n1
            new.right = n2
            node_list.append(new)

            huf_tree = new

    code_length = 0

    for c in character:
        create_code(huf_tree, c, """")
        code_length += len(code_list[c]) * count_list[c]

    print(code_length)

Main()
"
4880318,ALDS1_15_D,"from heapq import heappush, heappop, heapify
from collections import defaultdict
 
def encode(symb2freq):
    """"""Huffman encode the given dict mapping symbols to weights""""""
    heap = [[wt, [sym, """"]] for sym, wt in symb2freq.items()]
    heapify(heap)
    while len(heap) > 1:
        lo = heappop(heap)
        hi = heappop(heap)
        for pair in lo[1:]:
            pair[1] = '0' + pair[1]
        for pair in hi[1:]:
            pair[1] = '1' + pair[1]
        heappush(heap, [lo[0] + hi[0]] + lo[1:] + hi[1:])
    return sorted(heappop(heap)[1:], key=lambda p: (len(p[-1]), p))
 
def huffman(txt):
    if all(c == txt[0] for c in txt):
        return len(txt)

    symb2freq = defaultdict(int)
    for ch in txt:
        symb2freq[ch] += 1
    huff = encode(symb2freq)

    cont = 0
    for p in huff:
        cont+= int(symb2freq[p[0]])*len(p[1])
    return cont

if __name__ == ""__main__"":
    while True:
        try:
            print(huffman(input()))
        except:
            break
"
4908171,ALDS1_15_D,"# Author: Jardielma Queiroz De Lima
# Online Judge ID:	1171428
# Problema: Huffman Coding
# ID: ALDS1_15_D

def main():
      #recebe o numero de itens e o peso maximo do pacote
    entrada = input()

    #calcula a freqência de cada caractere
    all_freq = {} 
    for i in entrada: 
        if i in all_freq: 
            all_freq[i] += 1
        else: 
            all_freq[i] = 1

    #transforma para lista
    lista_caracteres = list()
    for i in all_freq:
        lista_caracteres.append([all_freq[i],i])
    lista_caracteres.sort()
    
    arvore = list()
    if(len(lista_caracteres)==1):
        arvore.append([lista_caracteres[0][0],lista_caracteres[0][1]])
        
    while(len(lista_caracteres)>1):
        no_1 = lista_caracteres[0]
        no_2 = lista_caracteres[1]
        lista_caracteres.remove(no_1)
        lista_caracteres.remove(no_2)
        lista_caracteres.append([no_1[0]+no_2[0],no_1[1]+no_2[1]])
        lista_caracteres.sort()
        arvore.append([no_1[0]+no_2[0],no_1[1]+no_2[1]])
    #fim while 
    
    resultado= 0
    for i in range(len(arvore)):
        resultado = resultado + arvore[i][0]
    print(resultado)
#fim função

if __name__ == ""__main__"":
    main()
"
3704016,ALDS1_15_D,"S = input()


dict_string = {}
dict_depth = {}

for s in S:
    if s in dict_string:
        dict_string[s] += 1
    else:
        dict_string[s] = 1
        dict_depth[s] = 0


dict_string_calc = dict_string.copy()


while len(dict_string_calc) != 1:
    x = None
    y = None

    for k, v in sorted(dict_string_calc.items(), key=lambda x: x[1]):
        if x == None:
            x = k
            x_cnt = v
            continue

        if y == None:
            y = k
            y_cnt = v
            break

    for s in (x + y):
        if s in dict_depth:
            dict_depth[s] += 1
        else:
            raise

    del dict_string_calc[x]
    del dict_string_calc[y]

    dict_string_calc[x + y] = x_cnt + y_cnt


ans = 0

for k, v in dict_depth.items():
    ans += dict_string[k] * v


if len(dict_string) == 1:
    ans = len(S)

print(ans)
"
4645154,ALDS1_15_D,"from collections import Counter, deque
from heapq import heappush, heappop, heapify
C = Counter(input())
N = len(C)

if N == 1:
    print(sum(C.values()))
    exit(0)
    
G = [0] * (N * 2)

G[:N] = C
que = [(v, i) for i, v in enumerate(C.values())]
heapify(que)

cur = len(C)
while len(que) > 1:
    v0, nd0 = heappop(que)
    v1, nd1 = heappop(que)
    G[cur]  = (nd0, nd1)
    heappush(que, (v0 + v1, cur))
    cur += 1
root = que[0][1]

ans = 0
que = deque([(0, root)])
while que:
    d, nd = que.popleft()
    if nd < N:
        ans += d * C[G[nd]]
        continue
    u, v = G[nd]
    
    que.append((d + 1, u))
    que.append((d + 1, v))
print(ans)
"
4883386,ALDS1_15_D,"import collections, heapq

def main():
    
    S = input()

    dicFreq = collections.Counter(S)
    
    #listFreq = [(frequencia, caracter, noEsq, noDir)]
    listFreq = [(f, c, None, None) for c, f in dicFreq.items()]
    
    heapq.heapify(listFreq)

    while len(listFreq) >= 2:
        noEsq = heapq.heappop(listFreq)
        noDir = heapq.heappop(listFreq)
        heapq.heappush(listFreq, (noEsq[0]+noDir[0], '', noEsq, noDir))
    
    arv = heapq.heappop(listFreq)
    
    def calcComp(no, prof):
        if no[1] == '':
            return no[0] + calcComp(no[3], prof+1) + calcComp(no[2], prof+1)
        else:
            return 0
    
    if not arv[2] and not arv[3]:
        print(arv[0])
    else:
        resp = calcComp(arv, 0)
        print(resp)

    return 0

if __name__ == '__main__':
    main()
"
4891321,ALDS1_15_D,"from collections import Counter
import heapq
import sys

def huffman(cs):
    alfabeto=""qwertyuiopasdfghjklzxcvbnm""
    lens = {a:0 for a in alfabeto}
    pilha = []
    ln = {} 
    
    for si in cs:
        heapq.heappush(pilha,(cs[si],[si]))

    for _ in range(len(cs)-2):

        ci,ssi=heapq.heappop(pilha)
        cj,ssj = heapq.heappop(pilha)
    
        for si in ssi:

            lens[si]+=1

        for sj in ssj:

            lens[sj]+=1

        heapq.heappush(pilha,(ci+cj,ssi+ssj))
    
    ans = 0
    for si in cs:
        ans += cs[si] * (lens[si]+1)
    
    return(ans)



def main():
    s = input()
    cs = Counter(s)
    print(huffman(cs))
    return 0

if __name__ == '__main__':
	main()
"
4906168,ALDS1_15_D,"from collections import Counter
import heapq
import sys


def huffman(f):
    alfabeto = ""abcdefghijklmnopqrstuvwxyz""
    alfabeto_dic = {letra: 0 for letra in alfabeto}
    arvore = []

    # montando
    for item in f:
        heapq.heappush(arvore, (f[item], [item]))

    for i in range(len(f) - 2):
        # retira menor
        numX, x = heapq.heappop(arvore)
        # retira segundo menor
        numY, y = heapq.heappop(arvore)

        for itemx in x:
            alfabeto_dic[itemx] += 1

        for itemy in y:
            alfabeto_dic[itemy] += 1

        # adiciona novo
        heapq.heappush(arvore, (numX + numY, x + y))

    total = 0
    for item in f:
        total += f[item] * (alfabeto_dic[item] + 1)
    print(total)
    
    
string = input().strip()
while string:
    try:
        frequencia = Counter(string)
        huffman(frequencia)
        string = input().strip()
    except:
        sys.exit(0)
"
4908470,ALDS1_15_D,"#!/usr/bin/env python3

from sys import stdin, stdout
from heapq import heappop, heappush, heapify
from collections import Counter

class TreeNode:
    def __init__(self, letter, frequency, left, right):
        self.value = letter
        self.frequency = frequency
        self.left = left
        self.right = right

    def __lt__(self, other):
        return self.frequency < other.frequency

def visit(node, i):
    if node.value == '':
        return node.frequency + visit(node.right, i+1) + visit(node.left, i+1)
    else:
        return 0

cfreq = [TreeNode(letter, frequency, None, None) for letter, frequency in Counter(input()).items()]
heapify(cfreq)

while len(cfreq) >= 2:
    l = heappop(cfreq)
    r = heappop(cfreq)
    heappush(cfreq, TreeNode('', l.frequency+r.frequency, l, r))

tree = heappop(cfreq)

if not tree.left and not tree.right:
    print(tree.frequency)
else:
    print(visit(tree, 0))
"
5293427,ALDS1_15_D,"import collections
import heapq
S = list(input())
counterS = collections.Counter(S)
invdict = dict()
dict1 = dict()
N = len(counterS)
if N == 1:
    print(len(S))
    exit()
children = [[] for i in range(2*N-1)]
parents = [-1]*(2*N-1)
h = []
ii = 0
for key,value in counterS.items():
    invdict[ii] = key
    dict1[key] = ii
    h.append((value,ii))
    ii += 1
heapq.heapify(h)
while len(h) >= 2:
    v1,node1 = heapq.heappop(h)
    v2,node2 = heapq.heappop(h)
    children[ii].append(node1)
    children[ii].append(node2)
    parents[node1] = ii
    parents[node2] = ii
    heapq.heappush(h,(v1+v2,ii))
    ii += 1
depth = [-1]*(2*N-1)
depth[-1] = 0
d = collections.deque([-1])
while d:
    v = d.pop()
    for j in children[v]:
        depth[j] = depth[v]+1
        d.append(j)
###符号求めるとき
'''
import copy
huffman = [[] for i in range(2*N-1)]
d = collections.deque([-1])
while d:
    v = d.pop()
    cnt = 0
    for j in children[v]:
        huffman[j] = copy.copy(huffman[v])
        huffman[j].append(cnt)
        cnt += 1
        d.append(j)
print(huffman)
'''
###
ans = 0
for key,value in counterS.items():
    ans += value*depth[dict1[key]]
print(ans)
"
6047083,ALDS1_15_D,"import sys
from collections import Counter
from heapq import heappop, heappush, heapify

read = sys.stdin.read
readline = sys.stdin.readline
readlines = sys.stdin.readlines


def main():
    S = readline().rstrip()

    dic = dict()
    C = Counter(S)

    if len(C) == 1:
        print(len(S))
        exit()
        
    for key in C:
        dic[key] = 0

    L = [(value, key) for key, value in C.items()]
    heapify(L)

    while len(L) > 1:
        tup1 = heappop(L)
        tup2 = heappop(L)
        tmpL = [tup1[0] + tup2[0]]

        for word in tup1[1:]:
            dic[word] += 1
            tmpL.append(word)
        for word in tup2[1:]:
            dic[word] += 1
            tmpL.append(word)
        
        heappush(L, tuple(tmpL))
    
    ans = 0

    for key in C:
        ans += C[key] * dic[key]
    
    print(ans)


if __name__ == '__main__':
    main()
"
6695914,ALDS1_15_D,"import sys
from collections import Counter
from heapq import heappush, heappop

# READ_FROM_FILE = True
READ_FROM_FILE = False


def main():
    if READ_FROM_FILE:
        f = open('test0.txt', 'r')
    else:
        f = sys.stdin

    input_list = list(f.readline().rstrip('\n'))
    frequency_dic = Counter(input_list)

    hq = []
    for v in frequency_dic.values():
        heappush(hq, v)

    counter = 0
    while hq:
        right = heappop(hq)
        if not hq:
            if counter == 0:
                counter += right
            print(counter)
            break
        left = heappop(hq)
        s = left + right
        counter += s
        heappush(hq, s)

    if READ_FROM_FILE:
        f.close()
    return


if __name__ == '__main__':
    main()

"
7622482,ALDS1_15_D,"from collections import Counter, deque
from heapq import heappush, heappop, heapify
C = Counter(input())
N = len(C)

if N == 1:
    print(sum(C.values()))
    exit(0)

G = [0]*(N*2)

G[:N] = C
que = [(v, i) for i, v in enumerate(C.values())]
heapify(que)

cur = len(C)
while len(que) > 1:
    v0, nd0 = heappop(que)
    v1, nd1 = heappop(que)
    G[cur] = (nd0, nd1)
    heappush(que, (v0+v1, cur))
    cur += 1
root = que[0][1]

ans = 0
que = deque([(0, root)])
while que:
    d, nd = que.popleft()
    if nd < N:
        ans += d * C[G[nd]]
        continue
    u, v = G[nd]

    que.append((d+1, u))
    que.append((d+1, v))
print(ans)
"
3363823,ALDS1_15_D,"from collections import Counter, deque
from heapq import heappush, heappop, heapify
C = Counter(input())
N = len(C)

if N == 1:
    print(sum(C.values()))
    exit(0)

G = [0]*(N*2)

G[:N] = C
que = [(v, i) for i, v in enumerate(C.values())]
heapify(que)

cur = len(C)
while len(que) > 1:
    v0, nd0 = heappop(que)
    v1, nd1 = heappop(que)
    G[cur] = (nd0, nd1)
    heappush(que, (v0+v1, cur))
    cur += 1
root = que[0][1]

ans = 0
que = deque([(0, root)])
while que:
    d, nd = que.popleft()
    if nd < N:
        ans += d * C[G[nd]]
        continue
    u, v = G[nd]

    que.append((d+1, u))
    que.append((d+1, v))
print(ans)
"
3743109,ALDS1_15_D,"# -*- coding: utf-8 -*-
""""""
Greedy algorithms - Huffman Coding
http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_15_D&lang=jp

""""""
import sys
from collections import Counter

class Node:
    def __init__(self, v, f):
        self.val = v
        self.freq = f
        self.left = None
        self.right = None


def solve(s):
    res = [Node(k, v) for k, v in Counter(s).items()]
    while len(res) > 1:
        res.sort(key=lambda x: x.freq)
        z = Node('@', res[0].freq + res[1].freq)
        z.left, z.right = res[0], res[1]
        res = res[2:]
        res.append(z)

    d = dict()
    stack = [(res[0], '')]
    while stack:
        n, st = stack.pop()
        if not n.left and not n.right:
            st = '0' if not st else st
            d[n.val] = st
        if n.left:
            stack.append((n.left, st+'0'))
        if n.right:
            stack.append((n.right, st+'1'))
    return len(''.join([d[ch] for ch in s]))


def main(args):
    s = input()
    ans = solve(s)
    print(ans)


if __name__ == '__main__':
    main(sys.argv[1:])

"
4599511,ALDS1_15_D,"import sys, collections, heapq
input = lambda: sys.stdin.readline().rstrip() 
sys.setrecursionlimit(10**7)
INF = 10**10
def I(): return int(input())
def F(): return float(input())
def SS(): return input()
def LI(): return [int(x) for x in input().split()]
def LI_(): return [int(x)-1 for x in input().split()]
def LF(): return [float(x) for x in input().split()]
def LSS(): return input().split()

def resolve():
    S = SS()

    # ハフマン木の構成
    cnt = collections.Counter(S)
    # (頻度, 文字, 左の子, 右の子)
    freq = [(v, k, None, None) for k, v in cnt.items()]
    heapq.heapify(freq)
    while len(freq) >= 2:
        l = heapq.heappop(freq)
        r = heapq.heappop(freq)
        heapq.heappush(freq, (l[0]+r[0], '', l, r))
    root = heapq.heappop(freq)

    # 符号長の導出
    code_len = {}
    for i in cnt.keys():
        code_len[i] = 1

    def dfs(node, depth):
        if node[1]:
            if depth == 0:
                code_len[node[1]] = 1
            else:
                code_len[node[1]] = depth
        else:
            dfs(node[2], depth+1)
            dfs(node[3], depth+1)

    dfs(root, 0)

    # 符号の長さの計算
    # print(code_len)
    ans = 0
    for i in S:
        ans += code_len[i]
    print(ans)

if __name__ == '__main__':
    resolve()

"
4817307,ALDS1_15_D,"s=input()
from collections import Counter
import heapq
cs=Counter(s)
h=[]
alp=""qwertyuiopasdfghjklzxcvbnm""
lens={a:0 for a in alp}
ln={}
for si in cs:
    heapq.heappush(h,(cs[si],[si]))

for _ in range(len(cs)-2):
    ci,ssi=heapq.heappop(h)
    cj,ssj=heapq.heappop(h)
    for si in ssi:
        lens[si]+=1
    for sj in ssj:
        lens[sj]+=1
    heapq.heappush(h,(ci+cj,ssi+ssj))
ans=0
for si in cs:
    ans+=cs[si]*(lens[si]+1)
print(ans)

"
5011756,ALDS1_15_D,"from collections import Counter, deque
from heapq import heappush, heappop, heapify
C = Counter(input())
N = len(C)

if N == 1:
    print(sum(C.values()))
    exit(0)

G = [0]*(N*2)

G[:N] = C
que = [(v, i) for i, v in enumerate(C.values())]
heapify(que)

cur = len(C)
while len(que) > 1:
    v0, nd0 = heappop(que)
    v1, nd1 = heappop(que)
    G[cur] = (nd0, nd1)
    heappush(que, (v0+v1, cur))
    cur += 1
root = que[0][1]

ans = 0
que = deque([(0, root)])
while que:
    d, nd = que.popleft()
    if nd < N:
        ans += d * C[G[nd]]
        continue
    u, v = G[nd]

    que.append((d+1, u))
    que.append((d+1, v))
print(ans)
"
5073216,ALDS1_15_D,"from collections import Counter
import heapq

def main():
    cnr = Counter(list(input())).most_common()
    bit = {k: 0 for k, _ in cnr}
    cnt = [(v, [k, ]) for k, v in cnr[::-1]]

    if len(cnt) == 1:
        print(cnt[0][0])
        return
        
    while len(cnt) != 1:
        v1, k1 = heapq.heappop(cnt)
        v2, k2 = heapq.heappop(cnt)
        heapq.heappush(cnt, (v1 + v2, k1 + k2))

        for k in k1 + k2:
            bit[k] += 1
    
    print(sum(bit[k] * v for k, v in cnr))

main()

"
7014408,ALDS1_15_D,"from collections import Counter
import heapq


class HuffmanNode:
    def __init__(self, letter: str = """", counter: int = -1, child_nodes=None) -> None:
        self.strings = set()
        self.left = None
        self.right = None
        self.counter = 0

        if child_nodes is None:
            self.strings.add(letter)
            self.counter = counter
        else:
            self.left = child_nodes[0]
            self.right = child_nodes[1]
            self.strings = self.left.strings | self.right.strings
            self.counter = self.left.counter + self.right.counter

    def __eq__(self, other):
        return self.counter == other.counter

    def __ne__(self, __o: object) -> bool:
        return not self.__eq__(__o)

    def __lt__(self, __o):
        return self.counter < __o.counter

    def __le__(self, __o):
        return self.__eq__(__o) or self.__lt__(__o)

    def __gt__(self, __o):
        return self.counter > __o.counter

    def __ge__(self, __o):
        return self.__eq__(__o) or self.__gt__(__o)

    def get_signature(self, letter: str) -> str:
        if self.left is None and self.right is None:
            return """"
        if letter in self.left.strings:
            return ""0"" + self.left.get_signature(letter)
        return ""1"" + self.right.get_signature(letter)


def main():
    S = input()
    counter = Counter(S)
    nodes = []
    for letter, value in counter.items():
        heapq.heappush(nodes, HuffmanNode(letter, value))

    while len(nodes) >= 2:
        most_least_node = heapq.heappop(nodes)
        second_less_node = heapq.heappop(nodes)
        parent_node = HuffmanNode(
            child_nodes=[most_least_node, second_less_node]
        )
        heapq.heappush(nodes, parent_node)

    root_node = nodes[0]
    digits = 0
    if len(counter) == 1:
        print(sum(counter.values()))
        return
    for letter, value in counter.items():
        signature = root_node.get_signature(letter)
        digits += len(signature) * value
    print(digits)


if __name__ == ""__main__"":
    main()

"
3826057,ALDS1_15_D,"from collections import Counter

S=input()
freq=sorted(list(dict(Counter(S)).items()),key=lambda w:w[1])
length={chr(ord('a')+i):0 for i in range(26)}
while len(freq)>1:
    minimum1=freq.pop(0)
    minimum2=freq.pop(0)
    for c in minimum1[0]+minimum2[0]:
        length[c]=length[c]+1
    freq.append((minimum1[0]+minimum2[0],minimum1[1]+minimum2[1]))
    freq=sorted(freq,key=lambda w:w[1])

retval=0
for s in S:
    retval+=max(length[s],1)
print(retval)

"
7052032,ALDS1_15_D,"def main():
    from heapq import heappop, heappush, heapify 
    
    S = input()
    count = {a: 0 for a in 'abcdefghijklmnopqrstuvwxyz'}
    for s in S:
        count[s] += 1
        
    que = [(v, a) for a, v in count.items() if v > 0]
    if len(que) == 1:
        return len(S)
    
    heapify(que)   
    C = {}
    while(len(que)) >= 2:
        v1, a1 = heappop(que)
        v2, a2 = heappop(que)
        v = v1 + v2
        a = a1 + a2 
        C[a] = {a1, a2}
        heappush(que, (v, a))
    
    D = {}
    root = que[0][1]
    Q = [root]
    D[root] = 0
    while Q:
        u = Q.pop()
        if u in C:
            for v in C[u]:
                D[v] = D[u] + 1
                Q.append(v)
    
    ans = 0
    for s in S:
        ans += D[s]
    return ans

print(main())
"
3417057,ALDS1_15_D,"import heapq
from collections import Counter


class HuffmanTreeNode:
    def __init__(self, char, freq):
        self.char = char
        self.freq = freq
        self.left = None
        self.right = None
    
    def __lt__(self, other):
        return self.freq < other.freq


def huffman_code_helper(root, code='', codes={}):
    if not root:
        return codes
    
    if not root.left and not root.right:
        codes[root.char] = code if code else '0'
        return codes
    
    huffman_code_helper(root.left, code + '0', codes)
    huffman_code_helper(root.right, code + '1', codes)
    return codes


def huffman_code(text):
    counter = Counter(text)
    heap = []
    for char, freq in counter.items():
        heap.append(HuffmanTreeNode(char, freq))
    heapq.heapify(heap)

    while len(heap) > 1:
        left, right = heapq.heappop(heap), heapq.heappop(heap)
        node = HuffmanTreeNode('', left.freq + right.freq)
        node.left, node.right = left, right
        heapq.heappush(heap, node)
    root = heap[0]

    return huffman_code_helper(root)


def solution():
    text = input()
    codes = huffman_code(text)
    encoded = []
    for char in text:
        encoded.append(codes[char])
    print(len(''.join(encoded)))

solution()
"
4766813,ALDS1_15_D,"# ハフマン符号
# https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/15/ALDS1_15_D

from collections import Counter
import heapq


class Node:
    def __init__(self, count, val=None, left=None, right=None):
        self.val = val
        self.count = count
        self.left = left
        self.right = right

    def __lt__(self, other):
        return self.count < other.count


class HuffmanCoding:
    def __init__(self, s: str):
        self.s = s
        self.counts = Counter(s).most_common()
        self.root = self.build_tree()
        self.encode_table = self.gen_encode_table()

    def build_tree(self):
        hq = list()
        for val, cnt in self.counts:
            heapq.heappush(hq, Node(cnt, val))
        while len(hq) > 1:
            x = heapq.heappop(hq)
            y = heapq.heappop(hq)
            cnt = x.count + y.count
            z = Node(cnt, None, y, x)
            heapq.heappush(hq, z)
        if hq:
            return heapq.heappop(hq)
        else:
            return None

    def gen_encode_table(self):
        encode_table = {}

        def traversal(node, key):
            if node.val:
                if key == """":
                    key = ""0""
                encode_table[node.val] = key
            else:
                if node.left:
                    traversal(node.left, key + ""1"")
                if node.right:
                    traversal(node.right, key + ""0"")
        key = """"
        if self.root:
            traversal(self.root, key)

        return encode_table

    def get_encode_size(self):
        size = 0
        for a in self.s:
            size += len(self.encode_table[a])
        return size

    def gen_encode_bin(self):
        enc = """"
        for a in self.s:
            enc += self.encode_table[a]
        return enc


def main():
    S = input().strip()
    huffman = HuffmanCoding(S)
    print(huffman.get_encode_size())


if __name__ == ""__main__"":
    main()

"
5223768,ALDS1_15_D,"from heapq import heappush, heapify, heappop
from collections import Counter
from collections import deque


def shortest_path_bfs(es: ""隣接リスト"", start: ""始点""):
    INF = 1_000_000_000
    V = len(es)
    d = [INF] * V  # 頂点startからの最短距離
    que = deque()
    que.append(start)
    d[start] = 0
    while que:
        v = que.popleft()
        for e in es[v]:
            if d[e] == INF:
                d[e] = d[v] + 1
                que.append(e)

    return d


s = input()
dic = {}
m = 0
for c in s:
    if c in dic:
        continue
    dic[c] = m
    m += 1

a = Counter(s)
if len(a) == 1:
    print(len(s))
    exit()
    
d = [(v, i) for i, v in enumerate(a.values())]
n = len(d)
heapify(d)
es = [[] for _ in range(n)]
while len(d) > 1:
    a, i = heappop(d)
    x, j = heappop(d)
    heappush(d, (a + x, n))
    es.append([i, j])
    n += 1
dist = shortest_path_bfs(es, n - 1)
ans = 0
for c in s:
    ans += dist[dic[c]]
print(ans)

"
5263134,ALDS1_15_D,"import heapq
s = input()
cnt = [0] * 26
for e in s:
    cnt[ord(e) - ord('a')] += 1

q = []
for i in cnt:
    if i > 0:
        heapq.heappush(q, i)

ans = 0
while q:
    a = heapq.heappop(q)
    if not(q):
        if ans == 0:
            ans += a
        print(ans)
        exit(0)

    b = heapq.heappop(q)
    ans += a + b
    heapq.heappush(q, a + b)

"
6292084,ALDS1_15_D,"import heapq # heapqをimportし, 優先度付きキューを使用できるようにする

# Description
#     - 各節点の出現頻度, 文字種, 親, 左の子, 右の子に関する情報をまとめて扱う
class point:  

    # Input:
    #     - fre:新たに作成する節点の出現頻度
    #     - chr:作成する節点の文字種
    # Description:
    #     - 新たな節点を作成する
    def __init__(self,fre,chr):
        self.fre = fre # 節点の出現頻度を与えられた値にする
        self.chr = chr # 節点の文字種を与えられたものにする
        self.p = None # 親をNoneで初期化する
        self.left = None # 左の子をNoneで初期化する
        self.right = None # 右の子をNoneで初期化する

s = input() # ビット文字列の長さを求めたい文字列sを入力する
cnt = {} # 各文字種の出現頻度を数えるcntを用意する
for i in s: # sに含まれる全ての文字について繰り返し
    if i not in cnt: # iがcntに含まれていない場合
        cnt[i] = 0 # iの出現頻度を0で初期化する
    cnt[i] += 1 # iの出現頻度に1加算

if len(cnt) == 1: # 文字が1種類しか存在しない場合
    print(cnt[s[0]]) # その出現頻度を出力し, 終了する
    exit()

hp = [] # 親を持たない節点を表わす優先度付きキューhpを用意
idx = 0 # 今までにhpに追加された節点数を数える変数idxを用意(pointの大小比較を行うと生じるエラーを防ぐために使用する)
for c in cnt: # cntに含まれる全ての要素について繰り返し
    heapq.heappush(hp,(cnt[c],idx,point(cnt[c],c))) # 節点を作成し, hpに追加する
    idx += 1 # idxに1加算

while len(hp) > 1: # hpの長さが1になるまで繰り返し
    min1_fre,_,min1_point = heapq.heappop(hp) # hpに含まれる節点の内, 出現頻度が最も小さいものを取り出し, min1_pointとする
    min2_fre,_,min2_point = heapq.heappop(hp) # hpに含まれる節点の内, 出現頻度が2番目に小さいものを取り出し, min2_pointとする
    new_point = point(min1_fre+min2_fre,'.') # 取り出した2つの節点の親となる節点を作成し, new_pointとする
    new_point.left = min1_point # new_pointの左の子をmin1_pointとする
    new_point.right = min2_point # new_pointの右の子をmin2_pointとする
    min1_point.p = new_point # min1_pointの親をnew_pointとする
    min2_point.p = new_point # min2_pointの親をnew_pointとする
    heapq.heappush(hp,(min1_fre+min2_fre,idx,new_point)) # hpにnew_pointを追加する
    idx += 1 # idxに1加算

ans = 0 # sを符号化して得られるビット文字列の長さを表わす変数ansを用意

# Input:
#     - i:現在いる節点の情報をまとめたもの
#     - d:現在いる節点の深さ
# Description:
#     - DFSを行い, 各節点の深さを求めながら, ansも求める
def dfs(i,d):
    if i.left == None: # iが葉である場合
        global ans # ansをグローバル変数と宣言
        ans += d * i.fre # ansにiの深さ*出現頻度を加算
    else: # iが子を持つ場合
        dfs(i.left,d+1) # 左の子に移動
        dfs(i.right,d+1) # 右の子に移動
    return

dfs(hp[0][2],0) # 木の根からDFSを開始
print(ans) # sを符号化して得られるビット文字列の長さを出力
"
7057550,ALDS1_15_D,"import heapq


class Node:
    def __init__(self, label, freq):
        self.label = label
        self.freq = freq
        self.left = None
        self.right = None
        self.parent = None
        self.code = """"

    def __gt__(self, other):
        if self.freq > other.freq:
            return True
        elif self.freq == other.freq:
            if self.label > other.label:
                return True
            else:
                return False
        else:
            return False

    def __lt__(self, other):
        if self.freq < other.freq:
            return True
        elif self.freq == other.freq:
            if self.label < other.label:
                return True
            else:
                return False
        else:
            return False

    def __eq__(self, other):
        return self.freq == other.freq and self.label == other.label


class HuffmanTree:
    def __init__(self, data_list):
        self.root = None
        self.dic = dict()
        self.build(data_list)

    def set_code(self, node, code):
        if node.left is None and node.right is None:
            node.code = code
            return
        self.set_code(node.left, code + ""0"")
        self.set_code(node.right, code + ""1"")

    def set_dic(self, node):
        if node is None:
            return
        if node.label not in self.dic:
            self.dic[node.label] = node.code
        self.set_dic(node.left)
        self.set_dic(node.right)

    def build(self, data_list):
        work = []
        data_list.sort()
        for d in data_list:
            node = Node(d[1], d[0])
            heapq.heappush(work, node)
        if len(work) == 1:
            node_x = heapq.heappop(work)
            self.root = Node(node_x.label + node_x.label, node_x.freq * 2)
            self.root.left = node_x
            node_x.code = ""0""
            self.dic[node_x.label] = node_x.code
            node_x.parent = self.root
        else:
            while len(work) > 0:
                node_x = heapq.heappop(work)
                if len(work) > 0 and work[0].parent is None:
                    node_y = heapq.heappop(work)
                    node_z = Node(node_x.label + node_y.label, node_x.freq + node_y.freq)
                    node_z.left = node_x
                    node_z.right = node_y
                    node_x.parent = node_z
                    node_y.parent = node_z
                    heapq.heappush(work, node_z)
                else:
                    self.root = node_x
            self.set_code(self.root, """")
            self.set_dic(self.root)

    def encoding(self, s_):
        ret = """"
        for c_ in s_:
            ret += self.dic[c_]
        return ret


s = input()
f = dict()
for c in s:
    if c in f:
        f[c] += 1
    else:
        f[c] = 1
val = []
for k, v in f.items():
    val.append((v, k))

ht = HuffmanTree(val)
ans = ht.encoding(s)
print(len(ans))

"
8146796,ALDS1_15_D,"from heapq import heappush, heappop, heapify
from collections import defaultdict

def huffman_encoding(p_list):
    n = len(p_list)
    todo = [(p, i) for i, p in enumerate(p_list)]
    heapify(todo)
    tree = [None]*n
    while len(todo) > 1:
        p1, t1 = heappop(todo)
        p2, t2 = heappop(todo)
        
        tree.append(None)
        p3, t3 = p1+p2, len(tree)-1
        tree[t1] = (t3, ""0"")
        tree[t2] = (t3, ""1"")
        heappush(todo, (p3, t3))
    
    s_list = []
    for i in range(n):
        li = []
        cursor = i
        while tree[cursor]:
            cursor, x = tree[cursor]
            li.append(x)
        s_list.append("""".join(li))
    
    return s_list

s = input()
alp_dict = defaultdict(int)

for i in s:
    alp_dict[i] += 1

alp_list = []
count_list = []
for k, v in alp_dict.items():
    alp_list.append(k)
    count_list.append(v)

if len(alp_list) == 1:
    print(len(s))
    exit()
x_list = huffman_encoding(count_list)
enc_dict = dict()
for alp, x in zip(alp_list, x_list):
    enc_dict[alp] = len(x)

ans = sum(enc_dict[i] for i in s)

print(ans)
"
8173232,ALDS1_15_D,"# Huffman Coding
# ハフマン符号
# 他人の解答閲覧



import heapq
s = input()
cnt = [0] * 26
for e in s:
    cnt[ord(e) - ord('a')] += 1

q = []
for i in cnt:
    if i > 0:
        heapq.heappush(q, i)

ans = 0
while q:
    a = heapq.heappop(q)
    if not(q):
        if ans == 0:
            ans += a
        print(ans)
        exit(0)

    b = heapq.heappop(q)
    ans += a + b
    heapq.heappush(q, a + b)



"
3366359,ALDS1_15_D,"class Node():
    p = None
    l = None
    r = None
    char = ''
    count = 0

    def __init__(self, char='', count=0):
        self.char = char
        self.count = count


def solve(n, h):
    if n.char:
        # print('{}:{}'.format(n.char, h))
        return len(h) * n.count
    else:
        ret = 0
        if n.l: ret += solve(n.l, h + '0')
        if n.r: ret += solve(n.r, h + '1')
        return ret


# --------------------
S = input()
C = {}
T = []

for s in S:
    C.setdefault(s, 0)
    C[s] += 1

T = [Node(*x) for x in C.items()]
T.sort(key=lambda x: x.count)

if len(T) == 1:
    n = Node()
    n.l = T.pop(0)
    T.append(n)
else:
    while len(T) != 1:
        n = Node()
        n.l = T.pop(0)
        n.r = T.pop(0)
        n.count = n.l.count + n.r.count
        T.append(n)
        T.sort(key=lambda x: x.count)

print(solve(T[0], ''))
"
7308751,ALDS1_15_D,"import heapq

S = input()

ans = 0

d = dict()
for c in S:
	if c in d:
		d[c] += 1
	else:
		d[c] = 1
		
que = []
heapq.heapify(que)
for v in d.values():
	heapq.heappush(que, v)

if len(que) == 1:
	print(heapq.heappop(que))
else:
	while len(que) > 1:
		l1 = heapq.heappop(que)
		l2 = heapq.heappop(que)
		ans += l1 + l2
		heapq.heappush(que, l1+l2)
	
	print(ans)
"
5791216,ALDS1_15_D,"from heapq import heappush, heappop
s = input()
cnt = [0] * 26
for e in s: cnt[ord(e) - ord('a')] += 1
q = []
for i in cnt:
    if i > 0: heappush(q, i) 
ans = 0
while q:
    a = heappop(q)
    if not(q): print(ans if ans else a);exit(0)
    b = heappop(q)
    ans += a + b
    heappush(q, a + b)
"
7703794,ALDS1_15_D,"# 15_D.py Huffman Coding

# from __future__ import annotations
from typing import Dict, Optional
from collections import Counter
from heapq import heapify, heappush, heappop


class HuffmanTree:

    class Node:

        def __init__(self, freq: int, c: str, 
                     l: Optional[""HuffmanTree.Node""] = None, 
                     r: Optional[""HuffmanTree.Node""] = None) -> None:
            self.freq = freq
            self.c = c
            self.l = l
            self.r = r

        def __repr__(self) -> str:
            return (f""Node({self.freq},'{self.c}')"")

        def __lt__(self, other: ""HuffmanTree.Node"") -> bool:
            return self.freq < other.freq

    def __init__(self, source: str) -> None:
        self.text = source
        self.root = self.build_tree()
        self.dict = self.build_dict()

    def build_tree(self) -> ""HuffmanTree.Node"":
        counts = [HuffmanTree.Node(freq, c)
                  for c, freq in Counter(self.text).items()]
        heapify(counts)
        if len(counts) == 1:
            l = heappop(counts)
            return HuffmanTree.Node(l.freq, """", l, None)
        while len(counts) > 1:
            l = heappop(counts)
            r = heappop(counts)
            heappush(counts, HuffmanTree.Node(l.freq + r.freq, """", l, r))
        return heappop(counts)

    def print_tree(self) -> None:

        def rec(n: ""HuffmanTree.Node"", prefix: str) -> None:
            print(f""{prefix} : '{n.c}', {n.freq}"")
            if n.l is not None:
                rec(n.l, prefix + ""0"")
            if n.r is not None:
                rec(n.r, prefix + ""1"")
        
        rec(self.root, """")

    def build_dict(self) -> Dict[str, str]:
        
        def rec(n: HuffmanTree.Node, s: str) -> None:
            if n.c != """":
                d[n.c] = s
            if n.l is not None:
                rec(n.l, s + ""0"")
            if n.r is not None:
                rec(n.r, s + ""1"")
        
        d: Dict[str, str] = {}
        rec(self.root, """")
        return d

    def encode(self, text: str) -> str:
        return """".join([self.dict[c] for c in text])

    def decode(self, text: str) -> str:
        decoded = """"
        n: Optional[""HuffmanTree.Node""] = self.root
        if n is None:
            return decoded
        for c in text:
            n = n.l if c == ""0"" else n.r
            if n is None:
                break
            if n.c != """":
                decoded += n.c
                n = self.root
        return decoded

S: str = input()
ht = HuffmanTree(S)
# ht.print_tree()
# print(ht.encode(S))
# print(ht.decode(ht.encode(S)))
print(len(ht.encode(S)))

"
7723859,ALDS1_15_D,"import sys
import os
from heapq import heapify, heappop, heappush
from collections import Counter

istest = False
fn = ""inputdata.txt""
if os.path.exists(fn):
    istest = True
    sys.stdin = open(fn)

s=sys.stdin.readline().rstrip()

class Node:
    def __init__(self,left=None,right=None,label=None):
        self.left=left
        self.right=right
        self.label=label
        self.parent=None
    def set_parent(self,p):
        self.parent=p

class HoffTree:
    def __init__ (self,hq):
        heapify(hq)
        cnt=0 
        while len(hq)>1:
            lcnt,lid,left=heappop(hq)
            rcnt,rid,right=heappop(hq)
            ID=str(cnt)
            ap=[lcnt+rcnt,ID,Node(left,right)]
            left.set_parent(ap[2])
            right.set_parent(ap[2])
            heappush(hq,ap)
            cnt+=1
        if len(hq)==1:
            self.root=hq[0][2]
        else:
            self.root=ap[2]
        
    def dfs(self,c,node,code,bit):
        code+=bit
        if c==node.label:
            return code
        if node.left==None:
            return False
        retleft=self.dfs(c,node.left,code,""0"")
        if retleft:
            return retleft
        retright= self.dfs(c,node.right,code,""1"")
        if retright:
            return retright
        return False

               

dic={}
hq=[]     
for c in s:
    if not c in dic:
        dic[c]=[1,c,Node(label=c)]
        hq.append(dic[c])
        continue
    dic[c][0]+=1
    
def bitlen(c):
    parent_node=dic[c][2].parent
    cnt=1
    while parent_node:
        parent_node=parent_node.parent
        if parent_node:
            cnt+=1      
    return cnt



tree=HoffTree(hq)
for key in dic:
    bitlength=bitlen(key)
    #bitlength=len(tree.dfs(key,tree.root,"""",""""))
    dic[key].append(bitlength)
l=0
for c in s:
    l+=dic[c][3]
print(l)
"
3773625,ALDS1_15_D,"import heapq

S = input()

# 数え上げ
chars = [[0, n] for n in range(256)]
for s in S:
	chars[ord(s)][0] += 1

# ハフマン木生成
# ：ノードの構造：[count, char, left=None, right=None]
# ：[1]のcharは、heapqでユニークキーとして機能するように追加した
counts = []
for char in chars:
	if not char[0]:
		continue
	heapq.heappush(counts, [char[0], char[1], None, None, char])

# ハフマン木編成
while 1 < len(counts):
	a, b = heapq.heappop(counts), heapq.heappop(counts)
	heapq.heappush(counts, [a[0] + b[0], -1, a, b])
root = heapq.heappop(counts)

# コード化(左：0、右：1)
codes = {};
def dfs(node, code):
	# 節の処理
	if node[1] < 0:
		dfs(node[2], code + ""0"")
		dfs(node[3], code + ""1"")
		return
	# 葉の処理
	codes[chr(node[1])] = code
dfs(root, """")

# 集計
count = 0
for s in S:
	count += len(codes[s])

# 1種類の場合のみ例外処理…いずれなんとか
if 1 == len(set(S)):
	print(len(S))
else:
	print(count)

"
3811150,ALDS1_15_D,"from typing import Dict


class Node():
    left = None
    right = None
    parent = None
    char = ''
    value = 0

    def __init__(self, char: str = '', value: int = 0) -> None:
        self.char = char
        self.value = value


def get_coded_str_len(node: Node, base_str: str) -> int:
    if node.char:
        # Return the length of the coded string.
        return len(base_str) * node.value
    else:
        coded_str_len = 0
        if node.left:
            coded_str_len += get_coded_str_len(node.left, base_str + '0')
        if node.right:
            coded_str_len += get_coded_str_len(node.right, base_str + '1')
        return coded_str_len


if __name__ == ""__main__"":
    input_str = input()
    char_dict: Dict[str, int] = {}
    for s in input_str:
        if s in char_dict:
            char_dict[s] += 1
        else:
            char_dict[s] = 1

    nodes = [Node(char=k, value=v) for k, v in char_dict.items()]
    # Sort in the ascending order.
    nodes.sort(key=lambda x: x.value)

    if 1 == len(nodes):
        node = Node()
        node.left = nodes.pop(0)  # type: ignore
        nodes.append(node)
    else:
        while 1 != len(nodes):
            node = Node()
            node.left = nodes.pop(0)  # type: ignore
            node.right = nodes.pop(0)  # type: ignore
            node.value = node.left.value + node.right.value  # type: ignore
            nodes.append(node)
            # Sort in the ascending order.
            nodes.sort(key=lambda x: x.value)

    print(f""{get_coded_str_len(nodes[0], '')}"")

"
5282738,ALDS1_15_D,"class Node:
    def __init__(self, key, value):
        self.key = key
        self.parent = None
        self.value = value
        self.bit = None
    
    def __lt__(self, other):
        if self.value == other.value:
            return self.key < other.key
        return self.value < other.value
    
    def __gt__(self, other):
        if self.value == other.value:
            return self.key > other.key
        return self.value > other.value


def huffman(string):
    code_dict = {}
    char_count = {}
    for s in string:
        char_count[s] = char_count.get(s, 0) + 1
    p_queue = sorted([Node(k, v) for k, v in char_count.items()])
    if len(p_queue) == 1:
        p_queue[0].bit = ""0""
    while len(p_queue) > 1:
        left = p_queue.pop(0)
        right = p_queue.pop(0)
        parent = left.key + right.key
        parent_value = left.value + right.value
        for i, node in enumerate([left, right]):
            node.parent = parent
            node.bit = str(i)
            code_dict[node.key] = node
        p_queue.append(Node(parent, parent_value))
        p_queue.sort()
    last_node = p_queue.pop()
    code_dict[last_node.key] = last_node
    huffman_code = {}
    for k in char_count:
        bit_list = []
        node = code_dict[k]
        while node.bit is not None:
            bit_list.append(node.bit)
            if node.parent is None:
                break
            node = code_dict[node.parent]
        huffman_code[k] = """".join(bit_list[::-1])
    return huffman_code


S = input()
huffman_code = huffman(S)
total_length = 0
for s in S:
    total_length += len(huffman_code[s])
print(total_length)
"
6376563,ALDS1_15_D,"from typing import List, Tuple, Counter, Union, Dict
import sys
import collections
import heapq
from array import array


sys.setrecursionlimit(1000000)
input = sys.stdin.readline


class HuffmanNode:
    def __init__(self, v: int, label: str = """"):
        self.value: int = v
        self.label: str = label
        self.left_child: Union[HuffmanNode, None] = None
        self.right_child: Union[HuffmanNode, None] = None
        # self.parent: Union[HuffmanNode, None] = None

    def __lt__(self, other):
        if not isinstance(other, HuffmanNode):
            return NotImplemented

        # return self.value < other.value

        if self.value == other.value:
            return self.label < other.label
        else:
            return self.value < other.value


def dfs(node: HuffmanNode, bit_assign: Dict[str, str], current_bit: str):
    if node.label != """":
        bit_assign[node.label] = current_bit

    if node.left_child is not None:
        dfs(node.left_child, bit_assign, current_bit + ""0"")

    if node.right_child is not None:
        dfs(node.right_child, bit_assign, current_bit + ""1"")


def main():
    S: str = input()
    count: Counter[str] = Counter(S)

    if len(count) == 2:
        print(len(S) - 1)
        return

    nodes: List[HuffmanNode] = [
        HuffmanNode(value, label) for (label, value) in count.items()
    ]
    nodes.pop()

    heapq.heapify(nodes)
    while len(nodes) != 1:
        x: HuffmanNode = heapq.heappop(nodes)
        y: HuffmanNode = heapq.heappop(nodes)

        z = HuffmanNode(x.value + y.value)
        if x.label == """":
            z.left_child = y
            z.right_child = x
        else:
            z.left_child = x
            z.right_child = y

        heapq.heappush(nodes, z)

    bit_assign: Dict[str, str] = {}
    dfs(nodes[0], bit_assign, """")

    answer: List[str] = []
    for s in S:
        if s != ""\n"":
            answer.append(bit_assign[s])

    # print("""".join(answer))
    print(len("""".join(answer)))


if __name__ == ""__main__"":
    main()

"
8032308,ALDS1_15_D,"S=list(input())
word=[0]*26
for i in range(len(S)):
    word[ord(S[i])-ord('a')]+=1

lis=[]
for i in range(26):
    if word[i]:
        lis.append(word[i])
if len(lis)==1:
    print(lis[0])
    exit()
import heapq
heapq.heapify(lis)

ans=0
while len(lis):
    a=heapq.heappop(lis)
    if not len(lis):
        #ans+=a
        break
    b=heapq.heappop(lis)
    ans+=a+b
    heapq.heappush(lis,a+b)
print(ans)



"
8044983,ALDS1_15_D,"import sys
import threading
import random
import math
import heapq
from collections import deque, OrderedDict
import bisect
import multiprocessing

# sys.getrecursionlimit() # 再起回数の上限を取得
sys.setrecursionlimit(200000) # 再起回数の上限を変更

# 以下のメモリ領域を自分でも計算しておきたい
# 再帰が多い時はpypyよりpython使った方がいい場合がある
# pypyjit.set_param使ってもTLEになった　
# sys.setrecursionlimit(67108864) #64MB
# threading.stack_size(1024*1024)  #2の20乗のstackを確保=メモリの確保

# 入力用関数
def I(): return int(input())
def IM(): return map(int, input().split())
def IL(): return list(map(int, input().split()))
def IF(): return list(map(float, input().split()))

def print_list_2(li):
  for l in li:
    print(l)


def print_list(A: list) -> None:
  for i in range(len(A)):
    print(A[i], end='')
    if i != len(A) - 1: print(' ', end='')
  print()





# 与えられた文字列から各文字のハフマン符号を算出する関数
# 引数：符号化対象の文字列
# 戻り値：各文字に対応する符号を保持したdict
def makeHuffmanCode(S: str) -> dict:
  # 各文字の出現回数をカウントし、ハフマン木を構築、ハフマン木から各文字に対する符号の割り当てを行う


  # 各文字の出現回数をカウント
  s_dic = {}

  for s in S:
    if s in s_dic.keys():
      s_dic[s] += 1
    else:
      s_dic[s] = 1

  # print('出現文字のカウント結果: ', s_dic)


  # 以下、ハフマン木の構築
  tree_list = {}

  PQ = []
  heapq.heapify(PQ)

  for k, v in s_dic.items():
    heapq.heappush(PQ, (v, k))
    tree_list[k] = (-1, -1)

  for i in range(len(s_dic.keys()) - 1):
    v_left, k_left = heapq.heappop(PQ)
    v_right, k_right = heapq.heappop(PQ)

    heapq.heappush(PQ, (v_right + v_left, k_left + k_right))
    tree_list[k_left + k_right] =  (k_left, k_right)

  # print('ルートノード: ', PQ)

  # print('ハフマン木のデータ: ', tree_list)


  # ハフマン木のルートノード
  root_node = PQ[0][1]

  # 以下、ハフマン木を探索して各文字の符号を算出する
  huffman_label = {}

  def DFS_TREE(v: str, label = ''):
    left, right = tree_list[v]

    if left == -1 and right == -1:
      huffman_label[v] = label
    
    if left != -1:
      DFS_TREE(left, label + '0')
    if right != -1:
      DFS_TREE(right, label + '1')

  if len(tree_list) == 1: # 構造上、ハフマン木の要素が一つだと符号が割り当てられないための対策
    huffman_label[root_node] = '0'
  else:
    DFS_TREE(root_node)

  # print('符号の割り当て結果: ', huffman_label)

  return huffman_label



S = input()

huffman_label = makeHuffmanCode(S)


cnt = 0

for s in S:
  cnt += len(huffman_label[s])


print(cnt)


"
5109661,ALDS1_15_D,"import heapq

class node:
    def __init__(self, i):
        self.index = i
        self.parent = None
        self.child = [None, None]
    
    def set_child(self, i, j):
        self.child = [i, j]
    
    def set_parent(self, i):
        self.parent = i

def huffman(i, s):
    global obj, sign
    
    n = obj[i]
    if n.child == [None, None]:
        sign[chr(i+97)] = s if s != '' else '0'
        return
    
    huffman(n.child[0], s + '0')
    huffman(n.child[1], s + '1')


s = input()
cnt = [0] * 26
for c in s: cnt[ord(c) - 97] += 1

que = []
obj = [None] * 26
for i, val in enumerate(cnt):
    if val > 0:
        obj[i] = node(i)
        heapq.heappush(que, [val, i])

i = 26
while len(que) >= 2:
    vx, ix = heapq.heappop(que)
    vy, iy = heapq.heappop(que)
    
    z = node(i)
    z.set_child(ix, iy)
    obj.append(z)
    heapq.heappush(que, [vx + vy, i])
    
    obj[ix].set_parent(i)
    obj[iy].set_parent(i)
    
    i += 1

sign = {}
while obj[i - 1] == None: i -= 1
huffman(i-1, '')

ans = 0
for c in s: ans += len(sign[c])
print(ans)

"
8120107,ALDS1_15_D,"Input = input()
letters = []
counts = []
for letter in Input:
    if letter in letters:
        counts[letters.index(letter)] += 1
    else:
        letters.append(letter)
        counts.append(1)

if len(letters) == 1:
    print(counts[0])
else:
    P = {}
    nodes,no_P = [i for i in range(len(letters))],[j for j in range(len(letters))]
    new_node = 0
    while len(no_P) != 1:
        new_node -= 1
        small,small_idx = [float(""inf""),float(""inf"")],[0,0]
        for idx in range(len(nodes)):
            if nodes[idx] in no_P:
                num = counts[idx]
                larger = 0 if small[0] > small[1] else 1
                if num < small[larger]:
                    small[larger] = num
                    small_idx[larger] = idx

        nodes.append(new_node)
        counts.append(small[0]+small[1])
        no_P.remove(nodes[small_idx[0]])
        no_P.remove(nodes[small_idx[1]])
        no_P.append(new_node)
        P[nodes[small_idx[0]]] = P[nodes[small_idx[1]]] = new_node
    
    answer = 0
    for idx in range(len(letters)):
        letter = nodes[idx]
        length = 1
        while P[letter] != new_node:
            letter = P[letter]
            length += 1
        answer += length * counts[idx]
    print(answer)
"
4908575,ALDS1_15_D,"from collections import Counter

class No:
	def __init__(self, freq):
		self.esq = None
		self.dir = None
		self.pai = None
		self.freq = freq


def criaNo(freqs):
	return [No(freq) for freq in freqs]


def criaArvore(nodes):
	janela = nodes[:]

	while len(janela) > 1:
		janela.sort(key=lambda item: item.freq)
		no_esq = janela.pop(0)
		no_dir = janela.pop(0)
		no_parente = No(no_esq.freq + no_dir.freq)
		no_parente.esq = no_esq
		no_parente.dir = no_dir
		no_esq.pai = no_parente
		no_dir.pai = no_parente
		janela.append(no_parente)

	janela[0].pai = None
	
	return janela[0]

# Faz o encode varrendo os nós
def huffman(nos, raiz):
	codigo = [''] * len(nos)
	
	for i in range(len(nos)):
		No = nos[i]
		while No != raiz: #coloca 0 na esquerda e 1 na direita
			if No.pai.esq:
				codigo[i] = '0' + codigo[i]
			else:
				codigo[i] = '1' + codigo[i]
			No = No.pai
			
	return codigo

# Conta frequencia de cada caracter
def frequencias(string):
	chaves = []
	lista = []
	
	for c in string:
		if c not in chaves:
			chaves.append(c)
			lista.append((c, string.count(c)))
	
	return lista


# retorna o codigo da string
def criaCodigo(texto, freq, cod):
	enc = ''
	for char in texto:
		i = 0
		for item in freq:
			if char == item[0]:
				enc += cod[i]
			i += 1

	return enc

def main():

	texto = input()
	# casos base
	if len(texto) == 1:
		print(1)
	else:
		
		freq = frequencias(texto)
		if len(freq) == 1:
			print(len(texto))
		else:
			nodes = criaNo([item[1] for item in freq])
			
			arvore = criaArvore(nodes)
			codigo = huffman(nodes, arvore)

			huffman_str = criaCodigo(texto, freq, codigo)

			print(len(huffman_str))

	return 0

if __name__ == '__main__':
	main()
"
3701719,ALDS1_15_D,"from heapq import heappop, heappush
from collections import Counter


class Node:
    
    def __init__(self, weight):
        self.weight = weight
    
    def set_parent(self,parent):
        self.parent = parent
        
    def get_length(self):
        try:
            tmp = 1 + self.parent.get_length()
        except AttributeError:
            tmp = 0
        return tmp
        
    def get_weight(self):
        return self.weight

    def __lt__(self, other):
        return self.weight < other.weight
    

S = input()
d = Counter(S)
tree_dic = {}
h = []
num = 0
for i in d:
    tree_dic[i] = Node(d[i])
    heappush(h,tree_dic[i])
while(len(h) > 1):
    tmp0 = heappop(h)
    tmp1 = heappop(h)
    tree_dic[num] = Node(tmp0.get_weight() + tmp1.get_weight())
    tmp0.set_parent(tree_dic[num])
    tmp1.set_parent(tree_dic[num])
    heappush(h,tree_dic[num])
    num+=1

ans = 0
for i in S:
    ans += tree_dic[i].get_length()
if len(S) == 1:
    print(1)
elif len(d) == 1:
    print(len(S))
else:
    print(ans)
"
